fmod K-SORTS is including QID .
  ops KSentence : -> Qid .
  eq KSentence = 'KSentence .
endfm

fmod K-META-OPS is including META-TERM .
  op nilKList : -> Qid .
  eq nilKList = '.List`{K`}.List`{K`} .

  op nilK : -> Qid .
  eq nilK = '..K .

  op kra_ : TermList -> Term .
  eq kra(Trl1,'_~>_[Trl],Trl2) = kra(Trl1,Trl,Trl2) .
  eq kra(empty) = nilK .
  eq kra(T) = T [owise] .
  eq kra(Trl) = '_~>_[Trl] [owise] .
 
  op klabel : -> Constant .
  eq klabel = 'k.CellLabel .
 
  var T : Term .  var Trl Trl1 Trl2 : TermList . 

  op kcell : Term -> Term .
  eq kcell(T) = '<_>_</_>[klabel,T,klabel] .
  
  op kWrap : Term -> Term .
  eq kWrap(T) = kcell(kra(T,'Rest:K)) .
--- replace the line above with the one below to get unrestricted strictness
---  eq kWrap(T) = T .

  op kList : TermList -> Term .
  eq kList(T) = T .
  eq kList(empty) = nilKList .
  eq kList(Trl) = '_`,`,_[Trl] [owise] .

  op kApplyS : -> Qid .
  eq kApplyS = '_`(_`) .

  op kApply : Term TermList -> Term .
  eq kApply(T, Trl) = kApplyS[T,kList(Trl)] .
endfm

fmod META-K-BUILTINS is
  including META-LEVEL-EXTRAS .
  including META-MODULE-EXTRAS .
  op Builtins : -> Sort .
  eq Builtins = 'Builtins .
  op builtinSorts : Module -> SortSet [memo] .
---  eq builtinSorts = getSorts(upModule('PL-BUILTINS, true)) .
  eq builtinSorts(M:Module) = getSubsorts(flatten(M:Module), Builtins) .
  op builtinModules : ~> SortSet [memo] .
  eq builtinModules 
   = getImportNames(getImports(upModule('PL-BUILTINS, false))) .
endfm

fmod META-K-MODULES is
  including META-MODULE .
  op kModules : ~> SortSet [memo] .
  eq kModules 
   = 'K-TECHNIQUE ; 'K-SENTENCE ; 'K-WHERE ; 'K-PROPER ; 'K-STRICNESS ; 'K-CONTEXTS ; 
     'K-WRAPPERS-LABELS ; 'K-WRAPPERS ; 'K-RULES ; 'K-POLYMORPHIC-VARIABLES ; 
     'K-OPEN-CELLS ; 'K-CONFIG ; 'K-DESTRUCTORS ; 'K-QUOTED-LABELS ;
     'K-CONDITION-SEARCH .
endfm

fmod META-K-MODULE is
  including META-LEVEL-EXTRAS .
  including META-K-BUILTINS .
  var S : Sort .  var T T' T1 T2 : Type .  var SSDS : SubsortDeclSet . 
  vars OPDS : OpDeclSet .  var Op : OpDecl .  var Q : Qid . 
  var AS : AttrSet .  var M : Module . var SS : SortSet .  var Tl : TypeList .

  ops KProper KResult NeK K KLabel KProperLabel KResultLabel KHybridLabel : -> Sort .
  ops NeProperList ResultList NeResultList NeKList KList : -> Sort .
  eq KProper = 'KProper .  eq KResult = 'KResult .
  eq NeK = 'NeK .  eq K = 'K .
  eq KLabel = 'KLabel .  eq KHybridLabel = 'KHybridLabel .
  eq KProperLabel = 'KProperLabel .  eq KResultLabel = 'KResultLabel .
  eq ResultList = 'List`{KResult`} .  eq NeProperList = 'NeKProperList .  eq NeResultList = 'NeList`{KResult`} .  eq KList = 'List`{K`} .  eq NeKList = 'NeList`{K`} .
  ops ksorts klabelsorts : -> SortSet [memo] .
  eq ksorts = KProper ; KResult ; NeK ; K .
  
  eq klabelsorts = KProperLabel ; KResultLabel ; KLabel ; KHybridLabel .

  op klistSorts : -> SortSet [memo] .
  eq klistSorts = NeProperList ; ResultList ; NeResultList ; NeKList ; KList .

  op isKSort : Type -> Bool [memo] .
  eq isKSort(T) = T in (ksorts ; Builtins) .

  op isKListSort : Type -> Bool [memo] .
  eq isKListSort(T) = T in klistSorts .

  op ksubsorts : -> SubsortDeclSet [memo] .
  eq ksubsorts = (
    subsort KProper < NeK .
    subsort KResult < NeK .
    subsort KProper < K .
    subsort KResult < K .
    subsort NeK < K .
    subsort Builtins < NeK .
    ) .

  op klabelsubsorts : -> SubsortDeclSet [memo] .
  eq klabelsubsorts = (
    subsort KProperLabel < KLabel .
    subsort KResultLabel < KLabel .
    subsort KHybridLabel < KLabel .
    ) .

  op ksupersorts : -> SubsortDeclSet [memo] .
  eq ksupersorts = (
    subsort KProper < NeK .
    subsort KProper < K .
    subsort KProper < NeProperList .
    subsort KResult < NeK .
    subsort KResult < K .
    subsort NeK < K .
      subsort K < KList .
      subsort K < NeKList .
      subsort KResult < NeResultList .
      subsort KResult < ResultList .
      subsort KResult < NeKList .
      subsort KResult < NeK .
     ) .

  op kops : -> OpDeclSet [memo] .
  eq kops = (
    op '. : nil -> K [none] .
    op '_`(_`) : KLabel KList -> NeK [none] .
    op '_`(_`) : KProperLabel KList -> KProper [none] .
    op '_`(_`) : KResultLabel KList -> KResult [none] .
    op '_`(_`) : KHybridLabel NeProperList -> KProper [none] .
    op '_`(_`) : KHybridLabel ResultList -> KResult [none] .
    op '_~>_ : K K -> K [none] .
    op '`[HOLE`] : nil -> K [none] .
    op '_`(_`) : 'Map K -> K [none] .
    
  ) .

 op pseudoKSubsorts : SubsortDeclSet -> SubsortDeclSet .
 eq pseudoKSubsorts(SSDS) = getSubsorts(removeSubsorts(SSDS,ksubsorts), ksorts) .
 
 op pseudoKLabelSubsorts : SubsortDeclSet -> SubsortDeclSet .
 eq pseudoKLabelSubsorts(SSDS) = getSubsorts(removeSubsorts(SSDS,klabelsubsorts), klabelsorts) . 

 op maximalKSubsorts : Module -> SubsortDeclSet .
 eq maximalKSubsorts(M)
  = getSubsorts(getSupersorts(getSubsorts(M),getMaximalSorts(M, getSubsorts(pseudoKSubsorts(getSubsorts(M))))), ksorts) .
 
 op pseudoKSupersorts : SubsortDeclSet -> SubsortDeclSet .
 eq pseudoKSupersorts(SSDS) = getSupersorts(removeSubsorts(SSDS,ksupersorts), ksorts) . 
 
  op pseudoKOps : OpDeclSet -> OpDeclSet .
  eq pseudoKOps(OPDS) = getOps(removeOps(OPDS,kops), ksorts) .

  op pseudoKListSorts : SubsortDeclSet OpDeclSet -> SubsortDeclSet .
  eq pseudoKListSorts(SSDS, OPDS)
   = (getSupersorts(removeSubsorts(SSDS,ksupersorts), K ; KResult)) .

  op syntaxSorts :  Module ~> SortSet .
  eq syntaxSorts(M) = removeSorts(getSubsorts(M, K),ksorts ; builtinSorts(M) ; getSubsorts(getList2KSubsorts(M))) .

  op syntaxOps : Module -> OpDeclSet .
  eq syntaxOps(M) = getOps(getOps(M), syntaxSorts(M)) .

  op getList2KSubsorts : Module -> SubsortDeclSet .
  eq getList2KSubsorts(M) = getList2KSubsorts(M, getSubsorts(M,K)) .

  op metaAssocSorts : -> SortSet [memo] .
  eq metaAssocSorts = klistSorts ; K ; KProper ; KResult ; NeK ; 'Bag ; 'NeBag ; 'Set ; 'NeSet ; 'List ; 'NeList ; 'Map ; 'NeMap .

  op getListSorts : Module -> SortSet .
  eq getListSorts(M) = removeSorts(getListSorts(getOps(M)), metaAssocSorts ; builtinSorts(M)) .

  op isListSort : Module Type -> Bool .
  eq isListSort(M,T) = isListSort(getListSorts(M),T) .
  
  op isListSort : SortSet Type -> Bool .
  eq isListSort(SS ; S , S) = true [print S " is a list sort together with " SS] .
  eq isListSort(SS, T) = false [owise].

  op getListSorts : OpDeclSet -> TypeSet .
  eq getListSorts(none) = none .
  eq getListSorts(Op OPDS) = getListSortsOp(Op) ;  getListSorts(OPDS) .
  
  op getListSortsOp : OpDecl -> TypeSet .
  eq getListSortsOp(op Q : T1 T2 -> T [assoc AS] .) = T1 ; T2 ; T .
  eq getListSortsOp(Op) = none [owise] .

  op getListSubsorts : Module -> SubsortDeclSet .
  eq getListSubsorts(M) = makeSubsorts(M, getListSorts(M), getMaximalSorts(M, getListSorts(M))) .

  op getResultLists : Module -> SortSet .
  eq getResultLists(M) = getSubsorts(makeSubsorts(M,getListSorts(M),KResult)) .


  op getNoResultListSubsorts : Module -> SubsortDeclSet .
  eq getNoResultListSubsorts(M) = removeSubsorts(getListSubsorts(M), getResultLists(M)) .

  
  op getList2KSubsorts : Module SortSet -> SubsortDeclSet .
  eq getList2KSubsorts(M, none) = none .
  eq getList2KSubsorts(M, T ; SS) 
   = if isListSort(M, T)
     then (subsort T < (if sortLeq(M,T,KResult) then KResult else K fi) .) 
        getList2KSubsorts(M, SS) 
     else getList2KSubsorts(M, SS) fi .

  op getK2ListSubsorts : Module SubsortDeclSet -> SubsortDeclSet .
  eq getK2ListSubsorts(M, none) = none .
  eq getK2ListSubsorts(M, (subsort T < T' .) SSDS) 
   = if isListSort(M, T') 
     then (subsort T < T' .)  getK2ListSubsorts(M, SSDS) 
     else getK2ListSubsorts(M, SSDS) fi .
endfm

fmod META-K-RULES is including K-SORTS .
  including META-MODULE .
  var Q : Qid . var T T' : Term . var S : Type . var C : Term .  var Cond : TermList .
  var AS : AttrSet .  var RK : KRuleKind .

  sort KRuleKind .
  ops krl kcrl : -> KRuleKind .
  op error : Qid -> [KRuleKind] .

  op trueCt : -> Constant .
  eq trueCt = 'true.Bool .
  
  ops symbol_ : KRuleKind -> Qid .
  eq symbol krl = 'rule_ .
  eq symbol kcrl = 'rule_if_ .  

  op replaceS : -> Qid .
  eq replaceS = '_=>_ .

  op getKRuleKind : Qid ~> KRuleKind . 
  eq getKRuleKind(Q) = if Q == symbol krl then krl else if Q == symbol kcrl then kcrl else error(Q) fi fi .

  sort KRuleSplit .
  op {_,_,_,_} : KRuleKind Term TermList AttrSet -> KRuleSplit .

  
  op splitKRule : MembAx ~> KRuleSplit .
 ceq splitKRule((mb Q[T] : S [AS] .))
   = {getKRuleKind(Q),T,empty,AS} if S := KSentence . 
 ceq splitKRule((mb Q[T,C] : S [AS] .))
   = {getKRuleKind(Q),T,C,AS} if S := KSentence . 

  op getContents : KRuleSplit -> Term .
  op getRuleKind : KRuleSplit -> KRuleKind .
  op getCondition : KRuleSplit -> TermList .
  op getAttrs : KRuleSplit -> AttrSet .
  eq getContents({RK,T,Cond,AS}) = T .
  op getKind : KRuleSplit -> KRuleKind .
  eq getKind({RK,T,Cond,AS}) = RK .
  eq getCondition({RK,T,Cond,AS}) = Cond .
  eq getAttrs({RK,T,Cond,AS}) = AS .

  op setContents : KRuleSplit Term -> KRuleSplit .
  eq setContents({RK,T,Cond,AS}, T') = {RK,T',Cond,AS} .

  op plugKRule : KRuleSplit ~> MembAx .
  eq plugKRule({RK,T,empty,AS}) = (mb symbol(RK)[T] : KSentence [AS] .) .
  eq plugKRule({RK,T,C,AS}) = (mb symbol(RK)[T,C] : KSentence [AS] .) [owise] .
endfm

fmod K-META-CONFIG is 
  including META-K-RULES .
  including META-K-MODULE .
  including META-TERM-EXTRAS .
  including META-LEVEL .
  including INT .
  var Label Label' : Constant . var Contents Contents' T : Term .
  var Q Q' : Qid .  var B B' : Bool . var E E' : Ellipses .  var M : Module .  
  var AS : AttrSet .  var MAS : MembAxSet .  var S : Sort .

  op extractConfTerm : Module ~> Term .
  eq extractConfTerm(M) = extractConfTerm(getMbs(M)) .
  op extractConfTerm : MembAxSet ~> Term .
  eq extractConfTerm((mb 'configuration_[T] : 'KSentence [AS] .) MAS) = T .

  op removeConfTerm : Module -> Module .
  eq removeConfTerm(M) = setMbs(M,removeConfTerm(getMbs(M))) .
  op removeConfTerm : MembAxSet -> MembAxSet .
  eq removeConfTerm((mb 'configuration_[T] : 'KSentence [AS] .) MAS) = MAS .
  eq removeConfTerm(MAS) = MAS [owise] .
  
  sort Ellipses .
  ops none : -> Ellipses .
  op error : -> [Ellipses] .
  op symbol_ : Ellipses -> Qid .
  eq symbol none = '<_>_</_> .

  sort SplitCell .
  op {_,_,_,_} : Constant Term Bool Ellipses -> SplitCell .

  op splitKCell : Term ~> SplitCell .
  eq splitKCell(Q[Label,Contents,Label]) = {Label, Contents,false, getEllipses(Q)} .
  eq splitKCell(Q[Q'[Label],Contents,Q'[Label]]) = {Label, Contents,true, getEllipses(Q)} .

  op getEllipses : Qid -> Ellipses .
  ceq getEllipses(Q) = none if Q = symbol none .

  op getEllipses : SplitCell -> Ellipses .
  eq getEllipses({Label,Contents,B,E}) = E .
  op setEllipses : SplitCell Ellipses -> SplitCell .
  eq setEllipses({Label,Contents,B,E}, E') = {Label,Contents,B,E'} .

  op getName : SplitCell -> Qid .
  eq getName({Label,Contents,B,E}) = getName(Label) .
  op setName : SplitCell Qid -> SplitCell .
  eq setName({Label,Contents,B,E},Q) = {mkCellLabel(Q),Contents,B,E} .

  op getContents : SplitCell -> Term .
  eq getContents({Label,Contents,B,E}) = Contents .
  op setContents : SplitCell Term -> SplitCell .
  eq setContents({Label,Contents,B,E}, Contents') = {Label,Contents',B,E} .

  op getMultiplicity : SplitCell -> Bool .
  eq getMultiplicity({Label,Contents,B,E}) = B .
  op setMultiplicity : SplitCell Bool -> SplitCell .
  eq setMultiplicity({Label,Contents,B,E}, B') = {Label,Contents,B',E} .

  op plugCell : SplitCell -> Term .
  eq plugCell({Label,Contents,B,E}) = symbol E[cellLabel(Label,B),Contents,cellLabel(Label,B)] .

  op mkCell : Qid Term -> Term .
  eq mkCell(Q,Contents) = plugCell({mkCellLabel(Q),Contents,false,none}) .

  op mkCellLabel : Qid -> Constant . 
  eq mkCellLabel(Q) = qid(string(Q) + ".CellLabel") .

  op multiCellS : -> Qid .
  eq multiCellS = '_* .  

  op cellLabel : Constant Bool -> Term .
  eq cellLabel(Label,B) = if B then multiCellS[Label] else Label fi .

  ops Map Bag List Set : -> Sort .
  eq Map = 'Map . eq Bag = 'Bag . eq List = 'List . eq Set = 'Set .
  op CellLabel : -> Sort .
  eq CellLabel = 'CellLabel .

  op emptyCt : Sort -> Constant .
  eq emptyCt(S) = if S == Bag then mkConstant('.,Bag) else if S == Map then mkConstant('.,Map) else if S == List then mkConstant('., List) else if S == K then mkConstant('., K) else if S == Set then mkConstant('., Set) else 'error.K fi fi fi fi fi .

  op ctor : Sort -> Qid .
  eq ctor(S) = if S == Bag then '__ else if S == Map then '__ else if S == List then '__ else if S == K then '_~>_ else if S == Set then '__ else 'error fi fi fi fi fi .

  var Ty : Type .

  op getCellType : Module Type ~> Sort .
 ceq getCellType(M, Ty) = Bag if sameKind(M, Ty, Bag) .
 ceq getCellType(M, Ty) = Set if sameKind(M, Ty, Set) .
 ceq getCellType(M, Ty) = Map if sameKind(M, Ty, Map) .
 ceq getCellType(M, Ty) = List if sameKind(M, Ty, List) .
 ceq getCellType(M, Ty) = K if sameKind(M, Ty, K) .
endfm

fmod K-META-OPEN-CELLS is 
  including K-META-CONFIG .
  ops left right both : -> Ellipses .
  eq symbol left = '<_>..._</_> .
  eq symbol right = '<_>_...</_> .
  eq symbol both = '<_>..._...</_> .
  var Q : Qid .
  eq getEllipses(Q) = if (Q == symbol left) then left else if (Q == symbol right) then right else if (Q == symbol both) then both else if (Q == symbol none) then none else error fi fi fi fi .
endfm

fmod META-ANONYMOUS-VARIABLE is
  including META-LEVEL .
  including CONVERSION .
  var T : Type . var N : Nat .
  var M : Module .  var Op : OpDecl . var OPDS : OpDeclSet . 
  var Q : Qid .   var AS : AttrSet .

  op anyVarS : -> Qid .
  eq anyVarS = '? .

  op Anonymous : -> Sort .
  eq Anonymous = 'Anonymous .

  op anyVar : Type -> Variable .
  eq anyVar(T) = qid(string(anyVarS) + ":" + string(T)) .

  op anyVar : Nat Type -> Variable .
  eq anyVar(N, T) = qid(string(anyVarS) + string(N,10) + ":" + string(T)) .


  op getAnonConsts : Module ~> TypeSet .
  eq getAnonConsts(M) = '`[HOLE`] ; '? . ---getAnonConsts(getOps(M)) .

  op getAnonConsts : OpDeclSet ~> SortSet .
  eq getAnonConsts(Op OPDS) = getAnonConsts(Op, OPDS) .
  eq getAnonConsts(none) = none .
  
  op getAnonConsts : OpDecl OpDeclSet ~> SortSet .
  eq getAnonConsts(op Q : nil -> T [poly(0) AS] ., OPDS) 
   = if T == Anonymous then Q ; getAnonConsts(OPDS) else getAnonConsts(OPDS) fi  [print "Q: " Q ", T: " T] .
  eq getAnonConsts(Op, OPDS) = getAnonConsts(OPDS) [owise] .
endfm

fmod META-K-WRAPPERS is
  including META-LEVEL-EXTRAS .
  including META-K-MODULE .
  including K-META-CONFIG  .
  vars T T' : Type . var Q : Qid . var AS : AttrSet . var OPDS : OpDeclSet .

  op builtin-wrappers : -> OpDeclSet [memo] .
  eq builtin-wrappers = getOps(upModule('K-WRAPPERS, false)) .

  op getWrappers : OpDeclSet -> OpDeclSet .
  eq getWrappers((op Q : T -> T' [metadata("builtin wrapper") AS] .) OPDS)
   = (op Q : T -> T' [metadata("builtin wrapper") AS] .) getWrappers(OPDS) .
  eq getWrappers((op Q : T -> T' [metadata("list wrapper") AS] .) OPDS)
   = (op Q : T -> T' [metadata("list wrapper") AS] .) getWrappers(OPDS) .
  eq getWrappers(OPDS) = none [owise] .

  op mkSubsortWrapper : Type Type -> Qid .
  eq mkSubsortWrapper(T,T') 
   = qid(string(T) + "_") .

  op isWrapped : Module Type -> Bool [memo] .
  eq isWrapped(M, T) = T in (klabelsorts ; 'CellLabel ; 'Bag ; 'NeBag ; 'BagItem ; 'Set ; 'NeSet ; 'SetItem ; 'List ; 'NeList ; 'ListItem ; 'Map ; 'NeMap ; 'MapItem ; 'List`{K`} ; 'NeList`{K`} ; 'List`{KResult`} ; 'NeKProperList) 
     or-else isWrapped(getWrappers(getOps(flatten(M))), T) .

  op isWrapped : OpDeclSet Type -> Bool .
  eq isWrapped(OPDS (op Q : T -> T' [AS] .), T) = true .
  eq isWrapped(OPDS, T) = false [owise] .

  var M : Module . var Op : OpDecl . 
endfm


fmod META-K-LABELS is
  including META-K-MODULE .
  including META-LEVEL .
  var Q : Qid . var T : Type .  var Str : String .

  op klistLabelS : -> Qid .
  eq klistLabelS = 'kList .

  op mkKLabel : Qid -> Qid .
  eq mkKLabel(Q) = qid("'" + string(Q)) .

  op downKLabel : Qid -> Qid .
  eq downKLabel(Q) = Q .

  op mkListLabel : Qid -> Term .
  eq mkListLabel(Q) = klistLabelS[upTerm(string(Q))] .

  op mkKLabelSort : Type String -> Type .
  eq mkKLabelSort(T,Str) 
   = if find(Str,"hybrid",0) :: Nat then KHybridLabel
     else if T == KProper then KProperLabel
     else if T == KResult then KResultLabel else KLabel fi fi fi .
endfm

fmod K-STRICTNESS-OPS is including META-LEVEL .
  including K-META-OPS .
  var S : String .  var T : Term . var Trl : TermList .

  op hole : -> Term .
  eq hole = '`[HOLE`]:K .

  op removeHole : TermList ~> TermList .
  eq removeHole((T, Trl)) = if T == hole then removeHole(Trl) else T,removeHole(Trl) fi .
  eq removeHole(empty) = empty .

  op freezeLabel : String -> Term .
  eq freezeLabel(S) = 'freezer[upTerm(S)] .

  op freezeVariable : String Term -> Term .
  eq freezeVariable(S, V:Term) = kApply('freezeVar[upTerm(S)],V:Term) .
endfm

fmod LIST-ATTRS is
  including META-MODULE .
  op klist : Nat Qid Type -> Attr .
  op klist : Nat Term -> Attr .
endfm

fmod STRICT-ATTRS is
  including META-MODULE .
  including NAT-LIST-EXTRAS .
  including LIST-ATTRS .
  ops kstrict seqkstrict : IntList -> Attr .
  op karity : Nat -> Attr .
  op khybrid : -> Attr .
endfm

fmod SYNTAX-ATTRS is
  including META-MODULE .
  ops kaux kdisolve : -> Attr .
  op krenameTo : Qid -> Attr .
  op ksyntax : -> Attr .
  op klatex : AttrSet -> Attr .
  op kcolor : Qid -> Attr .
endfm

fmod CONFIGURATION-ATTRS is
  including META-MODULE .
  op kwrapping : Qid -> Attr .
endfm

fmod K-ATTRS is 
  including SYNTAX-ATTRS .
  including STRICT-ATTRS .
  including CONFIGURATION-ATTRS .
endfm

fmod K-META-LISTS is including K-META-OPS .
  including META-K-MODULE .
  including META-TERM-EXTRAS .
  including LIST-ATTRS .
  including META-K-LABELS .

  var Q : Qid . var T : Type . var Tl : TypeList . var AS : AttrSet .
  var Trm : Term . var Trms : TermList .  var OPDS : OpDeclSet .
  var N : Nat .
  op klistType : Type ~> Type .
  eq klistType('K) = KList  .
  eq klistType('KResult) = ResultList .
  eq klistType(T) = KList [owise] .

  op klabelType : Type ~> Type .
  eq klabelType(Q) = if Q == K then KLabel else if Q ==  KResult then KResultLabel else if Q == KProper then KProperLabel else KHybridLabel fi fi fi .
  
  op wrapList : Type Term TermList ~> Term .
  eq wrapList(T, Q[Trm], Trms) = kApply(mkConstant(listWrapperS(Q),T),Trms) [print "listWrapper " T Q Trm Trms].

  op listWrapperS : Qid -> Qid .
  eq listWrapperS(Q) = mkKLabel(Q) .
  op listWrapperT : Qid Type -> Constant .
  eq listWrapperT(Q,T) = mkConstant(listWrapperS(Q),klabelType(T)) .

  eq klist(N,Q,T) = klist(N, listWrapperT(Q,T)) .


  op getListConstructor : OpDeclSet Type ~> OpDecl .
  eq getListConstructor(OPDS op Q : Tl -> T [assoc AS] ., T)
   = (op Q : Tl -> T [assoc AS] .) .

 sort CTORSMap .  var CTORS : CTORSMap .  var SSD : SubsortDecl .
 op _|->_ : SubsortDecl Term -> CTORSMap .
 op __ : CTORSMap CTORSMap -> CTORSMap [assoc comm id: empty] .
 op empty : -> CTORSMap .

 op getKeys : CTORSMap -> SubsortDeclSet .
 eq getKeys(empty) = none .
 eq getKeys(CTORS SSD |-> Trm) = getKeys(CTORS) SSD .

  op getListTerm : Type OpDeclSet ~> Term .
  eq getListTerm(T, (op Q : T T -> T [assoc id(Trm) AS] .) OPDS) = Q[Trm] .
  eq getListTerm(T, (op Q : T T -> T [assoc AS] .) OPDS) = Q[mkConstant('dummy,T)] [owise] .
endfm

fmod META-K-CONDITION-SEARCH is
  including QID .
  op searchS : -> Qid .
  eq searchS = 'search_ .
endfm

fmod META-K-LEAST-SORTS is
  including META-LEVEL-EXTRAS .
  including META-K-RULES .

 op errorT : Term Type -> [Type] .

 op leastSortsT : Module Term ~> Type .
 eq leastSortsT(M,C) = leastSort(M,C) .
 eq leastSortsT(M,V) = getType(V) .
 eq leastSortsT(M,Q[Trms]) = leastSortsT(M,Q[Trms],leastSortsTs(M, Trms)) .

 op leastSortsTs : Module TermList ~> TypeListSet .
 op leastSortsTs : Module TermList TypeListSet ~> TypeListSet .
 op leastSortsTs : Module TermList SortSet TypeListSet ~> TypeListSet .
 eq leastSortsTs(M, Trms) = leastSortsTs(M, Trms, nil) .
 eq leastSortsTs(M, empty, TlS) = TlS .
 eq leastSortsTs(M, (Trm, Trms), TlS) = leastSortsTs(M, Trms, leastSortsT(M, Trm), TlS) .
 eq leastSortsTs(M, Trms, errorT(Trm,T), TlS) = errorT(Trm,T) .
 eq leastSortsTs(M, Trms, SS, TlS) = leastSortsTs(M, Trms, TlS # SS) .

 op leastSortsT : Module Term TypeListSet ~> SortSet .
 op leastSortsT : Module Term SortSet TypeListSet ~> SortSet .
 op leastSortsT : Module Term SortSet SortSet TypeListSet ~> SortSet .
 op $leastSortsT : Module Term TypeListSet ~> SortSet .


 eq leastSortsT(M, Trm, TlSK) = leastSortsT(M, Trm, none, TlSK) [print "Finding sorts for " Trm] .
 eq leastSortsT(M, Trm, SS, Tl ; TlSK) 
  = leastSortsT(M, Trm, $leastSortsT(M, Trm, Tl), SS, TlSK) [print "Checking " Tl] . 
 
 eq leastSortsT(M, Trm, NSS, TlSK) = NSS [print "sorts " NSS " found for " Trm] .
 eq leastSortsT(M, Trm, none, errorT(Trm',T) ; TlSK) = errorT(Trm',T) .
 eq leastSortsT(M, 'context_[Trm], none, TlSK) 
  = errorT('context_[Trm],'`[All`contexts`should`have`sort`K`]) [owise] .
 eq leastSortsT(M, Trm, none, TlSK) = errorT(Trm, leastSort(M,Trm)) [owise print "no sorts found. generating error. unchecked " TlSK] .

 eq leastSortsT(M, Trm, SS, SS', TlSK) = leastSortsT(M, Trm, SS ; SS', TlSK) [print "found sorts " SS] .
 eq leastSortsT(M, Trm, SS:[SortSet], SS', TlSK) 
  = leastSortsT(M, Trm, SS', TlSK) [owise print SS:[SortSet]] .

 eq $leastSortsT(M, 'if_then_else_fi[Trms], T T' T'') 
  = leastSortsIf('if_then_else_fi[Trms], leastSort(M, 'if_then_else_fi[Trms]), sortLeq(M, T, 'Bool), lubSorts(M, T', T'')) .

 eq $leastSortsT(M, 'configuration_[Trm], S) = 'KSentence .
 eq $leastSortsT(M, 'rule_[Trm], S) = 'KSentence .
ceq $leastSortsT(M, 'rule_if_[Trms], S T') = 'KSentence if sortLeq(M,T','Bool).
ceq $leastSortsT(M, 'context_[Trm], S) = 'KSentence if sortLeq(M,S,'K) .

ceq $leastSortsT(M, Q[T1,T2], T T') 
  = leastSortsRed(Q[T1,T2], leastSort(M, Q[T1,T2]), lubSorts(M, T, T')) 
 if Q == replaceS . 
 eq $leastSortsT(M, Q[Trms], Tl) = leastSort(M, Q[genXVars(Tl)]) [owise print Q Tl] .

 op leastSortsIf : Term Type Bool TypeSet ~> SortSet .
 eq leastSortsIf(Trm, T, true, NSS) = NSS .
 eq leastSortsIf(Trm, T, B:[Bool], TS:[TypeSet]) = errorT(Trm, T) [owise print "Trm=" Trm " B=" B:[Bool] " TS=" TS:[TypeSet]] .

 op leastSortsRed : Term Type SortSet ~> SortSet .
 eq leastSortsRed(Trm, T, NSS) = NSS .
 eq leastSortsRed(Trm, T, none) = errorT(Trm, T) .

  vars M : Module . var Q : Qid . var Trms : TermList . 
  var Trm Trm' T1 T2 : Term .  var C : Constant . var V : Variable .
  var T T' T'' : Type . var S : Sort .   var Tl : TypeList .
  var SS SS' : SortSet . var NSS : NeSortSet . var TS : TypeSet .
  var TlS : TypeListSet .  var TlSK : [TypeListSet] .
endfm

