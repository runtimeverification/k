#!/usr/bin/env perl
use strict;
use File::Basename;
use File::Spec;
use File::Copy;
use File::Path 2.07 qw( make_path remove_tree );
use File::Spec::Link;
use Switch;
use Cwd;
use Digest::MD5 qw(md5 md5_hex md5_base64);
use English;

use Text::Wrap;
$Text::Wrap::columns = 75;

BEGIN {
    unshift (@INC, (File::Basename::fileparse($0))[1]);
}

# check installed software
check_perl_packages("XML::DOM");
check_perl_packages("Regexp::Common");
check_perl_packages("XML::LibXML::Reader");
check_perl_packages("Tree::Nary");
check_perl_packages("Text::Diff");


our @checksum_files = (); # used in checksumming kompile program to detect version changes
our $random;
our $preamble = "";
push(@checksum_files, File::Spec->catfile((File::Basename::fileparse($0))[1], 'kompile'));


# add common functions file
my $path = File::Spec->catfile((File::Basename::fileparse($0))[1], 'perl', 'common_functions.pl');
require $path;
push(@checksum_files, $path);

# add ids file
$path = File::Spec->catfile((File::Basename::fileparse($0))[1], 'perl', 'ids.pl');
require $path;
push(@checksum_files, $path);

# add lists file
$path = File::Spec->catfile((File::Basename::fileparse($0))[1], 'perl', 'lists.pl');
require $path;
push(@checksum_files, $path);

# add susbsorts
$path = File::Spec->catfile((File::Basename::fileparse($0))[1], 'perl', 'subsorts.pl');
require $path;
push(@checksum_files, $path);

# add unquoting functions file
$path = File::Spec->catfile((File::Basename::fileparse($0))[1], 'perl', 'unquote.pl');
require $path;
push(@checksum_files, $path);

# depending on the options given, different flags can be added here and they will be passed to maude when called
my $additionalMaudeFlags = "";

my $maude_path = 'maude';

# File names for the input to be sent to the Maude compiler, as well as
# file names for the output, errors and temporary files generated by it
# These are useful for debugging
my $k_dir = ".k";
my $kmain = "kmain-";
# my $input_file  = fresh("kompile_in", ".maude");
# my $error_file  = fresh("kompile_err", ".txt");
# my $output_file = fresh("kompile_out", ".txt");
# my $temp_file   = fresh("kompile_tmp", ".maude");
my $input_file  = "kompile_in.maude";
my $error_file  = "kompile_err.txt";
my $output_file = "kompile_out.txt";
my $temp_file   = "kompile_tmp.maude";
my $maude_xml_file   = fresh("kompile_xml", ".xml");


my $k_license="Copyright (C) This file is generated by K-framework.\n";
my $verbose = 0;
my $help = 0;
my $maudify_only = 0;
my $k_prelude_loaded = 0;

# K tags variables
my $flag_supercool = "supercool=()";
my $flag_transition = "transition=()";
my $flag_functions = "function=() predicate=()";
my $flag_anywhere = $flag_functions . " anywhere=()";
my $flag_defined = $flag_functions . " defined=()";
my $flag_superheat = "superheat=()";
my $supercool = 0;
my $transition = 0;
my $anywhere = 0;
my $defined = 0;
my $superheat = 0;
my $pure = 0;
my $flag = 0;

# keep all autogenerated files
my @generated_files = ();
# here we trap control-c (and others) so we can clean up when that happens
$SIG{'INT'} = 'interruptHandler'; # handle control-c 
$SIG{'QUIT'} = 'interruptHandler';
$SIG{'HUP' } = 'interruptHandler';
$SIG{'TRAP'} = 'interruptHandler';
$SIG{'ABRT'} = 'interruptHandler';
$SIG{'STOP'} = 'interruptHandler';


sub interruptHandler {
	finalCleanup(); # call single cleanup point
	exit(1); # since we were interrupted, we should exit with a non-zero code
}

# this block gets run at the end of a normally terminating program, whether it simply exits, or dies.  We use this to clean up.
END {
	my $retval = $?; # $? contains the value the program would normally have exited with
	finalCleanup(); # call single cleanup point
	exit($retval);
}

# this subroutine can be used as a way to ensure we clean up all resources whenever we exit.  This is going to be mostly temp files.  If the program terminates for almost any reason, this code will be executed.
sub finalCleanup {
	# clean(); # delete normal kompile files
	unlink("cfg_temp.tmp");
	unlink("xml-parser.pl");
	unlink($maude_xml_file); # we don't want to put this in clean, since clean gets called before the xml file is used
	compilation_cleanup();
}


sub compilation_cleanup
{
	# finish the execution

	# move .maude files into .k folder
	# print "GENERATED: @generated_files\n\n";

	# remove .k if there
	unlink($k_dir);

	#create directory
	mkdir $k_dir;

	foreach(@generated_files)
	{
#		print "$_ -- $kmain\n";
	
#		if (m/kmain\-/sgi)
		if (m/\Q$kmain\E/sgi)
		{
			unlink($_);
		}
		# ignore -compiled.maude files
		elsif ( !m/\-compiled\.maude/sg )
		{
			my $content = get_file_content($_);

			# solve paths
			foreach my $iter (@generated_files)
			{
				my($filename, $path, $suffix) = fileparse($iter); $filename =~ s/\..+?$//sg;
				$content =~ s!^\s*(in|load)(\s+)(.*?\Q$filename\E)(?=\s)!{"$1$2$filename"}!gme;
			}

			# save content
			open F, ">", $_ or die "Cannot open $_\n";
			print F $content;
			close F;

			# move file in directory
			my($filename, $path, $suffix) = fileparse($_);
			rename($_, "$k_dir/$filename");
		}
	}

	

	# move temp files in $k_dir too
	rename($input_file, "$k_dir/$input_file");
	rename($error_file, "$k_dir/$error_file");
	rename($output_file, "$k_dir/$output_file");
	rename($temp_file, "$k_dir/$temp_file");
	rename($maude_xml_file, "$k_dir/$maude_xml_file");

}

# add configuration parser
$path = File::Spec->catfile((File::Basename::fileparse($0))[1], 'perl', 'configuration_parser.pl');
require $path;
push(@checksum_files, $path);


my $short_help_message = 
"
  General options
  -h (or -help) : print this message and exit
  -v (or -verbose) : verbose mode
  -m (or -maudify) : only maudify, do not kompile
  -c (or -compile) : only compile, do not maudify
  -lint : only maudify and sanity checks, do not kompile
  -l (or -lang or -language) <module_name> : start module
  -file : the input source file (optional)

  Controlling non-determinism
  -transition \"<tags>\": tags to become rewrite rules 
  -superheat \"<tags>\": syntax tags triggering super heating
                  nondetermistic choice for strictness
  -supercool \"<tags>\" : rule tags triggering super cooling
  tags are space-separated and can include the tag default
  default values: the name of the option.

  Productivity options
  -prelude file.m(aude) : specifies the k-prelude file
  -flat : slurp all k or kmaude files into one k file 
  -u (or -unquote) : unquote the maude meta-terms to increase speed
  -lib : specify an user defined builtin file

  Latex options
  -latex : maudifies/compiles for generating latex output
  -pdf : maudifies/compiles for generating pdf output
  -ps : maudifies/compiles for generating ps output
  -eps : maudifies/compiles for generating eps output
  -png : maudifies/compiles for generating png output
  -crop : maudifies/compiles for generating a nice crop-pdf output
  
  The following options make sense only when Latex options are used:
  -style : useful for typesetting (optional)
  -output output_file : specifies the name of the generated (latex) file
  -draft : include [draft] in\ documentclass
  -topmatter : includes the content of the argument file
	after \\begin{document} but before first \\begin{module}
	in the latex file

 \n";

# next subroutine prints the usage message;
# $0 is initially bound to the program name, as typed
sub terminate {
    print "\nERROR: $_[0]\n\n" if defined $_[0];
    print "Usage: 
  kompile (-option)* <source_file>[.k|.kmaude|.maude] (-option)*

  $short_help_message" if (!$verbose && !$help);

    print "Usage:
  kompile (-option)* <source_file>[.k|.kmaude|.maude] (-option)*
  
  This program takes a K language definition and translates
  it into a Maude executable specification.  The input K
  definition can be spread over several files and modules,
  all reachable from <source_file>[.k|.kmaude|.maude], and the
  generated output will be saved in <source_file>-compiled.maude.

  <source_file> must be a K-Maude or a Maude file, expected
  to directly or indirectly (by loading other files) include
  the entire definition of the language.  It is highly
  recommended that one omits the (.maude or .kmaude or .k) extension
  of the loaded files, to let this program choose the appropriate
  one depending upon the compilation stage or parameters.

  <source_file> is assumed to be a K-Maude file whenever it
  has the extension \".kmaude\" or \".k\" and a Maude file whenever
  it has the extension \".maude\".  If none of these extensions
  is provided, then the K-Maude file <source_file>.kmaude (or 
  <source_file>.k) is  considered if it exists; if <source_file>.kmaude 
  (or <source_file>.k) does not exist, then the Maude file 
  <source_file>.maude is considered instead.
  If none of the files <source_file>.kmaude (<source_file>.k) or 
  <source_file>.maude is found, then this program stops with an error message.

  The same name resolution principle as above is recursively
  applied on files directly or indirectly loaded by <source_file>.

  As part of the Maude-ification process, a corresponding
  file.maude file will be associated to each file.k
  file directly or indirectly loaded by <source_file>.
  Note that these are only intermediate representation files,
  which are not executable.

  If an error occurs in the compilation process (including
  any Maude warnings), this program will stop, displaying the
  input, the (possibly partially) generated output, and the
  error/warning messages reported by Maude.  Files containing
  intermediate compilation results are also kept for debugging.

  $short_help_message

  The option -m generates all the Maude files file.maude
  corresponding to all the files file.k reachable from
  <source_file>.  Note that Maude files are also allowed to
  load K-Maude files, which, as explained above, is the default
  choice whenever an extension is not given for the loaded file.
  This option is fast (since it does not compile the Maude-ified
  K language definition), so it is generally good for debugging.

  The option -c assumes that the K definition is already
  Maude-ified (either manually or using the above -m option).
  In particular, files with the extension .k cannot be
  loaded anymore: the program terminates with an error if one
  attempts to do so, and the default extension is .maude.
   
  The option -lint checks that the definitions satisfies somes typing
  requirements whose failure would make compilation likely to fail.
  More precisely, it checks that the arguments of all operations whose
  result sort is K are either subsorted to K or have injections (\"builtin
  wrapper\"s) into K and that all (sub)terms appearing in rules have a least 
  sort (i.e., they do not parse into a kind).  This steps does the maudification
  before checking for consistency.

  If the -l option is used, then <source_file> must
  contain a module called <module_name>.  If the option
  -l is not used, then <source_file> must include a module
  with the same root name, but capitalized.

  Technically, the command \"kompile lang.k\" is equivalent to
  \"kompile -m lang.k\" followed by \"kompile -c lang.maude\".
  Since \"kompile -m lang.k\" associates a corresponding .maude
  file to each reachable .k file while it does not modify
  any of the reachable .maude files, in order for
  \"kompile -c lang.maude\" to work one is advised to not use
  extensions for the loaded file names; in other words, write, e.g.,
  \"in/load lang-syntax\" instead of \"in/load lang-syntax.k\".

  The option -latex is used for typesetting a K definition.  It can
  be used in combination with any of the other options above.  If
  used with -m, then it only maudifies the (entire) given input file,
  adding for each operation a special latex attribute inside the
  operation's metadata.  If used with -c, it assumes that the input
  file is already maudified as above and generates a latex and a
  PDF file corresponding to a list of specified module names.  The list
  of module names should be given following the -latex option.  If used
  wihout any of -m or -c, it first applies the -m and then the -c, as
  explained in the paragraph above but with the additional option -latex.

  The optional parameter passed to -style (which only makes sense when
  the -latex option is used) can alter the style used for typesetting.
  Currently, there are two style options available, bb, for typesetting
  via tikz graphical cells, and mm, for typesetting using the simple
  mathematical notation.  The default option is bb.

  If a file <source_file>.sty is provided by the user in the current
  directory, it will be included in the generated latex file after the
  above mentioned style, and thus could be used to alter the default
  typesetting macros.
  
  The options -transition, -superheat, and -supercool are designed
  to help fine-tuning the non-determinsm exposed by a definition by 
  changing the abstraction level of the rules and stricness axioms.
  The option '-superheat' lists all the (tags of the) operations which are 
  intended to be non-deterministic in the implementation.  The option 
  '-supercool' defines the set of transitions signaling side effects to 
  be used when exploring the behaviors of non-deterministic operations.
  By default, rules tagged with the 'transition' tag 
  are turned into rewrite rules, syntax/strictness rules tagged with 
  'superheat' trigger the computing of the entire heating class, while 
  rules tagged with 'supercool' force the computation to 
  cool completely before any other rule applies.
  All rules with no specific tag are considered structural and turned into
  equations.
  The above options allow to change this behavior by specifying explicit
  sets of tags which are to be handled as transition/superheat/supercool.
  In addition one can add the reserved tag 'default' to one of the categories
  to dictate the behavior for the rules with none of the specified tags.
  
 
  Examples

  kompile lang.k : compiles the K language definition
  found in file lang.k into an executable Maude
  specification saved in file lang-compiled.maude.
  The file lang.k must contain a module named LANG.

  kompile lang3.k -l LANG : compiles the K language
  definition reachable from module LANG of file lang3.k
  into a Maude specification saved in file lang3-compiled.maude.

  kompile -v -m lang3.k : it only (verbosely) Maude-ifies
  the K language definition reachable as above, saving it in
  file lang3.maude (and similarly for loaded files). To further
  compile the Maude-ified K definition, use the following:

  kompile lang3.maude -l LANG : it compiles the K definition
  starting with module LANG of file lang3.maude into an
  executable Maude specification saved in file
  lang3-compiled.maude.  lang3.maude is still allowed to load
  K-Maude files, which will be Maude-ified.

  kompile -l LANG lang3 -c : it compiles the already
  Maude-ified K definition starting with module LANG of file
  lang3.maude.  lang3.maude cannot load any K-Maude files; the
  default extension of loaded files is set to .maude.

  kompile -latex LANG LANG-SEMANTICS LANG-SYNTAX -f lang3
  or
  kompile lang3 -latex LANG LANG-SEMANTICS LANG-SYNTAX
  It typsets the specified modules reachable from the input
  file lang3.
  
  kompile lang -latex LANG LANG-SEMANTICS LANG-SYNTAX 
  -title \"MyLang Name\" -author \"LangAuthor anotherAuthor\"
  -output out
  will generate a latex file called out.tex and
  will also set the title and the author via \\maketitle.
  Note that after option -title you can have a string which
  can include latex code but only latex commands (like \"\\Huge\",
  etc. ). Also, note that -author will not count if -title is not used.

  The -pdf, -png, -ps, -eps and -crop options can be used in 
  the same way the -latex option is used in the example above.

  kompile lang -flat -m 
  or
  kompile lang -m -flat 
  If -m and -flat options are given in the same time
  then the tool will output two files: 
  lang-flat.k which contains all the defintion of the language
  and
  lang-flat.maude which is lang-flat.k maudified.

  ---- Syntax/Rule tags --- 
  By default, 'kompile language.k' is equivalent to

  kompile language.k -transition \"transition\" -superheat \"superheat\" 
                    -supercool \"supercool\"

  This way, one does not need to explicitly add the options above if 
  one follows the naming convention for the tags.  On the other hand, 
  if one used the implicit tags and one still wants to kompile the 
  definition for interpretation speed, then one has to call kompile 
  with the options

  kompile language.k -transition \"\" -superheat \"\" -supercool \"\"

  Also, once one adds a tag to a category, that category is not including 
  the default tag anymore.  For example,

  kompile language.k -transition \"nondet\"

  does not include the tags \"transition\" into the -transition set 
  anymore; it is actually equivalent to:

  kompile language.k -transition \"nondet\"  -superheat \"superheat\" 
                     -supercool \"supercool\"

" if ($verbose || $help); 
    print "\nERROR: $_[0]\n\n" if defined $_[0];
    exit(1);
}


########################
# <TOOL CONFIGURATION> #
########################

# Special chars, strings and patterns, for configuring/tuning the tool  
# Since these special chars will be used as patterns in matching        
# and since some of them have special matching meaning, we use \Q \E    

my $parentheses = "\Q{}[]()\E";

########
# PERL #
########
my $special_perl_chars  = "$parentheses\Q\\^|*+?.\$\E";

#########
# Maude #
#########
my $maude_special = "[ $parentheses\\s_\\,\\`]";
my $maude_unspecial = "[^$parentheses\\s_\\,\\`]";
my $maude_backquoted = "(?:`\\(|`\\)|`\\{|`\\}|`\\[|`\\]|`\\,|_|[^$parentheses\\s\\,\\`])*";

#########
# Latex #
#########
#my $latex_special = "[\\#\\$\\{\\}\\[\\]\\&\\^\\_\\%\\~\\\\]";
my $latex_special = '[\\#\\{\\}\\&\\_\\%]';

#####
# K #
#####
# Pattern matched by K variables
my $kvar  = "[A-Za-z][A-Za-z0-9]*[']*";

# Pattern matched by K sorts
our $ksort = '#?[A-Z][A-Za-z0-9\`\+\?\!#]*(?:\{#?[A-Z][A-Za-z0-9\`\+\?\!]*(\,".*?")?\})?';
# TODO: test exhaustively :-)

# Pattern matched by K variables
my $klabel_body = "$maude_backquoted\_$maude_backquoted";
my $klabel = "\'$klabel_body(?:[$parentheses\\s\\,])|$klabel_body(?=\\()";

# Builtin tokens
my @builtin_tokens = qw(=> = -> id: .K .List .Set .Bag .Map true false);

# A default freezer name, to be used as a prefix of frozen strings
my $default_freezer = "FREEZER";

# A special string that will be used for freezing substrings that need not be modified
# Choose a symbol which will never appear in any programming language or program
my $specialSymbol = "K";

my $k_tools_dir = File::Spec->catfile((File::Basename::fileparse($0))[1], 'maude','compiler');
my $k_base =  File::Spec->catfile((File::Basename::fileparse($0))[1], "..");
my $k_all_tools = File::Spec->catfile($k_tools_dir,"all-tools");
my $k_to_latex = File::Spec->catfile($k_tools_dir,"k-to-latex");
my $k_to_xml = File::Spec->catfile($k_tools_dir,"k-to-xml");
my $k_latex_dir = File::Spec->catfile((File::Basename::fileparse($0))[1], 'latex');
my $k_prelude = File::Spec->catfile($k_tools_dir,"..","lib","k-prelude");

my $tokens_file = "all_tokens.tok";
my @kmaude_keywords = qw(context rule macro eq ceq configuration op ops syntax kvar sort sorts subsort subsorts including kmod endkm mb tags);
my $kmaude_keywords_pattern = join("|",map("\\b$_\\b",@kmaude_keywords));
$kmaude_keywords_pattern =~ s/\\bsyntax\\b/\\ssyntax\\s/sg;
my $kmaude_kwds_pattern = join("|", @kmaude_keywords);

my @k_attributes = qw(binder strict metadata prec format assoc comm id: hybrid gather ditto extends parser seqstrict structural transition anywhere defined function computational superheat generated supercool large latex );           
my $k_attributes_pattern = join("|",  @k_attributes);   

my $k_sorts = ":Bag:BagItem:#Bool:CellLabel:CellKey:CellAttribute:#Char:#Int:K:KAssignments:KHybridLabel:KLabel:KResult:KResultLabel:KSentence:List:ListItem:List{KResult}:List{K}:Map:MapItem:#Nat:NeBag:NeK:NeList:NeList{KResult}:NeList{K}:NeMap:NeSet:#NzInt:#NzNat:Set:SetItem:#String:#Zero";

my $comment = join("|", (
        "\\/\\/.*?\n",
        "\\/\\*.*?\\*\\/",
		"---\\(.*?---\\)",
		"---.*?\n",
		"\\*\\*\\*\\(.*?\\*\\*\\*\\)",
		"\\*\\*\\*.*?\n"
));

# my $string_pattern = quotemeta("(?<![^\\]\\)\".*?(?<![^\\]\\)\"");
my $string_pattern = "\(?<![^\\\\]\\\\\)\".*?\(?<![^\\\\]\\\\\)\"";

# Top level patterns
my $top_level_pattern = join("|", (
		"kmod(?:.*?)endkm",
		"mod(?:.*?)endm",
		"fmod(?:.*?)endfm",
		"set\\s.*?\$",
		"(?:in|load|require)\\s+\\S+"
));

# Latex top level patterns
my $latex_top_level_pattern = join("|", (
		"\\/\\/@(before|after)=([a-zA-Z\\-]+)(\\s.*?)(?=\\n)",
		"\\/\\*@(before|after)=([a-zA-Z\\-]+)(\\s.*?)\\*\\/"
));

# storage for module specific latex comments 
my %module_before = ();
my %module_after = ();



# Configuration pattern: excludes, for the spacing, from the above all those substrings matching $exclude
my $exclude = join("|",
		   "\^\\s*(?:in|load|require)\\s+\\S+\\s*(?=(in|load|require|kmod))",   # in/load of a file
		   "kmod\\s+(?:\\S*(?=\\s))",                               # kmodule name
		   "including(?:.*?(?=\\s+(?=$kmaude_keywords_pattern)))",  # included module expressions
		   "(?<!:):$ksort",                                         # sort declarations for other than ordinary $kvar
		   "(?<=\\s)ops?\\s+.*?(?=\\s+(?=$kmaude_keywords_pattern))",       # operation declarations
		   "$klabel",                                               # K labels
		   "rule\\s*\\[[^\\[\\]]*\\]\\s*:",                         # rule labels
		   "\\d+\\.\\d+",                                           # real numbers
		   "-\\d+"                                                  # negative integer
		   );

my $modules_list = "[A-Z\\-\\s]+[A-Z]";
# my $modules_list = "[a-zA-Z\\-\\+]+(?:\\-(latex|pdf|crop|ps|eps|png|h|v|m|c|l|file|nd|flat|u|style))";

# @all_sorts will hold all defined sorts
my @all_sorts = ();

# @all_tokens will hold all defined tokens
my @all_tokens = @builtin_tokens;
my @all_syntax = ();

# variables to store command line arguments
my $style = "bubble";
my $compile_only = 0;
my $language_module_name = "";
my $language_file_name = "";
my $lang_name = "";
my $output_latex_file = "";
my $topmatter = "";
my $lib = "";
my $unquote = 0;
my $xml = 0;
my $pxml = 0;
my $xmlTo = 0;
my $flat = 0;
my $shared = 0;
my $k_auto_incl = 0;
my $require_k_main = 0;
my $k_nd = 0;

# latex, pdf, eps, ps, png, crop
my $pdf = 0;
my $latex = 0;
my $eps = 0;
my $ps = 0;
my $png = 0;
my $crop = 0;
my $draft = 0;

# used for generating modules for KLabels
my $klabels = "";

my $kshared = File::Spec->rel2abs(File::Spec->catfile(File::Spec->curdir(), "shared.maude"));
my $mset = 0;


my $begin_compiled_module = "---K-MAUDE-GENERATED-OUTPUT-BEGIN---";
my $end_compiled_module   = "---K-MAUDE-GENERATED-OUTPUT-END---";

#########################
# </TOOL CONFIGURATION> #
#########################

my @kmodules = ();

my @newcommands = ();
my $newcommand_prefix = "ksyntax";
my $newcommand_counter = 0;
my $newcommand_base = 6;

# modules to be 
my @latexify_modules =();
my @pdf_modules = ();
my @ps_modules = ();
my @eps_modules = ();
my @png_modules = ();
my @crop_modules = ();

# clean the old temporary files
erase_temp();

# Process the command arguments
foreach (@ARGV) {
    if (($language_file_name eq "?") && !/^-/) {
#	$language_file_name = $_;
	$language_file_name = get_full_name($_);
    }
    elsif (($language_module_name eq "?") && !/^-/) {
	$language_module_name = $_;
    }
    elsif (($style eq "?") && !/^-/) {
	$style = $_;
    }
    elsif (($topmatter eq "?") && !/^-/) {
	$topmatter = $_;
    }
    elsif (($output_latex_file eq "?") && !/^-/) {
	$output_latex_file = $_;
    }
    elsif (/^--?h(elp)?$/) {
	# Terminates with usage info when asked for help
		$help = 1;
		terminate;
    }
    elsif (/^--?v(erbose)?$/) {
	# By default, it is not verbose
	$verbose = 1;
    }
    elsif (/^--?flag$/) {
	# By default, it is not verbose
	$flag = 1;
    }
    elsif (/^--?m(audify)?$/) {
	# By default, it maudifies and compiles
		$maudify_only = 1;
    }
    elsif (/^--?c(ompile)?$/) {
	# By default, it maudifies and compiles
		$compile_only = 1;
    }
    elsif (/^--?l(ang|anguage)?$/) {
		$language_module_name = "?";
    }
    elsif (/^--?file$/) {
		$language_file_name = "?";
    }
    elsif (/^--?topmatter$/) {
		$topmatter = "?";
    }
    elsif (/^--?lint$/) {
       $k_all_tools =  File::Spec->catfile($k_tools_dir,"lint");
    }
    elsif (/^--?draft$/)
    {
		$draft = 1;
    }
    elsif(/^--?purify$/)
    {
    	$pure = 1;
    }
    elsif (/^--?flat$/) {
		$flat = 1;
    }
    elsif (/^--?output$/) {
		$output_latex_file = "?";
    }
    elsif (/^--?lib$/) {
		$lib = "?";
    }
    elsif (/^--?latex$/) {
		$latex = 1;
    }
    elsif (/^--?pdf$/) {
		$pdf = 1;
    }
    elsif (/^--?ps$/) {
		$ps = 1;
    }
    elsif (/^--?eps$/) {
		$eps = 1;
    }
    elsif (/^--?png$/) {
		$png = 1;
    }
    elsif (/^--?crop$/) {
		$crop = 1;
    }
    elsif (/^--?supercool$/) {
		$supercool = 1;
    }
    elsif (/^--?transition$/) {
		$transition = 1;
    }
    elsif (/^--?defined$/) {
		$defined = 1;
    }
    elsif (/^--?anywhere$/) {
		$anywhere = 1;
    }
    elsif (/^--?superheat$/) {
		$superheat = 1;
    }
    elsif (/^--?style$/) {
		$style = "?";
    }
    elsif (/^--?u(nquote)?$/)
    {
		$unquote = 1;
		$additionalMaudeFlags .= " -xml-log=$maude_xml_file "
    }
     elsif (/^--?x(ml)?$/)
    {
		$xml = 1;
                $pxml = 1;
    }
    elsif ($pxml)
    {
      $xmlTo = $_;
      $pxml = 0;
    }
    elsif (/^-prelude$/)
    {
		$shared = 1;
    }
    elsif ($shared)
    {
	$k_prelude = File::Spec->rel2abs($_);
	$shared = 0;
    }
    elsif ($lib eq "?" && !/^-/)
    {
	$lib = $_;
    }
    elsif (/^-/) {
	terminate("Unknown option $_");
    }
    elsif (($latex || $pdf || $ps || $eps || $png || $crop) && /[A-Z\-]+/)
    {
	# do nothing
	#	print "MODULES: $_\n";
    }
    elsif ($supercool || $transition || $superheat || $anywhere || $defined)
    {
    	# do nothing
    }
    else {
	$language_file_name = get_full_name($_);
    }
}

# print "Lib: $lib\n";
# print "LANG: $language_file_name\n";

# remove .k dir when a new compilation starts
File::Path->remove_tree($k_dir) if !$maudify_only;

# Extract only language name without path
$lang_name = basename($language_file_name);
$lang_name =~ s/\..*?$//;

# Set latex out file name
$output_latex_file = $lang_name if $output_latex_file eq "";

# print "MODULES:\n   PDF $pdf\n   LATEX $latex\n   PS: $ps\n   EPS: $eps\n   PNG: $png\n   CROP: $crop\n\n";
# print "LANG: $language_module_name\nStyle:$style\nFile: $language_file_name\n\n";
# print "Latex header $topmatter\n";

my $args = "@ARGV";
# print "ARGS: $args\n";
# exit(1);


# get latex modules
if ($args =~ /--?latex\s+($modules_list)/)
{
    @latexify_modules = split(/\s+/, $1);
#    print "LATEX M: |@latexify_modules|\n"; 
}

# get pdf modules
if ($args =~ /--?pdf\s+($modules_list)/)
{
    @pdf_modules = split(/\s+/, $1);
#    print "PDF M: |@pdf_modules|\n"; 
}

# get ps modules
if ($args =~ /--?ps\s+($modules_list)/)
{
    @ps_modules = split(/\s+/, $1);
    # print "PS M: |@ps_modules|\n"; 
}

# get eps modules
if ($args =~ /--?eps\s+($modules_list)/)
{
    @eps_modules = split(/\s+/, $1);
#    print "EPS M: |@eps_modules|\n"; 
}

# get png modules
if ($args =~ /--?png\s+($modules_list)/)
{
    @png_modules = split(/\s+/, $1);
#    print "PNG M: |@png_modules|\n"; 
}

# get crop modules
if ($args =~ /--?crop\s+($modules_list)/)
{
    @crop_modules = split(/\s+/, $1);
#    print "CROP M: |@crop_modules|\n"; 
}

# get tags
if ($args =~ /\-\-?supercool\s(.*)/s)
{
	$flag_supercool = process_tags($1);
}

if ($args =~ /\-\-?defined\s(.*)/s)
{
	$flag_defined = $flag_functions . " " . process_tags($1);
}

if ($args =~ /\-\-?anywhere\s(.*)/s)
{
	$flag_anywhere = $flag_functions . " " . process_tags($1);
}

if ($args =~ /\-\-?transition\s(.*)/s)
{
	$flag_transition = process_tags($1);
}

if ($args =~ /\-\-?superheat\s(.*)/s)
{
	$flag_superheat = process_tags($1);
}

#print "TRANSITION: $flag_transition\n";
#print "ND: $flag_superheat\n";
#print "LOCALTRANSITION: $flag_supercool\n";


# Check if an input file was given and exit if not
if ($language_file_name eq "") {
    terminate("No input file given");
}

# Check if both -m and -c are given together
if ($maudify_only && $compile_only) {
    terminate("Options -m and -c cannot be given together\n(-m/-c means \"only maudify/compile, do not compile/maudify\")");
}

# Check if the -c option is given together with a .k or .kmaude file
if ($compile_only && $language_file_name =~ /(?:.k|.kmaude)$/) {
    terminate("Option -c only works with a .maude file");
}

# Check that a $language_file_name was indeed given if -f option was used
if ($language_file_name eq "?") {
    terminate("Option -f|-file requires that a file name be given right after");
}

# Check that a $language_module_name was indeed given if -l option was used
if ($language_module_name eq "?") {
    terminate("Option -l|-lang|-language requires that a module name be given right after");
}

# Check that a $style was indeed given if -style option was used
if ($style eq "?") {
    terminate("Option -style requires that a style be given right after");
}

$language_file_name = basename($language_file_name);

# Create the module name, if not already given, by capitalizing the file name
    if ($language_module_name eq "") {
	$language_module_name = uc($language_file_name);
	$language_module_name =~ s/\.K$|\.KMAUDE$|\.MAUDE$|\.M$//;
    }


# Check the file for syntax errors
    setVerbose() if $verbose;



# Check that at least one module name was given with -latex option
if ($latex == 1 && !@latexify_modules) {
    my $deftemp = default_pdf("-latex", $language_module_name);
    @latexify_modules = @$deftemp;
#    print "@latexify_modules\n";
#    terminate("At least one module name must be given right after -latex");
}

# Check that at least one module name was given with -pdf option
if ($pdf == 1 && !@pdf_modules) {
    my $deftemp = default_pdf("-pdf", $language_module_name);
    @pdf_modules = @$deftemp;
#    terminate("At least one module name must be given right after -pdf");
}

# Check that at least one module name was given with -ps option
if ($ps == 1 && !@ps_modules) {
    my $deftemp = default_pdf("-ps", $language_module_name);
    @ps_modules = @$deftemp;
#    terminate("At least one module name must be given right after -ps");
}

# Check that at least one module name was given with -eps option
if ($eps == 1 && !@eps_modules) {
    my $deftemp = default_pdf("-eps", $language_module_name);
    @eps_modules = @$deftemp;
#    terminate("At least one module name must be given right after -eps");
}

# Check that at least one module name was given with -png option
if ($png == 1 && !@png_modules) {
    my $deftemp = default_pdf("-png", $language_module_name);
    @png_modules = @$deftemp;
#    terminate("At least one module name must be given right after -png");
}

# Check that at least one module name was given with -crop option
if ($crop == 1 && !@crop_modules) {
    my $deftemp = default_pdf("-crop", $language_module_name);
    @crop_modules = @$deftemp;
#    terminate("At least one module name must be given right after -crop");
}

sub default_pdf
{
    my ($option, $lg) = @_;
#    print "Choosing default modules $lg-SYNTAX and $lg.\n";
    my @md = ();
#    push(@md, "$lg-SYNTAX");
#    push(@md, $lg);
    $topmatter = 'README.tex' if $topmatter eq "" && (-e "README.tex");
    
    return \@md;
}
    
# build inclusion trees
appendFileInTree("$language_file_name", "");
recurseIntoFiles($language_file_name);

# flatten and maudify
if ($flat && $maudify_only)
{
    $language_file_name =~ s/\.k(maude)?$//;
    flattening($language_file_name);
    $language_file_name .= "-flat.k";
}

# flatten if only $flat is set
if ($flat && !$maudify_only)
{
    $language_file_name =~ s/\.k(maude)?$//;
    flattening($language_file_name);
    exit(0);
}



# Following is executed whenever the option -c was not selected
if (!$compile_only) {
# Maudify the .k|.kmaude files reachable from file "$language_file_name"
    print_header("Maudifying $language_file_name") if $verbose;

    # maudify
    maudify_file("$language_file_name","");
#    print "Maudification: $language_file_name\n\n";
    
    if ($klabels ne "")
    {
	my @tmp = split(/\s+/, $klabels);
	@tmp = uniq(@tmp);
	my $tmp = "ops @tmp : -> KLabel [metadata \"generated-label=()\"] . ";
	my $dir = cwd;
	open FILE,">",$kshared or die "Cannot create $kshared\n";
	my $prelude = basename($k_prelude);
#		print FILE "\*\*\*\(\n$k_license\n\)\*\*\*\n\n\n";
	print FILE "mod K-SHARED is including K . \n\t$tmp\nendm";
	close FILE;
	push(@generated_files, $kshared);
	
	# add shared in language_file_name.maude
	my $top_file = $language_file_name;
	$top_file =~ s!\..+?$!!sg; # delete extension
	if ( -e "$top_file.maude" )
	{
	    my $maudified = get_file_content("$top_file.maude");
	    
	    $maudified =~ s/^/in shared\.maude\n/sg;	
	    
	    open FILE,">", "$top_file.maude" or die "Cannot open $top_file.maude\n";
	    print FILE $maudified;
	    close FILE;
	}
    }
    

#    print_header("Done with maudifying $language_file_name") if $verbose;
    print_header("Data resulting from maudifying $language_file_name") if $verbose;
    print "Sorts:\n------\n@all_sorts\n\n" if $verbose;
    print "Tokens:\n-------\n@all_tokens\n" if $verbose;
    $language_file_name =~ s/(\.k|\.kmaude)$//;
    print "\n" if $verbose;

    print_header("New commands that will be added to the generated latex file") if $verbose && ($latex || $pdf || $crop || $ps || $eps || $png);
    print join("\n",@newcommands)."\n" if $verbose && ($latex || $pdf || $crop || $ps || $eps || $png);

}

# Following is executed whenever the option -m was not selected
if (!$maudify_only) {

# Remove .maude extension if there
    $language_file_name =~ s/\.maude$//;
    $language_file_name =~ s/\.k(maude)?$//;

# Checking whether Maude is available
    # run_maude("Detecting Maude ... ", "quit\n");
    check_maude_instalation();	

    # Check incompatible sorts
    check_incompatible($language_file_name, $language_module_name) if (!($latex || $pdf || $ps || $eps || $crop || $png || $maudify_only));


# Calling either the maude compiler or the latex/pdf compiler, depending upon $latex/$pdf

    # add missing subsortations to K
    add_subsorts();


    if ($latex || $pdf || $ps || $eps || $png || $crop) 
    {
	make_latexify() if $latex;
	make_pdf() if $pdf;
	make_eps() if $eps;
	make_ps() if $ps;
	make_png() if $png;
	make_crop() if $crop;
    }
    elsif ($xml)
    {
      xmlify();
    } 
    else
    {
	compile();
    }
}




# Prints a visible message, like
# *************************
# *** Here is a message ***
# *************************
sub print_header {
    my $starred_line = my $text = "*** $_[0] ***";
    $starred_line =~ s/./*/g;
    print "\n$starred_line\n$text\n$starred_line\n\n";
}

sub xmlify {
    
# Assumes $language_file_name is a file name with no extension

    print_header("Generate xml version for module $language_module_name from language definition $language_file_name") if $verbose;

# 
#    $_ = run_maude("Getting modules META-MODULE and K-TECHNIQUE ... ",
#		   "load $k_prelude\n",
##		   "show module META-MODULE .\n",
#		   "show module K-TECHNIQUE .\n",
#		   "quit\n");
#    
#    s/^Bye.//gms;
#    s/(\[[^\[\]]*?)comm([^\[\]]*?\])/$1$2/gms;
#
#    open FILE,">",$temp_file or die "Cannot create $temp_file\n";
#    print FILE;
#    close FILE;
#    print "Temporary modules META-MODULE and K-TECHNIQUE written in $temp_file\n" if $verbose;
#
    my $xml_output = $_ =
	run_maude("Calling the Maude XML-ifier ... ",
		  "load \"$k_prelude\"\n",
		  "load \"$language_file_name\"\n",
#		  "set show advisories off .\n",
#		  "load $temp_file\n",
#		  "select META-LEVEL .\n",
#		  "select $language_module_name .\n",
#		  "set show advisories on .\n",
		  "load \"$k_to_xml\n",
		  "--- set print attribute on .\n",
                  "--- red xmlPrint('$language_module_name,'$xmlTo) .\n",
                  "--- quit\n",
		  "loop xml-print .\n",
		  "(print $language_module_name $xmlTo .)\n",
		  "quit\n");
    

        $xml_output =~ s/Bye\.//gs; 

# File name where the compiled output will be stored:
	my $output_file_name = "$lang_name.xml";
	open FILE,">",$output_file_name or die "Cannot create $output_file_name\n";

	print FILE "<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n\n";
	print FILE "<definition xmlns=\"edu.uiuc.fsl.k.kil\">\n";
	print FILE $xml_output;
	print FILE "</definition>\n";
	close FILE;
}

sub latexify {
    
    my ($format, @modules) = @_;
  
    if (@modules == 0)
    {
	my $modules_ref = get_all_modules();
	@modules = @$modules_ref;
    }
    
    foreach(@modules)
    {
	if (!exist($_))
	  {
	      print "Module $_ doesn't exist in your defintion.\n" if emptyModuleList();
	      exit(1) if emptyModuleList();
	  }
    }
    
# Assumes $language_file_name is a file name with no extension

    print_header("Generate $format version for module $language_module_name from language definition $language_file_name") if $verbose;

 
    $_ = run_maude("Getting modules META-MODULE and K-TECHNIQUE ... ",
		   "load $k_prelude\n",
#		   "show module META-MODULE .\n",
		   "show module K-TECHNIQUE .\n",
		   "quit\n");
    
    s/^Bye.//gms;
    s/(\[[^\[\]]*?)comm([^\[\]]*?\])/$1$2/gms;

    open FILE,">",$temp_file or die "Cannot create $temp_file\n";
    print FILE;
    close FILE;
    print "Temporary modules META-MODULE and K-TECHNIQUE written in $temp_file\n" if $verbose;

#    print "@modules\n";
    my $latex_output = $_ =
	run_maude("Calling the Maude Latex-ifier ... ",
		  "load \"$k_prelude\"\n",
		  "load \"$language_file_name\"\n",
		  "set show advisories off .\n",
		  "load $temp_file\n",
#		  "select META-LEVEL .\n",
#		  "select $language_module_name .\n",
		  map("select $_ .\n", @modules),
		  "set show advisories on .\n",
		  "load \"$k_to_latex\"\n",
		  "--- set print attribute on .\n",
		  "loop latex-print .\n",
		  map("(print $_ .)\n", @modules),
#		  "(print $language_module_name .)\n",
		  "quit\n");

#    s/\\begin{module}.*?\\end{module}//gms;
    my @l_modules = ();
    while ($latex_output =~ /((\\begin{module}.*?\\end{module})|(\\begin{commentModule}.*?\\end{commentModule}))/gs)
    {
#	print "ADD: $1\n\n==========================\n\n\n\n";
	push(@l_modules, $1);
    }

    if (@l_modules > 0) # && !(($_ =~ m/\\begin\{module\}/) || ($_ =~ m/\\begin\{commentModule\}/))) 
    {
	print "Latex style used: $style\n" if $verbose;
	
# File name where the compiled output will be stored:
	my $output_file_name = "$lang_name-$format.tex";
	open FILE,">",$output_file_name or die "Cannot create $output_file_name\n";
	print FILE "\\documentclass{article}\n" if !$draft;
	print FILE "\\documentclass[draft]{article}\n" if $draft;
	print FILE "\\usepackage[poster,style=$style]{$k_latex_dir/k}\n";
	
	my $abs_filename = $language_file_name;
	$abs_filename =~ s/\..*?$//;
	if (-e "$abs_filename.sty") {
	    print FILE "\\input{$abs_filename.sty}\n";
	}

	print FILE "$preamble\n";
	
	print FILE join("\n",@newcommands)."\n";

	print FILE "\n\n\\begin{document}\n";
	print FILE "\\begin{kdefinition}\n\n";
	print FILE "\n\\maketitle\n\n" if $preamble ne "";
	
	# insert $topmatter here
	if ($topmatter ne "")
	{
	    my $header = get_file_content($topmatter);
	    print FILE "% begin latex header \n";
	    print FILE "$header\n";
	    print FILE "% end latex header \n\n";
	}

	my $latex_temp = join("\\newpage", @l_modules)."\n";
	# $latex_temp = restore_intermodule_latex($latex_temp);
	
	print FILE $latex_temp;
	print FILE "\\end{kdefinition}\n";
	print FILE "\\end{document}\n";
	close FILE;
	
	# call the post-processor for latex
	my $postprocessor = File::Spec->catfile((File::Basename::fileparse($0))[1], 'perl', 'postprocess_texcmds.pl');
	my $stat = system("perl $postprocessor $output_file_name thistemp");
	if (($stat >>= 8) != 0)
	{
	    print "Warning: cannot expand latex macros!\n";
	    unlink("thistemp");
	}
	else
	{  
	    # rename("thistemp.tex", "$lang_name-$format.tex");

	    # this is an ugly fix. Perl inserts sometimes whitespaces before
	    # each line
	    
	    my $elim_spaces = get_file_content("thistemp.tex");
	    unlink("thistemp.tex");
	    open F,">", "$lang_name-$format.tex" or die "Cannot create $lang_name-$format.tex\n";
	    $elim_spaces =~ s/\n\s*\\begin{verbatim}/\n\\begin{verbatim}/sgmi;
	    $elim_spaces =~ s/\n\s*\\end{verbatim}/\n\\end{verbatim}/sgmi;
	    print F $elim_spaces;;
	    close F;
	    
	    
	    print "Latex version written in $lang_name-$format.tex\n" if $verbose;
	}
    }
    else {
	print "ERROR: \\begin{module} ... \\end{module} not found in generated output\n";
	print "This error most likely due to wrong latex attributes\n";
	print "Check generated output in $output_file\n";
	open FILE,">",$output_file or die "Cannot create $output_file\n";
	print FILE $latex_output;
	close FILE;
	print "Aborting the compilation\n";
	exit(1);
    }
}

# run latex
sub run_latex
{
    my $tex_file = shift;
    
    # get approx pdf file
    my $latex_out = get_file_content("$tex_file.tex");
    $latex_out =~ s/^\\documentclass\[landscape\]/\\documentclass/;
    $latex_out =~ s/\\begin{document}/\\geometry{papersize={1400mm,11in},textwidth=1380mm}\\begin{document}\\thispagestyle{empty}/;
    $latex_out =~ s/\\newpage/\\bigskip/g;
    # print $latex_out;
    
    open FILE,">", "$tex_file-temp.tex" or die "Cannot create $tex_file-temp.tex\n";
    print FILE $latex_out;
    close FILE;

    # create pdf
    my $status = system("latex -interaction=nonstopmode $tex_file-temp.tex > out");
    if (($status >>= 8) != 0)
    {
		throw_error("Failed to run latex. Exit status $status.\nRun 'latex $tex_file-temp.tex' to see the error generated by latex.\n");
    }
    # get number of pages
    my $pages = 0;
    
    # latex acts weird.. it generates all the temp files in the same directory 
    # but the tex file in other directory
    # $tex_file =~ s/\.\.\///g;
    
    my $log = get_file_content("$tex_file-temp.log");
#    my $log = get_file_content("$lang_name-temp.log");
    if ($log =~ /(\d+)\s+pages?/)
    {
		$pages = $1;
    }
#    print "PAGES: $pages\n";

    unlink("out");
    unlink("$tex_file-temp.aux");    
    unlink("$tex_file-temp.mrk");    
    unlink("$tex_file-temp.log");    
    unlink("$tex_file-temp.dvi");    
    unlink("$tex_file-temp.tex");    
    return $pages;
}

sub get_file_content
{
    my $filename = shift;
    
    open FILEHANDLE, "<", $filename or die "Could not open $filename:\n$!";
    my @input = <FILEHANDLE>;
    close FILEHANDLE;
    
    return join("", @input);
}

sub latex_success_msg
{
    my ($file_ext, @modules) = @_;
    print "Generated $file_ext which contains modules: @modules\n" if (@modules > 0);
    print "Generated $file_ext which contains the language definition.\n" if (@modules == 0);
}

# generates latex if $latex
sub make_latexify
{
    latexify("latex", @latexify_modules);
    rename("$lang_name-latex.tex", "$output_latex_file.tex");
    latex_success_msg("$lang_name.tex", @latexify_modules);
}

sub get_pdf_crop
{
    
    my ($format, @modules) = @_;

    latexify("$format", @modules);

    # Generate pdf
    for (my $run = 0; $run < 2; $run++) {
        my $status = system("pdflatex -interaction=nonstopmode $lang_name-$format.tex> out");
        throw_error("Failed to run pdflatex. Exit status $status.\nRun 'pdflatex $lang_name-$format.tex' to see the error generated by latex.\n") if (($status >>= 8) != 0);
    }
    
    unlink("$lang_name-$format.aux") if !$verbose;
    unlink("$lang_name-$format.mrk") if !$verbose;
    unlink("$lang_name-$format.log") if !$verbose;
    unlink("$lang_name-$format.tex") if !$verbose;
    unlink("$lang_name-$format.out") if !$verbose;
    unlink("out");
}

# generates pdf if $pdf
sub make_pdf 
{
    # Generate eps
    get_pdf_crop("pdf", @pdf_modules);
    rename("$lang_name-pdf.pdf", "$output_latex_file.pdf");
    latex_success_msg("$lang_name.pdf", @pdf_modules);
}

# generate ps if $ps
sub make_ps
{
    get_pdf_crop("ps", @ps_modules);

    # Generate ps
    my $status = system("pdf2ps $lang_name-ps.pdf 2>/dev/null");
    throw_error("Failed to generate ps. Exit status $status.\n") if (($status >>= 8) != 0);
    
    # rename ps file
    rename("$lang_name-ps.ps", "$output_latex_file.ps");
    latex_success_msg("$lang_name.ps", @ps_modules);
    
    # delete auxialiary files if not verbose
    unlink("$lang_name-ps.pdf") if !$verbose;
}

sub make_eps
{
    get_pdf_crop("eps", @eps_modules);

    # Generate ps
    my $status = system("pdf2ps $lang_name-eps.pdf 2>/dev/null");
    throw_error("Failed to generate ps temporary file for generating eps. Exit status $status.\nRun 'pdf2ps $lang_name-eps.pdf' to see the error generated by pdf2ps.\n") if (($status >>= 8) != 0);

    # Generate eps
    $status = system("ps2eps $lang_name-eps.ps 2>/dev/null");
    throw_error("Failed to generate eps. Exit status $status.\nRun 'ps2eps $lang_name-eps.tex' to see the error generated by ps2eps.\n") if (($status >>= 8) != 0);
    
    # rename eps file
    rename("$lang_name-eps.eps", "$output_latex_file.eps");
    latex_success_msg("$lang_name.eps", @eps_modules);
    
    unlink("$lang_name-eps.pdf") if !$verbose;
    unlink("$lang_name-eps.ps") if !$verbose;
}

sub make_png
{
    get_pdf_crop("png", @png_modules);

    # Generate png
    my $status = system("gs -q -dNOPAUSE -sDEVICE=pngalpha -dBATCH -dEPSCrop -r150 -sOutputFile=$lang_name-png.png $lang_name-png.pdf");
    throw_error("Failed to generate png. Exit status $status.\nRun 'gs -q -dNOPAUSE -sDEVICE=pngalpha -dBATCH -dEPSCrop -r150 -sOutputFile=$lang_name-png.png $lang_name-png.pdf' to see the error generated by gs.\n") if (($status >>= 8) != 0);

    # rename png file
    rename("$lang_name-png.png", "$output_latex_file.png");
    latex_success_msg("$lang_name.png", @png_modules);
    
    # delete auxialiary files if not verbose
    unlink("$lang_name-png.eps") if !$verbose;
    unlink("$lang_name-png.pdf") if !$verbose;
}

# generates a nice - pdf if $crop
sub make_crop
{
print "Calling make_crop\n";
    latexify("crop", @crop_modules);

    # modify page and save it
    my $latex_out = get_file_content("$lang_name-crop.tex");

    # Find number of pages
    my $pages = run_latex("$lang_name-crop");
    my $h = 9 * $pages;
    my $ph = $h + 1;
    $latex_out =~ s/^\\documentclass\[landscape\]/\\documentclass/;
    my $settings = "\\geometry{papersize={1400mm,".$ph."in},textheight=".$h."in,textwidth=1380mm}\\begin{document}\\thispagestyle{empty}\\noindent\\hspace{-2px}\\rule{1px}{1px}";
    $latex_out =~ s/\\begin{document}/$settings/;
    
    # initial settings
    open FILE,">", "$lang_name-crop.tex" or die "Cannot create $lang_name-crop.tex\n";
    print FILE $latex_out;
    close FILE;    

    # Generate pdf
    my $status = system("latex -output-format=pdf $lang_name-crop.tex > out");
    throw_error("Failed to run latex. Exit status $status.\nRun 'pdflatex $lang_name-crop.tex' to see the error generated by latex.\n") if (($status >>= 8) != 0);
    
    # Generate pdf-crop
    $status = system("pdfcrop $lang_name-crop.pdf > out");
    throw_error("Failed to generate crop pdf. Exit status $status.\nRun 'pdfcrop $lang_name-crop.pdf' to see the error generated by pdfcrop.\n") if (($status >>= 8) != 0);

    # print message
    rename("$lang_name-crop-crop.pdf", "$output_latex_file-crop.pdf");
    latex_success_msg("$lang_name-crop.pdf", @crop_modules);
    
    # delete auxialiary files if not verbose
    unlink("$lang_name-crop.pdf") if !$verbose && ($lang_name ne $output_latex_file);
    unlink("$lang_name-crop.tex") if !$verbose;
    unlink("$lang_name-crop.aux") if !$verbose;
    unlink("$lang_name-crop.dvi") if !$verbose;
    unlink("$lang_name-crop.log") if !$verbose;
    unlink("$lang_name-crop.tex") if !$verbose;
    unlink("out");
    
}


# Next routine compiles the language definition in $language_file_name
# It also performs some sanity checks
sub compile {
# Assumes $language_file_name is a file name with no extension
    

#    print "FILES: " . getFileList() . "\n\n";
#    exit(1);
# Testing whether the input module $language_module_name exists
    run_maude("Testing if the input module $language_module_name exists ... ",
			"load \"$k_prelude\"\n",
	      "load \"$language_file_name\"\n",
	      "show module $language_module_name .\n",
	      "quit\n");

    print_header("Compiling $language_file_name, starting with module $language_module_name") if $verbose;

# File name where the compiled output will be stored:
    my $output_file_name = "$language_file_name-compiled.maude";
    
    my $old_language_file = $language_file_name;
	my $old_language_module = $language_module_name;
	if ($require_k_main)
	{
		$language_file_name = $kmain . $language_file_name . ".maude";
		$language_module_name = uc($kmain) . $language_module_name;
		
		open TEMP, ">", $language_file_name or die "Cannot open $language_file_name";
		print TEMP "in $old_language_file\n";
		print TEMP "mod $language_module_name is including K + $old_language_module . endm\n";
		close TEMP;
		push(@generated_files, $language_file_name);
	}
   
# Compiling the input module $language_module_name
    if ($unquote) {
       
		# If unquote is set then do some changes
		$_ = run_maude("Compiling the definition ... ",
			"load \"$k_prelude\"\n",
			"load \"$language_file_name\"\n",
			"load \"$k_all_tools\"\n",
			"set print attribute off .\n",
			"rew compile('$language_module_name, supercools(metadataParse(\"$flag_supercool\")) transitions(metadataParse(\"$flag_transition\")) superheats(metadataParse(\"$flag_superheat\"))
anywheres(metadataParse(\"$flag_anywhere\"))
defineds(metadataParse(\"$flag_defined\"))
) .\n",
			"quit\n");
		
		my @lines = split(/\n/, $_);
		shift @lines;
		shift @lines;
		shift @lines;
		pop @lines;
		my $errorSet = 0;
		if ($lines[0] =~ s/result \[ModuleSet\]: (.*)$/$1/) {
			$errorSet = 1;
		}
		if ($errorSet) {
			print wrap("", "", "[ERROR]: Aborting the compilation\n");
			my $unquotedOutput = unquote($maude_xml_file);
			print "$unquotedOutput\n";
			unlink($maude_xml_file);
			exit(1);
		}
		my $unquotedOutput = unquote($maude_xml_file);
		unlink($maude_xml_file);
		$_ = "$begin_compiled_module$unquotedOutput$end_compiled_module";
    }
    else
    {
	my $compile_supercools = "\"$flag_supercool\"";
	my $compile_transitions = "\"$flag_transition\"";
	my $compile_superheats = "\"$flag_superheat\"";    
	my $compile_anywheres = "\"$flag_anywhere\"";
	my $compile_defineds = "\"$flag_defined\"";
	my $action = "(compile $language_module_name transitions $compile_transitions superheats $compile_superheats supercools $compile_supercools anywheres $compile_anywheres defineds $compile_defineds .)";
	$action = "(purify $language_module_name transitions $compile_transitions superheats $compile_superheats supercools $compile_supercools anywheres $compile_anywheres defineds $compile_defineds .)" if $pure;
#	$action = "(xcompile $language_module_name $xmlTo transitions $compile_transitions superheats $compile_superheats supercools $compile_supercools anywheres $compile_anywheres defineds $compile_defineds  .)" if $xml;
	$_ = run_maude("Compiling the definition ... ",
	    "load \"$k_prelude\"\n",
	    "load \"$language_file_name\"\n",
	    "load \"$k_all_tools\"\n",
            "---(\n",
            "rew in COMPILE-ONESHOT : partialCompile(upModule('$language_module_name , false),'???,\n",
            "supercools(metadataParse(\"$flag_supercool\")) transitions(metadataParse(\"$flag_transition\")) superheats(metadataParse(\"$flag_superheat\")) anywheres(metadataParse(\"$flag_anywhere\")) defineds(metadataParse(\"$flag_defined\"))) .\n",
            "quit\n",
            "---)\n",
	    "loop compile .\n",
	    "$action\n",
	    "quit\n");
	
	
	unlink($maude_xml_file);
    }

    # remove KMAIN-
    $kmain = uc($kmain);
    s/$kmain//s;
#    print;
    
# If the keyword "Error" begins a line in the output, then extract and report the error message
    if (/^Error: (.*?)Bye/sm) {
	print wrap("", "", "[ERROR]: Aborting the compilation\n");
	print $1;
	exit(1);
    }

# If the output contains a generated Maude file, then write it in $output_file_name
    if (/$begin_compiled_module(.*?)$end_compiled_module/s) {
	open FILE,">",$output_file_name or die "Cannot create $output_file_name\n";
	#	print FILE "\*\*\*\(\n$k_license\n\)\*\*\*\n\n\n";	
	print FILE "--- Compiler checksum: " . get_checksum() . "\n";
	print FILE "load \"$k_prelude\"\n";
	print FILE "load $lib\n" if ($lib ne "" && $lib ne "?");
	print FILE $1;
	close FILE;
	push(@generated_files, $output_file_name);
	
	print "Compiled version written in $output_file_name.\n";
    }

# Otherwise there must be some error that the script is now aware of, so show the whole thing
    else {
	print wrap("","","[ERROR]: cannot parse the output below (returned by the compiler):\n$_\n") if $_ ne "-1";
	print wrap("", "", "Aborting the compilation\n");
	exit(1);
    }
}


# This is called whenever everything went fine, to clean up the temporary files
sub clean {
    unlink($input_file);
    unlink($output_file);
    unlink($error_file);
    unlink($temp_file);
}


# Running Maude (cross platform)
sub run_maude {
    my ($message,@commands) = @_;
    print $message if $verbose;
    open FILE,">",$input_file or die "Cannot create $input_file\n";
    print FILE "\n@commands\n";
    close FILE;

	# clean error file and output file
	unlink($output_file);
	unlink($error_file);

    # call maude
    my $status = system("$maude_path -no-banner -no-wrap $additionalMaudeFlags $input_file >$output_file 2>$error_file");
 
    my $err = get_file_content($error_file);
    my $out = get_file_content($output_file);
    
#    print "ERR: " . get_file_content($error_file) . "\n\n";
#    print "OUT: " . get_file_content($output_file) . "\n\n";
    
    if (($status >>= 8) != 0)
    {
	print wrap("", "", "Failed to run maude.\nExit status $status.\nTo reproduce run `maude $k_dir/$input_file`.\n");
	return -1 ;
    }

    if ($err =~ /\[ERROR\](.*?)\[ENDERROR\]/sg || $out =~ /\[ERROR\](.*?)\[ENDERROR\]/sg)
    {
	print wrap("", "", "[ERROR]: $1\n");
        if ($err ne "") {
 	  print wrap("", "", "Check $k_dir/$error_file to find additional errors.\n");
        }
	return -1;
    }
    
    if ($out =~ /\[ERROR\](.*?)\[ENDERROR\]/sg)
    {
	print wrap("", "", "[ERROR]: $1\n");
	return -1;
    }
        
    if ($? == 0) {
	if (-s $error_file) {
	    local $_ = get_file_content($error_file);
	    my $lfn = $language_file_name;
	    $lfn =~ s/$kmain//sg;
	    print wrap("", "", "[MAUDE ERROR]: " . parse_maude_error($_, $error_file, $lfn));
	    exit(1);
	}
	print "DONE\n" if $verbose;
	local $_ =  get_file_content($output_file);
	clean();
	return $_;
    }
    else {
	print wrap("", "", "\nMaude cannot be detected: the command $maude_path does not execute\nAborting the compilation\n");
	clean();
	exit(1);
    }
}


# The function maudify($file) does the following operations:
# 1) Maude-ifies $file in case it is a .k|.kmaude file, generating a .maude file
# 2) It does the same recursively on each included file
# 3) Updates the global variables @all_sorts and @all_tokens
# - one to the list of sorts that are declared in the $file or in its included files
# - another to the list of tokens that appear in operations declared in the $file or its included files
sub maudify_file {
# Bind $file and $indent (the latter used for pretty printing when$verbose
    my ($file,$indent) = @_;
# If $file has extension .k, .kmaude or .maude then tests if $file exists and errors if not
    
    print $indent."Processing file $file\n" if $verbose;
    $indent .= "|   ";
	
    open FILE,">","$file.k2slurp" or die "Cannot write $file.k2slurp\n";
    print FILE "\n\nrequire /modules/uris\nrequire $file\n\n";
    close FILE;
    
    $_ = slurp_k("$file.k2slurp", $latex || $png || $pdf || $ps || $crop || $eps);
    unlink("$file.k2slurp");

# crazy functions
    $_ = process_functions($_);

# remove quotes from syntax
    $_ = remove_quotes($_);

# extract subsorts
    sorting($_);
 
# resolve rule tags
    $_ = rule_tags($_);
        
# dots issue: change <cell>.</cell> into <cell> . </cell>
    s!<(.*?)>\.</\1>!<$1> \. </$1>!g;
    
# lists
    $_ = solve_lists($_);
#    print;
#    exit;
    
# lists
    $_ = solve_ids($_);
#    print;
#    exit;
    
# Replacing dots    
    $_ = replace_dots($_);

    # temp
    my $temporary = $_;

# maudifying     
    my $maudified = "";
    while ( s!^(\s*)($top_level_pattern)(\s*)!!sm ) 
    {
	(my $before, local $_, my $after) = ($1,$2,$3);
	if ( m!^kmod\s+(\S+)! ) 
	{
	    print $indent."K module $1 ... " if $verbose;
	    push(@kmodules,$1);
	    my $mno = countlines($`) if ($temporary =~ /\Q$_\E/);
	    # print "$_\n\n$mno\n\n";
	    
	    $_ = maudify_module($file, $mno, $_);
	    print "DONE\n" if $verbose;
	}
	elsif ( m!^f?mod\s+(\S+)! ) 
	{
	    print $indent."Maude module $1 ... " if $verbose;
	    add_sorts($_);
	    add_tokens($_);
	    print "DONE\n" if $verbose;
	}
        $maudified = "$maudified$before$_$after";
    }

    if (/\S/) 
    {
#        print "ERROR: Cannot finish processing $file\n";
#        print "ERROR: The following text does not parse:\n$_";
	print wrap("", "", generate_error("ERROR", 1, $file, "unknown line", "Cannot finish processing $file\n"));
	print wrap("", "", generate_error("ERROR", 1, $file, "unknown line", "The following text does not parse:\n$_"));
        exit(1);
    }
    
    $indent =~ s/\|   //;
    print $indent."Done with processing file $file\n" if $verbose;
    
    if ($file =~ /\.maude/) { return; }
    
    my $maude_file = ($file =~ /^(.*)\.k(?:maude)?$/)[0].".maude";
#    print generate_error("WARNING", 1, $file, "unknown line", "Unbalanced parentheses in file $maude_file\nMaude might not finish...\n") if (!balanced($maudified, '(', ')', '`'));
#    print "Warning: Unbalanced parentheses in file $maude_file\nMaude might not finish...\n" if (!balanced($maudified, '(', ')', '`'));

	# put comments back
#	$maudified = put_back_comments($maudified, $myComments);

	# add k_license to it
#	$maudified =~ s!^!\*\*\*\(\n$k_license\n\)\*\*\*\n\n\n!;

    open FILE,">",$maude_file or die "Cannot write $maude_file\n";
    print FILE $maudified;
    close FILE;

    push(@generated_files, $maude_file);

# Step: put all tokens in .k
    if (!$flag)
    {
	open F, ">", $tokens_file or print "Cannot save tokens!\n";
	print F "@all_tokens\n@all_syntax";
	close F;
	push(@generated_files, $tokens_file);
    }
}
sub maudify_module {
    (my $file, my $mno, local $_) = @_;

    # add K or K-LATEX automatically.
    $_ = addKandKLATEX($_, $file);

    build_module_tree($file, $_);
#    print "Maudifying module with tokens @all_tokens\n";

    # Parse the configuration
    if (/configuration\s+(.*?)\s+(?=$kmaude_keywords_pattern)/sg)
    {
	if (defined $1)
	{
	    parse_configuration($1, countlines($`), $file);
	}
    }
    
    
    my $mname = $1 if /kmod\s+(\S+)/sg;
#    if (!$k_auto_incl && $mname eq $language_module_name && !includesK($language_module_name))
#    {
	$require_k_main = 1;
#    }
    
    
    
# Step: resolve macros
    s/(\[[^\]]*?($k_attributes_pattern)[^\]]*?\])/Freeze($&, "ATTR")/gse;
    s!((?:$kmaude_keywords_pattern).*?)(?=(?:$kmaude_keywords_pattern|$))!resolve_where_macro($1)!gse;
    $_ = Unfreeze("ATTR", $_);
    
# Step: desugar latex newline <br/>
    $_ = desugar_latex($_);

# Step: Add whitespace between cell and Klabel
    s!(<\s*\/?\s*[^\s<]+\s*>)(')!$1 $2!g;

    # get KLabels
    my $tmp = $_;
    while ($tmp =~ /(rule|context).*?(?=$kmaude_keywords_pattern)/sg)
    {
	my $all = $&;
	my $alls = $all;
        $all =~ s/(?<!\,)($string_pattern)/Freeze($&,"STRINGS")/sge;
	s/\Q$alls\E/$all/s;
    }

    my $decl = getKLabelDeclarations($_);

    # unfreeze strings
    $_ = Unfreeze("STRINGS", $_);

# Step: Add to @all_sorts all sorts defined in  k-prelude
    add_kprelude_sorts($k_prelude, dirname($k_prelude)) if !$k_prelude_loaded;
    $k_prelude_loaded = 1;

# Step: Add to @all_sorts all sorts defined a la Maude, with "sort(s)"
    add_sorts($_);
    
# Step: Freeze on-the-fly anonymous variable declarations
    s!_(:$ksort)!?$1!sg;
    s!(\?:$ksort)!Freeze($1,"ANONYMOUS")!ge;
#     print  "Stage:\n$_\n\n";
    
# Step: Desugar syntax N ::= Prod1 | Prod2 | ... | Prodn
# At the same time, also declare N as a sort if it is not declared already
	# freeze strings and attributes
    s/($string_pattern)/Freeze($&,"MYSTRINGS")/sge;
    s/(\[[^\]]*?($k_attributes_pattern)[^\]]*?\])/Freeze($&, "ATTRIBUTES")/gse;
    s!(syntax\s+.*?)(?=$kmaude_keywords_pattern)!make_ops( (countlines($`) == 0 ? $mno : countlines($`) + $mno - 1), $file, $1)!gse;

	# unfreeze attributes if any
    $_ = Unfreeze("ATTRIBUTES", $_);
    $_ = Unfreeze("MYSTRINGS", $_);
    # print  "Stage:\n$_\n\n";

# Step: Store the on-the-fly variables
    my $vars = on_the_fly_kvars($_);
    #  print  "Stage:\n$_\n\n";
    
# Step: Reduce cell notation with _ to cell notation with ...
    s/\sops?\s(.*?):/Freeze($&,"OPS")/gse;
    
    # Sub-step: _ -> ... : Deprecated!
    s!<(\s*[^\s<]+\s*)_\s*>!<$1>... !gs;
    s!<\s*_(\s*/\s*[^\s>]+\s*)>! ...<$1>!gs;
    
    # Sub-step: <> ... goes into <>... 
    s!(<\s*[^\s>]+\s*>)\s*(\.\.\.)!$1$2 !gs;
    s!(\.\.\.)\s*(<\s*\/\s*[^\s>]+\s*>)! $1$2!gs;

    $_ = Unfreeze("OPS", $_);
#    print  "Stage:\n$_\n\n";
    
# Step: Declare cell labels as operations
    $_ = add_cell_label_ops($_);
#    print  "Stage:\n$_\n\n";
    
# Step: Add the module's newly defined tokens to @tokens
	my $klabelss = $decl . getDeclLabels();		
	$klabelss =~ s/\s+$//s;		
	my @kls = split(/\s+/, $klabelss);		
# print "LABELS: @kls\n\n";
	foreach my $kl (@kls)		
	{
	    if ( $kl =~ /'/sg )
            {
		s/(\Q$kl\E)/Freeze($kl, "KLABEL1")/sge;		
	    }
       }
       add_tokens($_);
       $_ = Unfreeze("KLABEL1", $_);
#     print  "Stage:\n$_\n\n";
    
# Step: Add missing spaces around tokens
	# freeze all attributes
	s/((?<!`)\[\s*($k_attributes_pattern).*?(?<!`)\])(\s*)(?=$kmaude_keywords_pattern)/{Freeze($1, "ATTR").$3;}/gse;
        # print "FROZEN: $_\n\n";

    # freeze all strings before spacifying
    my $tmp = $_;
    while ($tmp =~ /(rule|context|configuration).*?(?=$kmaude_keywords_pattern)/sg)
    {
	my $all = $&;
	my $alls = $all;
        $all =~ s/(?<!\,)($string_pattern)/Freeze($&,"STRINGS")/sge;
	s/\Q$alls\E/$all/s;
    }

    my $klabelss = $decl;		
    $klabelss =~ s/\s+$//s;		
	my @kls = split(/\s+/, $klabelss);		
	foreach my $kl (@kls)		
	{		
		s/(\Q$kl\E)/Freeze($kl, "KLABEL")/sge;		
	}

        s/(subsorts?\s+.*?)(\s+)(?=$kmaude_keywords_pattern|STRINGS|ATTR|KLABEL)/{Freeze($1, "SUBSORTS") . $2;}/sge;
        s/(sorts?\s+.*?)(\s+)(?=$kmaude_keywords_pattern|STRINGS|ATTR|KLABEL|SUBSORTS)/{Freeze($1, "SORTS") . $2;}/sge;

    # freeze configuration
    s/\$[A-Z]+/{Freeze($&, "PVAR");}/sge;

# print ;
        $_ = spacify($_);

        $_ = Unfreeze("PVAR", $_);
	$_ = Unfreeze("ATTR", $_);
	$_ = Unfreeze("STRINGS", $_);
	$_ = Unfreeze("KLABEL", $_);
        $_ = Unfreeze("SUBSORTS", $_);
        $_ = Unfreeze("SORTS", $_);


# print "$_\n\n";
#	print "============================\n\n\n";
    
# Step: Declare the on-the-fly variables
    s/(?=endkm)/$vars?"$vars ":""/se;
#      print  "Stage:\n$_\n\n";


# Step: Change .List into (.).List , etc.
    s/\.(K|List|Set|Bag|Map)(?!(`|\w|(\s*\{)))/(.).$1/gs;
#    print  "Stage:\n$_\n\n";
    
# Step: Replace remaining _ by ? (spaces were put around _ by spacify)
    s! _ ! ? !gs;
#     print  "Stage:\n$_\n\n";
    

# Step: Change K statements into Maude statements
	# freeze attributes first.. because sending parameters is dangerous: see ":"!!!
	s/((?<!`)\[\s*($k_attributes_pattern).*?(?<!`)\])(\s*)(?=$kmaude_keywords_pattern)/{Freeze($1, "ATTR").$3;}/gse;
#	s/(\[[^\]]*?($k_attributes_pattern)[^\]]*?\])/Freeze($&, "ATTR")/gse;
	
	# also freeze rule names
	s!(?<=rule\s)(\s*\[.*?\])!Freeze($&, "NAMES")!sge;


    # maudify
    s!((?:$kmaude_keywords_pattern).*?)(?=(?:$kmaude_keywords_pattern|$))!k2maude($1)!gse;

	# unfreeze if there are still frozen attributes
	$_ = Unfreeze("ATTR", $_);
#	print  "Stage:\n$_\n\n";
   
# Step: Unfreeze everything still frozen
    $_ = Unfreeze("ANONYMOUS", $_);
#    $_ = unfreeze($_);
    # print  "Stage:\n$_\n\n";

# Step: Add KLabel generated definitions - do that in shared.k for now
    if ($decl ne "")
    {
	$klabels .= $decl;
	s!mod(\s+)([\S]+)(\s+)is(\s+)!"mod$1$2$3is including K-SHARED .$4"!se;
	$mset = 1;
    }
#    print  "Stage:\n$_\n\n";

# Step: register all subsort relations
    register_subsorts($_);

# Step: check balanced parentheses - maude specific
    my $module_name = $1 if (/k?mod\s+([a-zA-Z\-]+)\s+is/);
    print wrap("", "", generate_error("WARNING", 1, $file, "unknown line", "Unbalanced parentheses in module $module_name\nMaude might not finish.\n")) if (!balanced($_, '(', ')', '`'));

    return $_;
}


# Takes a syntax statement and extracts sorts, subsorts and operations
sub make_ops {
    my $sno = shift;
    my $file = shift;
    local ($_) = @_;
    
#    print "$_\n\n$sno\n\n\n";
    
#	print "Frozen: $_\n";
    $_ = Unfreeze("ATTRIBUTES", $_);
    $_ = Unfreeze("MYSTRINGS", $_);
#    print "Unfrozen: $_\n";
#    print "make_ops:\n$_\nat line $sno\n";

# 	keep temporary four counting lines
	my $temporary = $_;

# Grab the result sort and the productions, as well as all spacing
 	my ($spaces1,$result_sort,$spaces2,$bnf,$productions,$spaces3) =  /^syntax(\s+)(\S*)(\s*)(::=)(.*?\S)(\s*)$/s;
#	print "$result_sort\n";
#	print "\$productions\n$productions\n";

# Report error and stop if the BNF form is not respected
	if (!defined($bnf)){
#		print "ERROR: Syntactic categories must contain \"::=\" at line:\n$_\n";
		print wrap("", "", generate_error("ERROR", 1, $file, "unknown line", "Syntactic categories must contain \"::=\" at line:\n$_\n"));
		exit(1);
	}

# Report error and stop if the sort name does not match $ksort
	if ($result_sort !~ /^$ksort$/) {
	    print wrap("", "", generate_error("ERROR", 1, $file, "unknown line", "Sort \"$result_sort\" does not match the pattern \"$ksort\" in\n$_\nSyntactic categories must currently match this pattern\n"));
	    exit(1);
	}

# Add $result_sort to @all_sorts if not already there
	my $sort_decl = "";
	if ( ! (grep { "$_" eq "$result_sort" } @all_sorts) ) {
	    $sort_decl = "sort $result_sort";
#	    print "ADD: $result_sort\n";
	    push(@all_sorts, $result_sort);
            my $oh_my = $result_sort;
#          
#          Code to add the sorts as tokens
#
#            $oh_my =~ s/`//gs;
#            push(@all_tokens, $oh_my);
#            print "OH_MY1: $oh_my\n";
#            $oh_my =~ s/[{}]/`$&/gs;
#            push(@all_tokens, $oh_my);
#            print "OH_MY1: $oh_my\n";
#	    print "ALL: @all_sorts\n\n";
	}

        my $result = "$spaces1 $sort_decl $spaces2";

# Extract all productions in @productions
	my @productions = ($productions =~ /(.*?\S.*?(?:\s\|\s|$))/gs);

#        print "PRODS: ".join("#",@productions)."\n";
	foreach my $production (@productions) {
	    
		# count line numbers
		my $absolute_line = countlines($PREMATCH) + $sno - 1 if ($temporary =~ /\Q$production\E/);

# Removing the | separator
		$production =~ s/(\s)\|(\s)/$1$2/gs;

# Getting the operation attributes, if any
		my $attributes = "";

		# freeze strings before extracting the attributes because these can contain
		# some [] which will cause a wrong extraction
		$production =~ s/($string_pattern)/Freeze($&,"MYS")/sge;	
		$production =~ s/(\[[^\[\]]*\]\s*)$/
						{
							if (op_attribute($1)) {
								$attributes = $1;
								"";
							} else {$1;}
						}/se;
		$production = Unfreeze("MYS", $production);
#		print "ATTR: $attributes\n";

# Removing the spaces before and after the actual production
		my ($space4,$space5) = ("","");
		$production =~ s/^(\s*)(.*?\S)(\s*)$/
						{
						    $space4 = $1;
						    $space5 = $3;
						    $2
						}/se;

# Extracting the list of sorts in the production, then replacing the sorts by "_"
#	    print "PROD: $production\n";
	    my @sorts = ();
	    while($production =~ m/((?:^|\s)$ksort(?=\s|$))/g)
	    {
		push(@sorts, $&);	
	    }
	    
#	    print "PROD: $production\nSORTS: @sorts\n";
		$production =~ s/(?:^|\s)$ksort(?=\s|$)/_/g;
		$production =~ s/\s*_\s*/_/gs;
#	    print "PROD: $production\n";

#	    print "==============================\n";
#	    print "Production1:\n$production\n";
	    
# Replacing spaces in the production by "`"
#	        $production =~ s/\s+/`/gs;
	        
	    # Ugly hack: replace all strings with !&!&! 
	    # to avoid replacing spaces inside strings
	    my $strings = "";
	    $production =~ s/(\".*?\")/ { 
			$strings .= "!&!&!$1"; 
	    }
	    "!&!&!"
	    /gse;
	    
	    # replace spaces
	    $production =~ s/\s+/`/gs;

#	    print "Production2:\n$production\n";
	    # put the strings back
	    while ($strings =~ m/!&!&!(\".*?\")/g)
	    {
		my $str = $1;
		$production =~ s/!&!&!/$str/;
	    }
	    
	    
#	    print "Production3:\n$production\n";
#	    print "String:\n$strings\n";
#	    print "==============================\n";

# Removing unnecessary `
		$production =~ s/(^|$maude_special)`/$1/gs;
		$production =~ s/`($|$maude_special)/$1/gs;



#	    print "PROD: $production\n";
# Add a latex attribute in case $latex and there is not already a user-defined one
	    if (($latex || $pdf || $png || $ps || $eps || $crop) && ($attributes !~ /latex/)) 
	    {
		my $latex_text = $production;
		my $counter = 0;
		$latex_text =~ s/([^_]+)/"\\terminal\{".make_latex($1)."\}"/gse;
		$latex_text =~ s/_/$counter++;"{#$counter}"/ges;
		$latex_text =~ s/"/&!&!&!/g;
                if ($attributes eq "") 
                {
                    $attributes = "[]";
		}
                 
                $attributes =~ s/^\[/[latex "$latex_text" /;
	    }


	
	# unfreeze here what was frozen in $production
	$attributes = Unfreeze("MYS", $attributes);

	$attributes = op_tags($attributes);
	
        # store the syntax production
        push(@all_syntax, $production);

# Generate the Maude replacement of the K syntactic construct
		my $random = fresh("a", "b");
		unlink($random);
		$random =~ s/[a-z_]//sg;

                $production =~ s/`/ /gs;
# print "SORTS: @sorts\n";
		if ($latex || $pdf || $ps || $crop || $eps || $png)
		{
			$result .= ($production eq "_")
						? "$space4 subsort @sorts < $result_sort op k2Latex@sorts"."2$result_sort$random"."_ : @sorts -> $result_sort $attributes $space5 "
						: "$space4 op $production : @sorts -> $result_sort$space5 $attributes ";
		}
		else {
			$result .= ($production eq "_")
						? "$space4 subsort @sorts < $result_sort$space5 "
						: "$space4 op $production : @sorts -> $result_sort$space5 $attributes ";
		}
	}

# print "Done\n";
#        print "RESULT:$result\n";
	return "$result$spaces3";
}


sub op_attribute {
	local ($_) = @_;
	/strict|extends|prec|hybrid|gather|metadata|latex|ditto|format|assoc|comm|id:/;
}


sub make_latex {
    local ($_) = @_;
    s/(\W)`/$1/gsm;
    s/`(\W)/$1/gsm;
    s/`/ /gsm;
    s/\\/\\textbackslash /gsm;
    s/($latex_special)/\\$1/gsm;
    s/\^/\\mbox{\\^{}}/gsm;
    s/\$/\\mbox{\\textdollar{}}/gsm;
    s/\~/\\ensuremath\\sim{}/gsm;
    return $_;
}

sub k2maude {
    local ($_) = @_;

    $_ = Unfreeze("ATTR", $_);
    $_ = Unfreeze("NAMES", $_);
    
#	print "TODO: $_\n";

	# macros
    s/macro(\s)/eq$1/gs;
    
    switch ($_) {
	case /^kmod/                    { s/kmod/mod/; }
	case /^endkm/                   { s/endkm/endm/; }
	case /^$default_freezer/        {}
	case /^mb/			{ s/^mb\s+latex(.*\S)(\s*)$/mb latex $1 .$2/sg }
	case /^kvar/                    { s/k(var.*\S)(?=\s*)/$1 ./; }
 	case /^rule/                    { s/^(.*\S)(\s*)$/mb $1 : KSentence .$2/sg;
									  s!(\[[^\[\]]*\]) : (KSentence)!
									  (rule_attribute($1))?": $2 $1":"$1 : $2"!se;
									  s!^mb(\s+)rule(\s+\[[^\[\]]*\]\s*:)!mb$2$1rule!s;
									}
	case /^context/                 { s/^(.*\S)(\s*)$/mb $1 : KSentence .$2/sg;
									  s!(\[[^\[\]]*\]) : (KSentence)!
									  (rule_attribute($1))?": $2 $1":"$1 : $2"!se;
									  s!^mb(\s+)context(\s+\[[^\[\]]*\]\s*:)!mb$2$1context!s;
							        }
	case /^(configuration)/         { 
	                                    if (/^(.*\S)(\s+)\[\s*metadata/s)
	                                    {
						s/^(.*\S)(\s*)(\[\s*metadata.*\S)(\s*)$/mb $1$2 : KSentence $3 . $4/s;
					    }
	                                    else { s/^(.*\S)(\s*)/mb $1 : KSentence .$2/s; }
	                                }
	else                            { s/(\S)(\s*)$/$1 .$2/s; }
    }
    return $_;
}


sub rule_attribute {
    local ($_) = @_;
    /metadata|label/;  # add more keywords/patterns to recognize rule attributes
}


sub get_newcommand 
{
    local ($_) = @_;
    s/&!&!&!/"/g;
#    print "Apelat.\n";
    my $n = $newcommand_counter++;
    my $newcommand = $newcommand_prefix.chr(65 + $n % $newcommand_base);
    while ($n >= $newcommand_base) {
		$n /= $newcommand_base;
		$newcommand .= chr(65 + $n % $newcommand_base);
    }

    my @args = sort /{#(\d+)}/gms;
    my $max = $args[$#args];
    my $args = @args ? "\[$max\]" : "";
    s/\\\[/[/g;
    s/\\\]/]/g;
    s!(\{\#\d+\})(\{\#\d+\})!$1\\mathrel{}$2!g;
    push(@newcommands, "\\newcommand\{\\$newcommand\}$args\{$_\}");
    s/terminal/terminalNoSpace/gs;
    my $newcommandNoSpace = $newcommand."NoSpace";
    push(@newcommands, "\\newcommand\{\\$newcommandNoSpace\}$args\{$_\}");
#    print "Comanda: $newcommand\n";
    return $newcommand;
}


# Extract and declare on-the-fly kvariables
sub on_the_fly_kvars {
    local ($_) = @_;
    my %kvar_decls = ();
    s/\b($kvar):($ksort)/
    {
	if ($kvar_decls{$1}) {
	    if ($kvar_decls{$1} ne $2) {
		print wrap("", "", "WARNING: Variable $1 declared with two distinct sorts ($kvar_decls{$1} and $2)\n") if $verbose;
#		exit(1);
	    }
	} 
#    else {
	    $kvar_decls{$1} = $2;
#	}
	"$1:$2";
    }
    /gse;
    my $kvars = "";
    while (my ($key,$val) = each %kvar_decls) {
      if ($key ne "HOLE") {
	$kvars .= "kvar $key : $val ";
      }
    }
    
    return $kvars;
    
    # deprecated
    s/(?=endkm)/$kvars?"$kvars ":""/se;
    return $_;
}

# If there is any configuration, get all its cell labels and declare them at the end of kmodule
sub add_cell_label_ops_ {
    local ($_) = @_;
    my $ops = (/(?<=\s)configuration\s+(.*?)(?:$kmaude_keywords_pattern)/s
	       ? "ops ".join(" ",set($1 =~ /<\s*\/?\s*(.*?)\s*[\*\+\?]?\s*>/gs))." : -> CellLabel " : "");
    s/(?=endkm)/$ops?"$ops ":""/se;

	# switch to old accepted configuration
	my $i = 0;
	while ($i < 20)
	{
		s!<\s*([a-zA-Z\-]+)\s+multiplicity="(.*?)"\s*>(.*?)<\/\1>!<$1$2>$3</$1$2>!s;
		$i++;
	};

    return $_;
}

sub add_cell_label_ops
{
	local $_ = shift;
	if (/(?<=\s)configuration\s+(.*?)(?=$kmaude_keywords_pattern)/s)
	{
		parse_configuration($1, 0, "$language_file_name.k");
		my $label_declarations = get_cell_label_declarations();
		s/(?=endkm)/ $label_declarations /s;

		# switch to old accepted configuration
		# replace multiplicity		
#		my $i = 0;
#		while ($i < 20)
#		{
#			s!<\s*([a-zA-Z\-]+)\s+multiplicity="(.*?)"\s*>(.*?)<\/\1>!<$1$2>$3</$1$2>!s;
#			$i++;
#		};

		# replace color attribute
#		s!<\s*([a-zA-Z\-]+)\s*color=".*?"\s*>!<$1>!sg;
	}

	$_;
}

# This subroutine returns a list of all spacifiable tokens that appear in operations defined (using op) in the argument
# By spacifiable tokens we mean ones that the tool may need to add spaces to their left and/or right
sub add_tokens {
    local $_ = shift;
# Extracting all the defined operations
#    my @ops = grep(split(/\s+/s, $_), /\sops?\s+(.*?)\s+:\s+/gms);
    my @ops = /\sops?\s+(.*?)\s+:\s+/gms;

# Put all operations in one string
    $_ = "@ops";

#    print "SOPS: $_\n";
    # Exclude strings because they can contain whitespaces
    my $strings = "";
    s/(\".*?\")/{$strings .= "$1!&!&!"; } "!&!&!"/gse;
    my @strs = split(/!&!&!/, $strings);
    
# Keep those operation names which have no _ or ` as tokens
    my @tokens = grep(!/[_`]/,split(/\s+/s));

    # print "TOKENS: @tokens\n";
# Extract all tokens that appear in operations
    @tokens = (@tokens, /$maude_special?($maude_unspecial+)/g) ;

    # Put the strings back
    my $index = 0;
    foreach my $token (@tokens)
    {
	while ($token =~ /!&!&!/g)
	{
	    $token =~ s/!&!&!/$strs[$index]/ if defined $strs[$index];
	    $index ++;
	}
    }
    
    
# Add allmeaningful tokens in @tokens to @all_tokens
    @all_tokens = set(@all_tokens, grep(/\W/, set(@tokens)));
}

# This subroutine returns a list of all spacifiable tokens that appear in operations defined (using op) in the argument
# By spacifiable tokens we mean ones that the tool may need to add spaces to their left and/or right
sub add_sorts {
    local $_ = shift;

# Extracting all the defined sorts
    my @sorts = /\ssorts?((?:\s+$ksort)+)\s+(?=\.|$kmaude_keywords_pattern)/gs;


    @sorts = split(/\s+/, "@sorts");
	
#    print "Adding sorts: @sorts\nModule: $_\n" if $verbose;
# Add these sorts to @all_sorts
    @all_sorts = set(@all_sorts, @sorts);

#    print "ALLSORTS: @all_sorts\n\n";
#    print "SORTS: @sorts\n\n";
    
# Add all sorts with alphanumerics to @all_tokens as well
    @all_tokens = set(@all_tokens, grep /\W/, @sorts);
#    print "ALLTOKENS: @all_tokens\n\n";
}

# Next subroutine takes a string (most likely a kmaude module),
# and returns a string obtained from the original one by adding spaces to the left and/or
# to the right of tokens in the string; recall that the global @all_tokens holds all tokens
sub spacify {
    my ($lines) = @_;
    my @dag;
    my %index;     # holds index of each token
    my @array;     # holds token associated to each index
    my $i=0;

    my @all = join("\n", @all_tokens);
#    print "TOKENS: @all\n\n";
    
# First associate each token with a distinct number
    foreach my $token (@all_tokens) {
	$array[$i] = $token;
	$index{$token} = $i++;
    }

# Then create a dag as a an array of arrays over indexes
    for $i (0..$#array) {
	(my $token_pattern = $array[$i]) =~ s/([$special_perl_chars])/\\$1/g;
	$dag[$i] = [map($index{$_}, grep(/.$token_pattern|$token_pattern./, @all_tokens))];
    }

# Freeze all excluded substrings, which we do NOT want to be spacified
    $lines =~ s/($exclude)/Freeze($1, $default_freezer)/gmse;
    
# Spacify and then freeze each token in reversed topological order
# This way, we are sure that a subtoken of a token will never be spacified
    foreach my $token (map($array[$_], reverse(topological_sort(@dag)))) {
	(my $token_pattern = $token) =~ s/([$special_perl_chars])/\\$1/g;
	$lines =~ s/(.)($token_pattern)((?=.))/add_spaces($1,$2,$3)/gse;
    }
 
# Dirty hack: add spaces around anonymous variables, so that they will be properly
# translated into ? later on
    $lines =~ s/_(?!\.)/ _ /gs;
    
# Next unfreeze all tokens and return the spacified string
    return Unfreeze($default_freezer, $lines);
}


# Pass it as input a list of array references; these specify that that index into the
# list must come before all elements of its array.  Output is a topologically sorted
# list of indices, or undef if input contains a cycle.  Note that you must pass an array
# ref for every input elements (if necessary, by adding an empty list reference)! 
sub topological_sort {
    my @out = @_;
    my @ret;

# Compute initial in degrees
    my @ind;
    for my $l (@out) {
    ++$ind[$_] for (@$l)
    }

# Work queue
    my @q;
    @q = grep { ! $ind[$_] } 0..$#out;

# Loop
    while (@q) {
	my $el = pop @q;
	$ret[@ret] = $el;
	for (@{$out[$el]}) {
	    push @q, $_ if (! --$ind[$_]);
	}
    }

    return @ret == @out ? @ret : undef;
}


# Adds spaces before and/or after token, if needed
sub add_spaces {
    my ($before,$token,$after) = @_;
#    print "BEFORE: $before\nTOKEN: $token\nAFTER: $after\n\n";
    if ($before =~ /\w$/ && $token =~ /^\w/) { return "$before$token"; }
    if ($after =~ /^\w/ && $token =~ /\w$/) { return "$before$token"; }
    return ($before.(($before =~ /$maude_special/) ? "":" ").Freeze($token, $default_freezer).(($after =~ /$maude_special/) ? "":" "));
}



# Takes a list and eliminates duplicates from it
sub set {
    my %hash = map { $_,1 } @_;
    return keys %hash;
}


# Report error and exit
sub throw_error
{
    my $err = shift;
    print wrap("", "", "$err\n");
    exit(1);
}


sub add_subsorts
{
    my $supersorts = find_k_sorts();
#    print "SUPERSORTS: $supersorts\n";
    my @modules = split(/\s+/, getModuleList());
    my $dir = cwd;
    
    return if (scalar(@modules) == 0);
    return if ($supersorts eq "");
    
    my @sorts = split(/\s+/, $supersorts);
    $supersorts = "";
    foreach(@sorts)
    {
	$supersorts .= "$_ " if ($k_sorts !~ /:$_:/);
    }
    
    return if ($supersorts eq "");
    
    # get all supersorts in an array
    my @ssorts = split(/\s+/, $supersorts);

    # search through all modules
    foreach(@modules)
    {
	my $cmod = $_;
	# get sorts for current module
	my $sortlist = "#" . getModuleSorts($cmod) . "#" if defined(getModuleSorts($cmod));
	$sortlist =~ s/ /#/g if defined($sortlist);
	
#	print "File: " . getModuleFile($_) . ", SORTS: $sortlist\n\n";
	
	# if this module contains sorts
	# and it is a module which includes K
	# then add apropriate subsortations
	if (defined($sortlist) && includesK($cmod))
	{
	    # will collect declared sorts
	    my @decllist = ();
	    # search through supersorts all sorts contained by this module
	    foreach my $ss (@ssorts)
	    {
		push(@decllist, $ss) if ($sortlist =~ /#$ss#/);
	    }
	    
	    if (scalar(@decllist) > 0)
	    {
		# get module file
		my $file = getModuleFile($_);
		
		# access its maude corresponding file
		$file =~ s/\.k$/\.maude/;
		
		# get content
		my $cpath = "$dir/$file";
		$cpath = $file if (File::Spec->file_name_is_absolute($file));
		my $content = get_file_content($cpath);
		
		my $o = "@decllist";
                if ($o ne "") {
                    $content =~ s/mod(\s+)$_(\s.*?)endm/mod$1$_$2 subsorts $o < K \. endm/sg;
                  }
		open FILE,">",$file or die "Cannot create $file\n";
		print FILE $content;
		close FILE;
	    }
	}
    }
    
#    print "SUPERSORTS: $supersorts\n";
#    print "MODULES: @modules\n";
}

# Latex top level patterns
# my $latex_top_level_pattern = join("|", (
#		"\\/\\/@(before|after)=([a-zA-Z\-]+)\s(.*?)(?=\n)",
#		"\\/\\*@(before|after)=([a-zA-Z\-]+)\s(.*?)\\*\\/"
# ));

# Args: k file content
# Return: void
# Stores all latex comments in some data structures
sub store_intermodule_latex
{
    local $_ = shift;
    
    while (/(\/\*)@(before|after)=([a-zA-Z\-]+)\s(.*?)\*\//sg)
    {
	$module_before{$3} = $4 if $2 eq "before";
	$module_after{$3} = $4 if $2 eq "after";
    }
    
    while (/(\/\/)@(before|after)=([a-zA-Z\-]+)\s(.*?)(?=\n)/sg)
    {
	$module_before{$3} = $4 if $2 eq "before";
	$module_after{$3} = $4 if $2 eq "after";
    }
    
}

# Args: latex file content
# Return: latex file content
# Restores all latex comments from som data structures
sub restore_intermodule_latex
{
	local $_ = shift;
	
	my @mlist = ();
	while (/\\begin{module}{\\moduleName{([a-zA-Z\-]+)}}/sg)
	{
		push(@mlist, $1);
	}

	foreach my $module (@mlist)
	{
		s/(\\begin{module}{\\moduleName{\Q$module\E}})/\n$module_before{$module}\n$1/sg	if (defined $module_before{$module});
		s/(\\begin{module}{\\moduleName{\Q$module\E}}.*?\\end{module})/$1\n$module_after{$module}\n/sg if (defined $module_after{$module});
	}
	
	return $_;
}

# Args: no input
# Return: null
# Check installed software on local machine:
# maude, perl XML::DOM package
# Issue: doesn't work fine if other perl packages are not installed.
sub check_perl_packages
{
	# check if maude is installed
        my $pack = shift;

	# check if XML::DOM package is installed
	$_ = `perl -e 'use $pack;print "okay"'`;
	my $found = $_ eq "okay"?1:0;

	if (!$found)
	{
		print wrap("", "", "[ERROR] Perl package $pack is not installed.\n");
		exit(1);
	}
	else
	{
		print "Package $pack installed...\n" if $verbose;
	}

}


sub check_maude_instalation
{
	local $_ = `echo 'rew "hello" + "world" .' | maude 2>&1`;
	return if ( m!helloworld!sg );

	my $maude_lib = $ENV{'MAUDE_LIB'};

	if ( m!command\s+not\s+found!sg )
	{
		print wrap("", "", "Maude command doesn't execute. Please install maude or set maude directory in PATH.\n");

		if ($maude_lib eq "")
		{
			print wrap("", "", "Also variable MAUDE_LIB is not set. Please check instalation instructions for maude.\n");
		}

		exit(1);
	}

	if ($maude_lib eq "")
	{
		print wrap("", "", "Variable MAUDE_LIB is not set and maude cannot find prelude.maude.\nPlease check installation instructions for maude.\n");
		exit(1);
	}
}

# Args: none
# Return: none
# Add k-prelude sorts in @all_sorts if not already...
# Atention: this recurses only in maude files.
sub add_kprelude_sorts
{
	if (!$k_prelude_loaded)
	{
		my $to_load = shift;
		my $to_load_dir = shift;

		# add maude extension if not already
		$to_load .= ".maude" if $to_load !~ /\..+?/sg;

		my $fullname = File::Spec->file_name_is_absolute($to_load) ? $to_load : File::Spec->catfile($to_load_dir, $to_load);
		$fullname = get_full_name($fullname);

		my $var = get_file_content($fullname);
		add_sorts($var);
		add_tokens($var);

#		print "@all_sorts\n\n@all_tokens\n\n\n\n";

		while ( $var =~ m!^\s*(in|load)\s+(\S+)!sgm )
		{
			add_kprelude_sorts($2, dirname($fullname));
		}

	}

}

sub addKandKLATEX
{
	my $content = shift;
	my $file = shift;
	my $k = 0;
	my $k_latex = 0;

	# extract module name
	my $mod = $1 if $content =~ /kmod\s+(.*?)\s/sg;
 
	if ($mod =~ /^#/){
		return $content;
	}

	# get list of imported modules
	while ( $content =~ /\s+including([\sA-Z0-9\-+]*)/sgm )
	{
		$k = 1 if $1 =~ /\sK\s/sg;
		$k_latex = 1 if $1 =~ /\sK-LATEX\s/sg;
	}

	return $content if $k;
	
	my $prelude_sorts = $k_sorts;
	$prelude_sorts =~ s/:/\|/sg;
	$prelude_sorts =~ s/^\s*\|//;
	$prelude_sorts =~ s/\|\s*$//;
        my $k_includes = " including K ";
        if ($mod ne "URIS") {
          $k_includes .= "\n including URIS "; 
        }
#	print "SORTS: $prelude_sorts\n\n";
	if ($content =~ /\s(syntax\s+($prelude_sorts)|configuration|rule)\s/sg)
	{
		# include K if syntax, configuration or rule keywords are used in module
		$content =~ s!(k?mod\s+\S+\s+is\s)!$1$k_includes!sg;

#		print "MOD: |$mod|\nMDD: |$language_module_name|\n\n";
		$k_auto_incl = 1 if $mod eq $language_module_name;
	}
	else
	{
		# include only K-LATEX
		$content =~ s!(k?mod\s+\S+\s+is\s)!$1 including K-LATEX including PL-BUILTINS including K-RESULT !sg if !$k_latex;
	}

	return $content;
}
