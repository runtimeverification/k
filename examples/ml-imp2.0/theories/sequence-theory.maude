mod MATHEMATICAL-SEQUENCE is inc MATHEMATICAL-INT .
  sorts ?Seq !Seq FreeSeq NeSeq Seq Seq++ NeSeq++ . 
  subsort NeSeq < Seq .
  subsort NeSeq++ Seq < Seq++ .
  subsort ?Seq !Seq FreeSeq NeSeq < NeSeq++ .
  subsort ?Seq < ?MathObj .
  subsort !Seq < !MathObj .
  subsort FreeSeq < FreeMathObj .
  subsort Seq < MathObj .
  subsort Seq++ < MathObj++ .
 
  op ?Seq : Nat -> ?Seq .
  op !Seq : Nat -> !Seq .
  op FreeSeq : Nat -> FreeSeq .
  op skolem : Nat ?Seq -> FreeSeq [ditto] .
  op co-skolem : Nat FreeSeq -> !Seq [ditto] .

  op epsilon : -> Seq .
  op `[_`] : List{MathObj++} -> NeSeq++ .
  ---op `[_`] : ?MathObj -> ?Seq [ditto] .
  ---op `[_`] : !MathObj -> !Seq [ditto] .
  ---op `[_`] : FreeMathObj -> FreeSeq [ditto] .
  op `[_`] : MathObj -> NeSeq [ditto] .
  op `[_`] : MathObj++ -> NeSeq++ [ditto] .
  op _@_ : Seq++ Seq++ -> Seq++ [assoc id: epsilon] .
  op _@_ : NeSeq++ Seq++ -> NeSeq++ [ditto] .
  op _@_ : Seq++ NeSeq++ -> NeSeq++ [ditto] .
  ---op _@_ : ?Seq ?Seq -> ?Seq [ditto] .
  ---op _@_ : !Seq !Seq -> !Seq [ditto] .
  ---op _@_ : FreeSeq FreeSeq -> FreeSeq [ditto] .
  op _@_ : Seq Seq -> Seq [ditto] .
  op _@_ : NeSeq Seq -> NeSeq [ditto] .
  op _@_ : Seq NeSeq -> NeSeq [ditto] .
  op _@_ : NeSeq Seq++ -> NeSeq++ [ditto] .
  op _@_ : Seq++ NeSeq -> NeSeq++ [ditto] .
  op _@_ : NeSeq++ Seq -> NeSeq++ [ditto] .
  op _@_ : Seq NeSeq++ -> NeSeq++ [ditto] .
  op _@_ : Seq++ Seq -> Seq++ [ditto] .
  op _@_ : Seq Seq++ -> Seq++ [ditto] .
  op _@_ : NeSeq++ NeSeq -> NeSeq++ [ditto] .
  op _@_ : NeSeq NeSeq++ -> NeSeq++ [ditto] . 

  op rev : Seq++ -> NeSeq++ .
  op len : Seq++ -> Int++ .
  op contain : Seq++ Int++ -> Atom .


  var Obj Obj1 Obj2 : MathObj++ .
  var ObjList : List{MathObj++} .
  var A A1 A2 : Seq++ .
  var NeA NeA1 NeA2 : NeSeq++ .
  var I J N : Int++ .
  var ?N1 ?N2 : ?Int .

  eq [Obj1, Obj2, ObjList] = [Obj1] @ [Obj2] @ [ObjList] .
  eq [.List{MathObj++}] = epsilon .
  eq [Obj] @ A === epsilon = FalseFormula .
  eq NeA @ A1 === NeA @ A2 = A1 === A2 .
  eq A1 @ NeA === A2 @ NeA = A1 === A2  .
  eq [Obj1] @ A1 === [Obj2] @ A2 = Obj1 === Obj2 /\ A1 === A2 .
  eq [Obj1] @ A1 === [Obj2] @ A2 = Obj1 === Obj2 /\ A1 === A2 .
  eq A1 @ [Obj1] === A2 @ [Obj2] = Obj1 === Obj2 /\ A1 === A2 .
  eq A1 @ [Obj1] === A2 @ [Obj2] = Obj1 === Obj2 /\ A1 === A2 .

  eq rev(NeA1 @ NeA2) = rev(NeA2) @ rev(NeA1) .
  eq rev([Obj]) = [Obj] .
  eq rev(epsilon) = epsilon .
  eq len(NeA1 @ NeA2) = len(NeA1) +Int len(NeA2) .
  eq len([Obj]) = 1 .
  eq len(epsilon) = 0 .
  
  eq contain(NeA1 @ NeA2 , I) = contain(NeA1 , I) \/ contain(NeA2 , I) .
  eq contain([J] , I) = (I === J) .
  eq contain(epsilon , I) = FalseFormula .
  
  ops avg sum : Seq++ -> Int++ .
  
  eq sum(NeA1 @ NeA2) = sum(NeA1) +Int sum(NeA2) .
  eq sum([Obj]) = Obj .
  eq sum(epsilon) = 0 .
  
  eq avg(NeA1) = (sum(NeA1)) /Int (len(NeA1)) .
  eq avg(epsilon) = 0 .
  
  op found : Seq++ Int++ -> Int++ .
 ceq found(NeA1,I) = 1 if (contain(NeA1,I) ==Bool TrueFormula) .
 ceq found(NeA1,I) = 0 if (contain(NeA1,I) ==Bool FalseFormula) .
  eq found(epsilon,I) = 0 [owise] .

endm

