The text in this file will eventually be incorporated within the K
reference manual.

-----------------------------

KTEST:
------

To test the definition against all the programs in this folder, go to the
parent folder where the simple-untyped.k definition is and execute

  ktest simple-untyped.k --programs programs_and_results --extension simple --exclude dekker

The --exclude option tells which programs to exclude from krunning.  You may
want to exclude programs which take a lot of time, or which don't terminate.

If you want to skip the PDF poster generation, which takes some time, execute

  ktest simple-untyped.k --programs programs_and_results --extension simple --exclude dekker --skip pdf

If you already kompiled your definition and want to only krun the programs:

  ktest simple-untyped.k --programs programs_and_results --extension simple --exclude dekker --skip "kompile pdf"

KTEST:
------

To test your solution, go to the folder where it is located (i.e.,
where the file simple-untyped.k that you wrote is) and then call the
ktest tool on the config.xml file (the one in this folder).  For
example, if your solution is in the parent folder, to test it go there
and type

  ktest tests/config.xml

As another example, if the k distribution is installed at
"/home/cs422-Fall-2013/k" and if you solve this exercise
in "/home/cs422-Fall-2013/joe/hw3/ex1", then test it by executing
the following command from the folder where your solution is:

ktest /home/cs422-Fall-2013/k/dist/tutorial/2_languages/1_simple/1_untyped/exer\
cises/break-continue/config.xml

If you want to skip the kompilation and the pdf generation, then use the
following command instead (and similarly for the second example above):

  ktest tests/config.xml --skip "kompile pdf"

If you want to skip only one of kompile or pdf (typically the pdf), then use
only that one in the --skip option (e.g., --skip pdf).

Both the original SIMPLE untyped programs and the programs in this folder
will be tested.  If your solution is correct, then all tests should pass,
except, potentially, the new break-from-function.simple (see the comments
there for the reason).

If your solution is somewhere else, then use the -d option of ktest to give
the directory to where your K definition is located.  For example, provided
that your definition is in the parent folder, then to test it you can type
the following command in this folder (i.e., programs_and_results):

  ktest config.xml -d ..

KTEST:
------

To test this definition, you can call ktest on the config.xml file in this
folder.  Recall that if you call ktest from any other folder than where
your definition is, then you need the option "-d path/to/your/def/directory".
For example, if you want to call it from this folder, then type

  ktest config.xml -d ..

If you want to call it from the parent folder then just type:

  ktest results/config.xml

Also recall that if your definition is already kompiled, then you can skip
kompilation to save time using the --skip kompile option; if you want to skip
both kompilation and pdf generation then use the option --skip "kompile pdf".

KTEST:
------

The general philosophy of ktest is that the config file contains all the static
info (where the programs and their results are), but it does not contains the
dynamic info (where the actual definition to be tested is).  The same
philosophy holds when we use include.  So all the non-definition attributes
need to be statically solved at the place where the include attribute appears.
The use of an include attribute is nothing but syntactic sugar, so the user
does not have to repeat all that information which has already been given in
the included configuration.  The include attributes can be desugared completely
statically, and thus independently from where the config file containing the
include attribute is called.

In short, the inclusion of a config2.xml file into a config1.xml file is
equivalent to having a flat config1'.xml file instead of config1.xml, which
would behave exactly the same way as config1.xml, wherever ktest may call it
from.  So imagine that you have that config1'.xml built that way, completely
statically (actually, this is probably the way you implement it anyway).  Now,
the same way I can call ktest on config1'.xml from wherever I want, the same
way I want to be able to completely equivalently call ktest on config1.xml from
the same place.

For example, suppose that you are somewhere called "the working directory" and
that the definition you want to test is at path/lang.k from the working
directory.  Suppose that for some reason you really need to put your
config1'.xml/config1.xml file at path1 from the working directory.  Then your
config1'.xml file will look something like this:

<test> definition="path/lang.k" programs="P1" ...  </test>

where P1 is the relative path from the directory path1 to where the programs
are, and you would call it with the command

  ktest path1/config1'.xml

Now suppose that a config2.xml file for testing lank.k against the same
programs has already been created in the past and that you would like to
replace the verbose and redundant config1'.xml with a config1.xml which simply
includes config2.xml.  For concreteness, assume that config2.xml is at relative
path path2 from where config1'.xml/config1.xml is, and that its contents is

<test> definition="lang.k" programs="P2" ...  </test>

Then it must be the case that P1=path1/P2.  Knowing this, we can call ktest on
config2.xml as follows:

  ktest path1/path2/config2.xml --directory path

This suggests that we include config2.xml into config1.xml as follows:

  <include file="path2/config2.xml" directory="path">

That is, the include attribute in config.xml contains exactly and only the
information that I would have to manually pass to ktest to call config2.xml
instead of config1'.xml or config1.xml.

However, since configuration files have fixed programs folders, we have to
agree on what are the programs corresponding to the include attribute in
config1.xml.  There is only one reasonable way that can be, namely the same
programs folder as in config1'.xml, that is, P1.  So in a command like

  ktest path1/config1.xml --directory path --programs P

the root directory P is applied to P1 and NOT to P2 (again, think config1'.xml
instead of config1.xml).  So the above command would be equivalent to

  ktest path1/path2/config2.xml --directory path --programs P/path1/P2


KTEST: PATH RESOLUTION:
-----------------------

Every path of a configuration file is relative. Three different kinds of paths
exist: definition, programs, and results. A root for the relative directories
can be specified using command line options. For example, let command line
arguments of ktest be:

  $ ktest C/config.xml --directory D --programs P --results R

and 'C/config.xml' be:

  <test
    definition="D1/lang.k"
    programs="P1 P2"
    results="R1 R2"
  />

then the paths are resolved as follows:

  <test
    definition="D/D1/lang.k"
    programs="P/P1 P/P2"
    results="R/R1 R/R2"
  />

Note that the option --directory is optional, and its default value is the
current directory. Also, the options --programs and --results are optional,
and their default values are the directory where the given configuration file
resides. For example, the following command

  ktest C/config.xml

is virtually same with the following:

  ktest C/config.xml --directory . --programs C --results C


The root can be also specified using <include>'s attributes. The same rule is
applied here. For example, let a configuration file 'C/config.xml' have the
following <include> element:

  C/config.xml:

  <include
    file=C1/config1.xml
    directory=D
    programs=P
    results=R
  />

and the included configuration file 'C/C1/config1.xml' be:

  C/C1/config1.xml:

  <test
    definition="D1/lang.k"
    programs="P1 P2"
    results="R1 R2"
  />

then the <include> element is resolved as follows:

  C/config.xml:

  <test
    definition="D/D1/lang.k"
    programs="P/P1 P/P2"
    results="R/R1 R/R2"
  />

Note that the attribute 'definition' is optional, and its default value is the
current directory. Also the attributes 'programs' and 'results' are optional,
and their default values are the directory where the included configuration
file resides. For example, the following <include> element

  <include
    file=C1/config1.xml
  />

is vitally same with the following:

  <include
    file=C1/config1.xml
    directory=.
    programs=C1
    results=C1
  />


To sum, the roots given by command line options and <include>'s attributes are
accumulated to resolve the relative paths. For example, let command line
argument of ktest be:

  $ ktest C/config.xml --directory D --programs P --results R

and configuration file 'C/config.xml' be:

  C/config.xml:

  <include
    file=C1/config1.xml
    directory=D0
    programs=P0
    results=R0
  />

and the included configuration file 'C/C1/config1.xml' be:

  C/C1/config1.xml:

  <test
    definition="D1/lang.k"
    programs="P1 P2"
    results="R1 R2"
  />

then the paths are eventually resolved as follows:

  <test
    definition="D/D0/D1/lang.k"
    programs="P/P0/P1 P/P0/P2"
    results="R/R0/R1 R/R0/R2"
  />

Note that when they are not specified, the default roots are:

  D  = .
  P  = C
  R  = C
  D0 = .
  P0 = C1
  R0 = C1


FILE READ/WRITE:
----------------

If you want to write something to a file at once,  you can go with  #open and
#write .

For example,

 rule <k> run => writeFile("file", "content") ... </k>

 syntax K ::= writeFile(String,String)
 rule writeFile(File:String, Content:String)
   => writeFD(#open(File), Content)

 syntax K ::= writeFD(Int,String)
 rule writeFD(FD:Int, Content:String)
   => #write(FD, Content) ~> #close(FD)

TODO: how to read from a file
