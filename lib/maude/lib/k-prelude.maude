load builtins-interface.maude

--- Level 0

mod K-TECHNIQUE is 
  including #INT-INTERFACE .
  including #BOOL-INTERFACE .

  var K : K . var Ks : KList .
  var LItem : ListItem .  var List : List .

  sorts KItem K .
  subsorts KItem < K .
  op .K : -> K .
  op _~>_ : K K -> K [prec 100  assoc id: .K metadata "latex=(renameTo _\\ensuremath{\\kra}_)"] .

  sorts KList NeKList .

  subsort K < NeKList < KList .
  op .KList : -> KList [metadata "latex=(renameTo \\ensuremath{\\dotCt{List\\{K\\}}})"] .

  op _`,`,_ : KList KList -> KList [assoc id: .KList prec 121 metadata "latex=(renameTo _\\ensuremath{,\\!\\!,}_)"] .
  --- One should not modify the precedence above.  
  --- Might cause the compilation to fail.
  op _`,`,_ : NeKList KList -> NeKList [ditto] .
  op _`,`,_ : KList NeKList -> NeKList [ditto] .


  sorts KLabel .

  op _`(_`) : KLabel KList -> KItem [prec 0 gather(& &)] .

  sort ListItem List NeList .
  subsort ListItem < NeList < List .
  subsort ListItem < List .
  op .List : -> List .
  op ListItem : K -> ListItem  [metadata "latex=(renameTo _)"] .
  op __ : List List -> List [assoc id: .List] .
  op __ : NeList List -> NeList [ditto] .
  op __ : List NeList -> NeList [ditto] .
  
  sort BagItem Bag NeBag .
  subsort BagItem < NeBag < Bag .
  subsort BagItem < Bag .
  op .Bag : -> Bag .
  op BagItem : K -> BagItem [metadata "latex=(renameTo _)"] .
  op __ : Bag Bag -> Bag [assoc comm id: .Bag] .
  op __ : NeBag Bag -> NeBag [ditto] .
  op BagMapItem : K Bag -> BagItem .

  sort SetItem Set NeSet .
  subsort SetItem < NeSet < Set .
  subsort SetItem < Set .
  op .Set : -> Set .
  op SetItem : K -> SetItem [metadata "latex=(renameTo _)"] .
  op __ : Set Set -> Set [assoc comm id: .Set] .
  op __ : NeSet Set -> NeSet [ditto] .

  eq SI:SetItem SI:SetItem = SI:SetItem .

  sort MapItem Map NeMap .
  subsort MapItem < NeMap < Map .
  subsort MapItem < Map .
  op .Map : -> Map .
  op _|->_ : K K -> MapItem [metadata "latex=(renameTo _\\ensuremath{\\mapsto}_)"] .
  op __ : Map Map -> Map [assoc comm id: .Map prec 120] .
  op __ : NeMap Map -> NeMap [ditto] .
  op update : Map K K -> Map .
  op update : Map Map -> Map .
  op remove : Map K K -> Map .
  op remove : Map Map -> Map .

  vars M M1 M2 : Map .
  vars Key V V' : K .
  eq update((M Key |-> V), Key, V') = M Key |-> V' .
  eq update(M, Key, V) = (M Key |-> V) [owise] .
  eq update(M1, (Key |-> V M2)) = update(update(M1, Key, V), M2) .
  eq update(M, .Map) = M .
  eq remove((M Key |-> V), Key, V) = M .
  eq remove(M1, (Key |-> V M2)) = remove(remove(M1, Key, V), M2) .  
  eq remove(M, .Map) = M .

  op _[_] : Map Map -> Map .
  eq M:Map[M':Map] = update(M:Map, M':Map) .

  op _[_/_] : Map KList KList -> Map .
  eq M:Map[(K2:K,,KL2:KList) / (K1:K,,KL1:KList)]
   = update(M:Map, K1:K, K2:K)[KL2:KList / KL1:KList] .
  eq M:Map[.KList / .KList] = M:Map .

  sort CellLabel .

  op <_>_</_> : CellLabel K CellLabel -> BagItem [prec 0 format(nib g b o+ -b g b o)] .
  op <_>_</_> : CellLabel List CellLabel -> BagItem [prec 0 format(nib g b o+ -b g b o)] .
  op <_>_</_> : CellLabel Bag CellLabel -> BagItem [prec 0 format(nib g b o+ -b g b o)] .
  op <_>_</_> : CellLabel Set CellLabel -> BagItem [prec 0 format(nib g b o+ -b g b o)]. 
  op <_>_</_> : CellLabel Map CellLabel -> BagItem [prec 0 format(nib g b o+ -b g b o)] .

  sort KCellSort .
  op <k>_</k> : K -> KCellSort [format(b o++ni --nib o)].
  op k : -> CellLabel .


  op HOLE : -> K .
  op #freezer : K -> KLabel [strat(0) frozen] .

endm

--- K notation starts from here on

--- KLabel-Wrappers level

mod K-WRAPPERS-LABELS is
  including K-TECHNIQUE .
  including #STRING-INTERFACE .
  op KLabel2KLabel_ : KLabel -> KLabel [metadata "wrapper=(builtin)"] .
  op CellLabel2KLabel_ : CellLabel -> KLabel [metadata "wrapper=(builtin)"] .
  op KList2KLabel_ : KList -> KLabel [metadata "wrapper=(builtin)"] .
  op Bag2KLabel_ : Bag -> KLabel [metadata "wrapper=(builtin)"] .
  op Set2KLabel_ : Set -> KLabel [metadata "wrapper=(builtin)"] .
  op List2KLabel_ : List -> KLabel [metadata "wrapper=(builtin)"] .
  op Map2KLabel_ : Map -> KLabel [metadata "wrapper=(builtin)"] .
  op 'wrap-with : -> KLabel .
  op #_ : #Bool -> KLabel [metadata "wrapper=(builtin)"] .

  op _+MySet_ : K K -> K [assoc] .
  eq Set2KLabel(S1:Set)(.KList) +MySet Set2KLabel(S2:Set)(.KList) 
   = Set2KLabel(S1:Set S2:Set)(.KList) . 

  op _+MyList_ : K K -> K [assoc] .
  eq List2KLabel(S1:List)(.KList) +MyList List2KLabel(S2:List)(.KList) 
   = List2KLabel(S1:List S2:List)(.KList) . 

  op _+MyMap_ : K K -> K [assoc] .
  eq Map2KLabel(S1:Map)(.KList) +MyMap Map2KLabel(S2:Map)(.KList) 
   = Map2KLabel(S1:Map S2:Map)(.KList) . 


  op values_ :  Map -> Set .
  eq values (X:K |-> V:K M:Map) = SetItem(V:K) values M:Map .
  eq values .Map = .Set .

  op keys_ :  Map -> Set .
  eq keys (X:K |-> V:K M:Map) = SetItem(X:K) keys M:Map .
  eq keys .Map = .Set .

  op inSet : -> KLabel .
  eq inSet(K:K,, Set2KLabel(SetItem(K:K) S:Set)(.KList)) = (# true)(.KList) .
  eq inSet(K:K,, S:K) = (# false)(.KList) [owise] .

  op '$hasMapping`(_`,_`) : -> KLabel .
  eq '$hasMapping`(_`,_`)(Map2KLabel (X:KItem |-> V:KItem M:Map)(.KList),,X:KItem) =  (# true)(.KList) .
  eq '$hasMapping`(_`,_`)(Map2KLabel M:Map(.KList),,X:KItem) =  (# false)(.KList) [owise] .


  op deprecatedMapLookup : -> KLabel .
  eq deprecatedMapLookup(Map2KLabel (X:KItem |-> V:KItem M:Map)(.KList),,X:KItem) = V:KItem .

  op 'Set2KTerm : -> KLabel .
  op #set : -> KLabel .
  eq 'Set2KTerm(Set2KLabel S:Set(.KList))
   = Set2KList(S:Set) .

  op Set2KList : Set -> KList .
  eq Set2KList(.Set) = .KList .
  eq Set2KList(SetItem(K:K) S:Set) = K:K,,Set2KList(S:Set) .

  op '#isMapInK : -> KLabel .
  op #getMapFromK`(_`) : K -> Map  .
  op '#map : -> KLabel .
  eq '#isMapInK('#map(K:K)) = (# true)(.KList) .
  eq #getMapFromK('#map(Map2KLabel M:Map(.KList))) = M:Map .

  op _-Set_ : Set Set -> Set .
  eq S1:Set -Set (SI1:SetItem SI2:SetItem S2:Set)
   = ((S1:Set -Set SI1:SetItem) -Set SI2:SetItem) -Set S2:Set .
  eq S1:Set -Set .Set = S1:Set .
 
  eq (S1:Set SI:SetItem) -Set SI:SetItem = S1:Set .
  eq S1:Set -Set SI:SetItem = S1:Set [owise] .

  op intersectSet`(_`,_`) : Set Set -> Set .
  eq intersectSet(A:Set, B:Set) = A:Set -Set (A:Set -Set B:Set) .

  op 'isEmptySet : -> KLabel .
  eq 'isEmptySet(Set2KLabel .Set(.KList)) = (# true)(.KList) .
  eq 'isEmptySet(Set2KLabel S:Set(.KList)) = (# false)(.KList) [owise] .

 
  op isSet : -> KLabel .
  eq isSet(Set2KLabel S:Set(.KList)) = (# true)(.KList) .

endm

load builtins.maude
