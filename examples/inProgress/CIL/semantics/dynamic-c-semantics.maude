mod DYNAMIC-C-SEMANTICS is
	including COMMON-C-SEMANTICS .
	
---C99 5.1.2.2.1:2
--- If they are declared, the parameters to the main function shall obey the following
--- constraints:
--- — The value of argc shall be nonnegative.
--- — argv[argc] shall be a null pointer.
--- — If the value of argc is greater than zero, the array members argv[0] through
--- argv[argc-1] inclusive shall contain pointers to strings, which are given
--- implementation-defined values by the host environment prior to program startup. The
--- intent is to supply to the program information determined prior to program startup
--- from elsewhere in the hosted environment. If the host environment is not capable of
--- supplying strings with letters in both uppercase and lowercase, the implementation
--- shall ensure that the strings are received in lowercase.
--- — If the value of argc is greater than zero, the string pointed to by argv[0]
--- represents the program name; argv[0][0] shall be the null character if the
--- program name is not available from the host environment. If the value of argc is
--- greater than one, the strings pointed to by argv[1] through argv[argc-1]
--- represent the program parameters.
--- — The parameters argc and argv and the strings pointed to by the argv array shall
--- be modifiable by the program, and retain their last-stored values between program
--- startup and program termination.	
	op incomingArgumentArray : -> Id .
	op incomingArguments : List{K} -> K .
	op incomingArguments-aux : List{K} Nat -> K .
	eq incomingArguments(L:List{K}) = incomingArguments-aux(L:List{K}, 0) .
	eq incomingArguments-aux((E:Expression,, L:List{K}), N:Nat) = ((incomingArgumentArray[N:Nat] := Cast(Pointer(char), E:Expression) ;) ~> incomingArguments-aux(L:List{K}, sNat(N:Nat))) .
	eq incomingArguments-aux(.List{K}, N:Nat) = (incomingArgumentArray[N:Nat] := Cast(Pointer(char), NULL) ;) .
---C99 5.1.2.2.1:1
--- The function called at program startup is named main. The implementation declares no
--- prototype for this function. It shall be defined with a return type of int and with no
--- parameters:
--- int main(void) { /* ... */ }
--- or with two parameters (referred to here as argc and argv, though any names may be
--- used, as they are local to the function in which they are declared):
--- int main(int argc, char *argv[]) { /* ... */ }
--- or equivalent;9) or in some other implementation-defined manner

	--- op unclutterConfiguration : Bag -> Bag .
	--- op stripConfiguration : Bag -> Bag .
	
	--- doesn't [owise] rules :(
	---eq unclutterConfiguration(B:Bag) = stripConfiguration(B:Bag) [owise] .
	
	--- eq stripConfiguration(B0:Bag (< T > B1:Bag (< aLabelMap > M:Map </ aLabelMap >) </ T >)) = stripConfiguration(B0:Bag < T > B1:Bag </ T >) .
	--- eq stripConfiguration(B0:Bag (< T > B1:Bag
		--- < threads > B2:Bag
				--- < thread > B3:Bag
					--- < callStack > ?:List </ callStack >
				--- </ thread >
		--- </ threads >
	--- </ T >)) = stripConfiguration(B0:Bag < T > B1:Bag 
		--- < threads > B2:Bag
			--- < thread > B3:Bag
			--- </ thread >
		--- </ threads > </ T >) .
	--- eq stripConfiguration(B0:Bag (< T > B1:Bag
		--- < threads > B2:Bag
				--- < thread > B3:Bag
					--- < types > ?:Map </ types >
				--- </ thread >
		--- </ threads >
	--- </ T >)) = stripConfiguration(B0:Bag < T > B1:Bag 
		--- < threads > B2:Bag
			--- < thread > B3:Bag
			--- </ thread >
		--- </ threads > </ T >) .
	--- eq stripConfiguration(B0:Bag (< T > B1:Bag
		--- < mem > M:Map
			--- B:Nat |-> memblock(N:Nat, (0 |-> Closure(X:Id, functionType(?, ?), ?)))
		--- </ mem >
	--- </ T >)) = stripConfiguration(B0:Bag < T > B1:Bag 
		--- < mem > M:Map
			--- B:Nat |-> memblock(N:Nat, (0 |-> Closure(X:Id, (.).K, (.).K)))
		--- </ mem >
		--- </ T >) .
	--- eq stripConfiguration(B0:Bag (< T > B1:Bag
		--- < typedefs > ?:Map </ typedefs >
	--- </ T >)) = stripConfiguration(B0:Bag < T > B1:Bag </ T >) .
	--- eq stripConfiguration(B0:Bag (< T > B1:Bag
		--- < genv > ?:Map </ genv >
	--- </ T >)) = stripConfiguration(B0:Bag < T > B1:Bag </ T >) .
	
	eq eval(P:Program) = eval(P:Program, .List{K}, "") .
	eq eval(P:Program, L:List{K}, Input:String) = 
		< T >
			< threads >
				< thread >
					< buffer > (.).List </ buffer >
					< blocked > false </ blocked >
					< registers > (.).Map </ registers >
					< k > P:Program 
						~> Global(Declaration(char, Pointer(incomingArgumentArray[sNat(lengthList{K} L:List{K})]))) 
						~> incomingArguments(L:List{K})
						--- ~> incomingArgumentArray[0] := Cast(Pointer(char), Name:String) ; 
						--- ~> incomingArgumentArray[1] := Cast(Pointer(char), NULL) ; 
						~> Apply(main, ((lengthList{K} L:List{K}) .,. incomingArgumentArray)) </ k >
					< locsWrittenTo > (.).Bag </ locsWrittenTo >
					< holds > (.).Map </ holds >
					---< children > (.).Bag </ children >
					< callStack > (.).List </ callStack >
					< env > (.).Map </ env >
					< loopStack > (.).List </ loopStack >
					< locals > (.).Bag </ locals >
					< types > (.).Map </ types >
					< currentFunction > File-Scope </ currentFunction >
				</ thread >
			</ threads >
			< busy > (.).Bag </ busy >
			< gotoMap > (.).Map </ gotoMap > 
			< sizes > (.).Map </ sizes >
			< genv > (.).Map </ genv > 
			< mem > (.).Map </ mem >
			< nextLoc > loc(1, 0) </ nextLoc >
			< nextFile > 3 </ nextFile >
			< freshNat > 0 </ freshNat >
			< malloced > (.).Map </ malloced >
			< statics > (.).Map </ statics >
			< typedefs > (.).Map </ typedefs >
			< structs > (.).Map </ structs >
			< openFiles >
				0 |-> "stdin" --- stdin
				1 |-> "stdout" --- stdout
				2 |-> "stdout" --- stderr
			</ openFiles >
		</ T >
		< files > 
			"stdin" |-> Input:String
			"stdout" |-> ""
		</ files >
	.
	
	--- throw away annotations
	mb [no-annotations]: rule (annotation(?); => (.).K) : KSentence [metadata "structural"] .
	
	--- fixme I'm not sure threads clean up their memory
	
	--- this shouldn't happen for normal programs (functions end in a return).  it is only used for threads
	mb [terminate-thread]: rule
		< thread >... < k > (.).K </ k > < buffer > (.).List </ buffer > ...</ thread > => (.).Bag
		: KSentence [metadata "structural"] .
		
	mb [terminate]: rule 
		(< T >... < threads > < thread >... < k > V:Value </ k > < buffer > (.).List </ buffer > ...</ thread > </ threads > ...</ T >
		=> < resultValue > V:Value </ resultValue >)
		< files >...
			"stdin" |-> S1:String	"stdout" |-> S2:String => (.).Map
		...</ files >
		((.).Bag => < input > S1:String </ input >	< output > S2:String </ output >)
		: KSentence .
	
endm
