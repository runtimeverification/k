% Type the command ``make pdf'' to generate the PDF poster of this language.
% Alternatively, type in the equivalent command
% kompile.pl simple-untyped.k -l SIMPLE-UNTYPED -style bb -pdf SIMPLE-UNTYPED-SYNTAX SIMPLE-UNTYPED-DESUGARED-SYNTAX SIMPLE-UNTYPED-SEMANTICS SIMPLE-UNTYPED -topmatter README.tex
% The generated simple-untyped.pdf file is easier to read than the actual ASCII files.

\setlength{\parindent}{1em}
\title{SIMPLE --- Untyped}
\author{Grigore Ro\c{s}u and 
        Traian Florin \c{S}erb\u{a}nu\c{t}\u{a} (\texttt{\{grosu,tserban2\}@illinois.edu})}
\organization{University of Illinois at Urbana-Champaign}

\maketitle

\begin{latexComment}
\section{Abstract}
This is the \K semantic definition of the untyped SIMPLE language.
SIMPLE is intended to be a pedagogical and reasearch language that captures
the essence of the imperative programming paradigm, extended with several
features often encountered in imperative programming languages.
A program consists of a set of global variable declarations and
function definitions.  Like in C, function definitions cannot be
nested and each program must have one function called \texttt{main},
which is invoked when the program is executed.  To make it more
interesting and to highlight some of \K's strengths, SIMPLE includes
the following features in addition to the conventional imperative
expression and statement constructs:
\begin{itemize}
\item Multidimensional arrays and array references.  An array evaluates
to an array reference, which is a special value holding a location (where
the elements of the array start) together with the size of the array;
the elements of the array can be array references themselves (particularly
when the array is multi-dimensional).  Array references are ordinary values,
so they can be assigned to variables and passed/received by functions.
\item Functions and function references.  Functions can have zero or
more parameters and can return abruptly using a \texttt{return} statement.
SIMPLE follows a call-by-value parameter passing style, with static scoping.
Function names evaluate to function references, which hereby become ordinary
values in the language, same like the array references.
\item Blocks with locals.  SIMPLE variables can be declared
anywhere, their scope being the most nested enclosing block.
\item Input/Output.  The expression \texttt{read()} evaluates to the
next value in the input buffer, and the statement \texttt{write(e)}
evaluates \texttt{e} and outputs its value to the output buffer.  The
input and output buffers are lists of values.
\item Exceptions.  SIMPLE has parametric exceptions (the value thrown as
an exception can be caught and bound).
\item Concurrency via dynamic thread creation/termination and
synchronization.  One can spawn a thread to execute any statement.
The spawned thread shares with its parent its environment at creation time.
Threads can be synchronized via reentrant locks which can be acquired and
released, as well as through rendezvous.

\end{itemize}
Like in many other languages, some of SIMPLE's constructs can be
desugared into a smaller set of basic constructs.  We do that in a 
dedicated module between the syntax and the semantics, and we only
give semantics to the core constructs.

\paragraph{Note:}{
This definition is commented slightly more than others, because it is
intended to be one of the first that the new user of \K sees.
For a quick introduction to the \K prototype, you are referred to
the README file at the root of this k-framework distribution.  If you are
interested in reading more about \K, please check the following paper:
\begin{quote}
Grigore Ro\c su, Traian-Florin \c Serb\u anu\c t\u a:
\href{http://dx.doi.org/10.1016/j.jlap.2010.03.012}{An overview of the K semantic framework}.

Journal of Logic and Algebraic Programming, 79(6): 397-434 (2010)
\end{quote}
}
\end{latexComment}

\vspace*{3ex}
