---load smt.maude
load utils.maude


---mod FOL= is inc CONFIG-UTILS + SMT-INTERFACE .
mod FOL= is inc CONFIG-UTILS .
--- FOL= is the proving heart of matching logic.  Provided that one had a "FOL= oracle" that can
--- prove any implications of the form "Pattern ===> Pattern1 Pattern2 ... PatternN" (the conclusion is a disjunction of patterns),
--- then one basically has a matching logic verifier.  Since we do not have such a magic oracle, we are going to mimic one.
--- We do it in a few steps.
  var Cfg Cfg' Cfg1 Cfg2 : BagItem .
  var Cfgs CfgItems CfgItems' CfgItems1 CfgItems2 : Bag .
  var ?Obj : ?MathObj .
  var !Obj : !MathObj .
  var FreeObj : FreeMathObj .
  var Obj Obj' Obj1 Obj2 : MathObj++ .
  var ObjList ObjList1 ObjList2 : List{MathObj++} .
  var X Id1 Id2 : Id .
  var N M : Nat .
  var P Q P' : Int++ .
  var T : KLabel .
  var HPN : HeapLabel .
  var Env Env1 Env2 TEnv FrameEnv : Map .
  var ?Env : ?MapItem .
  var !Env : !MapItem .
  var FreeEnv : FreeMapItem .
  var H H1 H2 : Map .
  var !H : !MapItem .
  var FreeH : FreeMapItem .
  var Set : Set .
  var Phi Phi1 Phi2 : Formula .
  var NtPhi NtPhi1 NtPhi2 : NtFormula .
  var K : K .
  var NeSubst : NeSubst .
  var Subst : Subst .
  var F : Field .


--- split the configuration if the formula is a disjunction
---   eq < config > < form > NtPhi1 \/ NtPhi2 </ form > Cfg </ config > = < config > < form > NtPhi1 </ form > Cfg </ config >
---                                                               < config > < form > NtPhi2 </ form > Cfg </ config > .


--- Step 0: generate multiple cases, one for each pattern in the conclusion
--- leads to state explosion
  rl Cfg ===> (Cfg' Cfgs) => Cfg =subst=> Cfg' .
  rl Cfg ===> (Cfg' Cfgs) => Cfg ===> Cfgs .
  eq Cfg ===> (.).Bag
   = < form > FalseFormula </ form > < subst > .Subst </ subst > .


--- Step 1:
  eq < config > < subst > Subst </ subst > CfgItems1 </ config >
     =subst=> < config > CfgItems2 </ config >
   = < config > applySubst(CfgItems1, Subst) </ config >
     =env=> < config > < subst > Subst </ subst > applySubst(CfgItems2, Subst) </ config > .

--- Step 2: Eliminate the environment and the return value
--- Step 2.1: Stepwise eliminate the environment 
  eq < config > < env > X |-> Obj1 Env1 </ env > CfgItems1 </ config >
     =env=> < config > < env > X |-> Obj2 Env2 </ env > < form > Phi2 </ form > CfgItems2 </ config >
   = < config > < env > Env1 </ env > CfgItems1 </ config >
     =env=> < config > < env > Env2 </ env > < form > Phi2 /\ Obj1 === Obj2 </ form > CfgItems2 </ config > .

--- Step 2.2 : Eliminate a locally bounded variable
  eq < config > < env > Env </ env > CfgItems1 </ config >
     =env=> < config > < env > ?Env </ env > CfgItems2 </ config >
   = < config > CfgItems1 </ config >
     =ret=> < config > CfgItems2 </ config > .

--- Step 2.2 : Eliminate a globally bounded variable
  eq < config > < env > Env </ env > < subst > Subst </ subst > CfgItems1 </ config >
     =env=> < config > < env > !Env </ env > CfgItems2 </ config >
   = < config > < subst > (!Env <- Env) ; Subst </ subst > CfgItems1 </ config >
     =ret=> < config > CfgItems2 </ config > .

--- Step 2.3 : Eliminate a env frame
  eq < config > < env > Env1 FreeEnv </ env > CfgItems1 </ config >
     =env=> < config > < env > Env2 FreeEnv </ env > CfgItems2 </ config >
   = < config > < env > Env1 </ env > CfgItems1 </ config >
     =env=> < config > < env > Env2 </ env > CfgItems2 </ config > .

--- Step 2.4 : Eliminate the environment cell
  eq < config > < env > (.).Map </ env > CfgItems1 </ config >
     =env=> < config > < env > (.).Map </ env > CfgItems2 </ config >
   = < config > CfgItems1 </ config >
     =ret=> < config > CfgItems2 </ config > .

--- Step 2.5 : Eliminate the return value (only when checking asserions at the end of function)
  eq < config > < form > Phi1 /\ returns(Obj1) </ form > CfgItems1 </ config >
     =ret=> < config > < form > Phi2 /\ returns(Obj2) </ form > CfgItems2 </ config >
   = < config > < form > Phi1 </ form > CfgItems1 </ config >
     =heap=> < config > < form > Phi2 /\ Obj1 === Obj2 </ form > CfgItems2 </ config > .
  eq Cfg1 =ret=> Cfg2 = Cfg1 =heap=> Cfg2 [owise] .


--- Step 3: Get rid of variable equalities and propagate them via substitution
--- Step 3.0.1 : Get rid of bound variables equalities at any time
***(
 ceq < config > < k > K </ k > < form > Phi </ form > CfgItems </ config >
   = < config > < k > K </ k > applySubst(< form > Phi </ form > CfgItems, NeSubst) </ config >
  if NeSubst := get?SubstItem(Phi) .
***)
--- Step 3.0.2 : Get rid of unbound variable equalities at any time
 ceq < config > < k > K </ k > < form > Phi </ form > CfgItems < subst > Subst </ subst > </ config >
   = < config > < k > K </ k > applySubst(< form > Phi </ form > CfgItems, NeSubst) < subst > NeSubst ; applySubst(Subst, NeSubst) </ subst > </ config >
  if NeSubst := getFreeSubstItem(Phi) .
***(
--- Step 3.0.3 : Get rid of bound environment frame
 ceq < config > < k > K </ k > < env > Env ?Env </ env > < tenv > TEnv </ tenv > CfgItems </ config > < counter > N </ counter >
   = < config > < k > K </ k > < env > Env FrameEnv </ env > < tenv > TEnv </ tenv > CfgItems </ config > < counter > M </ counter >
  if (FrameEnv initPVarMap(M, (.).Set)) := initPVarMap(N, keys(TEnv) -Set keys(Env)) .
***)

--- Step 3.1 : Get rid of proof tasks for bound variables equalities in the conclusion
 ceq Cfg =heap=> < config > < form > Phi </ form > CfgItems < subst > Subst </ subst > </ config >
   = Cfg =heap=> < config > applySubst(< form > Phi </ form > CfgItems, NeSubst) < subst > NeSubst ; applySubst(Subst, NeSubst) </ subst > </ config >
  if NeSubst := get?SubstItem(Phi) .
 ceq Cfg =form=> < config > < form > Phi </ form > CfgItems < subst > Subst </ subst > </ config >
   = Cfg =form=> < config > applySubst(< form > Phi </ form > CfgItems, NeSubst) < subst > NeSubst ; applySubst(Subst, NeSubst) </ subst > </ config >
  if NeSubst := get?SubstItem(Phi) .

--- Step 3.2 : Get rid of unbound variables equalities in the hypothesis
 ceq < config > < form > Phi </ form > CfgItems1 </ config >
     =heap=> < config > < subst > Subst </ subst > CfgItems2 </ config >
   = applySubst(< config > < form > Phi </ form > CfgItems1 </ config >, NeSubst)
     =heap=> < config > < subst > NeSubst ; applySubst(Subst, NeSubst) </ subst > applySubst(CfgItems2, NeSubst) </ config >
  if NeSubst := getFreeSubstItem(Phi) .
 ceq < config > < form > Phi </ form > CfgItems1 </ config >
     =form=> < config > < subst > Subst </ subst > CfgItems2 </ config >
   = applySubst(< config > < form > Phi </ form > CfgItems1 </ config >, NeSubst)
     =form=> < config > < subst > NeSubst ; applySubst(Subst, NeSubst) </ subst > applySubst(CfgItems2, NeSubst) </ config >
  if NeSubst := getFreeSubstItem(Phi) .

--- Step 3.3 : Get rid of a globally bound equality in the conclusion
 ceq Cfg =heap=> < config > < form > Phi </ form > < subst > Subst </ subst > CfgItems </ config >
   = applySubst(Cfg, NeSubst)
     =heap=> < config > < subst > NeSubst ; applySubst(Subst, NeSubst) </ subst > applySubst(< form > Phi </ form > CfgItems, NeSubst) </ config >
  if NeSubst := get!SubstItem(Phi) .
 ceq Cfg =form=> < config > < form > Phi </ form > < subst > Subst </ subst > CfgItems </ config >
   = applySubst(Cfg, NeSubst)
     =form=> < config > < subst > NeSubst ; applySubst(Subst, NeSubst) </ subst > applySubst(< form > Phi </ form > CfgItems, NeSubst) </ config >
  if NeSubst := get!SubstItem(Phi) .


--- Step 4: Stepwise, eliminate the heap, if any
--- Step 4.1: Eliminate a heap pattern
  eq < config > < heap > HPN(ObjList)(ObjList1) H1 </ heap > CfgItems1 </ config >
     =heap=> < config > < heap > HPN(ObjList)(ObjList2) H2 </ heap > < form > Phi2 </ form > CfgItems2 </ config >
   = < config > < heap > H1 </ heap > CfgItems1 </ config >
     =heap=> < config > < heap > H2 </ heap > < form > Phi2 /\ ObjList1 === ObjList2 </ form > CfgItems2 </ config > .

--- Step 4.2 : Eliminate a location
 eq < config > < heap > P |-> Obj1 : F H1 </ heap > CfgItems1 </ config >
     =heap=> < config > < heap > P |-> Obj2 : F H2 </ heap > < form > Phi2 </ form > CfgItems2 </ config >
   = < config > < heap > H1 </ heap > CfgItems1 </ config >
     =heap=> < config > < heap > H2 </ heap > < form > Phi2 /\ Obj1 === Obj2 </ form > CfgItems2 </ config > .

--- Step 4.3 : Eliminate a globally bounded variable in the hypothesis
  eq < config > < heap > H </ heap > CfgItems1 </ config >
    =heap=> < config > < heap > ?H </ heap > CfgItems2 </ config >
   = < config > CfgItems1 </ config >
     =form=> < config > CfgItems2 </ config > .

--- Step 4.4 : Eliminate a globally bounded variable in the hypothesis
  eq < config > < heap > H </ heap > CfgItems1 </ config >
    =heap=> < config > < heap > !H </ heap > < subst > Subst </ subst > CfgItems2 </ config >
   = < config > CfgItems1 </ config >
     =form=> < config > < subst > (!H <- H) ; Subst </ subst > CfgItems2 </ config > .

--- Step 4.5 : Eliminate a heap frame
  eq < config > < heap > H1 FreeH </ heap > CfgItems1 </ config >
     =heap=> < config > < heap > H2 FreeH </ heap > CfgItems2 </ config >
   = < config > < heap > H1 </ heap > CfgItems1 </ config >
     =heap=> < config > < heap > H2 </ heap > CfgItems2 </ config > .

--- Step 4.6 : Eliminate the heap cell
  eq < config > < heap > (.).Map </ heap > < form > Phi1 </ form > CfgItems1 </ config >
     =heap=> < config > < heap > (.).Map </ heap > < form > Phi2 </ form > CfgItems2 </ config >
   = < config > < form > Phi1 </ form > CfgItems1 </ config >
     =form=> < config > < form > Phi2 </ form > CfgItems2 </ config > .


--- Step 5: Get rid of the formula implication task
  eq < config > < form > Phi1 </ form > </ config >
     =form=>
     < config > < form > Phi2 </ form > < subst > Subst </ subst > </ config >
   = < config > < form > Phi1 ===> Phi2 </ form > < subst > Subst </ subst > </ config > [owise] .


--- Step 6: Call external SMT solver to check the formula if the "in-house" approach failed
 crl < config > < form > NtPhi </ form > < subst > Subst </ subst > </ config >
  => < config > < form > TrueFormula </ form > < subst > Subst </ subst > </ config >
  if check-sat(~ NtPhi) ==Bool "unsat" [owise] .


--- helper operations
  op get?SubstItem : Formula -> Subst .
  eq get?SubstItem(?Obj === Obj /\ Phi) = (?Obj <- Obj) .
  eq get?SubstItem(Obj === ?Obj /\ Phi) = (?Obj <- Obj) .
  eq get?SubstItem(Phi) = .Subst [owise] .

  op get!SubstItem : Formula -> Subst .
  eq get!SubstItem(!Obj === Obj /\ Phi) = (!Obj <- Obj) .
  eq get!SubstItem(Obj === !Obj /\ Phi) = (!Obj <- Obj) .
  eq get!SubstItem(Phi) = .Subst [owise] .

  op getFreeSubstItem : Formula -> Subst .
  eq getFreeSubstItem(FreeObj === Obj /\ Phi) = (FreeObj <- Obj) .
  eq getFreeSubstItem(Obj === FreeObj /\ Phi) = (FreeObj <- Obj) .
  eq getFreeSubstItem(Phi) = .Subst [owise] .

  op initPVarMap : Nat Set -> Map .
  eq initPVarMap(N, SetItem(X) Set) = X |-> ?Int(N) initPVarMap(sNat N, Set) .
endm

