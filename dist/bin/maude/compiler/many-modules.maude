fmod MANY-MODULES is
  including META-MODULE-EXTRAS .
  including  META-K-MODULE .
  including META-K-MODULES .
  including META-K-BUILTINS .
  including K-META-CONFIG .
  including META-K-ERROR .
  var M M' : Module . 
  var SS SS' : SortSet .
  var O : Qid .
  var MS : ModuleSet .
  var Ms : Modules .
  var T : [Term] .
  
  op manyModules : Qid Modules ~> Module .
  eq manyModules(O, Ms) 
   = checkModule(removeImports(setImports(setName(manyModules(emptySModule, getModules(Ms), 'noConfig), O), getImports(Ms)), (including 'K-LATEX .))) .

  op manyModules : Module ModuleSet  Term ~> Module .
  eq manyModules(M, M' MS, T) = $manyModules(if getName(M') == 'SUBSTITUTION then setName(M,'SUBSTITUTION) else M fi, M', MS, T) .

  op $manyModules : Module Module ModuleSet  Term ~> Module .
  eq $manyModules(M, M', MS, T)
   = if T :: Term 
     then manyModules(addModule(removeConfTerm(setImports(M',nil)),M), MS,  T) 
     else manyModules(addModule(setImports(M',nil),M), MS, extractConfTerm(M')) 
     fi 
  [owise print T] .
  eq manyModules(M, empty, T) 
   = $manyModules(M, if getName(M) == 'SUBSTITUTION 
                     then if T :: Term 
                          then ctor(Bag)[T,mkCell('nextId,mkConstant('0,Int))] 
                          else ctor(Bag)[mkCell('k,mkVariable('$PGM,K)),
                                         mkCell('nextId,mkConstant('0,Int))] 
                          fi 
                     else T
                     fi) .
  op $manyModules : Module [Term] -> Module .
  eq $manyModules(M, T)
   = if T :: Term 
        then setConfTerm(M, T) 
        else M 
     fi .
endfm

