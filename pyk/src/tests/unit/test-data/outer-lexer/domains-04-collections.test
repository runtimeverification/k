module SET
  imports private INT-SYNTAX
  imports private BASIC-K

  syntax Set [hook(SET.Set)]
  syntax Set ::= Set Set                  [left, function, hook(SET.concat), klabel(_Set_), symbol, assoc, comm, unit(.Set), idem, element(SetItem), format(%1%n%2)]
  syntax Set ::= ".Set"                   [function, total, hook(SET.unit), klabel(.Set), symbol, latex(\dotCt{Set})]
  syntax Set ::= SetItem(KItem)               [function, total, hook(SET.element), klabel(SetItem), symbol, injective]
  syntax Set ::= Set "|Set" Set              [left, function, total, hook(SET.union), comm]
  rule S1:Set |Set S2:Set => S1 (S2 -Set S1) [concrete]
  syntax Set ::= intersectSet(Set, Set)   [function, total, hook(SET.intersection), comm]
  syntax Set ::= Set "-Set" Set           [function, total, hook(SET.difference), latex({#1}-_{\it Set}{#2}), klabel(Set:difference), symbol]
  syntax Bool ::= KItem "in" Set              [function, total, hook(SET.in), klabel(Set:in), symbol]
  syntax Bool ::= Set "<=Set" Set         [function, total, hook(SET.inclusion)]
  syntax Int ::= size(Set)                [function, total, hook(SET.size)]
  syntax KItem ::= choice(Set)                [function, hook(SET.choice), klabel(Set:choice)]
endmodule


module SET-KORE-SYMBOLIC [kore,symbolic]
  imports SET
  imports private K-EQUAL
  imports private BOOL

  //Temporarly rule for #Ceil simplification, should be generated in front-end

// Matching for this version not implemented.
  // rule #Ceil(@S1:Set @S2:Set) =>
  //        {intersectSet(@S1, @S2) #Equals .Set} #And #Ceil(@S1) #And #Ceil(@S2)
  //   [simplification]

//simpler version
  rule #Ceil(@S:Set SetItem(@E:KItem)) =>
         {(@E in @S) #Equals false} #And #Ceil(@S) #And #Ceil(@E)
    [simplification]

  // -Set simplifications
  rule S              -Set .Set           => S          [simplification]
  rule .Set           -Set  _             => .Set       [simplification]
  rule SetItem(X)     -Set (S SetItem(X)) => .Set
                               ensures notBool (X in S) [simplification]
  rule S              -Set (S SetItem(X)) => .Set
                               ensures notBool (X in S) [simplification]
  rule (S SetItem(X)) -Set S              => SetItem(X)
                               ensures notBool (X in S) [simplification]
  rule (S SetItem(X)) -Set SetItem(X)     => S
                               ensures notBool (X in S) [simplification]
  // rule SetItem(X)     -Set S              => SetItem(X)
  //                            requires notBool (X in S)  [simplification]
  // rule (S1 SetItem(X)) -Set (S2 SetItem(X))  => S1 -Set S2
  //                             ensures notBool (X in S1)
  //                             andBool notBool (X in S2) [simplification]

  // |Set simplifications
  rule S    |Set .Set => S    [simplification, comm]
  rule S    |Set S    => S    [simplification]

  rule (S SetItem(X)) |Set SetItem(X) => S SetItem(X)
                             ensures notBool (X in S) [simplification, comm]
  // Currently disabled, see runtimeverification/haskell-backend#3301
  // rule (S SetItem(X)) |Set S          => S SetItem(X)
  //                            ensures notBool (X in S) [simplification, comm]

  // intersectSet simplifications
  rule intersectSet(.Set, _   ) => .Set    [simplification, comm]
  rule intersectSet( S  , S   ) =>  S      [simplification]

  rule intersectSet( S SetItem(X), SetItem(X))     => SetItem(X)
                                                        ensures notBool (X in S)      [simplification, comm]
  // Currently disabled, see runtimeverification/haskell-backend#3294
  // rule intersectSet( S SetItem(X) , S)             => S ensures notBool (X in S)      [simplification, comm]
  rule intersectSet( S1 SetItem(X), S2 SetItem(X)) => intersectSet(S1, S2) SetItem(X)
                                                        ensures notBool (X in S1)
                                                        andBool notBool (X in S2)     [simplification]

  // membership simplifications
  rule _E in .Set           => false   [simplification]
  rule E  in (S SetItem(E)) => true
              ensures notBool (E in S) [simplification]

// These two rules would be sound but impose a giant overhead on `in` evaluation:
  // rule E1 in (S SetItem(E2)) => true requires E1 in S
  //                                 ensures notBool (E2 in S) [simplification]
  // rule E1 in (S SetItem(E2)) => E1 in S requires E1 =/=K E2
  //                                 ensures notBool (E2 in S) [simplification]

  rule X in ((SetItem(X) S) |Set  _            ) => true
                                    ensures notBool (X in S) [simplification]
  rule X in ( _             |Set (SetItem(X) S)) => true
                                    ensures notBool (X in S) [simplification]

endmodule


module SET-SYMBOLIC
  imports SET-KORE-SYMBOLIC
endmodule


module LIST
  imports private INT-SYNTAX
  imports private BASIC-K

  syntax List [hook(LIST.List)]
  syntax List ::= List List               [left, function, total, hook(LIST.concat), klabel(_List_), symbol, smtlib(smt_seq_concat), assoc, unit(.List), element(ListItem), format(%1%n%2)]
  syntax List ::= ".List"                 [function, total, hook(LIST.unit), klabel(.List), symbol, smtlib(smt_seq_nil), latex(\dotCt{List})]
  syntax List ::= ListItem(KItem)             [function, total, hook(LIST.element), klabel(ListItem), symbol, smtlib(smt_seq_elem)]
  syntax KItem ::= List "[" Int "]"           [function, hook(LIST.get), klabel(List:get), symbol]
  syntax List ::= List "[" index: Int "<-" value: KItem "]" [function, hook(LIST.update), klabel(List:set)]
  syntax List ::= makeList(length: Int, value: KItem) [function, hook(LIST.make)]
  syntax List ::= updateList(dest: List, index: Int, src: List) [function, hook(LIST.updateAll)]
  syntax List ::= fillList(List, index: Int, length: Int, value: KItem) [function, hook(LIST.fill)]
  syntax List ::= range(List, fromFront: Int, fromBack: Int)   [function, hook(LIST.range), klabel(List:range), symbol]
  syntax Bool ::= KItem "in" List             [function, total, hook(LIST.in), klabel(_inList_)]
  syntax Int ::= size(List)               [function, total, hook(LIST.size), klabel (sizeList), smtlib(smt_seq_len)]
endmodule


module COLLECTIONS
  imports LIST
  imports SET
  imports MAP

  syntax List ::= Set2List(Set) [function, total, hook(SET.set2list)]
  syntax Set ::= List2Set(List) [function, total, hook(SET.list2set)]
endmodule
===
KW_MODULE
1,1
module

MODNAME
1,8
SET

KW_IMPORTS
2,3
imports

KW_PRIVATE
2,11
private

MODNAME
2,19
INT-SYNTAX

KW_IMPORTS
3,3
imports

KW_PRIVATE
3,11
private

MODNAME
3,19
BASIC-K

KW_SYNTAX
5,3
syntax

ID_UPPER
5,10
Set

LBRACK
5,14
[

ATTR_KEY
1,0
hook

LPAREN
1,0
(

ATTR_CONTENT
1,0
SET.Set

RPAREN
1,0
)

RBRACK
1,0
]

KW_SYNTAX
6,3
syntax

ID_UPPER
6,10
Set

DCOLONEQ
6,14
::=

ID_UPPER
6,18
Set

ID_UPPER
6,22
Set

LBRACK
6,43
[

ATTR_KEY
1,0
left

COMMA
1,0
,

ATTR_KEY
1,0
function

COMMA
1,0
,

ATTR_KEY
1,0
hook

LPAREN
1,0
(

ATTR_CONTENT
1,0
SET.concat

RPAREN
1,0
)

COMMA
1,0
,

ATTR_KEY
1,0
klabel

LPAREN
1,0
(

ATTR_CONTENT
1,0
_Set_

RPAREN
1,0
)

COMMA
1,0
,

ATTR_KEY
1,0
symbol

COMMA
1,0
,

ATTR_KEY
1,0
assoc

COMMA
1,0
,

ATTR_KEY
1,0
comm

COMMA
1,0
,

ATTR_KEY
1,0
unit

LPAREN
1,0
(

ATTR_CONTENT
1,0
.Set

RPAREN
1,0
)

COMMA
1,0
,

ATTR_KEY
1,0
idem

COMMA
1,0
,

ATTR_KEY
1,0
element

LPAREN
1,0
(

ATTR_CONTENT
1,0
SetItem

RPAREN
1,0
)

COMMA
1,0
,

ATTR_KEY
1,0
format

LPAREN
1,0
(

ATTR_CONTENT
1,0
%1%n%2

RPAREN
1,0
)

RBRACK
1,0
]

KW_SYNTAX
7,3
syntax

ID_UPPER
7,10
Set

DCOLONEQ
7,14
::=

STRING
7,18
".Set"

LBRACK
7,43
[

ATTR_KEY
1,0
function

COMMA
1,0
,

ATTR_KEY
1,0
total

COMMA
1,0
,

ATTR_KEY
1,0
hook

LPAREN
1,0
(

ATTR_CONTENT
1,0
SET.unit

RPAREN
1,0
)

COMMA
1,0
,

ATTR_KEY
1,0
klabel

LPAREN
1,0
(

ATTR_CONTENT
1,0
.Set

RPAREN
1,0
)

COMMA
1,0
,

ATTR_KEY
1,0
symbol

COMMA
1,0
,

ATTR_KEY
1,0
latex

LPAREN
1,0
(

ATTR_CONTENT
1,0
\dotCt{Set}

RPAREN
1,0
)

RBRACK
1,0
]

KW_SYNTAX
8,3
syntax

ID_UPPER
8,10
Set

DCOLONEQ
8,14
::=

ID_UPPER
8,18
SetItem

LPAREN
8,25
(

ID_UPPER
8,26
KItem

RPAREN
8,31
)

LBRACK
8,47
[

ATTR_KEY
1,0
function

COMMA
1,0
,

ATTR_KEY
1,0
total

COMMA
1,0
,

ATTR_KEY
1,0
hook

LPAREN
1,0
(

ATTR_CONTENT
1,0
SET.element

RPAREN
1,0
)

COMMA
1,0
,

ATTR_KEY
1,0
klabel

LPAREN
1,0
(

ATTR_CONTENT
1,0
SetItem

RPAREN
1,0
)

COMMA
1,0
,

ATTR_KEY
1,0
symbol

COMMA
1,0
,

ATTR_KEY
1,0
injective

RBRACK
1,0
]

KW_SYNTAX
9,3
syntax

ID_UPPER
9,10
Set

DCOLONEQ
9,14
::=

ID_UPPER
9,18
Set

STRING
9,22
"|Set"

ID_UPPER
9,29
Set

LBRACK
9,46
[

ATTR_KEY
1,0
left

COMMA
1,0
,

ATTR_KEY
1,0
function

COMMA
1,0
,

ATTR_KEY
1,0
total

COMMA
1,0
,

ATTR_KEY
1,0
hook

LPAREN
1,0
(

ATTR_CONTENT
1,0
SET.union

RPAREN
1,0
)

COMMA
1,0
,

ATTR_KEY
1,0
comm

RBRACK
1,0
]

KW_RULE
10,3
rule

BUBBLE
10,8
S1:Set |Set S2:Set => S1 (S2 -Set S1)

LBRACK
1,0
[

ATTR_KEY
1,0
concrete

RBRACK
1,0
]

KW_SYNTAX
11,3
syntax

ID_UPPER
11,10
Set

DCOLONEQ
11,14
::=

ID_LOWER
11,18
intersectSet

LPAREN
11,30
(

ID_UPPER
11,31
Set

COMMA
11,34
,

ID_UPPER
11,36
Set

RPAREN
11,39
)

LBRACK
11,43
[

ATTR_KEY
1,0
function

COMMA
1,0
,

ATTR_KEY
1,0
total

COMMA
1,0
,

ATTR_KEY
1,0
hook

LPAREN
1,0
(

ATTR_CONTENT
1,0
SET.intersection

RPAREN
1,0
)

COMMA
1,0
,

ATTR_KEY
1,0
comm

RBRACK
1,0
]

KW_SYNTAX
12,3
syntax

ID_UPPER
12,10
Set

DCOLONEQ
12,14
::=

ID_UPPER
12,18
Set

STRING
12,22
"-Set"

ID_UPPER
12,29
Set

LBRACK
12,43
[

ATTR_KEY
1,0
function

COMMA
1,0
,

ATTR_KEY
1,0
total

COMMA
1,0
,

ATTR_KEY
1,0
hook

LPAREN
1,0
(

ATTR_CONTENT
1,0
SET.difference

RPAREN
1,0
)

COMMA
1,0
,

ATTR_KEY
1,0
latex

LPAREN
1,0
(

ATTR_CONTENT
1,0
{#1}-_{\it Set}{#2}

RPAREN
1,0
)

COMMA
1,0
,

ATTR_KEY
1,0
klabel

LPAREN
1,0
(

ATTR_CONTENT
1,0
Set:difference

RPAREN
1,0
)

COMMA
1,0
,

ATTR_KEY
1,0
symbol

RBRACK
1,0
]

KW_SYNTAX
13,3
syntax

ID_UPPER
13,10
Bool

DCOLONEQ
13,15
::=

ID_UPPER
13,19
KItem

STRING
13,25
"in"

ID_UPPER
13,30
Set

LBRACK
13,47
[

ATTR_KEY
1,0
function

COMMA
1,0
,

ATTR_KEY
1,0
total

COMMA
1,0
,

ATTR_KEY
1,0
hook

LPAREN
1,0
(

ATTR_CONTENT
1,0
SET.in

RPAREN
1,0
)

COMMA
1,0
,

ATTR_KEY
1,0
klabel

LPAREN
1,0
(

ATTR_CONTENT
1,0
Set:in

RPAREN
1,0
)

COMMA
1,0
,

ATTR_KEY
1,0
symbol

RBRACK
1,0
]

KW_SYNTAX
14,3
syntax

ID_UPPER
14,10
Bool

DCOLONEQ
14,15
::=

ID_UPPER
14,19
Set

STRING
14,23
"<=Set"

ID_UPPER
14,31
Set

LBRACK
14,43
[

ATTR_KEY
1,0
function

COMMA
1,0
,

ATTR_KEY
1,0
total

COMMA
1,0
,

ATTR_KEY
1,0
hook

LPAREN
1,0
(

ATTR_CONTENT
1,0
SET.inclusion

RPAREN
1,0
)

RBRACK
1,0
]

KW_SYNTAX
15,3
syntax

ID_UPPER
15,10
Int

DCOLONEQ
15,14
::=

ID_LOWER
15,18
size

LPAREN
15,22
(

ID_UPPER
15,23
Set

RPAREN
15,26
)

LBRACK
15,43
[

ATTR_KEY
1,0
function

COMMA
1,0
,

ATTR_KEY
1,0
total

COMMA
1,0
,

ATTR_KEY
1,0
hook

LPAREN
1,0
(

ATTR_CONTENT
1,0
SET.size

RPAREN
1,0
)

RBRACK
1,0
]

KW_SYNTAX
16,3
syntax

ID_UPPER
16,10
KItem

DCOLONEQ
16,16
::=

ID_LOWER
16,20
choice

LPAREN
16,26
(

ID_UPPER
16,27
Set

RPAREN
16,30
)

LBRACK
16,47
[

ATTR_KEY
1,0
function

COMMA
1,0
,

ATTR_KEY
1,0
hook

LPAREN
1,0
(

ATTR_CONTENT
1,0
SET.choice

RPAREN
1,0
)

COMMA
1,0
,

ATTR_KEY
1,0
klabel

LPAREN
1,0
(

ATTR_CONTENT
1,0
Set:choice

RPAREN
1,0
)

RBRACK
1,0
]

KW_ENDMODULE
17,1
endmodule

KW_MODULE
20,1
module

MODNAME
20,8
SET-KORE-SYMBOLIC

LBRACK
20,26
[

ATTR_KEY
1,0
kore

COMMA
1,0
,

ATTR_KEY
1,0
symbolic

RBRACK
1,0
]

KW_IMPORTS
21,3
imports

MODNAME
21,11
SET

KW_IMPORTS
22,3
imports

KW_PRIVATE
22,11
private

MODNAME
22,19
K-EQUAL

KW_IMPORTS
23,3
imports

KW_PRIVATE
23,11
private

MODNAME
23,19
BOOL

KW_RULE
33,3
rule

BUBBLE
33,8
#Ceil(@S:Set SetItem(@E:KItem)) =>
         {(@E in @S) #Equals false} #And #Ceil(@S) #And #Ceil(@E)

LBRACK
1,0
[

ATTR_KEY
1,0
simplification

RBRACK
1,0
]

KW_RULE
38,3
rule

BUBBLE
38,8
S              -Set .Set           => S

LBRACK
1,0
[

ATTR_KEY
1,0
simplification

RBRACK
1,0
]

KW_RULE
39,3
rule

BUBBLE
39,8
.Set           -Set  _             => .Set

LBRACK
1,0
[

ATTR_KEY
1,0
simplification

RBRACK
1,0
]

KW_RULE
40,3
rule

BUBBLE
40,8
SetItem(X)     -Set (S SetItem(X)) => .Set
                               ensures notBool (X in S)

LBRACK
1,0
[

ATTR_KEY
1,0
simplification

RBRACK
1,0
]

KW_RULE
42,3
rule

BUBBLE
42,8
S              -Set (S SetItem(X)) => .Set
                               ensures notBool (X in S)

LBRACK
1,0
[

ATTR_KEY
1,0
simplification

RBRACK
1,0
]

KW_RULE
44,3
rule

BUBBLE
44,8
(S SetItem(X)) -Set S              => SetItem(X)
                               ensures notBool (X in S)

LBRACK
1,0
[

ATTR_KEY
1,0
simplification

RBRACK
1,0
]

KW_RULE
46,3
rule

BUBBLE
46,8
(S SetItem(X)) -Set SetItem(X)     => S
                               ensures notBool (X in S)

LBRACK
1,0
[

ATTR_KEY
1,0
simplification

RBRACK
1,0
]

KW_RULE
55,3
rule

BUBBLE
55,8
S    |Set .Set => S

LBRACK
1,0
[

ATTR_KEY
1,0
simplification

COMMA
1,0
,

ATTR_KEY
1,0
comm

RBRACK
1,0
]

KW_RULE
56,3
rule

BUBBLE
56,8
S    |Set S    => S

LBRACK
1,0
[

ATTR_KEY
1,0
simplification

RBRACK
1,0
]

KW_RULE
58,3
rule

BUBBLE
58,8
(S SetItem(X)) |Set SetItem(X) => S SetItem(X)
                             ensures notBool (X in S)

LBRACK
1,0
[

ATTR_KEY
1,0
simplification

COMMA
1,0
,

ATTR_KEY
1,0
comm

RBRACK
1,0
]

KW_RULE
65,3
rule

BUBBLE
65,8
intersectSet(.Set, _   ) => .Set

LBRACK
1,0
[

ATTR_KEY
1,0
simplification

COMMA
1,0
,

ATTR_KEY
1,0
comm

RBRACK
1,0
]

KW_RULE
66,3
rule

BUBBLE
66,8
intersectSet( S  , S   ) =>  S

LBRACK
1,0
[

ATTR_KEY
1,0
simplification

RBRACK
1,0
]

KW_RULE
68,3
rule

BUBBLE
68,8
intersectSet( S SetItem(X), SetItem(X))     => SetItem(X)
                                                        ensures notBool (X in S)

LBRACK
1,0
[

ATTR_KEY
1,0
simplification

COMMA
1,0
,

ATTR_KEY
1,0
comm

RBRACK
1,0
]

KW_RULE
72,3
rule

BUBBLE
72,8
intersectSet( S1 SetItem(X), S2 SetItem(X)) => intersectSet(S1, S2) SetItem(X)
                                                        ensures notBool (X in S1)
                                                        andBool notBool (X in S2)

LBRACK
1,0
[

ATTR_KEY
1,0
simplification

RBRACK
1,0
]

KW_RULE
77,3
rule

BUBBLE
77,8
_E in .Set           => false

LBRACK
1,0
[

ATTR_KEY
1,0
simplification

RBRACK
1,0
]

KW_RULE
78,3
rule

BUBBLE
78,8
E  in (S SetItem(E)) => true
              ensures notBool (E in S)

LBRACK
1,0
[

ATTR_KEY
1,0
simplification

RBRACK
1,0
]

KW_RULE
87,3
rule

BUBBLE
87,8
X in ((SetItem(X) S) |Set  _            ) => true
                                    ensures notBool (X in S)

LBRACK
1,0
[

ATTR_KEY
1,0
simplification

RBRACK
1,0
]

KW_RULE
89,3
rule

BUBBLE
89,8
X in ( _             |Set (SetItem(X) S)) => true
                                    ensures notBool (X in S)

LBRACK
1,0
[

ATTR_KEY
1,0
simplification

RBRACK
1,0
]

KW_ENDMODULE
92,1
endmodule

KW_MODULE
95,1
module

MODNAME
95,8
SET-SYMBOLIC

KW_IMPORTS
96,3
imports

MODNAME
96,11
SET-KORE-SYMBOLIC

KW_ENDMODULE
97,1
endmodule

KW_MODULE
100,1
module

MODNAME
100,8
LIST

KW_IMPORTS
101,3
imports

KW_PRIVATE
101,11
private

MODNAME
101,19
INT-SYNTAX

KW_IMPORTS
102,3
imports

KW_PRIVATE
102,11
private

MODNAME
102,19
BASIC-K

KW_SYNTAX
104,3
syntax

ID_UPPER
104,10
List

LBRACK
104,15
[

ATTR_KEY
1,0
hook

LPAREN
1,0
(

ATTR_CONTENT
1,0
LIST.List

RPAREN
1,0
)

RBRACK
1,0
]

KW_SYNTAX
105,3
syntax

ID_UPPER
105,10
List

DCOLONEQ
105,15
::=

ID_UPPER
105,19
List

ID_UPPER
105,24
List

LBRACK
105,43
[

ATTR_KEY
1,0
left

COMMA
1,0
,

ATTR_KEY
1,0
function

COMMA
1,0
,

ATTR_KEY
1,0
total

COMMA
1,0
,

ATTR_KEY
1,0
hook

LPAREN
1,0
(

ATTR_CONTENT
1,0
LIST.concat

RPAREN
1,0
)

COMMA
1,0
,

ATTR_KEY
1,0
klabel

LPAREN
1,0
(

ATTR_CONTENT
1,0
_List_

RPAREN
1,0
)

COMMA
1,0
,

ATTR_KEY
1,0
symbol

COMMA
1,0
,

ATTR_KEY
1,0
smtlib

LPAREN
1,0
(

ATTR_CONTENT
1,0
smt_seq_concat

RPAREN
1,0
)

COMMA
1,0
,

ATTR_KEY
1,0
assoc

COMMA
1,0
,

ATTR_KEY
1,0
unit

LPAREN
1,0
(

ATTR_CONTENT
1,0
.List

RPAREN
1,0
)

COMMA
1,0
,

ATTR_KEY
1,0
element

LPAREN
1,0
(

ATTR_CONTENT
1,0
ListItem

RPAREN
1,0
)

COMMA
1,0
,

ATTR_KEY
1,0
format

LPAREN
1,0
(

ATTR_CONTENT
1,0
%1%n%2

RPAREN
1,0
)

RBRACK
1,0
]

KW_SYNTAX
106,3
syntax

ID_UPPER
106,10
List

DCOLONEQ
106,15
::=

STRING
106,19
".List"

LBRACK
106,43
[

ATTR_KEY
1,0
function

COMMA
1,0
,

ATTR_KEY
1,0
total

COMMA
1,0
,

ATTR_KEY
1,0
hook

LPAREN
1,0
(

ATTR_CONTENT
1,0
LIST.unit

RPAREN
1,0
)

COMMA
1,0
,

ATTR_KEY
1,0
klabel

LPAREN
1,0
(

ATTR_CONTENT
1,0
.List

RPAREN
1,0
)

COMMA
1,0
,

ATTR_KEY
1,0
symbol

COMMA
1,0
,

ATTR_KEY
1,0
smtlib

LPAREN
1,0
(

ATTR_CONTENT
1,0
smt_seq_nil

RPAREN
1,0
)

COMMA
1,0
,

ATTR_KEY
1,0
latex

LPAREN
1,0
(

ATTR_CONTENT
1,0
\dotCt{List}

RPAREN
1,0
)

RBRACK
1,0
]

KW_SYNTAX
107,3
syntax

ID_UPPER
107,10
List

DCOLONEQ
107,15
::=

ID_UPPER
107,19
ListItem

LPAREN
107,27
(

ID_UPPER
107,28
KItem

RPAREN
107,33
)

LBRACK
107,47
[

ATTR_KEY
1,0
function

COMMA
1,0
,

ATTR_KEY
1,0
total

COMMA
1,0
,

ATTR_KEY
1,0
hook

LPAREN
1,0
(

ATTR_CONTENT
1,0
LIST.element

RPAREN
1,0
)

COMMA
1,0
,

ATTR_KEY
1,0
klabel

LPAREN
1,0
(

ATTR_CONTENT
1,0
ListItem

RPAREN
1,0
)

COMMA
1,0
,

ATTR_KEY
1,0
symbol

COMMA
1,0
,

ATTR_KEY
1,0
smtlib

LPAREN
1,0
(

ATTR_CONTENT
1,0
smt_seq_elem

RPAREN
1,0
)

RBRACK
1,0
]

KW_SYNTAX
108,3
syntax

ID_UPPER
108,10
KItem

DCOLONEQ
108,16
::=

ID_UPPER
108,20
List

STRING
108,25
"["

ID_UPPER
108,29
Int

STRING
108,33
"]"

LBRACK
108,47
[

ATTR_KEY
1,0
function

COMMA
1,0
,

ATTR_KEY
1,0
hook

LPAREN
1,0
(

ATTR_CONTENT
1,0
LIST.get

RPAREN
1,0
)

COMMA
1,0
,

ATTR_KEY
1,0
klabel

LPAREN
1,0
(

ATTR_CONTENT
1,0
List:get

RPAREN
1,0
)

COMMA
1,0
,

ATTR_KEY
1,0
symbol

RBRACK
1,0
]

KW_SYNTAX
109,3
syntax

ID_UPPER
109,10
List

DCOLONEQ
109,15
::=

ID_UPPER
109,19
List

STRING
109,24
"["

ID_LOWER
109,28
index

COLON
109,33
:

ID_UPPER
109,35
Int

STRING
109,39
"<-"

ID_LOWER
109,44
value

COLON
109,49
:

ID_UPPER
109,51
KItem

STRING
109,57
"]"

LBRACK
109,61
[

ATTR_KEY
1,0
function

COMMA
1,0
,

ATTR_KEY
1,0
hook

LPAREN
1,0
(

ATTR_CONTENT
1,0
LIST.update

RPAREN
1,0
)

COMMA
1,0
,

ATTR_KEY
1,0
klabel

LPAREN
1,0
(

ATTR_CONTENT
1,0
List:set

RPAREN
1,0
)

RBRACK
1,0
]

KW_SYNTAX
110,3
syntax

ID_UPPER
110,10
List

DCOLONEQ
110,15
::=

ID_LOWER
110,19
makeList

LPAREN
110,27
(

ID_LOWER
110,28
length

COLON
110,34
:

ID_UPPER
110,36
Int

COMMA
110,39
,

ID_LOWER
110,41
value

COLON
110,46
:

ID_UPPER
110,48
KItem

RPAREN
110,53
)

LBRACK
110,55
[

ATTR_KEY
1,0
function

COMMA
1,0
,

ATTR_KEY
1,0
hook

LPAREN
1,0
(

ATTR_CONTENT
1,0
LIST.make

RPAREN
1,0
)

RBRACK
1,0
]

KW_SYNTAX
111,3
syntax

ID_UPPER
111,10
List

DCOLONEQ
111,15
::=

ID_LOWER
111,19
updateList

LPAREN
111,29
(

ID_LOWER
111,30
dest

COLON
111,34
:

ID_UPPER
111,36
List

COMMA
111,40
,

ID_LOWER
111,42
index

COLON
111,47
:

ID_UPPER
111,49
Int

COMMA
111,52
,

ID_LOWER
111,54
src

COLON
111,57
:

ID_UPPER
111,59
List

RPAREN
111,63
)

LBRACK
111,65
[

ATTR_KEY
1,0
function

COMMA
1,0
,

ATTR_KEY
1,0
hook

LPAREN
1,0
(

ATTR_CONTENT
1,0
LIST.updateAll

RPAREN
1,0
)

RBRACK
1,0
]

KW_SYNTAX
112,3
syntax

ID_UPPER
112,10
List

DCOLONEQ
112,15
::=

ID_LOWER
112,19
fillList

LPAREN
112,27
(

ID_UPPER
112,28
List

COMMA
112,32
,

ID_LOWER
112,34
index

COLON
112,39
:

ID_UPPER
112,41
Int

COMMA
112,44
,

ID_LOWER
112,46
length

COLON
112,52
:

ID_UPPER
112,54
Int

COMMA
112,57
,

ID_LOWER
112,59
value

COLON
112,64
:

ID_UPPER
112,66
KItem

RPAREN
112,71
)

LBRACK
112,73
[

ATTR_KEY
1,0
function

COMMA
1,0
,

ATTR_KEY
1,0
hook

LPAREN
1,0
(

ATTR_CONTENT
1,0
LIST.fill

RPAREN
1,0
)

RBRACK
1,0
]

KW_SYNTAX
113,3
syntax

ID_UPPER
113,10
List

DCOLONEQ
113,15
::=

ID_LOWER
113,19
range

LPAREN
113,24
(

ID_UPPER
113,25
List

COMMA
113,29
,

ID_LOWER
113,31
fromFront

COLON
113,40
:

ID_UPPER
113,42
Int

COMMA
113,45
,

ID_LOWER
113,47
fromBack

COLON
113,55
:

ID_UPPER
113,57
Int

RPAREN
113,60
)

LBRACK
113,64
[

ATTR_KEY
1,0
function

COMMA
1,0
,

ATTR_KEY
1,0
hook

LPAREN
1,0
(

ATTR_CONTENT
1,0
LIST.range

RPAREN
1,0
)

COMMA
1,0
,

ATTR_KEY
1,0
klabel

LPAREN
1,0
(

ATTR_CONTENT
1,0
List:range

RPAREN
1,0
)

COMMA
1,0
,

ATTR_KEY
1,0
symbol

RBRACK
1,0
]

KW_SYNTAX
114,3
syntax

ID_UPPER
114,10
Bool

DCOLONEQ
114,15
::=

ID_UPPER
114,19
KItem

STRING
114,25
"in"

ID_UPPER
114,30
List

LBRACK
114,47
[

ATTR_KEY
1,0
function

COMMA
1,0
,

ATTR_KEY
1,0
total

COMMA
1,0
,

ATTR_KEY
1,0
hook

LPAREN
1,0
(

ATTR_CONTENT
1,0
LIST.in

RPAREN
1,0
)

COMMA
1,0
,

ATTR_KEY
1,0
klabel

LPAREN
1,0
(

ATTR_CONTENT
1,0
_inList_

RPAREN
1,0
)

RBRACK
1,0
]

KW_SYNTAX
115,3
syntax

ID_UPPER
115,10
Int

DCOLONEQ
115,14
::=

ID_LOWER
115,18
size

LPAREN
115,22
(

ID_UPPER
115,23
List

RPAREN
115,27
)

LBRACK
115,43
[

ATTR_KEY
1,0
function

COMMA
1,0
,

ATTR_KEY
1,0
total

COMMA
1,0
,

ATTR_KEY
1,0
hook

LPAREN
1,0
(

ATTR_CONTENT
1,0
LIST.size

RPAREN
1,0
)

COMMA
1,0
,

ATTR_KEY
1,0
klabel

LPAREN
1,0
(

ATTR_CONTENT
1,0
sizeList

RPAREN
1,0
)

COMMA
1,0
,

ATTR_KEY
1,0
smtlib

LPAREN
1,0
(

ATTR_CONTENT
1,0
smt_seq_len

RPAREN
1,0
)

RBRACK
1,0
]

KW_ENDMODULE
116,1
endmodule

KW_MODULE
119,1
module

MODNAME
119,8
COLLECTIONS

KW_IMPORTS
120,3
imports

MODNAME
120,11
LIST

KW_IMPORTS
121,3
imports

MODNAME
121,11
SET

KW_IMPORTS
122,3
imports

MODNAME
122,11
MAP

KW_SYNTAX
124,3
syntax

ID_UPPER
124,10
List

DCOLONEQ
124,15
::=

ID_UPPER
124,19
Set2List

LPAREN
124,27
(

ID_UPPER
124,28
Set

RPAREN
124,31
)

LBRACK
124,33
[

ATTR_KEY
1,0
function

COMMA
1,0
,

ATTR_KEY
1,0
total

COMMA
1,0
,

ATTR_KEY
1,0
hook

LPAREN
1,0
(

ATTR_CONTENT
1,0
SET.set2list

RPAREN
1,0
)

RBRACK
1,0
]

KW_SYNTAX
125,3
syntax

ID_UPPER
125,10
Set

DCOLONEQ
125,14
::=

ID_UPPER
125,18
List2Set

LPAREN
125,26
(

ID_UPPER
125,27
List

RPAREN
125,31
)

LBRACK
125,33
[

ATTR_KEY
1,0
function

COMMA
1,0
,

ATTR_KEY
1,0
total

COMMA
1,0
,

ATTR_KEY
1,0
hook

LPAREN
1,0
(

ATTR_CONTENT
1,0
SET.list2set

RPAREN
1,0
)

RBRACK
1,0
]

KW_ENDMODULE
126,1
endmodule

EOF
126,9

