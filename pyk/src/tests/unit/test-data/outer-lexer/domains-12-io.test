module K-IO
  imports private LIST
  imports private STRING
  imports private INT

  syntax IOError ::= "#EOF" [klabel(#EOF), symbol] | #unknownIOError(errno: Int) [symbol]
                   | "#E2BIG" [klabel(#E2BIG), symbol]
                   | "#EACCES" [klabel(#EACCES), symbol]
                   | "#EAGAIN" [klabel(#EAGAIN), symbol]
                   | "#EBADF" [klabel(#EBADF), symbol]
                   | "#EBUSY" [klabel(#EBUSY), symbol]
                   | "#ECHILD" [klabel(#ECHILD), symbol]
                   | "#EDEADLK" [klabel(#EDEADLK), symbol]
                   | "#EDOM" [klabel(#EDOM), symbol]
                   | "#EEXIST" [klabel(#EEXIST), symbol]
                   | "#EFAULT" [klabel(#EFAULT), symbol]
                   | "#EFBIG" [klabel(#EFBIG), symbol]
                   | "#EINTR" [klabel(#EINTR), symbol]
                   | "#EINVAL" [klabel(#EINVAL), symbol]
                   | "#EIO" [klabel(#EIO), symbol]
                   | "#EISDIR" [klabel(#EISDIR), symbol]
                   | "#EMFILE" [klabel(#EMFILE), symbol]
                   | "#EMLINK" [klabel(#EMLINK), symbol]
                   | "#ENAMETOOLONG" [klabel(#ENAMETOOLONG), symbol]
                   | "#ENFILE" [klabel(#ENFILE), symbol]
                   | "#ENODEV" [klabel(#ENODEV), symbol]
                   | "#ENOENT" [klabel(#ENOENT), symbol]
                   | "#ENOEXEC" [klabel(#ENOEXEC), symbol]
                   | "#ENOLCK" [klabel(#ENOLCK), symbol]
                   | "#ENOMEM" [klabel(#ENOMEM), symbol]
                   | "#ENOSPC" [klabel(#ENOSPC), symbol]
                   | "#ENOSYS" [klabel(#ENOSYS), symbol]
                   | "#ENOTDIR" [klabel(#ENOTDIR), symbol]
                   | "#ENOTEMPTY" [klabel(#ENOTEMPTY), symbol]
                   | "#ENOTTY" [klabel(#ENOTTY), symbol]
                   | "#ENXIO" [klabel(#ENXIO), symbol]
                   | "#EPERM" [klabel(#EPERM), symbol]
                   | "#EPIPE" [klabel(#EPIPE), symbol]
                   | "#ERANGE" [klabel(#ERANGE), symbol]
                   | "#EROFS" [klabel(#EROFS), symbol]
                   | "#ESPIPE" [klabel(#ESPIPE), symbol]
                   | "#ESRCH" [klabel(#ESRCH), symbol]
                   | "#EXDEV" [klabel(#EXDEV), symbol]
                   | "#EWOULDBLOCK" [klabel(#EWOULDBLOCK), symbol]
                   | "#EINPROGRESS" [klabel(#EINPROGRESS), symbol]
                   | "#EALREADY" [klabel(#EALREADY), symbol]
                   | "#ENOTSOCK" [klabel(#ENOTSOCK), symbol]
                   | "#EDESTADDRREQ" [klabel(#EDESTADDRREQ), symbol]
                   | "#EMSGSIZE" [klabel(#EMSGSIZE), symbol]
                   | "#EPROTOTYPE" [klabel(#EPROTOTYPE), symbol]
                   | "#ENOPROTOOPT" [klabel(#ENOPROTOOPT), symbol]
                   | "#EPROTONOSUPPORT" [klabel(#EPROTONOSUPPORT), symbol]
                   | "#ESOCKTNOSUPPORT" [klabel(#ESOCKTNOSUPPORT), symbol]
                   | "#EOPNOTSUPP" [klabel(#EOPNOTSUPP), symbol]
                   | "#EPFNOSUPPORT" [klabel(#EPFNOSUPPORT), symbol]
                   | "#EAFNOSUPPORT" [klabel(#EAFNOSUPPORT), symbol]
                   | "#EADDRINUSE" [klabel(#EADDRINUSE), symbol]
                   | "#EADDRNOTAVAIL" [klabel(#EADDRNOTAVAIL), symbol]
                   | "#ENETDOWN" [klabel(#ENETDOWN), symbol]
                   | "#ENETUNREACH" [klabel(#ENETUNREACH), symbol]
                   | "#ENETRESET" [klabel(#ENETRESET), symbol]
                   | "#ECONNABORTED" [klabel(#ECONNABORTED), symbol]
                   | "#ECONNRESET" [klabel(#ECONNRESET), symbol]
                   | "#ENOBUFS" [klabel(#ENOBUFS), symbol]
                   | "#EISCONN" [klabel(#EISCONN), symbol]
                   | "#ENOTCONN" [klabel(#ENOTCONN), symbol]
                   | "#ESHUTDOWN" [klabel(#ESHUTDOWN), symbol]
                   | "#ETOOMANYREFS" [klabel(#ETOOMANYREFS), symbol]
                   | "#ETIMEDOUT" [klabel(#ETIMEDOUT), symbol]
                   | "#ECONNREFUSED" [klabel(#ECONNREFUSED), symbol]
                   | "#EHOSTDOWN" [klabel(#EHOSTDOWN), symbol]
                   | "#EHOSTUNREACH" [klabel(#EHOSTUNREACH), symbol]
                   | "#ELOOP" [klabel(#ELOOP), symbol]
                   | "#EOVERFLOW" [klabel(#EOVERFLOW), symbol]

  syntax IOInt ::= Int | IOError
  syntax IOString ::= String | IOError

  syntax IOInt ::= "#open" "(" path: String ")" [function]
               | "#open" "(" path: String "," mode: String ")" [function, hook(IO.open), impure]

  rule #open(S:String) => #open(S:String, "r+")

  syntax IOInt ::= "#tell" "(" fd: Int ")" [function, hook(IO.tell), impure]
  syntax K ::= "#seek" "(" fd: Int "," index: Int ")" [function, hook(IO.seek), impure]
             | "#seekEnd" "(" fd: Int "," fromEnd: Int ")" [function, hook(IO.seekEnd), impure]

  syntax IOInt ::= "#getc" "(" fd: Int ")"             [function, hook(IO.getc), impure]
  syntax IOString ::= "#read" "(" fd: Int "," length: Int ")"    [function, hook(IO.read), impure]

  syntax K ::= "#putc" "(" fd: Int "," value: Int ")"      [function, hook(IO.putc), impure]
             | "#write" "(" fd: Int "," value: String ")" [function, hook(IO.write), impure]

  syntax K ::= "#close" "(" fd: Int ")" [function, hook(IO.close), impure]

  syntax K ::= "#lock" "(" fd: Int "," endIndex: Int ")" [function, hook(IO.lock), impure]
             | "#unlock" "(" fd: Int "," endIndex: Int ")" [function, hook(IO.unlock), impure]

  syntax IOInt ::= "#accept" "(" fd: Int ")" [function, hook(IO.accept), impure]
  syntax K ::= "#shutdownWrite" "(" fd: Int ")" [function, hook(IO.shutdownWrite), impure]

  syntax Int ::= "#time" "(" ")" [function, hook(IO.time), impure]
  syntax Int ::= "#stdin"   [function, total]
                | "#stdout" [function, total]
                | "#stderr" [function, total]

  rule #stdin => 0
  rule #stdout => 1
  rule #stderr => 2

  syntax KItem ::= #system ( String ) [function, hook(IO.system), impure]
                 | "#systemResult" "(" Int /* exit code */ "," String /* stdout */ "," String /* stderr */ ")" [klabel(#systemResult), symbol]

  syntax IOFile ::= #mkstemp(template: String) [function, hook(IO.mkstemp), impure]
  syntax IOFile ::= IOError
                  | "#tempFile" "(" path: String "," fd: Int ")" [klabel(#tempFile), symbol]

  syntax K ::= #remove(path: String) [function, total, hook(IO.remove), impure]

  syntax K ::= #logToFile(name: String, value: String) [function, total, hook(IO.log), impure, returnsUnit, symbol]
  syntax K ::= #log(value: String) [function, total, hook(IO.logString), impure, returnsUnit, symbol]

  syntax K ::= #trace(value: KItem) [function, total, hook(IO.traceTerm), impure, returnsUnit, symbol]
             | #traceK(value: K)    [function, total, hook(IO.traceTerm), impure, returnsUnit, symbol]

  syntax Stream ::= #buffer(K)
                  | #istream(Int)
                  | #parseInput(String, String)
                  | #ostream(Int)

endmodule

// NOTE: DO NOT DIRECTLY IMPORT *-STREAM MODULES
// These stream modules will be automatically instantiated and implicitly imported
// into the main module when `stream` attributes appear in configuration cells.
// Only `Stream` productions and `[stream]` rules will be imported.
// The cell name will be replaced with the one of the main configuration.

module STDIN-STREAM
  imports K-IO
  imports K-REFLECTION
  imports LIST
  imports INT
  imports BOOL

  configuration <stdin> ListItem(#buffer($STDIN:String)) ListItem($IO:String) ListItem(#istream(#stdin)) </stdin>

  // read one character at a time until we read whitespace
  rule [stdinGetc]:
       <stdin>
       ListItem(#parseInput(_:String, Delimiters:String))
       ListItem(#buffer(S:String => S +String chrChar({#getc(N)}:>Int)))
       ListItem("on")
       ListItem(#istream(N:Int))
       </stdin>
    requires findChar(S, Delimiters, 0) ==Int -1 // [stdin]
       [stream, priority(200)]

  // when we reach whitespace, if it parses create a ListItem
  rule [stdinParseString]:
       <stdin>
       (ListItem(#parseInput("String", Delimiters:String)) => ListItem(S))
       ListItem(#buffer(S:String => ""))
       _:List
       </stdin>
    requires findChar(S, Delimiters, 0) =/=Int -1 // [stdin]
       [stream]

  // a hack: handle the case when we read integers without the help of the IO server
  rule [stdinParseInt]:
       <stdin>
       (ListItem(#parseInput("Int", Delimiters:String))
       => ListItem(String2Int(substrString(S, 0, findChar(S, Delimiters, 0)))))
       ListItem(#buffer(S:String => substrString(S,findChar(S, Delimiters, 0) +Int 1, lengthString(S))))
       _:List
       </stdin>
    requires findChar(S, Delimiters, 0) =/=Int -1
       andBool lengthString(S) >Int 1 // [stdin]
       [stream]

  rule [stdinTrim]:
       <stdin>
       ListItem(#parseInput(Sort:String, Delimiters:String))
       ListItem(#buffer(S:String => substrString(S, 1, lengthString(S))))
       _:List
       </stdin>
    requires findChar(S, Delimiters, 0) =/=Int -1
       andBool Sort =/=String "String"
       andBool lengthString(S) <=Int 1 // [stdin]
       [stream]

  // NOTE: This unblocking rule will be instantiated and inserted carefully
  // when necessary according to user-defined rules, since otherwise it will
  // lead to a diverging (i.e., non-terminating) transition system definition.
  // Currently, it supports only a simple pattern matching on the top of the
  // input stream cell, e.g.,
  //   rule <k> read() => V ... </k> <in> ListItem(V:Int) => .List ...  </in>
  // Non-supported rules that refer to the input stream cell in a sophisticated
  // way will get stuck in concrete execution mode with real IO enabled (i.e.,
  // under `--io on` option), while they will still work in symbolic execution
  // mode or concrete execution mode with real IO disabled (i.e., under `--io
  // off`, `--search`, or `--debug` options).
  //
  // TODO: More patterns need to be supported as well. In that case, we need to
  // have a way to specify such patterns.
  rule [stdinUnblock]:
       <stdin>
         (.List => ListItem(#parseInput(?Sort:String, ?Delimiters:String)))
         ListItem(#buffer(_:String))
         ...
       </stdin>
       [unblock]

  /*
  syntax Stream ::= "#noIO"

  rule ListItem(#buffer(_))
       (ListItem(#noIO) ListItem(#istream(_:Int)) => .List) [stdin]
  */

endmodule


module STDOUT-STREAM
  imports K-IO
  imports LIST
  imports STRING

  configuration <stdout> ListItem(#ostream(#stdout)) ListItem($IO:String) ListItem(#buffer("")) </stdout>
//configuration <stderr> ListItem(#ostream(#stderr)) ListItem($IO:String) ListItem(#buffer("")) </stderr>

  rule [stdoutBufferFloat]:
       <stdout>
       ListItem(#ostream(_))
       ListItem(_)
       ListItem(#buffer(Buffer:String => Buffer +String Float2String(F)))
       (ListItem(F:Float) => .List)
       _:List
       </stdout>
       // [stdout, stderr]
       [stream, priority(25)]
  rule [stdoutBufferInt]:
       <stdout>
       ListItem(#ostream(_))
       ListItem(_)
       ListItem(#buffer(Buffer:String => Buffer +String Int2String(I)))
       (ListItem(I:Int) => .List)
       _:List
       </stdout>
       // [stdout, stderr]
       [stream, priority(25)]
  rule [stdoutBufferString]:
       <stdout>
       ListItem(#ostream(_))
       ListItem(_)
       ListItem(#buffer(Buffer:String => Buffer +String S))
       (ListItem(S:String) => .List)
       _:List
       </stdout>
       // [stdout, stderr]
       [stream, priority(25)]

  // Send first char from the buffer to the server
  rule [stdoutWrite]:
       <stdout>
       ListItem(#ostream(N:Int => {#write(N, S) ~> N:Int}:>Int))
       ListItem("on")
       ListItem(#buffer(S:String => ""))
       _:List
       </stdout>
    requires S =/=String "" // [stdout, stderr]
       [stream, priority(30)]

  /*
  syntax Stream ::= "#noIO"

  rule ListItem(#buffer(Buffer:String => Buffer +String Float2String(F)))
       (ListItem(F:Float) => .List)
       _:List [stdout, stderr]
  rule ListItem(#buffer(Buffer:String => Buffer +String Int2String(I)))
       (ListItem(I:Int) => .List)
       _:List [stdout, stderr]
  rule ListItem(#buffer(Buffer:String => Buffer +String S))
       (ListItem(S:String) => .List)
       _:List [stdout, stderr]

  rule (ListItem(#ostream(_:Int)) ListItem(#noIO) => .List)
       ListItem(#buffer(_))
       _:List [stdout, stderr]
  */

endmodule
===
KW_MODULE
1,1
module

MODNAME
1,8
K-IO

KW_IMPORTS
2,3
imports

KW_PRIVATE
2,11
private

MODNAME
2,19
LIST

KW_IMPORTS
3,3
imports

KW_PRIVATE
3,11
private

MODNAME
3,19
STRING

KW_IMPORTS
4,3
imports

KW_PRIVATE
4,11
private

MODNAME
4,19
INT

KW_SYNTAX
6,3
syntax

ID_UPPER
6,10
IOError

DCOLONEQ
6,18
::=

STRING
6,22
"#EOF"

LBRACK
6,29
[

ATTR_KEY
6,30
klabel

LPAREN
6,36
(

ATTR_CONTENT
6,37
#EOF

RPAREN
6,41
)

COMMA
6,42
,

ATTR_KEY
6,44
symbol

RBRACK
6,50
]

VBAR
6,52
|

ID_LOWER
6,54
#unknownIOError

LPAREN
6,69
(

ID_LOWER
6,70
errno

COLON
6,75
:

ID_UPPER
6,77
Int

RPAREN
6,80
)

LBRACK
6,82
[

ATTR_KEY
6,83
symbol

RBRACK
6,89
]

VBAR
7,20
|

STRING
7,22
"#E2BIG"

LBRACK
7,31
[

ATTR_KEY
7,32
klabel

LPAREN
7,38
(

ATTR_CONTENT
7,39
#E2BIG

RPAREN
7,45
)

COMMA
7,46
,

ATTR_KEY
7,48
symbol

RBRACK
7,54
]

VBAR
8,20
|

STRING
8,22
"#EACCES"

LBRACK
8,32
[

ATTR_KEY
8,33
klabel

LPAREN
8,39
(

ATTR_CONTENT
8,40
#EACCES

RPAREN
8,47
)

COMMA
8,48
,

ATTR_KEY
8,50
symbol

RBRACK
8,56
]

VBAR
9,20
|

STRING
9,22
"#EAGAIN"

LBRACK
9,32
[

ATTR_KEY
9,33
klabel

LPAREN
9,39
(

ATTR_CONTENT
9,40
#EAGAIN

RPAREN
9,47
)

COMMA
9,48
,

ATTR_KEY
9,50
symbol

RBRACK
9,56
]

VBAR
10,20
|

STRING
10,22
"#EBADF"

LBRACK
10,31
[

ATTR_KEY
10,32
klabel

LPAREN
10,38
(

ATTR_CONTENT
10,39
#EBADF

RPAREN
10,45
)

COMMA
10,46
,

ATTR_KEY
10,48
symbol

RBRACK
10,54
]

VBAR
11,20
|

STRING
11,22
"#EBUSY"

LBRACK
11,31
[

ATTR_KEY
11,32
klabel

LPAREN
11,38
(

ATTR_CONTENT
11,39
#EBUSY

RPAREN
11,45
)

COMMA
11,46
,

ATTR_KEY
11,48
symbol

RBRACK
11,54
]

VBAR
12,20
|

STRING
12,22
"#ECHILD"

LBRACK
12,32
[

ATTR_KEY
12,33
klabel

LPAREN
12,39
(

ATTR_CONTENT
12,40
#ECHILD

RPAREN
12,47
)

COMMA
12,48
,

ATTR_KEY
12,50
symbol

RBRACK
12,56
]

VBAR
13,20
|

STRING
13,22
"#EDEADLK"

LBRACK
13,33
[

ATTR_KEY
13,34
klabel

LPAREN
13,40
(

ATTR_CONTENT
13,41
#EDEADLK

RPAREN
13,49
)

COMMA
13,50
,

ATTR_KEY
13,52
symbol

RBRACK
13,58
]

VBAR
14,20
|

STRING
14,22
"#EDOM"

LBRACK
14,30
[

ATTR_KEY
14,31
klabel

LPAREN
14,37
(

ATTR_CONTENT
14,38
#EDOM

RPAREN
14,43
)

COMMA
14,44
,

ATTR_KEY
14,46
symbol

RBRACK
14,52
]

VBAR
15,20
|

STRING
15,22
"#EEXIST"

LBRACK
15,32
[

ATTR_KEY
15,33
klabel

LPAREN
15,39
(

ATTR_CONTENT
15,40
#EEXIST

RPAREN
15,47
)

COMMA
15,48
,

ATTR_KEY
15,50
symbol

RBRACK
15,56
]

VBAR
16,20
|

STRING
16,22
"#EFAULT"

LBRACK
16,32
[

ATTR_KEY
16,33
klabel

LPAREN
16,39
(

ATTR_CONTENT
16,40
#EFAULT

RPAREN
16,47
)

COMMA
16,48
,

ATTR_KEY
16,50
symbol

RBRACK
16,56
]

VBAR
17,20
|

STRING
17,22
"#EFBIG"

LBRACK
17,31
[

ATTR_KEY
17,32
klabel

LPAREN
17,38
(

ATTR_CONTENT
17,39
#EFBIG

RPAREN
17,45
)

COMMA
17,46
,

ATTR_KEY
17,48
symbol

RBRACK
17,54
]

VBAR
18,20
|

STRING
18,22
"#EINTR"

LBRACK
18,31
[

ATTR_KEY
18,32
klabel

LPAREN
18,38
(

ATTR_CONTENT
18,39
#EINTR

RPAREN
18,45
)

COMMA
18,46
,

ATTR_KEY
18,48
symbol

RBRACK
18,54
]

VBAR
19,20
|

STRING
19,22
"#EINVAL"

LBRACK
19,32
[

ATTR_KEY
19,33
klabel

LPAREN
19,39
(

ATTR_CONTENT
19,40
#EINVAL

RPAREN
19,47
)

COMMA
19,48
,

ATTR_KEY
19,50
symbol

RBRACK
19,56
]

VBAR
20,20
|

STRING
20,22
"#EIO"

LBRACK
20,29
[

ATTR_KEY
20,30
klabel

LPAREN
20,36
(

ATTR_CONTENT
20,37
#EIO

RPAREN
20,41
)

COMMA
20,42
,

ATTR_KEY
20,44
symbol

RBRACK
20,50
]

VBAR
21,20
|

STRING
21,22
"#EISDIR"

LBRACK
21,32
[

ATTR_KEY
21,33
klabel

LPAREN
21,39
(

ATTR_CONTENT
21,40
#EISDIR

RPAREN
21,47
)

COMMA
21,48
,

ATTR_KEY
21,50
symbol

RBRACK
21,56
]

VBAR
22,20
|

STRING
22,22
"#EMFILE"

LBRACK
22,32
[

ATTR_KEY
22,33
klabel

LPAREN
22,39
(

ATTR_CONTENT
22,40
#EMFILE

RPAREN
22,47
)

COMMA
22,48
,

ATTR_KEY
22,50
symbol

RBRACK
22,56
]

VBAR
23,20
|

STRING
23,22
"#EMLINK"

LBRACK
23,32
[

ATTR_KEY
23,33
klabel

LPAREN
23,39
(

ATTR_CONTENT
23,40
#EMLINK

RPAREN
23,47
)

COMMA
23,48
,

ATTR_KEY
23,50
symbol

RBRACK
23,56
]

VBAR
24,20
|

STRING
24,22
"#ENAMETOOLONG"

LBRACK
24,38
[

ATTR_KEY
24,39
klabel

LPAREN
24,45
(

ATTR_CONTENT
24,46
#ENAMETOOLONG

RPAREN
24,59
)

COMMA
24,60
,

ATTR_KEY
24,62
symbol

RBRACK
24,68
]

VBAR
25,20
|

STRING
25,22
"#ENFILE"

LBRACK
25,32
[

ATTR_KEY
25,33
klabel

LPAREN
25,39
(

ATTR_CONTENT
25,40
#ENFILE

RPAREN
25,47
)

COMMA
25,48
,

ATTR_KEY
25,50
symbol

RBRACK
25,56
]

VBAR
26,20
|

STRING
26,22
"#ENODEV"

LBRACK
26,32
[

ATTR_KEY
26,33
klabel

LPAREN
26,39
(

ATTR_CONTENT
26,40
#ENODEV

RPAREN
26,47
)

COMMA
26,48
,

ATTR_KEY
26,50
symbol

RBRACK
26,56
]

VBAR
27,20
|

STRING
27,22
"#ENOENT"

LBRACK
27,32
[

ATTR_KEY
27,33
klabel

LPAREN
27,39
(

ATTR_CONTENT
27,40
#ENOENT

RPAREN
27,47
)

COMMA
27,48
,

ATTR_KEY
27,50
symbol

RBRACK
27,56
]

VBAR
28,20
|

STRING
28,22
"#ENOEXEC"

LBRACK
28,33
[

ATTR_KEY
28,34
klabel

LPAREN
28,40
(

ATTR_CONTENT
28,41
#ENOEXEC

RPAREN
28,49
)

COMMA
28,50
,

ATTR_KEY
28,52
symbol

RBRACK
28,58
]

VBAR
29,20
|

STRING
29,22
"#ENOLCK"

LBRACK
29,32
[

ATTR_KEY
29,33
klabel

LPAREN
29,39
(

ATTR_CONTENT
29,40
#ENOLCK

RPAREN
29,47
)

COMMA
29,48
,

ATTR_KEY
29,50
symbol

RBRACK
29,56
]

VBAR
30,20
|

STRING
30,22
"#ENOMEM"

LBRACK
30,32
[

ATTR_KEY
30,33
klabel

LPAREN
30,39
(

ATTR_CONTENT
30,40
#ENOMEM

RPAREN
30,47
)

COMMA
30,48
,

ATTR_KEY
30,50
symbol

RBRACK
30,56
]

VBAR
31,20
|

STRING
31,22
"#ENOSPC"

LBRACK
31,32
[

ATTR_KEY
31,33
klabel

LPAREN
31,39
(

ATTR_CONTENT
31,40
#ENOSPC

RPAREN
31,47
)

COMMA
31,48
,

ATTR_KEY
31,50
symbol

RBRACK
31,56
]

VBAR
32,20
|

STRING
32,22
"#ENOSYS"

LBRACK
32,32
[

ATTR_KEY
32,33
klabel

LPAREN
32,39
(

ATTR_CONTENT
32,40
#ENOSYS

RPAREN
32,47
)

COMMA
32,48
,

ATTR_KEY
32,50
symbol

RBRACK
32,56
]

VBAR
33,20
|

STRING
33,22
"#ENOTDIR"

LBRACK
33,33
[

ATTR_KEY
33,34
klabel

LPAREN
33,40
(

ATTR_CONTENT
33,41
#ENOTDIR

RPAREN
33,49
)

COMMA
33,50
,

ATTR_KEY
33,52
symbol

RBRACK
33,58
]

VBAR
34,20
|

STRING
34,22
"#ENOTEMPTY"

LBRACK
34,35
[

ATTR_KEY
34,36
klabel

LPAREN
34,42
(

ATTR_CONTENT
34,43
#ENOTEMPTY

RPAREN
34,53
)

COMMA
34,54
,

ATTR_KEY
34,56
symbol

RBRACK
34,62
]

VBAR
35,20
|

STRING
35,22
"#ENOTTY"

LBRACK
35,32
[

ATTR_KEY
35,33
klabel

LPAREN
35,39
(

ATTR_CONTENT
35,40
#ENOTTY

RPAREN
35,47
)

COMMA
35,48
,

ATTR_KEY
35,50
symbol

RBRACK
35,56
]

VBAR
36,20
|

STRING
36,22
"#ENXIO"

LBRACK
36,31
[

ATTR_KEY
36,32
klabel

LPAREN
36,38
(

ATTR_CONTENT
36,39
#ENXIO

RPAREN
36,45
)

COMMA
36,46
,

ATTR_KEY
36,48
symbol

RBRACK
36,54
]

VBAR
37,20
|

STRING
37,22
"#EPERM"

LBRACK
37,31
[

ATTR_KEY
37,32
klabel

LPAREN
37,38
(

ATTR_CONTENT
37,39
#EPERM

RPAREN
37,45
)

COMMA
37,46
,

ATTR_KEY
37,48
symbol

RBRACK
37,54
]

VBAR
38,20
|

STRING
38,22
"#EPIPE"

LBRACK
38,31
[

ATTR_KEY
38,32
klabel

LPAREN
38,38
(

ATTR_CONTENT
38,39
#EPIPE

RPAREN
38,45
)

COMMA
38,46
,

ATTR_KEY
38,48
symbol

RBRACK
38,54
]

VBAR
39,20
|

STRING
39,22
"#ERANGE"

LBRACK
39,32
[

ATTR_KEY
39,33
klabel

LPAREN
39,39
(

ATTR_CONTENT
39,40
#ERANGE

RPAREN
39,47
)

COMMA
39,48
,

ATTR_KEY
39,50
symbol

RBRACK
39,56
]

VBAR
40,20
|

STRING
40,22
"#EROFS"

LBRACK
40,31
[

ATTR_KEY
40,32
klabel

LPAREN
40,38
(

ATTR_CONTENT
40,39
#EROFS

RPAREN
40,45
)

COMMA
40,46
,

ATTR_KEY
40,48
symbol

RBRACK
40,54
]

VBAR
41,20
|

STRING
41,22
"#ESPIPE"

LBRACK
41,32
[

ATTR_KEY
41,33
klabel

LPAREN
41,39
(

ATTR_CONTENT
41,40
#ESPIPE

RPAREN
41,47
)

COMMA
41,48
,

ATTR_KEY
41,50
symbol

RBRACK
41,56
]

VBAR
42,20
|

STRING
42,22
"#ESRCH"

LBRACK
42,31
[

ATTR_KEY
42,32
klabel

LPAREN
42,38
(

ATTR_CONTENT
42,39
#ESRCH

RPAREN
42,45
)

COMMA
42,46
,

ATTR_KEY
42,48
symbol

RBRACK
42,54
]

VBAR
43,20
|

STRING
43,22
"#EXDEV"

LBRACK
43,31
[

ATTR_KEY
43,32
klabel

LPAREN
43,38
(

ATTR_CONTENT
43,39
#EXDEV

RPAREN
43,45
)

COMMA
43,46
,

ATTR_KEY
43,48
symbol

RBRACK
43,54
]

VBAR
44,20
|

STRING
44,22
"#EWOULDBLOCK"

LBRACK
44,37
[

ATTR_KEY
44,38
klabel

LPAREN
44,44
(

ATTR_CONTENT
44,45
#EWOULDBLOCK

RPAREN
44,57
)

COMMA
44,58
,

ATTR_KEY
44,60
symbol

RBRACK
44,66
]

VBAR
45,20
|

STRING
45,22
"#EINPROGRESS"

LBRACK
45,37
[

ATTR_KEY
45,38
klabel

LPAREN
45,44
(

ATTR_CONTENT
45,45
#EINPROGRESS

RPAREN
45,57
)

COMMA
45,58
,

ATTR_KEY
45,60
symbol

RBRACK
45,66
]

VBAR
46,20
|

STRING
46,22
"#EALREADY"

LBRACK
46,34
[

ATTR_KEY
46,35
klabel

LPAREN
46,41
(

ATTR_CONTENT
46,42
#EALREADY

RPAREN
46,51
)

COMMA
46,52
,

ATTR_KEY
46,54
symbol

RBRACK
46,60
]

VBAR
47,20
|

STRING
47,22
"#ENOTSOCK"

LBRACK
47,34
[

ATTR_KEY
47,35
klabel

LPAREN
47,41
(

ATTR_CONTENT
47,42
#ENOTSOCK

RPAREN
47,51
)

COMMA
47,52
,

ATTR_KEY
47,54
symbol

RBRACK
47,60
]

VBAR
48,20
|

STRING
48,22
"#EDESTADDRREQ"

LBRACK
48,38
[

ATTR_KEY
48,39
klabel

LPAREN
48,45
(

ATTR_CONTENT
48,46
#EDESTADDRREQ

RPAREN
48,59
)

COMMA
48,60
,

ATTR_KEY
48,62
symbol

RBRACK
48,68
]

VBAR
49,20
|

STRING
49,22
"#EMSGSIZE"

LBRACK
49,34
[

ATTR_KEY
49,35
klabel

LPAREN
49,41
(

ATTR_CONTENT
49,42
#EMSGSIZE

RPAREN
49,51
)

COMMA
49,52
,

ATTR_KEY
49,54
symbol

RBRACK
49,60
]

VBAR
50,20
|

STRING
50,22
"#EPROTOTYPE"

LBRACK
50,36
[

ATTR_KEY
50,37
klabel

LPAREN
50,43
(

ATTR_CONTENT
50,44
#EPROTOTYPE

RPAREN
50,55
)

COMMA
50,56
,

ATTR_KEY
50,58
symbol

RBRACK
50,64
]

VBAR
51,20
|

STRING
51,22
"#ENOPROTOOPT"

LBRACK
51,37
[

ATTR_KEY
51,38
klabel

LPAREN
51,44
(

ATTR_CONTENT
51,45
#ENOPROTOOPT

RPAREN
51,57
)

COMMA
51,58
,

ATTR_KEY
51,60
symbol

RBRACK
51,66
]

VBAR
52,20
|

STRING
52,22
"#EPROTONOSUPPORT"

LBRACK
52,41
[

ATTR_KEY
52,42
klabel

LPAREN
52,48
(

ATTR_CONTENT
52,49
#EPROTONOSUPPORT

RPAREN
52,65
)

COMMA
52,66
,

ATTR_KEY
52,68
symbol

RBRACK
52,74
]

VBAR
53,20
|

STRING
53,22
"#ESOCKTNOSUPPORT"

LBRACK
53,41
[

ATTR_KEY
53,42
klabel

LPAREN
53,48
(

ATTR_CONTENT
53,49
#ESOCKTNOSUPPORT

RPAREN
53,65
)

COMMA
53,66
,

ATTR_KEY
53,68
symbol

RBRACK
53,74
]

VBAR
54,20
|

STRING
54,22
"#EOPNOTSUPP"

LBRACK
54,36
[

ATTR_KEY
54,37
klabel

LPAREN
54,43
(

ATTR_CONTENT
54,44
#EOPNOTSUPP

RPAREN
54,55
)

COMMA
54,56
,

ATTR_KEY
54,58
symbol

RBRACK
54,64
]

VBAR
55,20
|

STRING
55,22
"#EPFNOSUPPORT"

LBRACK
55,38
[

ATTR_KEY
55,39
klabel

LPAREN
55,45
(

ATTR_CONTENT
55,46
#EPFNOSUPPORT

RPAREN
55,59
)

COMMA
55,60
,

ATTR_KEY
55,62
symbol

RBRACK
55,68
]

VBAR
56,20
|

STRING
56,22
"#EAFNOSUPPORT"

LBRACK
56,38
[

ATTR_KEY
56,39
klabel

LPAREN
56,45
(

ATTR_CONTENT
56,46
#EAFNOSUPPORT

RPAREN
56,59
)

COMMA
56,60
,

ATTR_KEY
56,62
symbol

RBRACK
56,68
]

VBAR
57,20
|

STRING
57,22
"#EADDRINUSE"

LBRACK
57,36
[

ATTR_KEY
57,37
klabel

LPAREN
57,43
(

ATTR_CONTENT
57,44
#EADDRINUSE

RPAREN
57,55
)

COMMA
57,56
,

ATTR_KEY
57,58
symbol

RBRACK
57,64
]

VBAR
58,20
|

STRING
58,22
"#EADDRNOTAVAIL"

LBRACK
58,39
[

ATTR_KEY
58,40
klabel

LPAREN
58,46
(

ATTR_CONTENT
58,47
#EADDRNOTAVAIL

RPAREN
58,61
)

COMMA
58,62
,

ATTR_KEY
58,64
symbol

RBRACK
58,70
]

VBAR
59,20
|

STRING
59,22
"#ENETDOWN"

LBRACK
59,34
[

ATTR_KEY
59,35
klabel

LPAREN
59,41
(

ATTR_CONTENT
59,42
#ENETDOWN

RPAREN
59,51
)

COMMA
59,52
,

ATTR_KEY
59,54
symbol

RBRACK
59,60
]

VBAR
60,20
|

STRING
60,22
"#ENETUNREACH"

LBRACK
60,37
[

ATTR_KEY
60,38
klabel

LPAREN
60,44
(

ATTR_CONTENT
60,45
#ENETUNREACH

RPAREN
60,57
)

COMMA
60,58
,

ATTR_KEY
60,60
symbol

RBRACK
60,66
]

VBAR
61,20
|

STRING
61,22
"#ENETRESET"

LBRACK
61,35
[

ATTR_KEY
61,36
klabel

LPAREN
61,42
(

ATTR_CONTENT
61,43
#ENETRESET

RPAREN
61,53
)

COMMA
61,54
,

ATTR_KEY
61,56
symbol

RBRACK
61,62
]

VBAR
62,20
|

STRING
62,22
"#ECONNABORTED"

LBRACK
62,38
[

ATTR_KEY
62,39
klabel

LPAREN
62,45
(

ATTR_CONTENT
62,46
#ECONNABORTED

RPAREN
62,59
)

COMMA
62,60
,

ATTR_KEY
62,62
symbol

RBRACK
62,68
]

VBAR
63,20
|

STRING
63,22
"#ECONNRESET"

LBRACK
63,36
[

ATTR_KEY
63,37
klabel

LPAREN
63,43
(

ATTR_CONTENT
63,44
#ECONNRESET

RPAREN
63,55
)

COMMA
63,56
,

ATTR_KEY
63,58
symbol

RBRACK
63,64
]

VBAR
64,20
|

STRING
64,22
"#ENOBUFS"

LBRACK
64,33
[

ATTR_KEY
64,34
klabel

LPAREN
64,40
(

ATTR_CONTENT
64,41
#ENOBUFS

RPAREN
64,49
)

COMMA
64,50
,

ATTR_KEY
64,52
symbol

RBRACK
64,58
]

VBAR
65,20
|

STRING
65,22
"#EISCONN"

LBRACK
65,33
[

ATTR_KEY
65,34
klabel

LPAREN
65,40
(

ATTR_CONTENT
65,41
#EISCONN

RPAREN
65,49
)

COMMA
65,50
,

ATTR_KEY
65,52
symbol

RBRACK
65,58
]

VBAR
66,20
|

STRING
66,22
"#ENOTCONN"

LBRACK
66,34
[

ATTR_KEY
66,35
klabel

LPAREN
66,41
(

ATTR_CONTENT
66,42
#ENOTCONN

RPAREN
66,51
)

COMMA
66,52
,

ATTR_KEY
66,54
symbol

RBRACK
66,60
]

VBAR
67,20
|

STRING
67,22
"#ESHUTDOWN"

LBRACK
67,35
[

ATTR_KEY
67,36
klabel

LPAREN
67,42
(

ATTR_CONTENT
67,43
#ESHUTDOWN

RPAREN
67,53
)

COMMA
67,54
,

ATTR_KEY
67,56
symbol

RBRACK
67,62
]

VBAR
68,20
|

STRING
68,22
"#ETOOMANYREFS"

LBRACK
68,38
[

ATTR_KEY
68,39
klabel

LPAREN
68,45
(

ATTR_CONTENT
68,46
#ETOOMANYREFS

RPAREN
68,59
)

COMMA
68,60
,

ATTR_KEY
68,62
symbol

RBRACK
68,68
]

VBAR
69,20
|

STRING
69,22
"#ETIMEDOUT"

LBRACK
69,35
[

ATTR_KEY
69,36
klabel

LPAREN
69,42
(

ATTR_CONTENT
69,43
#ETIMEDOUT

RPAREN
69,53
)

COMMA
69,54
,

ATTR_KEY
69,56
symbol

RBRACK
69,62
]

VBAR
70,20
|

STRING
70,22
"#ECONNREFUSED"

LBRACK
70,38
[

ATTR_KEY
70,39
klabel

LPAREN
70,45
(

ATTR_CONTENT
70,46
#ECONNREFUSED

RPAREN
70,59
)

COMMA
70,60
,

ATTR_KEY
70,62
symbol

RBRACK
70,68
]

VBAR
71,20
|

STRING
71,22
"#EHOSTDOWN"

LBRACK
71,35
[

ATTR_KEY
71,36
klabel

LPAREN
71,42
(

ATTR_CONTENT
71,43
#EHOSTDOWN

RPAREN
71,53
)

COMMA
71,54
,

ATTR_KEY
71,56
symbol

RBRACK
71,62
]

VBAR
72,20
|

STRING
72,22
"#EHOSTUNREACH"

LBRACK
72,38
[

ATTR_KEY
72,39
klabel

LPAREN
72,45
(

ATTR_CONTENT
72,46
#EHOSTUNREACH

RPAREN
72,59
)

COMMA
72,60
,

ATTR_KEY
72,62
symbol

RBRACK
72,68
]

VBAR
73,20
|

STRING
73,22
"#ELOOP"

LBRACK
73,31
[

ATTR_KEY
73,32
klabel

LPAREN
73,38
(

ATTR_CONTENT
73,39
#ELOOP

RPAREN
73,45
)

COMMA
73,46
,

ATTR_KEY
73,48
symbol

RBRACK
73,54
]

VBAR
74,20
|

STRING
74,22
"#EOVERFLOW"

LBRACK
74,35
[

ATTR_KEY
74,36
klabel

LPAREN
74,42
(

ATTR_CONTENT
74,43
#EOVERFLOW

RPAREN
74,53
)

COMMA
74,54
,

ATTR_KEY
74,56
symbol

RBRACK
74,62
]

KW_SYNTAX
76,3
syntax

ID_UPPER
76,10
IOInt

DCOLONEQ
76,16
::=

ID_UPPER
76,20
Int

VBAR
76,24
|

ID_UPPER
76,26
IOError

KW_SYNTAX
77,3
syntax

ID_UPPER
77,10
IOString

DCOLONEQ
77,19
::=

ID_UPPER
77,23
String

VBAR
77,30
|

ID_UPPER
77,32
IOError

KW_SYNTAX
79,3
syntax

ID_UPPER
79,10
IOInt

DCOLONEQ
79,16
::=

STRING
79,20
"#open"

STRING
79,28
"("

ID_LOWER
79,32
path

COLON
79,36
:

ID_UPPER
79,38
String

STRING
79,45
")"

LBRACK
79,49
[

ATTR_KEY
79,50
function

RBRACK
79,58
]

VBAR
80,16
|

STRING
80,18
"#open"

STRING
80,26
"("

ID_LOWER
80,30
path

COLON
80,34
:

ID_UPPER
80,36
String

STRING
80,43
","

ID_LOWER
80,47
mode

COLON
80,51
:

ID_UPPER
80,53
String

STRING
80,60
")"

LBRACK
80,64
[

ATTR_KEY
80,65
function

COMMA
80,73
,

ATTR_KEY
80,75
hook

LPAREN
80,79
(

ATTR_CONTENT
80,80
IO.open

RPAREN
80,87
)

COMMA
80,88
,

ATTR_KEY
80,90
impure

RBRACK
80,96
]

KW_RULE
82,3
rule

BUBBLE
82,8
#open(S:String) => #open(S:String, "r+")

KW_SYNTAX
84,3
syntax

ID_UPPER
84,10
IOInt

DCOLONEQ
84,16
::=

STRING
84,20
"#tell"

STRING
84,28
"("

ID_LOWER
84,32
fd

COLON
84,34
:

ID_UPPER
84,36
Int

STRING
84,40
")"

LBRACK
84,44
[

ATTR_KEY
84,45
function

COMMA
84,53
,

ATTR_KEY
84,55
hook

LPAREN
84,59
(

ATTR_CONTENT
84,60
IO.tell

RPAREN
84,67
)

COMMA
84,68
,

ATTR_KEY
84,70
impure

RBRACK
84,76
]

KW_SYNTAX
85,3
syntax

ID_UPPER
85,10
K

DCOLONEQ
85,12
::=

STRING
85,16
"#seek"

STRING
85,24
"("

ID_LOWER
85,28
fd

COLON
85,30
:

ID_UPPER
85,32
Int

STRING
85,36
","

ID_LOWER
85,40
index

COLON
85,45
:

ID_UPPER
85,47
Int

STRING
85,51
")"

LBRACK
85,55
[

ATTR_KEY
85,56
function

COMMA
85,64
,

ATTR_KEY
85,66
hook

LPAREN
85,70
(

ATTR_CONTENT
85,71
IO.seek

RPAREN
85,78
)

COMMA
85,79
,

ATTR_KEY
85,81
impure

RBRACK
85,87
]

VBAR
86,14
|

STRING
86,16
"#seekEnd"

STRING
86,27
"("

ID_LOWER
86,31
fd

COLON
86,33
:

ID_UPPER
86,35
Int

STRING
86,39
","

ID_LOWER
86,43
fromEnd

COLON
86,50
:

ID_UPPER
86,52
Int

STRING
86,56
")"

LBRACK
86,60
[

ATTR_KEY
86,61
function

COMMA
86,69
,

ATTR_KEY
86,71
hook

LPAREN
86,75
(

ATTR_CONTENT
86,76
IO.seekEnd

RPAREN
86,86
)

COMMA
86,87
,

ATTR_KEY
86,89
impure

RBRACK
86,95
]

KW_SYNTAX
88,3
syntax

ID_UPPER
88,10
IOInt

DCOLONEQ
88,16
::=

STRING
88,20
"#getc"

STRING
88,28
"("

ID_LOWER
88,32
fd

COLON
88,34
:

ID_UPPER
88,36
Int

STRING
88,40
")"

LBRACK
88,56
[

ATTR_KEY
88,57
function

COMMA
88,65
,

ATTR_KEY
88,67
hook

LPAREN
88,71
(

ATTR_CONTENT
88,72
IO.getc

RPAREN
88,79
)

COMMA
88,80
,

ATTR_KEY
88,82
impure

RBRACK
88,88
]

KW_SYNTAX
89,3
syntax

ID_UPPER
89,10
IOString

DCOLONEQ
89,19
::=

STRING
89,23
"#read"

STRING
89,31
"("

ID_LOWER
89,35
fd

COLON
89,37
:

ID_UPPER
89,39
Int

STRING
89,43
","

ID_LOWER
89,47
length

COLON
89,53
:

ID_UPPER
89,55
Int

STRING
89,59
")"

LBRACK
89,66
[

ATTR_KEY
89,67
function

COMMA
89,75
,

ATTR_KEY
89,77
hook

LPAREN
89,81
(

ATTR_CONTENT
89,82
IO.read

RPAREN
89,89
)

COMMA
89,90
,

ATTR_KEY
89,92
impure

RBRACK
89,98
]

KW_SYNTAX
91,3
syntax

ID_UPPER
91,10
K

DCOLONEQ
91,12
::=

STRING
91,16
"#putc"

STRING
91,24
"("

ID_LOWER
91,28
fd

COLON
91,30
:

ID_UPPER
91,32
Int

STRING
91,36
","

ID_LOWER
91,40
value

COLON
91,45
:

ID_UPPER
91,47
Int

STRING
91,51
")"

LBRACK
91,60
[

ATTR_KEY
91,61
function

COMMA
91,69
,

ATTR_KEY
91,71
hook

LPAREN
91,75
(

ATTR_CONTENT
91,76
IO.putc

RPAREN
91,83
)

COMMA
91,84
,

ATTR_KEY
91,86
impure

RBRACK
91,92
]

VBAR
92,14
|

STRING
92,16
"#write"

STRING
92,25
"("

ID_LOWER
92,29
fd

COLON
92,31
:

ID_UPPER
92,33
Int

STRING
92,37
","

ID_LOWER
92,41
value

COLON
92,46
:

ID_UPPER
92,48
String

STRING
92,55
")"

LBRACK
92,59
[

ATTR_KEY
92,60
function

COMMA
92,68
,

ATTR_KEY
92,70
hook

LPAREN
92,74
(

ATTR_CONTENT
92,75
IO.write

RPAREN
92,83
)

COMMA
92,84
,

ATTR_KEY
92,86
impure

RBRACK
92,92
]

KW_SYNTAX
94,3
syntax

ID_UPPER
94,10
K

DCOLONEQ
94,12
::=

STRING
94,16
"#close"

STRING
94,25
"("

ID_LOWER
94,29
fd

COLON
94,31
:

ID_UPPER
94,33
Int

STRING
94,37
")"

LBRACK
94,41
[

ATTR_KEY
94,42
function

COMMA
94,50
,

ATTR_KEY
94,52
hook

LPAREN
94,56
(

ATTR_CONTENT
94,57
IO.close

RPAREN
94,65
)

COMMA
94,66
,

ATTR_KEY
94,68
impure

RBRACK
94,74
]

KW_SYNTAX
96,3
syntax

ID_UPPER
96,10
K

DCOLONEQ
96,12
::=

STRING
96,16
"#lock"

STRING
96,24
"("

ID_LOWER
96,28
fd

COLON
96,30
:

ID_UPPER
96,32
Int

STRING
96,36
","

ID_LOWER
96,40
endIndex

COLON
96,48
:

ID_UPPER
96,50
Int

STRING
96,54
")"

LBRACK
96,58
[

ATTR_KEY
96,59
function

COMMA
96,67
,

ATTR_KEY
96,69
hook

LPAREN
96,73
(

ATTR_CONTENT
96,74
IO.lock

RPAREN
96,81
)

COMMA
96,82
,

ATTR_KEY
96,84
impure

RBRACK
96,90
]

VBAR
97,14
|

STRING
97,16
"#unlock"

STRING
97,26
"("

ID_LOWER
97,30
fd

COLON
97,32
:

ID_UPPER
97,34
Int

STRING
97,38
","

ID_LOWER
97,42
endIndex

COLON
97,50
:

ID_UPPER
97,52
Int

STRING
97,56
")"

LBRACK
97,60
[

ATTR_KEY
97,61
function

COMMA
97,69
,

ATTR_KEY
97,71
hook

LPAREN
97,75
(

ATTR_CONTENT
97,76
IO.unlock

RPAREN
97,85
)

COMMA
97,86
,

ATTR_KEY
97,88
impure

RBRACK
97,94
]

KW_SYNTAX
99,3
syntax

ID_UPPER
99,10
IOInt

DCOLONEQ
99,16
::=

STRING
99,20
"#accept"

STRING
99,30
"("

ID_LOWER
99,34
fd

COLON
99,36
:

ID_UPPER
99,38
Int

STRING
99,42
")"

LBRACK
99,46
[

ATTR_KEY
99,47
function

COMMA
99,55
,

ATTR_KEY
99,57
hook

LPAREN
99,61
(

ATTR_CONTENT
99,62
IO.accept

RPAREN
99,71
)

COMMA
99,72
,

ATTR_KEY
99,74
impure

RBRACK
99,80
]

KW_SYNTAX
100,3
syntax

ID_UPPER
100,10
K

DCOLONEQ
100,12
::=

STRING
100,16
"#shutdownWrite"

STRING
100,33
"("

ID_LOWER
100,37
fd

COLON
100,39
:

ID_UPPER
100,41
Int

STRING
100,45
")"

LBRACK
100,49
[

ATTR_KEY
100,50
function

COMMA
100,58
,

ATTR_KEY
100,60
hook

LPAREN
100,64
(

ATTR_CONTENT
100,65
IO.shutdownWrite

RPAREN
100,81
)

COMMA
100,82
,

ATTR_KEY
100,84
impure

RBRACK
100,90
]

KW_SYNTAX
102,3
syntax

ID_UPPER
102,10
Int

DCOLONEQ
102,14
::=

STRING
102,18
"#time"

STRING
102,26
"("

STRING
102,30
")"

LBRACK
102,34
[

ATTR_KEY
102,35
function

COMMA
102,43
,

ATTR_KEY
102,45
hook

LPAREN
102,49
(

ATTR_CONTENT
102,50
IO.time

RPAREN
102,57
)

COMMA
102,58
,

ATTR_KEY
102,60
impure

RBRACK
102,66
]

KW_SYNTAX
103,3
syntax

ID_UPPER
103,10
Int

DCOLONEQ
103,14
::=

STRING
103,18
"#stdin"

LBRACK
103,29
[

ATTR_KEY
103,30
function

COMMA
103,38
,

ATTR_KEY
103,40
total

RBRACK
103,45
]

VBAR
104,17
|

STRING
104,19
"#stdout"

LBRACK
104,29
[

ATTR_KEY
104,30
function

COMMA
104,38
,

ATTR_KEY
104,40
total

RBRACK
104,45
]

VBAR
105,17
|

STRING
105,19
"#stderr"

LBRACK
105,29
[

ATTR_KEY
105,30
function

COMMA
105,38
,

ATTR_KEY
105,40
total

RBRACK
105,45
]

KW_RULE
107,3
rule

BUBBLE
107,8
#stdin => 0

KW_RULE
108,3
rule

BUBBLE
108,8
#stdout => 1

KW_RULE
109,3
rule

BUBBLE
109,8
#stderr => 2

KW_SYNTAX
111,3
syntax

ID_UPPER
111,10
KItem

DCOLONEQ
111,16
::=

ID_LOWER
111,20
#system

LPAREN
111,28
(

ID_UPPER
111,30
String

RPAREN
111,37
)

LBRACK
111,39
[

ATTR_KEY
111,40
function

COMMA
111,48
,

ATTR_KEY
111,50
hook

LPAREN
111,54
(

ATTR_CONTENT
111,55
IO.system

RPAREN
111,64
)

COMMA
111,65
,

ATTR_KEY
111,67
impure

RBRACK
111,73
]

VBAR
112,18
|

STRING
112,20
"#systemResult"

STRING
112,36
"("

ID_UPPER
112,40
Int

STRING
112,60
","

ID_UPPER
112,64
String

STRING
112,84
","

ID_UPPER
112,88
String

STRING
112,108
")"

LBRACK
112,112
[

ATTR_KEY
112,113
klabel

LPAREN
112,119
(

ATTR_CONTENT
112,120
#systemResult

RPAREN
112,133
)

COMMA
112,134
,

ATTR_KEY
112,136
symbol

RBRACK
112,142
]

KW_SYNTAX
114,3
syntax

ID_UPPER
114,10
IOFile

DCOLONEQ
114,17
::=

ID_LOWER
114,21
#mkstemp

LPAREN
114,29
(

ID_LOWER
114,30
template

COLON
114,38
:

ID_UPPER
114,40
String

RPAREN
114,46
)

LBRACK
114,48
[

ATTR_KEY
114,49
function

COMMA
114,57
,

ATTR_KEY
114,59
hook

LPAREN
114,63
(

ATTR_CONTENT
114,64
IO.mkstemp

RPAREN
114,74
)

COMMA
114,75
,

ATTR_KEY
114,77
impure

RBRACK
114,83
]

KW_SYNTAX
115,3
syntax

ID_UPPER
115,10
IOFile

DCOLONEQ
115,17
::=

ID_UPPER
115,21
IOError

VBAR
116,19
|

STRING
116,21
"#tempFile"

STRING
116,33
"("

ID_LOWER
116,37
path

COLON
116,41
:

ID_UPPER
116,43
String

STRING
116,50
","

ID_LOWER
116,54
fd

COLON
116,56
:

ID_UPPER
116,58
Int

STRING
116,62
")"

LBRACK
116,66
[

ATTR_KEY
116,67
klabel

LPAREN
116,73
(

ATTR_CONTENT
116,74
#tempFile

RPAREN
116,83
)

COMMA
116,84
,

ATTR_KEY
116,86
symbol

RBRACK
116,92
]

KW_SYNTAX
118,3
syntax

ID_UPPER
118,10
K

DCOLONEQ
118,12
::=

ID_LOWER
118,16
#remove

LPAREN
118,23
(

ID_LOWER
118,24
path

COLON
118,28
:

ID_UPPER
118,30
String

RPAREN
118,36
)

LBRACK
118,38
[

ATTR_KEY
118,39
function

COMMA
118,47
,

ATTR_KEY
118,49
total

COMMA
118,54
,

ATTR_KEY
118,56
hook

LPAREN
118,60
(

ATTR_CONTENT
118,61
IO.remove

RPAREN
118,70
)

COMMA
118,71
,

ATTR_KEY
118,73
impure

RBRACK
118,79
]

KW_SYNTAX
120,3
syntax

ID_UPPER
120,10
K

DCOLONEQ
120,12
::=

ID_LOWER
120,16
#logToFile

LPAREN
120,26
(

ID_LOWER
120,27
name

COLON
120,31
:

ID_UPPER
120,33
String

COMMA
120,39
,

ID_LOWER
120,41
value

COLON
120,46
:

ID_UPPER
120,48
String

RPAREN
120,54
)

LBRACK
120,56
[

ATTR_KEY
120,57
function

COMMA
120,65
,

ATTR_KEY
120,67
total

COMMA
120,72
,

ATTR_KEY
120,74
hook

LPAREN
120,78
(

ATTR_CONTENT
120,79
IO.log

RPAREN
120,85
)

COMMA
120,86
,

ATTR_KEY
120,88
impure

COMMA
120,94
,

ATTR_KEY
120,96
returnsUnit

COMMA
120,107
,

ATTR_KEY
120,109
symbol

RBRACK
120,115
]

KW_SYNTAX
121,3
syntax

ID_UPPER
121,10
K

DCOLONEQ
121,12
::=

ID_LOWER
121,16
#log

LPAREN
121,20
(

ID_LOWER
121,21
value

COLON
121,26
:

ID_UPPER
121,28
String

RPAREN
121,34
)

LBRACK
121,36
[

ATTR_KEY
121,37
function

COMMA
121,45
,

ATTR_KEY
121,47
total

COMMA
121,52
,

ATTR_KEY
121,54
hook

LPAREN
121,58
(

ATTR_CONTENT
121,59
IO.logString

RPAREN
121,71
)

COMMA
121,72
,

ATTR_KEY
121,74
impure

COMMA
121,80
,

ATTR_KEY
121,82
returnsUnit

COMMA
121,93
,

ATTR_KEY
121,95
symbol

RBRACK
121,101
]

KW_SYNTAX
123,3
syntax

ID_UPPER
123,10
K

DCOLONEQ
123,12
::=

ID_LOWER
123,16
#trace

LPAREN
123,22
(

ID_LOWER
123,23
value

COLON
123,28
:

ID_UPPER
123,30
KItem

RPAREN
123,35
)

LBRACK
123,37
[

ATTR_KEY
123,38
function

COMMA
123,46
,

ATTR_KEY
123,48
total

COMMA
123,53
,

ATTR_KEY
123,55
hook

LPAREN
123,59
(

ATTR_CONTENT
123,60
IO.traceTerm

RPAREN
123,72
)

COMMA
123,73
,

ATTR_KEY
123,75
impure

COMMA
123,81
,

ATTR_KEY
123,83
returnsUnit

COMMA
123,94
,

ATTR_KEY
123,96
symbol

RBRACK
123,102
]

VBAR
124,14
|

ID_LOWER
124,16
#traceK

LPAREN
124,23
(

ID_LOWER
124,24
value

COLON
124,29
:

ID_UPPER
124,31
K

RPAREN
124,32
)

LBRACK
124,37
[

ATTR_KEY
124,38
function

COMMA
124,46
,

ATTR_KEY
124,48
total

COMMA
124,53
,

ATTR_KEY
124,55
hook

LPAREN
124,59
(

ATTR_CONTENT
124,60
IO.traceTerm

RPAREN
124,72
)

COMMA
124,73
,

ATTR_KEY
124,75
impure

COMMA
124,81
,

ATTR_KEY
124,83
returnsUnit

COMMA
124,94
,

ATTR_KEY
124,96
symbol

RBRACK
124,102
]

KW_SYNTAX
126,3
syntax

ID_UPPER
126,10
Stream

DCOLONEQ
126,17
::=

ID_LOWER
126,21
#buffer

LPAREN
126,28
(

ID_UPPER
126,29
K

RPAREN
126,30
)

VBAR
127,19
|

ID_LOWER
127,21
#istream

LPAREN
127,29
(

ID_UPPER
127,30
Int

RPAREN
127,33
)

VBAR
128,19
|

ID_LOWER
128,21
#parseInput

LPAREN
128,32
(

ID_UPPER
128,33
String

COMMA
128,39
,

ID_UPPER
128,41
String

RPAREN
128,47
)

VBAR
129,19
|

ID_LOWER
129,21
#ostream

LPAREN
129,29
(

ID_UPPER
129,30
Int

RPAREN
129,33
)

KW_ENDMODULE
131,1
endmodule

KW_MODULE
139,1
module

MODNAME
139,8
STDIN-STREAM

KW_IMPORTS
140,3
imports

MODNAME
140,11
K-IO

KW_IMPORTS
141,3
imports

MODNAME
141,11
K-REFLECTION

KW_IMPORTS
142,3
imports

MODNAME
142,11
LIST

KW_IMPORTS
143,3
imports

MODNAME
143,11
INT

KW_IMPORTS
144,3
imports

MODNAME
144,11
BOOL

KW_CONFIG
146,3
configuration

BUBBLE
146,17
<stdin> ListItem(#buffer($STDIN:String)) ListItem($IO:String) ListItem(#istream(#stdin)) </stdin>

KW_RULE
149,3
rule

LBRACK
149,8
[

RULE_LABEL
149,9
stdinGetc

RBRACK
149,18
]

COLON
149,19
:

BUBBLE
150,8
<stdin>
       ListItem(#parseInput(_:String, Delimiters:String))
       ListItem(#buffer(S:String => S +String chrChar({#getc(N)}:>Int)))
       ListItem("on")
       ListItem(#istream(N:Int))
       </stdin>
    requires findChar(S, Delimiters, 0) ==Int -1 // [stdin]

LBRACK
157,8
[

ATTR_KEY
157,9
stream

COMMA
157,15
,

ATTR_KEY
157,17
priority

LPAREN
157,25
(

ATTR_CONTENT
157,26
200

RPAREN
157,29
)

RBRACK
157,30
]

KW_RULE
160,3
rule

LBRACK
160,8
[

RULE_LABEL
160,9
stdinParseString

RBRACK
160,25
]

COLON
160,26
:

BUBBLE
161,8
<stdin>
       (ListItem(#parseInput("String", Delimiters:String)) => ListItem(S))
       ListItem(#buffer(S:String => ""))
       _:List
       </stdin>
    requires findChar(S, Delimiters, 0) =/=Int -1 // [stdin]

LBRACK
167,8
[

ATTR_KEY
167,9
stream

RBRACK
167,15
]

KW_RULE
170,3
rule

LBRACK
170,8
[

RULE_LABEL
170,9
stdinParseInt

RBRACK
170,22
]

COLON
170,23
:

BUBBLE
171,8
<stdin>
       (ListItem(#parseInput("Int", Delimiters:String))
       => ListItem(String2Int(substrString(S, 0, findChar(S, Delimiters, 0)))))
       ListItem(#buffer(S:String => substrString(S,findChar(S, Delimiters, 0) +Int 1, lengthString(S))))
       _:List
       </stdin>
    requires findChar(S, Delimiters, 0) =/=Int -1
       andBool lengthString(S) >Int 1 // [stdin]

LBRACK
179,8
[

ATTR_KEY
179,9
stream

RBRACK
179,15
]

KW_RULE
181,3
rule

LBRACK
181,8
[

RULE_LABEL
181,9
stdinTrim

RBRACK
181,18
]

COLON
181,19
:

BUBBLE
182,8
<stdin>
       ListItem(#parseInput(Sort:String, Delimiters:String))
       ListItem(#buffer(S:String => substrString(S, 1, lengthString(S))))
       _:List
       </stdin>
    requires findChar(S, Delimiters, 0) =/=Int -1
       andBool Sort =/=String "String"
       andBool lengthString(S) <=Int 1 // [stdin]

LBRACK
190,8
[

ATTR_KEY
190,9
stream

RBRACK
190,15
]

KW_RULE
206,3
rule

LBRACK
206,8
[

RULE_LABEL
206,9
stdinUnblock

RBRACK
206,21
]

COLON
206,22
:

BUBBLE
207,8
<stdin>
         (.List => ListItem(#parseInput(?Sort:String, ?Delimiters:String)))
         ListItem(#buffer(_:String))
         ...
       </stdin>

LBRACK
212,8
[

ATTR_KEY
212,9
unblock

RBRACK
212,16
]

KW_ENDMODULE
221,1
endmodule

KW_MODULE
224,1
module

MODNAME
224,8
STDOUT-STREAM

KW_IMPORTS
225,3
imports

MODNAME
225,11
K-IO

KW_IMPORTS
226,3
imports

MODNAME
226,11
LIST

KW_IMPORTS
227,3
imports

MODNAME
227,11
STRING

KW_CONFIG
229,3
configuration

BUBBLE
229,17
<stdout> ListItem(#ostream(#stdout)) ListItem($IO:String) ListItem(#buffer("")) </stdout>

KW_RULE
232,3
rule

LBRACK
232,8
[

RULE_LABEL
232,9
stdoutBufferFloat

RBRACK
232,26
]

COLON
232,27
:

BUBBLE
233,8
<stdout>
       ListItem(#ostream(_))
       ListItem(_)
       ListItem(#buffer(Buffer:String => Buffer +String Float2String(F)))
       (ListItem(F:Float) => .List)
       _:List
       </stdout>
       // [stdout, stderr]

LBRACK
241,8
[

ATTR_KEY
241,9
stream

COMMA
241,15
,

ATTR_KEY
241,17
priority

LPAREN
241,25
(

ATTR_CONTENT
241,26
25

RPAREN
241,28
)

RBRACK
241,29
]

KW_RULE
242,3
rule

LBRACK
242,8
[

RULE_LABEL
242,9
stdoutBufferInt

RBRACK
242,24
]

COLON
242,25
:

BUBBLE
243,8
<stdout>
       ListItem(#ostream(_))
       ListItem(_)
       ListItem(#buffer(Buffer:String => Buffer +String Int2String(I)))
       (ListItem(I:Int) => .List)
       _:List
       </stdout>
       // [stdout, stderr]

LBRACK
251,8
[

ATTR_KEY
251,9
stream

COMMA
251,15
,

ATTR_KEY
251,17
priority

LPAREN
251,25
(

ATTR_CONTENT
251,26
25

RPAREN
251,28
)

RBRACK
251,29
]

KW_RULE
252,3
rule

LBRACK
252,8
[

RULE_LABEL
252,9
stdoutBufferString

RBRACK
252,27
]

COLON
252,28
:

BUBBLE
253,8
<stdout>
       ListItem(#ostream(_))
       ListItem(_)
       ListItem(#buffer(Buffer:String => Buffer +String S))
       (ListItem(S:String) => .List)
       _:List
       </stdout>
       // [stdout, stderr]

LBRACK
261,8
[

ATTR_KEY
261,9
stream

COMMA
261,15
,

ATTR_KEY
261,17
priority

LPAREN
261,25
(

ATTR_CONTENT
261,26
25

RPAREN
261,28
)

RBRACK
261,29
]

KW_RULE
264,3
rule

LBRACK
264,8
[

RULE_LABEL
264,9
stdoutWrite

RBRACK
264,20
]

COLON
264,21
:

BUBBLE
265,8
<stdout>
       ListItem(#ostream(N:Int => {#write(N, S) ~> N:Int}:>Int))
       ListItem("on")
       ListItem(#buffer(S:String => ""))
       _:List
       </stdout>
    requires S =/=String "" // [stdout, stderr]

LBRACK
272,8
[

ATTR_KEY
272,9
stream

COMMA
272,15
,

ATTR_KEY
272,17
priority

LPAREN
272,25
(

ATTR_CONTENT
272,26
30

RPAREN
272,28
)

RBRACK
272,29
]

KW_ENDMODULE
292,1
endmodule

EOF
292,9

