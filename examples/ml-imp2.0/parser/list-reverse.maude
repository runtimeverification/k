mod P-LIST-REVERSE is including IMP-SYNTAX + LIST-HP .
  ops A : -> FreeSeq .
  ops ?x ?y ?p : -> ?Int .
  ops ?B ?C : -> ?Seq .
  ops ?rho ?H : -> ?MapItem .
  ops val free reverse p next nodeList malloc y main x : -> Id .
  op prog : -> TranslationUnit .
  eq prog = (translationUnit_(_~~>_(struct_`{_`};(nodeList,_`,`,`,_(__;(int,val),__;(_*(struct_(nodeList)),next))),_~~>_(__`(_`)___(int,reverse,__;(_*(struct_(nodeList)),x),/*@ pre < config > < env > x |-> ?x </ env > < heap > list(?x)(A) </ heap > < form > TrueFormula </ form > </ config > */,/*@ post < config > < env > ?rho </ env > < heap > list(?x)(rev(A)) </ heap > < form > returns ?x </ form > </ config > */,block_(_~~>_(__;(_*(struct_(nodeList)),p),_~~>_(__;(_*(struct_(nodeList)),y),_~~>_(_;(_=_(p,tv(int,0))),_~~>_(/*@ invariant < config > < env > p |-> ?p x |-> ?x y |-> ?y </ env >
                          < heap > list(?p)(?B) list(?x)(?C) </ heap >
                          < form > rev(A) === rev(?C) @ ?B </ form > </ config > */,_~~>_(while`(_`)_(_!=_(x,tv(int,0)),block_(_~~>_(_;(_=_(y,_->_(x,next))),_~~>_(_;(_=_(_->_(x,next),p)),_~~>_(_;(_=_(p,x)),_;(_=_(x,y))))))),return_(p)))))))),__`(_`)___(void,main,.List{KernelC},/*@ pre < config > < env > (.).Map </ env > < heap > (.).Map </ heap > < form > TrueFormula </ form > </ config > */,/*@ post < config > < env > ?rho </ env > < heap > ?H </ heap > < form > TrueFormula </ form > </ config > */,block_(_~~>_(__;(_*(struct_(nodeList)),x),_~~>_(_;(_=_(x,`(_`)_(_*(struct_(nodeList)),_`(_`)(malloc,sizeof_(struct_(nodeList)))))),_~~>_(_;(_`(_`)(free,x)),_~~>_(/*@ assume < config > < env > x |-> ?x </ env > < heap > list(?x)(A) </ heap > < form > TrueFormula </ form > </ config > */,_~~>_(_;(_=_(x,_`(_`)(reverse,x))),/*@ assert < config > < env > x |-> ?x </ env > < heap > list(?x)(rev(A)) </ heap > < form > TrueFormula </ form > </ config > */))))))))))) .
endm
