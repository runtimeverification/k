  configuration <T color="red">
                  <threads color="orange">
                    <thread multiplicity="*" color="yellow">
                      <k color="green"> (PGM:K ~> execute) </k>
                      <control color="cyan">
                        <fstack color="blue"> .List </fstack>
                        <xstack color="purple"> .List </xstack>
                      </control>
                      <env color="violet"> .Map </env>
                      <holds color="black"> .Map </holds>
                    </thread>
                  </threads>
                  //<br/>
                  <genv color="pink"> .Map </genv>
                  <store color="white"> .Map </store>
                  <busy color="cyan">.Set</busy>
                  <in color="magenta" stream="stdin"> .List </in>
                  <out color="brown" stream="stdout"> .List </out>
                  <nextLoc color="gray"> 0 </nextLoc>
                </T>



  rule <k> var X:#Id; => . ...</k>
       <env> Env:Map => Env[L:#Int/X] </env>
       <store>... . => L|->undefined ...</store>
       <nextLoc> L => L +Int 1 </nextLoc>

  rule <k> var X[N:#Int]; => . ...</k>
       <env> Env => Env[L/X] </env>
       <store>... . => L |-> arrayRef(L +Int 1, N)
                       (L +Int 1) .. (L +Int N) |-> undefined ...</store>
       <nextLoc> L => (L +Int 1) +Int N </nextLoc>


  context var X[HOLE];

  rule var X[N1,N2,Vs:Vals]; =>
       var X[N1];
       {
         var $1 = X;
         for $2 = 0 to N1 - 1 do   // stupid parser
         {
           var X[N2,Vs];            // stupid parser
           $1[$2] = X;
         }
       }  [structural]

  rule <k> function F:#Id(Xs:Ids) S:Stmt => . ...</k>
       <env> Env => Env[L/F] </env>
       <store>... . => L|->lambda(Xs,S) ...</store>
       <nextLoc> L => L +Int 1 </nextLoc>

  rule <k> execute => main(.Exps); </k>
       <env> Env </env> <genv> . => Env </genv>  [structural]

  rule <k> X => V:Val ...</k>
       <env>...X|->L...</env>
       <store>...L|->V...</store>  [transition]



  context ++(HOLE => lvalue(HOLE))
  rule <k> ++loc(L) => I:#Int +Int 1 ...</k>
       <store>... L |-> (I => I +Int 1) ...</store>  [transition]

  rule I1:#Int + I2:#Int => I1 +Int I2
  //rule Str1:#String + Str2:#String => Str1 +String Str2
  rule I1:#Int - I2:#Int => I1 -Int I2
  rule I1:#Int * I2 => I1 *Int I2
  rule I1:#Int / I2 => I1 /Int I2 when I2 =/=Bool 0
  rule I1:#Int % I2 => I1 %Int I2 when I2 =/=Bool 0
  rule - I:#Int => -Int I
  rule I1:#Int < I2 => I1 <Int I2
  rule I1:#Int <= I2 => I1 <=Int I2
  rule I1:#Int > I2 => I1 >Int I2
  rule I1:#Int >= I2 => I1 >=Int I2
  rule V1:Val == V2:Val => V1 ==Bool V2
  rule V1:Val != V2 => V1 =/=Bool V2
  rule B1:#Bool and B2:#Bool => B1 andBool B2
  rule B1:#Bool or B2 => B1 orBool B2
  rule not(B:#Bool) => notBool(B)


  rule V[N1,N2,Vs] => V[N1][N2,Vs]  [structural]
  rule arrayRef(L,_)[N] => lookup(L +Int N)  [structural]

  rule <k> lookup(L) => V ...</k> <store>...L|->V...</store>  [transition]

  rule sizeOf(arrayRef(_,N)) => N



  rule <k> lambda(Xs,S)(Vs:Vals) ~> K:K
        => bindto(Xs,Vs) ~> S ~> return; </k>
       <control> <fstack> . => (Env,K,C) ...</fstack> C:Bag </control>
       <env> Env => GEnv </env>
       <genv> GEnv:Map </genv>
  rule <k> return(V); ~> _ => V ~> K </k>
       <control> <fstack> (Env,K,C) => . ...</fstack> (_ => C) </control>
       <env> _ => Env </env>

  rule return; => return nothing;   [structural]



  rule <k> bindto((X,Xs => Xs),(V,Vs:Vals => Vs)) ...</k>
       <env> Env => Env[L/X] </env>
       <store>... . => L |-> V ...</store>
       <nextLoc> L => L +Int 1 </nextLoc>
  rule <k> bindto(.Ids,.Exps) => . ...</k>  [structural]

  rule <k> read() => I ...</k> <in> ListItem(I) => . ...</in>  [transition]


  context (HOLE => lvalue(HOLE)) = _
  rule <k> loc(L)=V => V ...</k>
       <store>... L|->(_=>V) ...</store> [transition]

  rule {} => . [structural]
  rule <k> {Ss:Stmts} => Ss~>env(Env) ...</k> <env> Env </env>  [structural]



  rule <k> env(Env) => . ...</k> <env> _ => Env </env>  [structural]


  rule (env(_) => .) ~> env(_)  [structural]


  rule S1:Stmt S2:Stmt => S1 ~> S2  [structural]

  rule V; => .

  rule if  true then S else _ => S
  rule if false then _ else S => S

  rule <k> while E:Exp do S
    => if E then {S while E do S} else {} ...</k>  [structural]

  rule <k> print(V,Vs => Vs); ...</k>
       <out>... . => ListItem(V) </out>  [transition]
  rule print(.Vals); => .                [structural]



  rule <k> (try S1 catch(X) S2 => S1 ~> popx) ~> K </k>
       <control> <xstack> . => (X,S2,K,Env,C) ...</xstack> C:Bag </control>
       <env> Env </env>
  rule <k> popx => . ...</k> <xstack> _:ListItem => . ...</xstack>
  rule <k> throw V; ~> _ => {var X=V; S2} ~> K </k>
       <control> <xstack> (X,S2,K,Env,C) => . ...</xstack> (_ => C) </control>
       <env> _ => Env </env>


   rule <thread>... <k> spawn S => . ...</k> <env> Env </env> ...</thread>
        (. => <thread>... <k> S </k> <env> Env </env> ...</thread>)

   rule (<thread>... <k>.K</k> <holds> H:Map </holds> ...</thread> => .)
        <busy> Busy:Set => Busy -Set keys(H) </busy>


   rule <k> acquire V; => . ...</k> <holds>... . => V|->0 ...</holds>
        <busy> Busy (. => SetItem(V)) </busy>
     when (notBool(V in Busy:Set)) [transition]
   rule <k> acquire V; => . ...</k> <holds>... V|->(N => N +Int 1) ...</holds>


   rule <k> release V; => . ...</k>
        <holds>... V|->(N => N:#Int -Int 1) ...</holds>
     when N >Int 0
   // used prefix notation for -Int because of parsing problems
   rule <k> release V; => . ...</k> <holds>... V|->0 => . ...</holds>
        <busy>... SetItem(V)=>. ...</busy>


   rule <k> rendezvous V; => . ...</k>
        <k> rendezvous V; => . ...</k>  [transition]

// For parsing reasons, we prefer to allow lvalue to take a K

// Local variable
  rule <k> lvalue(X) => loc(L:#Int) ...</k>
       <env>... X|->L ...</env>  [structural]
// Array element: evaluate the array and its index;
// then the array lookup rule above applies.
  context lvalue(_[HOLE])
  context lvalue(HOLE[_])
// Finally, return the address of the desired object member
  rule <k> lvalue(lookup(L)) => loc(L) ...</k>  [structural]




  rule N1:#Int..N2:#Int => .List{K}              when N1  >Int N2  [structural]
  rule N1:#Int..N2:#Int => N1 ,, (N1 +Int 1)..N2 when N1 <=Int N2  [structural]

