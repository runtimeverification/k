mod LIST-HP is
  inc ML-K
    + MATHEMATICAL-SEQUENCE-BUILTIN-MODULE .

  var N : Nat .
  var P P' P1 P2 Q Q' Q1 Q2 : Int++ .
  var I : Int++ .
  var Alpha Beta : Seq++ .
  var H : Map .
  var K : K .
  var Phi : Formula .
  var NtPhi : NtFormula .
  var Cfg : BagItem .
  var CfgItems Cfgs : Bag .

*** Definition of Lists ***
  op list : -> HeapLabel .
 ceq < tasks >
       < config >
         < k > derive(P') ~> K </ k >
         < heap > list(P)(Alpha) H </ heap >
         < form > Phi </ form >
         CfgItems
       </ config >
     Cfgs
     </ tasks >
     < counter > N </ counter >
   = < tasks >
       < config >
         < k > derive(P') ~> K </ k >
         < heap > H </ heap > 
         < form > (P === 0) /\ (Alpha === epsilon) /\ Phi </ form >
         CfgItems
       </ config >
       < config >
         < k > K </ k >
         < heap >
           P |-> FreeInt(N) : listNode . val
           (P +Int 1) |-> FreeInt(N +Int 1) : listNode . next
           list(FreeInt(N +Int 1))(FreeSeq(N +Int 2))
           H
         </ heap >
         < form >
           ~(P === 0) /\ (Alpha === [FreeInt(N)] @ FreeSeq(N +Int 2)) /\ Phi
         </ form >
         CfgItems
       </ config >
     Cfgs
     </ tasks >
     < counter > N +Int 3 </ counter >
  if VALID(Phi ===> P' === P \/ P' === P +Int 1) .
  eq < tasks >
       < config >
         < heap > list(P)(Alpha) H </ heap >
         < form > ~(P === 0) /\ Phi </ form >
         CfgItems
       </ config >
     Cfgs
     </ tasks >
     < counter > N </ counter >
   = < tasks >
       < config >
         < heap >
           P |-> FreeInt(N) : listNode . val
           (P +Int 1) |-> FreeInt(N +Int 1) : listNode . next
           list(FreeInt(N +Int 1))(FreeSeq(N +Int 2))
           H
         </ heap >
         < form >
           ~(P === 0) /\ (Alpha === [FreeInt(N)] @ FreeSeq(N +Int 2)) /\ Phi
         </ form >
         CfgItems
       </ config >
     Cfgs
     </ tasks >
     < counter > N +Int 3 </ counter > .

  eq < heap > list(0)(Alpha) H </ heap > < form > Phi </ form >
   = < heap > H </ heap > < form > Phi /\ Alpha === epsilon </ form > .
  eq < heap > list(P)(epsilon) H </ heap > < form > Phi </ form >
   = < heap > H </ heap > < form > Phi /\ P === 0 </ form > .

  rl < config >
       < heap >
         P |-> I : listNode . val
         (P +Int 1) |-> 0 : listNode . next
         H
       </ heap >
       CfgItems
     </ config >
     =match=> Cfg
  => < config >
       < heap >
         list(P)([I])
         H
       </ heap >
       CfgItems
     </ config >
     =match=> Cfg .
  rl < config >
       < heap >
         P |-> I : listNode . val
         (P +Int 1) |-> P' : listNode . next
         list(P')(Alpha)
         H
       </ heap >
       CfgItems
     </ config >
     =match=> Cfg
  => < config >
       < heap >
         list(P)([I] @ Alpha)
         H
       </ heap >
       CfgItems
     </ config >
     =match=> Cfg .
***(
  rl Cfg =match=>
     < config >
       < heap >
         P |-> I : listNode . val
         (P +Int 1) |-> 0 : listNode . next
         H
       </ heap >
       CfgItems
     </ config > 
  => Cfg =match=>
     < config >
       < heap >
         list(P)([I])
         H
       </ heap >
       CfgItems
     </ config > .
  rl Cfg =match=>
     < config >
       < heap >
         P |-> I : listNode . val
         (P +Int 1) |-> P' : listNode . next
         list(P')(Alpha)
         H
       </ heap >
       CfgItems
     </ config >
  => Cfg =match=>
     < config >
       < heap >
         list(P)([I] @ Alpha)
         H
       </ heap >
       CfgItems
     </ config > .
***)


*** Definition of List Segments ***
  op lseg : -> HeapLabel .

 ceq < tasks >
       < config >
         < k > derive(P') ~> K </ k >
         < heap > lseg(P, Q)(Alpha) H </ heap >
         < form > Phi </ form >
         CfgItems
       </ config >
     Cfgs
     </ tasks >
     < counter > N </ counter >
   = < tasks >
       < config >
         < k > derive(P') ~> K </ k >
         < heap > H </ heap >
         < form > (P === Q) /\ (Alpha === epsilon) /\ Phi </ form >
         CfgItems
       </ config >
       < config >
         < k > K </ k >
         < heap >
           P |-> FreeInt(N) : listNode . val
           (P +Int 1) |-> FreeInt(N +Int 1) : listNode . next
           lseg(FreeInt(N +Int 1), Q)(FreeSeq(N +Int 2))
           H
         </ heap >
         < form >
           ~(P === Q) /\ (Alpha === [FreeInt(N)] @ FreeSeq(N +Int 2)) /\ Phi
         </ form >
         CfgItems
       </ config >
     Cfgs
     </ tasks >
     < counter > N +Int 3 </ counter >
  if VALID(Phi ===> P' === P \/ P' === P +Int 1) .

  eq < heap > lseg(P, P)(Alpha) H </ heap > < form > Phi </ form >
   = < heap > H </ heap > < form > Phi /\ Alpha === epsilon </ form > .
  eq < heap > lseg(P, 0)(Alpha) H </ heap >
   = < heap > list(P)(Alpha) H </ heap > .

  rl < config >
       < heap >
         P |-> I : listNode . val
         (P +Int 1) |-> Q : listNode . next
         H </ heap >
       CfgItems
     </ config >
     =match=> Cfg
  => < config >
       < heap >
         lseg(P, Q)([I])
         H
       </ heap >
       CfgItems
     </ config >
     =match=> Cfg .
     
  rl < config >
       < heap >
         lseg(P, P')(Alpha)
         lseg(P', Q)(Beta)
         H
       </ heap >
       CfgItems
     </ config >
     =match=> Cfg
  => < config >
       < heap >
         lseg(P, Q)(Alpha @ Beta)
         H
       </ heap >
       CfgItems
     </ config >
     =match=> Cfg .
     
  rl < config >
       < heap >
         lseg(P, P')(Alpha)
         list(P')(Beta)
         H
       </ heap >
       CfgItems
     </ config >
     =match=> Cfg
  => < config >
       < heap >
         list(P)(Alpha @ Beta)
         H
       </ heap >
       CfgItems
     </ config >
     =match=> Cfg .
endm
