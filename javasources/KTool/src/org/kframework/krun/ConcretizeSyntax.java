package org.kframework.krun;

import org.kframework.compile.utils.MetaK;
import org.kframework.kil.*;
import org.kframework.kil.loader.DefinitionHelper;
import org.kframework.kil.visitors.CopyOnWriteTransformer;
import org.kframework.kil.visitors.exceptions.TransformerException;
import org.kframework.utils.StringUtil;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class ConcretizeSyntax extends CopyOnWriteTransformer {

	private String sortContext = "K";

	public ConcretizeSyntax() {
		super("Abstract K to Syntax K");
	}

	@Override
	public ASTNode transform(KApp kapp) throws TransformerException {
		Term label = kapp.getLabel();
		Term child = kapp.getChild();
		child = child.shallowCopy();
		List<Term> possibleTerms;
		if (label instanceof KInjectedLabel && child instanceof Empty) {
			Term injected = ((KInjectedLabel)label).getTerm();
			if (MetaK.isBuiltinSort(injected.getSort()) || DefinitionHelper.isSubsortedEq(sortContext, injected.getSort())) {
				return (Term)injected.accept(this);
			}
		} else if (label instanceof Constant) {
			String klabel = ((Constant)label).getValue();
			Set<String> conses = DefinitionHelper.labels.get(klabel);
			Set<String> validConses = new HashSet<String>();
			List<Term> contents = new ArrayList<Term>();
			possibleTerms = new ArrayList<Term>();
			if (child instanceof KList) {
				contents = ((KList)child).getContents();
			} else if (!(child instanceof Empty)) {
				contents.add(child);
			}
			if (conses != null) {	
				for (String cons : conses) {
					Production p = DefinitionHelper.conses.get(cons);
					if ((DefinitionHelper.isSubsortedEq(sortContext, p.getSort())) && p.getArity() == contents.size()) {
						validConses.add(cons);
						for (int i = 0; i < contents.size(); i++) {
							String temp = sortContext;
							sortContext = p.getChildSort(i);
							contents.set(i, (Term)contents.get(i).accept(this));
							sortContext = temp;
						}
					}
				}
				for (String cons : validConses) {
					Production p = DefinitionHelper.conses.get(cons);
					possibleTerms.add(new TermCons(p.getSort(), cons, contents));
				}
				if (possibleTerms.size() == 0) {
					return super.transform(kapp);
				}
				if (possibleTerms.size() == 1) {
					return possibleTerms.get(0);
				} else {
					
					return new Ambiguity(sortContext, possibleTerms);
				}
			} else if (child instanceof Empty) {
				//could be a list terminator, which don't have conses
				Set<String> sorts = DefinitionHelper.listLabels.get(((Constant)label).getValue());
				possibleTerms = new ArrayList<Term>();
				if (sorts != null) {
					for (String sort : sorts) {
						if (DefinitionHelper.isSubsortedEq(sortContext, sort)) {
							possibleTerms.add(new Empty(sort));
						}
					}
					if (possibleTerms.size() == 0) {
						return super.transform(kapp);
					}
					if (possibleTerms.size() == 1) {
						return possibleTerms.get(0);
					} else {
						
						return new Ambiguity(sortContext, possibleTerms);
					}
				}
			} else if (klabel.equals("#token")) {
				ASTNode sortNode = contents.get(0).accept(this);
				ASTNode valueNode = contents.get(1).accept(this);
				if (!(sortNode instanceof Constant && valueNode instanceof Constant)) {
					return super.transform(kapp);
				}
				Constant sort = (Constant)sortNode;
				Constant value = (Constant)valueNode;
				if (!(sort.getSort().equals("#String") && value.getSort().equals("#String"))) {
					return super.transform(kapp);
				}
				String escapedSort = sort.getValue();
				String escapedValue = value.getValue();
				escapedSort = escapedSort.substring(1, escapedSort.length() - 1);
				escapedValue = escapedValue.substring(1, escapedValue.length() - 1);
				return new Constant(StringUtil.unescape(escapedSort), StringUtil.unescape(escapedValue));
			}
		}
		return super.transform(kapp);
	}

	@Override
	public ASTNode transform(Freezer f) throws TransformerException {
		return ((Freezer)f).getTerm().accept(this);
	}

	@Override
	public ASTNode transform(Cell c) throws TransformerException {
		String temp = sortContext;
		Cell decl = DefinitionHelper.cells.get(c.getLabel());
		if (decl == null) {
			// for autogenerated cells like freshCounter and generatedTop
			sortContext = "K";
		} else {
			sortContext = DefinitionHelper.cellSorts.get(c.getLabel());
		}
		ASTNode result = super.transform(c);
		sortContext = temp;
		return result;
	}

	@Override
	public ASTNode transform(TermCons term) throws TransformerException {
		term = term.shallowCopy();
		List<Term> contents = term.getContents();
		Production p = term.getProduction();
		for (int i = 0; i < contents.size(); i++) {
			String temp = sortContext;
			sortContext = p.getChildSort(i);
			contents.set(i, (Term)contents.get(i).accept(this));
			sortContext = temp;
		}
		return term;
	}

	@Override
	public ASTNode transform(KSequence i) throws TransformerException {
		String temp = sortContext;
		sortContext = "K";
		ASTNode result = super.transform(i);
		sortContext = temp;
		return result;
	}

	@Override
	public ASTNode transform(BagItem i) throws TransformerException {
		String temp = sortContext;
		sortContext = "K";
		ASTNode result = super.transform(i);
		sortContext = temp;
		return result;
	}

	@Override
	public ASTNode transform(SetItem i) throws TransformerException {
		String temp = sortContext;
		sortContext = "K";
		ASTNode result = super.transform(i);
		sortContext = temp;
		return result;
	}

	@Override
	public ASTNode transform(ListItem i) throws TransformerException {
		String temp = sortContext;
		sortContext = "K";
		ASTNode result = super.transform(i);
		sortContext = temp;
		return result;
	}

	@Override
	public ASTNode transform(MapItem i) throws TransformerException {
		String temp = sortContext;
		sortContext = "K";
		ASTNode result = super.transform(i);
		sortContext = temp;
		return result;
	}
}
