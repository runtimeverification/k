\setlength{\parindent}{1em}
\title{SIMPLE --- Typed --- Static}
\author{Grigore Ro\c{s}u and 
        Traian Florin \c{S}erb\u{a}nu\c{t}\u{a}
        (\texttt{\{grosu,tserban2\}@illinois.edu})}
\organization{University of Illinois at Urbana-Champaign}

\maketitle

\begin{latexComment}
\section{Abstract}
This is the \K definition of the static semantics of the typed SIMPLE
language, or in other words, a type system for the typed SIMPLE
language in \K.  We do not re-discuss the various features of the
SIMPLE language here.  The reader is referred to the untyped version of
the language for such discussions.  We here only focus on the new and
interesting problems raised by the addition of type declarations, and
what it takes to devise a type checker for the language.

When designing a type system for a language, no matter in what
paradigm, we have to decide upon the intended typing policy.  Note
that we can have multiple type systems for the same language, one for
each typing policy.  For example, should we accept programs which
don't have a main function?  Or should we allow functions that do not
return explicitly?  Or should we allow functions whose type expects 
them to return a value (say an \texttt{int}) to use a plain
``\texttt{return;}'' statement, which returns no value, like in C?
And so on and so forth.  Typically, there are two opposite tensions
when designing a type system.  On the one hand, you want your type
system to be as permissive as possible, that is, to accept as many
programs that do not get stuck when executed with the untyped
semantics as possible; this will keep the programmers using your
language happy.  On  the other hand, you want your type system to have
a reasonable performance when implemented; this will keep both the
programmers and the implementers of your language happy.  For example,
a type system that rejects programs that could perform
division-by-zero is not feasible in general.  A simple guideline when
designing typing policies is to imagine how the semantics of the
untyped language may get stuck and try to prevent those situations
from happening.

Before we give the \K type system of SIMPLE formally, we discuss, informally,
the intended typing policy:
\begin{itemize}
\item Each program should contain a \texttt{main} function.  Indeed, the
untyped SIMPLE semantics will get stuck on any program which does not have a
\texttt{main} function.
\item Each primitive value has its own type, which can be \texttt{int}
\texttt{bool}, or \texttt{string}.  There is also a type \texttt{void} for
nonexistent values, for example for the result of a function meant to return
no value (but only be used for its side effects, like a procedure).
\item The syntax of untyped SIMPLE is extended to allow type declarations for
all the variables.  This is done in a Pascal-style, following the declared
variable with a colon followed by the type.  For example,
``\texttt{var x:int;}'' or ``\texttt{var x:int=7, y:int, z:int=x+y;}''.
\item Arrays of values of type $T$ have the type \texttt{arrayOf $T$}
(displayed as $T[\,]$ in this generated PDF) and are declared using a
syntax similar to the one for simple variables, but where the colon
and the type follow the dimension of the declared array.
For example, ``\texttt{var x[10]:arrayOf int;}'', or
``\texttt{var x[10,20]:arrayOf arrayOf int;}'', or even
``\texttt{var x:arrayOf arrayOf int;}'' when \texttt{x} is only needed
as a reference to an array (allocated somewhere else), or even
``\texttt{var x[10]:arrayOf arrayOf int;}'', as well as any combinations of
simple variables (with or without initializations) and arrays (with or without
allocation---given sizes).
\item Functions taking arguments of type $\it Ts$ (a list of types) and
returning a result of type $T$ have the type
\texttt{function from $\it Ts$ to $T$} (displayed as ${\it Ts}\rightarrow T$
in this generated PDF documentation).  For example, a function taking an
array of functions from \texttt{int} to \texttt{int} and returning an array
of \texttt{bool} elements is declared using a syntax of the form
\begin{verbatim}
function f(x:arrayOf function from int to int):arrayOf bool {
  ...
}
\end{verbatim}
and has the type
\texttt{function from arrayOf function from int to int to bool}.
\item We allow any variable declarations at the top level.  Functions can
only be declared at the top level.  No other statements are allowed at the
top level.  In particular we don'l allow declared variables to be initialized.
That is because our semantics of initialized variables is to first declare
them and then initialize them using an assignment statement; however,
assignments are not allowed at the top level in typed SIMPLE.  If you want
to allow initialization for declared variables at the top level, then you
have to do it explicitly in the semantics.  For simplicity we don't.
Each function can only access the other functions and variables declared
at the top level, or its own locally declared variables.
SIMPLE has static scoping.
\item The various expression and statement constructs take only elements of
the expected types.
\item Increment and assignment can operate both on variables and on array
elements.  For example, if \texttt{f} has type
\texttt{function from int to arrayOf arrayOf int} and function
\texttt{g} has the type \texttt{function from int to int}, then the
increment expression \texttt{++f(7)[g(2),g(3)]} is valid.
\item The \texttt{for} loops only iterate over counter variables of type
\texttt{int}, which therefore need not be manually declared; they are
automatically assumed declared only for the scope of the \texttt{for} and of
type \texttt{int}.
\item Functions should only return values of their declared result type.
To give the programmers more flexibility, we allow functions to use
``\texttt{return;}'' statements to terminate without returning an actual
value, or to not explicitly use any return statement, regardless of their
declared return type.  This flexibility can be handy when writing programs
using certain functions only for their side effects.
\item For simplicity, we here limit exceptions to only throw integer values.
This way, we don't need to declare a type for the variable that binds the
thrown value (similarly to the counter variables in \texttt{for} loops).
\end{itemize}
Like in untyped SIMPLE, some constructs can be desugared into a smaller set of
basic constructs.
\end{latexComment}

\vspace*{3ex}
