--- why isn't K ~> K proper?
--- arithmetic on a void * pointer
--- argument of function type
--- need one past array
--- 6.7.5.3:11 if, in a parameter declaration, an identifier can be treated either as a typedef name or as a parameter name, it shall be taken as a typedef name
--- switch with only one case?
--- casting from unsigned long long int to int is super slow
--- pr34099.c checks if anding unknown with 0 is 0.  need to add named unknowns and better interpret

--- extern inside block that shadows variable in a function that shadows global extern

---C99 6.7.8:10 If an object has static duration ... if it has pointer type, it is NULL, if it is arithmetic, 0, aggregate, recursively these, union, first member by these

***( 
not handling this type:
static union {
  unsigned char buf[MAX_LENGTH];
  long long align_int;
  long double align_fp;
} u1, u2;

("Field").KProperLabel(unsigned-char,,("_`[_`]").KProperLabel("Id"(buf),,("_+_").KProperLabel(("_+_").KProperLabel(("_+_").KProperLabel(("sizeof").KProperLabel(long-long-int),,("_*_").KProperLabel(("tv").KResultLabel(8,,unsigned-long-int),,("sizeof").KProperLabel(long-long-int))),,("sizeof").KProperLabel(long-long-int)),,("tv").KResultLabel(2,,unsigned-long-int)))) 
***)

set print attribute on .
mod INCOMING-MODULES is
	including K .
	including C-SYNTAX .
	including C-CONFIGURATION .
	including K-CONTEXTS .
	including K-PROPER .
	including K-QUOTED-LABELS .
endm

mod COMMON-SEMANTIC-SYNTAX is
	including INCOMING-MODULES .
	op List : BagItem -> ListItem .
	op ListToK : List -> K .
	op Map : Map -> K .
	op piece : Nat Nat -> Nat .
	op trueUnknown : -> Nat [ctor] .
	op unknown : Nat -> Nat [ctor] .
	op unknownF : -> Float [ctor] .
	op skipval : -> KResult .
	op debugK : -> K .
	op discard : -> K .
	op File-Scope : -> Id [ctor] .
	op unnamedBitField : -> Id [ctor] .
	op bignum : -> Type .
	op sym : Nat -> Nat .
	op byteo : Nat -> Nat .
	op bito : Nat -> Nat .
	eq bito(0) = 0 . --- FIXME need to check this is okay in all circumstances
	op bitoffset : Nat -> Nat .
	op byteoffset : Nat -> Nat .
	op declare : K K -> K [metadata "strict(1)"] .
	op enumItem : Id Value -> Value .
	op resolveReferences : -> K .
	--- op t : Type -> Type .
	--- op t : Type Set -> Type .
	
	op bitRange : Nat Nat Nat -> Nat . --- original number, from, to inclusive
	
	op fillToBytes : K -> K [metadata "strict(1)"] .
	
	op floorLoc : Nat -> Nat . --- loc with possible bit offset returning base byte	
	op figureInitializer : Id Type K -> K .  --- id, type, initializer
	op figureInitializer-aux : Id Type K -> K [metadata "strict(3)"] .  --- id, type, initializer
	op readFunction : Nat -> K .
	
	ceq _bit::_(piece(N:Nat, Len:Nat), piece(N':Nat, Len':Nat)) 
		= piece((N:Nat <<Nat Len':Nat) |Nat N':Nat, Len:Nat +Nat Len':Nat)
		if N:Nat >=Nat 0 andBool N':Nat >=Nat 0 .
	eq _bit::_(piece(0, 0), N:Nat) = N:Nat .
	eq piece(piece(N:Nat, Len:Nat), Len:Nat) = piece(N:Nat, Len:Nat) .
	op declarationObject : Type K K -> K . --- type, translation unit it was defined in, definition
	op initializerValue : Id Type K -> KResult .
	op external : -> K .
	op internal : -> K .
	op noLinkage : -> K .
	
	
	op AttributeValue : String List{C} -> KResult .
	
	op extractBitsFromList : K Nat Nat -> K [metadata "strict(1)"] . --- data, offset, size in bits
	op typedef : Id -> Id .
	op unnamed : Nat -> Id .
	
	op NullPointerConstant : -> Nat .
	eq NullPointerConstant = 0 .
	op NullPointer : -> Nat .
	
	op emptyValue : -> Value .
	--- subsort List{KResult} < K .
	op _bit::_ : Nat Nat -> Nat [assoc] .
	--- op allocateIfAbsent : Type Id -> K .
	op allocate : Type K -> K .	
	
	op zero : K -> K .
	op zeroBlock : Nat -> K .
	
	op initializer : K -> KResult .
	op startInitializer : Type Id K -> K .
	op popBlock : -> K .
	op pushBlock : -> K .
	
	op value : K -> K .
	eq value(tv(V:List{K}, ?)) = V:List{K} .
	
	op type : K -> Type .
	eq type(tv(?, T:Type)) = T:Type .
	
	op allocateType : Nat Type -> K .
	op allocateTypeIfAbsent : Nat Type -> K .
	op giveType : Id Type -> K .
	op addToEnv : Id Nat -> K .
	
	op read : K K -> K [metadata "strict(2)"] . --- location, type
	op write : K K -> K [metadata "strict(2)"] . --- location, value
	--- fixme might not always be what I want, but it seems to work
	--- eq loc(Block:Nat, N:Nat) <Int loc(Block:Nat, N':Nat) = N:Nat <Int N':Nat .
	--- eq loc(Block:Nat, N:Nat) >Int loc(Block:Nat, N':Nat) = N:Nat >Int N':Nat .
	--- eq loc(Block:Nat, N:Nat) <=Int loc(Block:Nat, N':Nat) = N:Nat <=Int N':Nat .
	--- eq loc(Block:Nat, N:Nat) >=Int loc(Block:Nat, N':Nat) = N:Nat >=Int N':Nat .
	
	op isTypeCompatible : K K -> Bool .
	
	op hasBeenPromoted : Type -> Bool .
	
	op bitloc : Nat Nat Nat -> Nat .
	op inc : Nat -> Nat .
	op initialize : Id Type K -> K .
	op memblock : Nat Map -> K . --- length and an array from offsets to bytes
	
	op listToK : K -> K .
	op klistToK : List{K} -> K .
	op UnknownCabsLoc : -> K .
	
	--- Basic types
	ops bool : -> BaseType .
	ops void char short-int int long-int long-long-int : -> BaseType .
	ops float double long-double : -> BaseType .
	ops signed-char unsigned-char : -> BaseType .
	ops unsigned-short-int unsigned-int unsigned-long-int unsigned-long-long-int : -> BaseType .
	op no-type : -> BaseType .
	
	
	--- Composite types
	op enumType : Id -> BaseType [ctor] .
	op arrayType : Type Nat -> Type [ctor] .
	op incompleteArrayType : Type -> Type [ctor] .
	op flexibleArrayType : Type -> Type [ctor] .
	op bitfieldType : Type Nat -> Type [ctor] .
	op functionType : Type List{Type} -> Type [ctor] .
	op pointerType : Type -> Type [ctor] .
	op structType : Id -> Type [ctor] .
	op unionType : Id -> Type [ctor] .
	op qualifiedType : Type K -> Type [ctor] .
	
	op unqualifyType : Type -> Type .
	
	--- these aren't real types, but are values that can appear in type contexts
	op typedefType : Id Type -> Type [ctor] .
	op preFunctionType : Type -> Type .
	op variadic : -> Type .
	--- op typedefType : Type -> Type [ctor] .
	
	--- sort State .
	--- subsort String < State .
	
	sort Type .
	sort Value .
	subsort Type < C .
	subsort Value < C .
	--- sort Type .
	sort BaseValue .
	--- sort Field .
	--- subsort Field < KResult .

	subsort Nat Int Rat Float < BaseValue .
	subsort BaseValue < C .
	subsort BaseValue < Builtins .
	op dataList : List{K} -> KResult .
	--- --- subsort BaseValue < Expression .
	--- --- subsort Value < Expression .
	subsort Value < KResult K .
	subsort Type < KResult K .
	sort BaseType .
	subsort BaseType < Type Builtins .
	--- --- subsort SeqList < Expression .
	
	
	op DeclType : K K -> K .
	op sizeofType : K -> K [metadata "strict"] . --- generates a tv(size, cfg:sizeut)
	op bitSizeofType : K -> K [metadata "strict"] .
	op byteSizeofType : K -> K [metadata "strict"] .
	op bitsToBytes : Nat -> Nat .
	--- op sizeofExp : K -> K .
	op HOLE : -> Expression .
	op l : KLabel -> K [metadata "builtin wrapper"] .
	--- ---op l : KLabel -> K .
	op _contains_ : Set K -> Bool [memo] .
	--- --- Types
	--- op anonymousId : -> Id .

	--- op typedParameterList : List{K} -> KResult [metadata "strict"] .
	op typedDeclaration : Type Id -> Type . --- would rather this be KResult, but can't get the subsorting to work
	--- op definedType : Type K -> KResult . 
	
	sort List{Type} .
	subsort List{Type} < KResult .
	subsort List{Type} < List{C} .
	subsort Type < List{Type} .
	subsort Type < List{C} .
	op _::_ : List{Type} List{Type} -> List{Type} [ditto metadata "ditto"] .
	op Nil : -> List{Type} [ditto] .
	
	op setOfTypes : -> Set [memo] .
	eq setOfTypes = Set(
		l('arrayType),, 
		l('bitfieldType),, 
		l('functionType),, 
		l('pointerType),, l('structType),, l('unionType),, 
		l('qualifiedType)
	) .
	
	op bind : List{C} List{Type} -> K .
	--- op typedField : Type Id -> KResult .
	--- op declare : K K -> K [metadata "strict(1)"] .
	--- op converted : K K -> K .
	op tv : List{K} Type -> Value .
	--- op atv : List{K} Type -> Value .
	op concretize : Type K -> K [metadata "strict(2)"] .
	--- op addTypes : K K -> K .
	--- op addGlobalTypes : K K -> K .
	--- op addGlobalTypes : K -> K .
	op functionObject : Id Type K -> Value .
	--- op putInMem : BaseValue K Type K -> K [metadata "strict(2 4)"] .
	--- op putBytesInMem : Nat List{K} Type K -> K [metadata "strict(4)"] .
	--- --- op sizeofType : K -> Expression [metadata "strict"] .
	op firstChar : String -> Char .
	op nthChar : String Nat -> Char .
	op butFirstChar : String -> String .
	op charToAscii : String -> Nat .
	op _to_ : Nat Nat -> List{K} .
	--- op necessaryBytes : K -> K [metadata "strict"] .
	op cast : K K -> K [metadata "strict"] . --- as described in 6.3
	op arithInterpret : Type BaseValue -> K . --- interpret the result of arithmetic as in 6.5.4
	op interpret : Type K -> K . --- interpret the values of reading from mem
	op leftShiftInterpret : Type BaseValue K -> K .
	op rightShiftInterpret : Type BaseValue -> K .
	--- op addLocals : Nat -> K .			
	op integerTypes : -> Set [memo] .
	op unsignedIntegerTypes : -> Set [memo] .
	op signedIntegerTypes : -> Set [memo] .
	op hasIntegerType : Type -> Bool [memo] .
	op hasFloatType : Type -> Bool [memo] .
	op hasUnsignedIntegerType : Type -> Bool [memo] .
	op hasSignedIntegerType : Type -> Bool [memo] .
	op typeof : K -> K .
	op writeToFD : Nat Nat -> K .
	op writeToFD : Nat String -> K .
	op readFromFD : Nat -> K .
	op readFromFD : Nat Nat -> K .

	op calculateLength : List{Type} -> K .
	op calculateGotoMap : Id K -> K .
	
	op hasCharType : Type -> Bool .
	op isABaseType_ : K -> Bool .
	op hasPointerType : Type -> Bool .
	op hasArrayType : Type -> Bool .
	op hasStructType : Type -> Bool .
	op hasUnionType : Type -> Bool .
	op hasAggregateType : Type -> Bool .
	op hasFunctionType : Type -> Bool .
	op hasFunctionPointerType : Type -> Bool .
	op hasBitfieldType : Type -> Bool .
	op hasExternType : Type -> Bool .
	op hasStaticType : Type -> Bool .
	op hasIncompleteType : Type -> Bool .
	op hasTypedefType : Type -> Bool .
	
	op kpair : K K -> K .
	--- op kpair : K List -> K .
	op promote : K -> K .
	--- op readFromMem : Nat Type -> K .
	op extractField : List{K} Type Id -> K .
	op allocString : Nat String -> K .
	--- op unknownRange : Nat Nat Nat -> List{K} .
	op popLoop : -> K .
	--- op giveGlobalType : Type K -> K .
	--- op giveLocalType : Type K -> K .
	op application : K List{C} -> K [metadata "strict(1)"] .
	--- op case : K BaseValue -> K .
	--- op defaultCase : K -> K .
	op sequencePoint : -> K .
	
	op min : Type -> Int [memo] .
	op max : Type -> Int [memo] .
	op storeNew_atLoc_ : K Nat -> K [metadata "strict(1)"] .
	op store_atLoc_ : K Nat -> K [metadata "strict(1)"] .
	op alloc : K K -> K . --- should be K K 
	
endm

mod C-SETTINGS is
	including INCOMING-MODULES .
	including COMMON-SEMANTIC-SYNTAX .

	--- S 6.2.5 p.35 i.15.  "The implementation shall define char to have the same range, representation, and behavior as either signed char or unsigned char.  37)... Irrespective of the choice made, char is a separate type from the other two and is not compatible with either
	--- fixme I'm not sure what consequence being a separate type entails, so for now it will just be rewritten to the chosen type
	mb rule char => signed-char : KSentence [metadata "structural"] .

	op numBitsPerByte : -> NzNat .
	op numBytes : Type -> Nat [memo] .
	op numBits : Type -> Nat [memo] .

	eq numBitsPerByte = 8 .
	
	eq numBytes(signed-char) = 1 .
	eq numBytes(short-int) = 2 .
	eq numBytes(int) = 4 .
	eq numBytes(long-int) = 4 .
	eq numBytes(long-long-int) = 8 .
	
	eq numBytes(float) = 4 .
	eq numBytes(double) = 8 .
	eq numBytes(long-double) = 16 .
	
	eq numBytes(enumType(X:Id)) = numBytes(int) .
	
	op cfg:sizeut : -> Type .
	eq cfg:sizeut = unsigned-long-int .
	
	op cfg:largestUnsigned : -> Type .
	eq cfg:largestUnsigned = unsigned-long-long-int .

	op cfg:ptrsize : -> Nat .
	eq cfg:ptrsize = 8 .
	
	op cfg:ptrdiffut : -> Type .
	eq cfg:ptrdiffut = long-long-int .
	
	eq min(enumType(?)) = min(int) .
	eq max(enumType(?)) = max(int) .
	
	--- — number of bits for smallest object that is not a bit-field (byte)
	--- CHAR_BIT 8
	--- — minimum value for an object of type signed char
	--- SCHAR_MIN -127 // -(27 - 1)
	--- — maximum value for an object of type signed char
	--- SCHAR_MAX +127 // 27 - 1
	--- — maximum value for an object of type unsigned char
	--- UCHAR_MAX 255 // 28 - 1
	--- — minimum value for an object of type char
	--- CHAR_MIN see below
	--- — maximum value for an object of type char
	--- CHAR_MAX see below
	--- — maximum number of bytes in a multibyte character, for any supported locale
	--- MB_LEN_MAX 1
	--- — minimum value for an object of type short int
	--- SHRT_MIN -32767 // -(215 - 1)
	--- — maximum value for an object of type short int
	--- SHRT_MAX +32767 // 215 - 1
	--- — maximum value for an object of type unsigned short int
	--- USHRT_MAX 65535 // 216 - 1
	--- — minimum value for an object of type int
	--- INT_MIN -32767 // -(215 - 1)
	--- — maximum value for an object of type int
	--- INT_MAX +32767 // 215 - 1
	--- — maximum value for an object of type unsigned int
	--- UINT_MAX 65535 // 216 - 1
	--- — minimum value for an object of type long int
	--- LONG_MIN -2147483647 // -(231 - 1)
	--- — maximum value for an object of type long int
	--- LONG_MAX +2147483647 // 231 - 1
	--- — maximum value for an object of type unsigned long int
	--- ULONG_MAX 4294967295 // 232 - 1
	--- — minimum value for an object of type long long int
	--- LLONG_MIN -9223372036854775807 // -(263 - 1)
	--- — maximum value for an object of type long long int
	--- LLONG_MAX +9223372036854775807 // 263 - 1
	--- — maximum value for an object of type unsigned long long int
	--- ULLONG_MAX 18446744073709551615 // 264 - 1
	
	op rank : Type -> Nat .
	
	--- fixme, this is kind of cheating as it will promote bitfields smaller than int to int leave others unchanged
	--- ceq rank(bitfieldType(?, N:Nat)) = 0 
		--- if N:Nat < numBits(int) .
		
	eq rank(char) = 1 .
	eq rank(signed-char) = 1 .
	eq rank(unsigned-char) = 1 .
	eq rank(short-int) = 2 .
	eq rank(unsigned-short-int) = 2 .
	eq rank(int) = 3 .
	eq rank(unsigned-int) = 3 .
	eq rank(long-int) = 4 .
	eq rank(unsigned-long-int) = 4 .
	eq rank(long-long-int) = 5 .
	eq rank(unsigned-long-long-int) = 5 .
	
	eq rank(bignum) = 100 . --- used for internal calculation.  should be bigger than all other ranks
	
	eq rank(enumType(?)) = rank(int) .
	---C99 6.3.1.1
	
	***(
	--- no two signed are the same
	rank of signed shall be greater than rank of signed with less precision
	rank(long-long-int) > rank(long int) > rank(int) > rank(short int) > rank(signed-char)
	rank unsigned is same as signed
	rank(char) == rank(signed char) == rank(unsigned-char)
	rank(_Bool) < rank(char)
	rank(enumType) == rank compatible int type
	transitive
	***)
endm

mod SEMANTIC-HELPERS is 
	including COMMON-SEMANTIC-SYNTAX .
	including C-SETTINGS .
	
	mb [discard]: rule
		< k > V:Value ~> discard => (.).K ...</ k >
		: KSentence [metadata "structural"] .
	
	---- derived
	eq bitsToBytes(N:Nat) = absInt(ceilingRat(N:Nat /Rat numBitsPerByte)) .
		
	eq numBytes(unsigned-char) = numBytes(signed-char) .
	eq numBytes(unsigned-short-int) = numBytes(short-int) .
	eq numBytes(unsigned-int) = numBytes(int) .
	eq numBytes(unsigned-long-int) = numBytes(long-int) .
	eq numBytes(unsigned-long-long-int) = numBytes(long-long-int) .
	
	ceq numBits(T:Type) = numBytes(T:Type) *Nat numBitsPerByte 
		if getKLabel(T:Type) =/=Bool 'bitfieldType .
	eq numBits(bitfieldType(?, N:Nat)) = N:Nat .

	eq min(signed-char) = -Int (2 ^Nat absInt(_-Int_(numBits(signed-char), 1))) .
	eq max(signed-char) = _-Int_(2 ^Nat absInt(_-Int_(numBits(signed-char), 1)), 1) .
	eq min(short-int) = -Int (2 ^Nat absInt(_-Int_(numBits(short-int), 1))) .
	eq max(short-int) = _-Int_(2 ^Nat absInt(_-Int_(numBits(short-int), 1)), 1) .
	eq min(int) = -Int (2 ^Nat absInt(_-Int_(numBits(int), 1))) .
	eq max(int) = _-Int_(2 ^Nat absInt(_-Int_(numBits(int), 1)), 1) .
	eq min(long-int) = -Int (2 ^Nat absInt(_-Int_(numBits(long-int), 1))) .
	eq max(long-int) = _-Int_(2 ^Nat absInt(_-Int_(numBits(long-int), 1)), 1) .
	eq min(long-long-int) = -Int (2 ^Nat absInt(_-Int_(numBits(long-long-int), 1))) .
	eq max(long-long-int) = _-Int_(2 ^Nat absInt(_-Int_(numBits(long-long-int), 1)), 1) .
	
	eq min(unsigned-char) = 0 .
	eq max(unsigned-char) = _-Int_(2 ^Nat absInt(numBits(unsigned-char)), 1) .
	eq min(unsigned-short-int) = 0 .
	eq max(unsigned-short-int) = _-Int_(2 ^Nat absInt(numBits(unsigned-short-int)), 1) .
	eq min(unsigned-int) = 0 .
	eq max(unsigned-int) = _-Int_(2 ^Nat absInt(numBits(unsigned-int)), 1) .
	eq min(unsigned-long-int) = 0 .
	eq max(unsigned-long-int) = _-Int_(2 ^Nat absInt(numBits(unsigned-long-int)), 1) .
	eq min(unsigned-long-long-int) = 0 .
	eq max(unsigned-long-long-int) = _-Int_(2 ^Nat absInt(numBits(unsigned-long-long-int)), 1) .
	
	mb [firstChar]: rule
		firstChar(S:String) => substrString(S:String, 0, 1)
		: KSentence [metadata "structural"] .
	mb [nthChar]: rule
		nthChar(S:String, N:Nat) => substrString(S:String, N:Nat, 1)
		: KSentence [metadata "structural"] .
	mb [charToAscii]: rule
		charToAscii(C:Char) => asciiString(C:Char)
		: KSentence [metadata "structural"] .
	mb [butFirstChar]: rule
		butFirstChar(S:String) => substrString(S:String, 1, lengthString(S:String))
		: KSentence [metadata "structural"] .
		
	eq N:Nat to N:Nat = .List{K} .
	ceq N:Nat to N':Nat = (N:Nat,,((N:Nat +Nat 1) to N':Nat))
		if N:Nat <Nat N':Nat .

	--- Note: it only makes sense to memo this if the sets are just used to represent categories
	eq S:Set SetItem(K:K) contains K:K = true .
	ceq S:Set SetItem(K1:K) contains K2:K = S:Set contains K2:K 
		if K1:K =/=Bool K2:K .
	eq (.).Set contains K:K = false .

	ceq hasIntegerType(T:Type) = true
		if (integerTypes contains T:Type) .
	ceq hasIntegerType(T:Type) = false if getKLabel(T:Type) =/=Bool 'bitfieldType andBool setOfTypes contains l(getKLabel(T:Type)) .
	eq hasIntegerType(bitfieldType(?, ?)) = true .
	
	ceq hasUnsignedIntegerType(T:Type) = true
		if (unsignedIntegerTypes contains T:Type) .
	ceq hasUnsignedIntegerType(T:Type) = false if getKLabel(T:Type) =/=Bool 'bitfieldType andBool setOfTypes contains l(getKLabel(T:Type)) .
	ceq hasUnsignedIntegerType(bitfieldType(T:Type, ?)) = true 
		if hasUnsignedIntegerType(T:Type) ==Bool true .
	ceq hasUnsignedIntegerType(bitfieldType(T:Type, ?)) = false 
		if hasUnsignedIntegerType(T:Type) ==Bool false .
	
	ceq hasSignedIntegerType(T:Type) = true
		if (signedIntegerTypes contains T:Type) .
	eq hasIntegerType(enumType(?)) = true .
	ceq hasSignedIntegerType(T:Type) = false if getKLabel(T:Type) =/=Bool 'bitfieldType andBool setOfTypes contains l(getKLabel(T:Type)) .
	ceq hasSignedIntegerType(bitfieldType(T:Type, ?)) = true 
		if hasSignedIntegerType(T:Type) ==Bool true .
	ceq hasSignedIntegerType(bitfieldType(T:Type, ?)) = false 
		if hasSignedIntegerType(T:Type) ==Bool false .
	



	ceq min(bitfieldType(T:Type, N:Nat)) = 0
		if unsignedIntegerTypes contains T:Type .
	ceq max(bitfieldType(T:Type, N:Nat)) = _-Int_(2 ^Nat absInt(N:Nat), 1)
		if unsignedIntegerTypes contains T:Type .
	
	ceq min(bitfieldType(T:Type, N:Nat)) = -Int (2 ^Nat absInt(_-Int_(N:Nat, 1)))
		if signedIntegerTypes contains T:Type .
	ceq max(bitfieldType(T:Type, N:Nat)) = _-Int_(2 ^Nat absInt(_-Int_(N:Nat, 1)), 1) 
		if signedIntegerTypes contains T:Type .

endm

mod COMMON-INCLUDE is
	including INCOMING-MODULES .
	including SEMANTIC-HELPERS .
	including C-SETTINGS .
	including COMMON-SEMANTIC-SYNTAX .	
endm

mod COMMON-PARAMETER-BINDING is
	including COMMON-INCLUDE .

	--- empty binding
	--- fixme not really a sequence point
	
	op bind-aux : Nat List{C} List{Type} -> K .
	mb rule
		< k > bind(L:List{C}, L':List{Type}) => bind-aux(NullPointer, L:List{C}, L':List{Type}) ...</ k > 
		: KSentence [metadata "structural"] .
	
	mb [bind-empty]: rule
		< k > bind-aux(?, Nil, typedDeclaration(void, ?)) => sequencePoint ...</ k > 
		: KSentence [metadata "structural"] .
	mb [bind-empty]: rule
		< k > bind-aux(?, Nil, Nil) => sequencePoint ...</ k > 
		: KSentence [metadata "structural"] .
	
	mb [bind-coerce-array]: rule
		bind-aux(?, L:List{C}, (?:List{Type} :: typedDeclaration((arrayType(T:Type, ?) => pointerType(T:Type)), X:Id) :: ?:List{Type}))
		: KSentence [metadata "structural"] .
	mb [bind-coerce-incompleteArray]: rule
		bind-aux(?, L:List{C}, (?:List{Type} :: typedDeclaration((incompleteArrayType(T:Type) => pointerType(T:Type)), X:Id) :: ?:List{Type}))
		: KSentence [metadata "structural"] .
		
	mb [bind-one]: rule
		< k > true ~> bind-aux(?, (tv(V:List{K}, T':Type) :: L:List{C}), (typedDeclaration(T:Type, X:Id) :: P:List{Type}))
			=> allocateType(Loc:Nat, T:Type)
			~> addToEnv(X:Id, Loc:Nat)
			~> giveType(X:Id, T:Type)
			~> initialize(X:Id, T:Type, (X:Id := tv(V:List{K}, T':Type) ~> discard))
			~> bind-aux(Loc:Nat, L:List{C}, P:List{Type}) 
		...</ k > 
		< nextLoc > Loc:Nat => inc(Loc:Nat) </ nextLoc >
		--- if isTypeCompatible(T:Type, T':Type)
		if notBool hasArrayType(T:Type)
		: KSentence [metadata "structural"] .
		
	mb [bind-one]: rule
		< k > (. => isTypeCompatible(T:Type, T':Type)) ~> bind-aux(?, (tv(V:List{K}, T':Type) :: L:List{C}), (typedDeclaration(T:Type, X:Id) :: P:List{Type}))
		...</ k > 
		: KSentence [metadata "structural"] .
	
	op append : Nat Nat Value -> K .	
	mb [append-existing]: rule
		< k > append(sym(Block:Nat) +Nat 0, Len:Nat, V:Value) 
			=> write(sym(Block:Nat) +Nat OldLen:Nat, V:Value)
		...</ k >
		< mem >... Block:Nat |-> memblock((OldLen:Nat => OldLen:Nat +Nat Len:Nat), M:Map) ...</ mem >
		: KSentence [metadata "structural"] .
	--- mb [append-new]: rule
		--- < k > append(sym(Block:Nat, Offset:Nat), Len:Nat, V:Value) 
			--- => storeNew V:Value atLoc loc(Block:Nat, Offset:Nat) 
		--- ...</ k >
		--- < mem > M:Map </ mem >
		--- if notBool($hasMapping(M:Map, Block:Nat))
		--- : KSentence [metadata "structural"] .
		
	op bindVariadic : K List{KResult} -> K .
	op bindVariadic-pre : K List{K} -> K .
	--- the idea here is that there should have been a previous argument, so we can use its address to append all of the variadic arguments
	op promoteList : List{C} -> List{K} .
	ceq promoteList((tv(V:List{K}, T:Type) :: L:List{C})) = (promote(tv(V:List{K}, T:Type)),, promoteList(L:List{C}))
		if (rank(T:Type) <Int rank(int) andBool hasIntegerType(T:Type)) 
		orBool T:Type ==Bool float .
	ceq promoteList((tv(V:List{K}, T:Type) :: L:List{C})) = (tv(V:List{K}, T:Type),, promoteList(L:List{C}))
		if (notBool(hasIntegerType(T:Type)) orBool rank(T:Type) >=Int rank(int))
		orBool T:Type ==Bool double orBool T:Type ==Bool long-double .
	--- eq promoteList((atv(LV:List{K}, T:Type) :: L:List{K})) = (atv(LV:List{K}, T:Type),, promoteList(L:List{K})) .

	eq promoteList(Nil) = .List{K} .
	--- fixme report bug: this context doesn't work
	--- op bindVariadic : Nat List{K} -> K .
	---mb context bindVariadic(?, (?,, `[HOLE`]:K,, ?)) : KSentence .
	--- mb context bindVariadic(?, (?,, `[HOLE`]:K,, ?)) : KSentence .
	
	mb [bind-variadic-start]: rule
		< k > bind-aux(Loc:Nat, L:List{C}, variadic)
			=> bindVariadic-pre(Loc:Nat, promoteList(L:List{C}))
		...</ k >
		--- < mem >... Block:Nat |-> memblock(Len:Nat, ?) ...</ mem >
		: KSentence [metadata "structural"] .
		
	mb [bind-variadic-start]: rule
		< k > bindVariadic-pre(Loc:Nat, L:List{KResult}) => bindVariadic(Loc:Nat, L:List{KResult}) ...</ k > 
		: KSentence [metadata "structural"] .
	
	mb [bind-variadic]: rule
		< k > (. => bitSizeofType(type(V:Value))) ~> bindVariadic(?, (V:Value,, ?:List{KResult})) ...</ k > 
		: KSentence [metadata "structural"] .
	
	mb [bind-variadic-done]: rule
		< k > bindVariadic(?, .List{K}) => sequencePoint ...</ k > 
		: KSentence [metadata "structural"] .

	mb [bind-variadic-withSize]: rule
		< k > (tv(Len:Nat, ?) => append(Loc:Nat, Len:Nat /Nat numBitsPerByte, V:Value)) 
			~> bindVariadic(Loc:Nat, ((V:Value => .List{K}),, L:List{KResult}))
		...</ k > 
		: KSentence [metadata "structural"] .
		
	--- --- mb [bind-variadic]: rule
		--- --- < k > [bind((tv(V:BaseValue, T:Type),, L:List{KResult}), typedDeclaration(no-type, ...))
			--- --- => 
			--- --- addLocals(Loc:Nat) ~> 
			--- --- storeNew tv(V:BaseValue, T:Type) atLoc Loc:Nat ~>
			--- --- bind(L:List{KResult}, typedDeclaration(no-type, ...))] ...</ k > 
		--- --- < nextLoc > Loc:Nat </ nextLoc >
		--- --- : KSentence [metadata "structural"] .
		
	--- --- mb [bind-struct-variadic]: rule
		--- --- < k > [bind((atv(V:List{K}, T:Type),, L:List{KResult}), typedDeclaration(no-type, ...))
			--- --- => 
			--- --- addLocals(Loc:Nat) ~> 
			--- --- storeNew atv(V:List{K}, T:Type) atLoc Loc:Nat ~>
			--- --- bind(L:List{KResult}, typedDeclaration(no-type, ...))] ...</ k > 
		--- --- < nextLoc > [Loc:Nat => inc(Loc:Nat)] </ nextLoc >
		--- --- : KSentence [metadata "structural"] .
		
	--- --- --- fixme todo this happens when we don't have the right prototype
	--- mb [bind-bad-prototype]: rule
		--- < k > [bind((tv(V:BaseValue, T:Type),, L:List{KResult}), .List{K})
			--- => 
			--- addLocals(Loc:Nat) ~> 
			--- storeNew tv(V:BaseValue, T:Type) atLoc Loc:Nat ~>
			--- bind(L:List{KResult}, typedDeclaration(no-type, ...))] ...</ k > 
		--- < nextLoc > [Loc:Nat => inc(Loc:Nat)] </ nextLoc >
		--- : KSentence [metadata "structural"] .
	--- mb [bind-bad-prototype-struct]: rule
		--- < k > [bind((atv(V:List{K}, T:Type),, L:List{KResult}), .List{K})
			--- => 
			--- addLocals(Loc:Nat) ~> 
			--- storeNew atv(V:List{K}, T:Type) atLoc Loc:Nat ~>
			--- bind(L:List{KResult}, typedDeclaration(no-type, ...))] ...</ k > 
		--- < nextLoc > [Loc:Nat => inc(Loc:Nat)] </ nextLoc >
		--- : KSentence [metadata "structural"] .	
endm

mod COMMON-INITIALIZATION is
	including COMMON-INCLUDE .
	
	op te : K Type -> K .
	op getInitializer : -> K .
	op fillInitializer : K -> K .
	op fillInitializer-aux : K -> K .
	op fillInitializer : List{C} -> K .
	op completeInitializerFragment : K K -> C .
	op initializerFragment : K -> KResult .
	
	mb rule
		< k > getInitializer => initializer(K:C) ...</ k >
		< savedInitialization > K:C => . </ savedInitialization > 
		< currentObject > ?:List => . </ currentObject > 
		< currentSubObject > ?:List => . </ currentSubObject > 
		: KSentence [metadata "structural"] .

	mb rule
		< k > startInitializer(T:Type, X:Id, CompoundInit(L:List{C}))
			=> fillInitializer(L:List{C}) ~> getInitializer
		...</ k >
		< incompleteLength > ? => 0 </ incompleteLength >
		< currentSubObject > . => ListItem(te(X:Id, T:Type)) </ currentSubObject >
		< currentObject > . => ListItem(te(X:Id, T:Type)) </ currentObject >
		< savedInitialization >... . => zero(X:Id) </ savedInitialization > 
		if hasUnionType(T:Type) orBool hasAggregateType(T:Type)
		: KSentence [metadata "structural"] .
	
	mb rule
		< k > fillInitializer(InitFragment(K:K, Exp:K) :: L:List{C})
		=> fillInitializer(InitFragment(K:K, Exp:K)) ~> fillInitializer(L:List{C})
		...</ k >
		: KSentence [metadata "structural"] .
	mb rule
		< k > fillInitializer(Nil) => . ...</ k >
		: KSentence [metadata "structural"] .
	
	op next : -> ListItem .
	op block : -> ListItem .
	
	mb rule
		< currentSubObject > 
			ListItem(te(K:K, arrayType(T:Type, Len:Nat)))
			=> ListItem(te(K:K[0], T:Type)) ListItem(te(K:K, arrayType(T:Type, Len:Nat)))
		...</ currentSubObject >
		: KSentence [metadata "structural"] .
	mb rule
		< currentSubObject > 
			ListItem(te(K:K, incompleteArrayType(T:Type)))
			=> ListItem(te(K:K[0], T:Type)) ListItem(te(K:K, incompleteArrayType(T:Type)))
		...</ currentSubObject >
		: KSentence [metadata "structural"] .
	mb rule
		< currentSubObject > 
			ListItem(te(K:K, structType(S:Id)))
			=> ListItem(te(K:K . F:Id, T:Type)) ListItem(te(K:K, structType(S:Id)))
		...</ currentSubObject >
		< structs >... S:Id |-> typedDeclaration(T:Type, F:Id) :: ? ...</ structs > 
		: KSentence [metadata "structural"] .
	mb rule
		< currentSubObject > 
			ListItem(te(K:K, unionType(S:Id)))
			=> ListItem(te(K:K . F:Id, T:Type)) ListItem(te(K:K, unionType(S:Id)))
		...</ currentSubObject >
		< structs >... S:Id |-> typedDeclaration(T:Type, F:Id) :: ? ...</ structs > 
		: KSentence [metadata "structural"] .
		
	--- fixme should i worry about basetype here?
	mb [init-next-array-element]: rule
		< currentSubObject > 
			(next ListItem(te(K:K[N:Nat], T:Type)) => ListItem(te(K:K[sNat(N:Nat)], T:Type)))
			ListItem(te(K:K, arrayType(?, Len:Nat)))
		...</ currentSubObject >
		if Len:Nat >Nat sNat(N:Nat)
		: KSentence [metadata "structural"] .
	mb [init-next-array-element-done]: rule
		< currentSubObject >
			next (ListItem(te(K:K[N:Nat], T:Type)) => .) ListItem(te(K:K, arrayType(?, Len:Nat)))
		...</ currentSubObject >
		if notBool Len:Nat >Nat sNat(N:Nat)
		: KSentence [metadata "structural"] .
	
	mb [init-next-incomplete-array-element]: rule
		< currentSubObject >
			(next ListItem(te(K:K[N:Nat], T:Type)) => ListItem(te(K:K[sNat(N:Nat)], T:Type))) 
			ListItem(te(K:K, incompleteArrayType(?)))
		...</ currentSubObject >
		---< incompleteLength > N':Nat => maxNat(sNat(N:Nat), N':Nat) </ incompleteLength >
		: KSentence [metadata "structural"] .
	
	mb [init-next-struct-element]: rule
		< currentSubObject >
			next ListItem(te(K:K . F:Id, T:Type)) ListItem(te(K:K, structType(S:Id)))
			=> ListItem(te(K:K . F':Id, T':Type)) ListItem(te(K:K, structType(S:Id)))
		...</ currentSubObject >
		< structs >...
			S:Id |-> ? :: typedDeclaration(T:Type, F:Id) :: typedDeclaration(T':Type, F':Id) :: ? 
		...</ structs > 
		if F':Id =/=Bool #NoName
		: KSentence [metadata "structural"] .
		
***(
	 ('typedDeclaration).KResultLabel(BaseType int(.List{K}),,Id Identifier("a")(.List{K}))
	 ,,('typedDeclaration).KResultLabel(BaseType signed-char(.List{K}),,Id Identifier("b")(.List{K}))
	 ,,('typedDeclaration).KResultLabel(('bitfieldType).KResultLabel(BaseType unsigned-int(.List{K}),,BaseValue 12(.List{K})),,Id Identifier("x")(.List{K}))
	 ,,('typedDeclaration).KResultLabel(('bitfieldType).KResultLabel(BaseType unsigned-int(.List{K}),,BaseValue 4(.List{K})),,Id Identifier("y")(.List{K}))
	 ,,('typedDeclaration).KResultLabel(('bitfieldType).KResultLabel(BaseType unsigned-int(.List{K}),,BaseValue 0(.List{K})),,Id #NoName(.List{K}))
	 ,,('typedDeclaration).KResultLabel(('bitfieldType).KResultLabel(BaseType unsigned-int(.List{K}),,BaseValue 4(.List{K})),,Id #NoName(.List{K}))
	 ,,('typedDeclaration).KResultLabel(('bitfieldType).KResultLabel(BaseType unsigned-int(.List{K}),,BaseValue 3(.List{K})),,Id Identifier("z")(.List{K}))
	 ,,('typedDeclaration).KResultLabel(('bitfieldType).KResultLabel(BaseType unsigned-int(.List{K}),,BaseValue 1(.List{K})),,Id #NoName(.List{K}))
	 ,,('typedDeclaration).KResultLabel(BaseType signed-char(.List{K}),,Id Identifier("c")(.List{K}))
***)

	 
	mb [init-next-struct-element]: rule
		< currentSubObject >
			next ListItem(te(K:K . F:Id, T:Type)) ListItem(te(K:K, structType(S:Id)))
			=> ListItem(te(K:K . F':Id, T':Type)) ListItem(te(K:K, structType(S:Id)))
		...</ currentSubObject >
		< structs >...
			S:Id |-> ? :: typedDeclaration(T:Type, F:Id) :: typedDeclaration(?, #NoName) :: typedDeclaration(T':Type, F':Id) :: ? 
		...</ structs >
		: KSentence [metadata "structural"] .
		
	mb [init-next-struct-element-done]: rule
		< currentSubObject >
			next (ListItem(te(K:K . F:Id, T:Type)) => .) ListItem(te(K:K, structType(S:Id)))
		...</ currentSubObject >
		< structs >...
			S:Id |-> ? :: typedDeclaration(T:Type, F:Id)
		...</ structs > 
		: KSentence [metadata "structural"] .
	mb [init-next-struct-element-done]: rule
		< currentSubObject >
			next (ListItem(te(K:K . F:Id, T:Type)) => .) ListItem(te(K:K, structType(S:Id)))
		...</ currentSubObject >
		< structs >...
			S:Id |-> ? :: typedDeclaration(T:Type, F:Id) :: typedDeclaration(?, #NoName)
		...</ structs > 
		: KSentence [metadata "structural"] .
		
	mb [init-next-union-element-done]: rule
		< currentSubObject >
			next (ListItem(te(K:K . ?, T:Type)) => .) ListItem(te(K:K, unionType(S:Id)))
		...</ currentSubObject >
		: KSentence [metadata "structural"] .
		
	mb rule
		< k > fillInitializer(InitFragment(NextInit, Exp:K)) => fillInitializer(Exp:K) ...</ k >
		: KSentence [metadata "structural"] .
		
	op finishCompoundInit : List -> K .
	mb rule
		< k > fillInitializer(CompoundInit(L:List{C})) 
			=> fillInitializer(L:List{C}) ~> finishCompoundInit(next ListItem(te(K:K, T:Type)) Remainder:ListItem)
		...</ k >
		< currentSubObject > (?:List => .) ListItem(te(K:K, T:Type)) (Remainder:ListItem => .) </ currentSubObject >
		< currentObject > (. => ListItem(te(K:K, T:Type))) ...</ currentObject >
		if hasAggregateType(T:Type) orBool hasUnionType(T:Type)
		: KSentence [metadata "structural"] .
	mb rule
		< k > finishCompoundInit(L:List) => . ...</ k >
		< currentObject > (ListItem(te(K:K, T:Type)) => .) ...</ currentObject >
		< currentSubObject > (? => L:List) </ currentSubObject >
		: KSentence [metadata "structural"] .	
			
	mb context fillInitializer(InitFragment(`[HOLE`]:K, ?)) : KSentence .
	op buildDesignator : K -> K .
	
	--- note that these clear the current subobject cell, because it will be repopulated when building the designator
	mb rule
		< k > fillInitializer(InitFragment(InFieldInit(F:Id, K':K), Exp:K))
			=> fillInitializer(InitFragment(buildDesignator(InFieldInit(F:Id, K':K)), Exp:K))
		...</ k >
		< currentObject > ListItem(te(K:K, T:Type)) ...</ currentObject >
		< currentSubObject > ?:List => block ListItem(te(K:K, T:Type)) </ currentSubObject >
		if hasStructType(T:Type) orBool hasUnionType(T:Type)
		: KSentence [metadata "structural"] .
	--- fixme does this need to worry about incompleteLength?
	mb rule
		< k > fillInitializer(InitFragment(AtIndexInit(Index:K, K':K), Exp:K))
			=> fillInitializer(InitFragment(buildDesignator(AtIndexInit(Index:K, K':K)), Exp:K))
		...</ k >
		< currentObject > ListItem(te(K:K, T:Type)) ...</ currentObject >
		< currentSubObject > ?:List => block ListItem(te(K:K, T:Type)) </ currentSubObject >
		if hasArrayType(T:Type)
		: KSentence [metadata "structural"] .
		
	
	--- fixme these are also too restrictive on type.  if we try to assign an int to a long-int field, it will fail
	mb rule
		< k > buildDesignator(InFieldInit(F:Id, More:K)) 
			=> buildDesignator(More:K)
		...</ k >
		< currentSubObject > block (. => ListItem(te(K:K . F:Id, T:Type))) ListItem('te(K:K,, KL:KLabel(S:Id))) ...</ currentSubObject >
		< structs >... S:Id |-> ? :: typedDeclaration(T:Type, F:Id) :: ? ...</ structs >
		if KL:KLabel ==Bool 'structType 
		orBool KL:KLabel ==Bool 'unionType
		: KSentence [metadata "structural"] .
		
	mb rule
		< k > buildDesignator(NextInit) => NextInit ...</ k >
		< currentSubObject > (block => .) ...</ currentSubObject >
		: KSentence [metadata "structural"] .
		
	op innerType : Type -> Type .
	eq innerType(arrayType(T:Type, ?)) = T:Type .
	eq innerType(incompleteArrayType(T:Type)) = T:Type .

	mb context buildDesignator(AtIndexInit(`[HOLE`]:K, ?)) : KSentence .
	mb rule
		< k > buildDesignator(AtIndexInit(tv(N:Nat, ?), More:K)) 
			=> buildDesignator(More:K)
		...</ k >
		< currentSubObject > block (. => ListItem(te(K:K[N:Nat], innerType(T:Type)))) ListItem(te(K:K, T:Type)) ...</ currentSubObject >
		if hasArrayType(T:Type)
		: KSentence [metadata "structural"] .
	
	op popInit : -> K .		
	
	op getTopArrayUse : K -> Nat .
	eq getTopArrayUse(X:Id) = 0 .
	eq getTopArrayUse(X:Id[N:Nat]) = sNat(N:Nat) . --- +1 for length instead of index
	eq getTopArrayUse(K:K . F:Id) = getTopArrayUse(K:K) .
	eq getTopArrayUse((K:K[N:Nat])[?]) = getTopArrayUse(K:K[N:Nat]) .
	eq getTopArrayUse((K:K . F:Id)[?]) = getTopArrayUse(K:K) .
	
	op initializeSingleInit : K -> K .
	--- forces a basetype
	mb rule
		< k > initializeSingleInit(K':K) => . ...</ k >
		< currentSubObject > (. => next) ListItem(te(K:K, T:Type)) ...</ currentSubObject >
		< incompleteLength > N:Nat => maxNat(N:Nat, getTopArrayUse(K:K)) </ incompleteLength >
		< savedInitialization >... . => (K:K := K':K) ~> discard </ savedInitialization > 
		--- if getKLabel(K':K) =/=Bool 'Constant
		if isABaseType(T:Type) orBool hasPointerType(T:Type) orBool hasBitfieldType(T:Type)
		: KSentence .
	mb rule
		< k > fillInitializer(SingleInit(K:K)) => initializeSingleInit(K:K) ...</ k >
		if getKLabel(K:K) =/=Bool 'Constant
		: KSentence .
	mb rule
		< k > fillInitializer(SingleInit(Constant(K:K))) => initializeSingleInit(Constant(K:K)) ...</ k >
		if getKLabel(K:K) =/=Bool 'StringLiteral
		andBool getKLabel(K:K) =/=Bool 'WStringLiteral
		: KSentence .
		
	mb rule
		< k > fillInitializer(SingleInit(Constant(StringLiteral(S:String))))
			=> fillInitializer-aux(SingleInit(Constant(StringLiteral(S:String))))
		...</ k >
		< currentSubObject > ListItem(te(K:K, T:Type)) ListItem(te(?, arrayType(T:Type, Len:Nat))) ...</ currentSubObject >
		if hasCharType(T:Type)
		andBool lengthString(S:String) ==Bool Len:Nat
		: KSentence .
	mb rule
		< k > fillInitializer(SingleInit(Constant(StringLiteral(S:String))))
			=> fillInitializer-aux(SingleInit(Constant(StringLiteral(S:String +String "\0"))))
		...</ k >
		< currentSubObject > ListItem(te(K:K, T:Type)) ListItem(te(?, arrayType(T:Type, Len:Nat))) ...</ currentSubObject >
		if hasCharType(T:Type)
		andBool sNat(lengthString(S:String)) ==Bool Len:Nat
		: KSentence .
	mb rule
		< k > fillInitializer(SingleInit(Constant(StringLiteral(S:String))))
			=> fillInitializer-aux(SingleInit(Constant(StringLiteral(S:String +String "\0"))))
		...</ k >
		< currentSubObject > ListItem(te(K:K, T:Type)) ListItem(te(?, incompleteArrayType(T:Type))) ...</ currentSubObject >
		if hasCharType(T:Type)
		: KSentence .
		
	mb rule
		< k > fillInitializer-aux(SingleInit(Constant(StringLiteral(S:String))))
			=> fillInitializer(SingleInit(tv(charToAscii(firstChar(S:String)), char))) 
			~> fillInitializer-aux(SingleInit(Constant(StringLiteral(butFirstChar(S:String))))) 
		...</ k >
		< currentSubObject > ListItem(te(K:K, T:Type)) ...</ currentSubObject >
		if S:String =/=Bool ""
		andBool hasCharType(T:Type)
		: KSentence .
	--- fixme not sure what happens in the case of   char *x = "";
	mb rule
		< k > fillInitializer-aux(SingleInit(Constant(StringLiteral("")))) => . ...</ k >
		--- if hasCharType(T:Type)
		: KSentence .
	mb rule
		< k > fillInitializer(SingleInit(Constant(StringLiteral(S:String))))
			=> initializeSingleInit(Constant(StringLiteral(S:String)))
		...</ k >
		< currentSubObject > ListItem(te(K:K, T:Type)) ...</ currentSubObject >
		if notBool hasCharType(T:Type)
		: KSentence .
endm

mod COMMON-GLOBAL-DECLARATION is
	including COMMON-INCLUDE .

	--- c99 6.7.8:9 Except where explicitly stated otherwise, for the purposes of this subclause unnamed members of objects of structure and union type do not participate in initialization.  Unnamed members of structure objects have indeterminate value even after initialization.
	--- c99 6.7.8:10 If an object that has automatic storage duration is not initialized explicitly, its value is indeterminate. If an object that has static storage duration is not initialized explicitly, then:
	--- — if it has pointer type, it is initialized to a null pointer;
	--- — if it has arithmetic type, it is initialized to (positive or unsigned) zero;
	--- if it is an aggregate, every member is initialized (recursively) according to these rules;
	--- — if it is a union, the first named member is initialized (recursively) according to these rules.

	op defineType : K -> K [metadata "strict"] .
	mb context DeclarationDefinition(InitNameGroup(`[HOLE`]:K, ?)) : KSentence .
	mb context Typedef(NameGroup(`[HOLE`]:K, ?)) : KSentence .
	eq LocalDefinition(DefinitionLoc(K:K, Loc:K)) = DefinitionLoc(K:K, Loc:K) .
	
	--- aggregates
	mb rule
		< k > figureInitializer(X:Id, T:Type, CompoundInit(L:List{C}))
			=> figureInitializer-aux(X:Id, T:Type, startInitializer(T:Type, X:Id, CompoundInit(L:List{C})))
		...</ k >
		if (hasAggregateType(T:Type) orBool hasUnionType(T:Type)) 
		---andBool notBool hasIncompleteType(T:Type)
		: KSentence [metadata "structural"] .
	mb rule
		< k > figureInitializer(X:Id, arrayType(T:Type, Len:Nat), SingleInit(Constant(StringLiteral(S:String)))) 
			=> figureInitializer(X:Id, arrayType(T:Type, Len:Nat), CompoundInit(InitFragment(NextInit, SingleInit(Constant(StringLiteral(S:String))))))
		...</ k >
		if hasCharType(T:Type)
		andBool lengthString(S:String) <=Nat Len:Nat
		: KSentence [metadata "structural"] .
		
	--- mb rule
		--- < k > declare(typedDeclaration(incompleteArrayType(T:Type), X:Id), SingleInit(Constant(StringLiteral(S:String))))
			--- => allocString(Loc:Nat, (S:String +String "\0"))
			--- ~> addToEnv(X:Id, Loc:Nat)
			--- ~> giveType(X:Id, arrayType(T:Type, lengthString(S:String) +Nat 1))
		--- ...</ k >
		--- < nextLoc > Loc:Nat => inc(Loc:Nat) </ nextLoc >
		--- if hasCharType(T:Type)
		--- : KSentence [metadata "structural"] .
	mb rule
		< k > figureInitializer(X:Id, (incompleteArrayType(T:Type) => arrayType(T:Type, lengthString(S:String) +Nat 1)), SingleInit(Constant(StringLiteral(S:String)))) ...</ k >
		if hasCharType(T:Type)
		: KSentence [metadata "structural"] .
		
	mb rule
		< k > figureInitializer(X:Id, incompleteArrayType(T:Type), CompoundInit(InitFragment(NextInit, SingleInit(Constant(StringLiteral(S:String))))))
			=> figureInitializer(X:Id, incompleteArrayType(T:Type), SingleInit(Constant(StringLiteral(S:String))))
		...</ k >
		: KSentence [metadata "structural"] .
		
	--- this comes from function declarations.  should probably adjust this
	mb rule
		< k > figureInitializer(X:Id, T:Type, initializer(K:K))
			=> figureInitializer-aux(X:Id, T:Type, initializer(K:K))
		...</ k >
		: KSentence [metadata "structural"] .

	mb rule
		< k > figureInitializer-aux(X:Id, T:Type, initializer(K:K))
			=> initializerValue(X:Id, T:Type, K:K)
		...</ k >
		if notBool hasIncompleteType(T:Type) --- I'd like to get rid of this cleanly
		: KSentence [metadata "structural"] .
	
	--- base types
	mb rule
		< k > figureInitializer(X:Id, T:Type, SingleInit(K:K))
			=> figureInitializer-aux(X:Id, T:Type, initializer((X:Id := K:K ~> discard)))
		...</ k >
		if notBool hasArrayType(T:Type)
		: KSentence [metadata "structural"] .
	--- c1x 6.7.8:11
	mb rule
		< k > figureInitializer(X:Id, T:Type, CompoundInit(InitFragment(NextInit, SingleInit(K:K))))
			=> figureInitializer-aux(X:Id, T:Type, initializer((X:Id := K:K ~> discard)))
		...</ k >
		if notBool (hasAggregateType(T:Type) orBool hasUnionType(T:Type))
		: KSentence [metadata "structural"] .
		
	eq DeclarationDefinition(InitNameGroup(T:Type, (K:C :: K':C :: L:List{C}))) 
		= DeclarationDefinition(InitNameGroup(T:Type, K:C)) 
		~> DeclarationDefinition(InitNameGroup(T:Type, K':C :: L:List{C})) .
	op idOfName : K -> K .
	eq idOfName(Name(X:Id, ?)) = X:Id .
	eq DeclarationDefinition(InitNameGroup(T:Type, InitName(Name:K, Exp:K))) = declare(SingleName(T:Type, Name:K), Exp:K) .
		
	eq Typedef(NameGroup(T:Type, (K:C :: K':C :: L:List{C}))) = Typedef(NameGroup(T:Type, K:C)) ~> Typedef(NameGroup(T:Type, K':C :: L:List{C})) .
	eq Typedef(NameGroup(T:Type, Name:C)) = defineType(SingleName(T:Type, Name:C)) .

	eq EnumItem(X:Id, V:Value)
		= enumItem(X:Id, V:Value) .
		
	op initialize-aux : Id Type K -> K .
		
	--- c1x 6.7.8:21 ... the remainder of the aggregate shall be initialized implicitly the same as objects that have static storage duration
	mb rule
		< k > initialize(X:Id, T:Type, K:K)
			=> if (F:Id ==Bool File-Scope) then zero(X:Id) else (.) fi 
			~> K:K
		...</ k >
		< currentFunction > F:Id </ currentFunction >
		: KSentence .
	mb rule
		< k > zero(Name:K) => . ...</ k >
		< currentFunction > F:Id </ currentFunction >
		< env >... Name:K |-> sym(Block:Nat) +Nat 0 ...</ env >
		< mem >... Block:Nat |-> memblock(Len:Nat, (? => (.).Map[piece(0, numBitsPerByte) / 0 to Len:Nat])) ...</ mem >
		: KSentence .
	mb rule
		< k > zeroBlock(sym(Block:Nat) +Nat 0) => . ...</ k >
		< mem >... Block:Nat |-> memblock(Len:Nat, (? => (.).Map[piece(0, numBitsPerByte) / 0 to Len:Nat])) ...</ mem >
		: KSentence .
	
	mb rule
		< k > defineType(typedDeclaration(T:Type, X:Id)) => giveType(typedef(X:Id), T:Type) ...</ k >
		: KSentence .
			
	op declareFunction : Id Type K -> K .
	op declareExternalVariable : Id Type K -> K .
	op declareInternalVariable : Id Type K -> K .
	mb rule
		< k > declare(typedDeclaration(T:Type, X:Id), K:K) 
			=> declareFunction(X:Id, T:Type, K:K)
		...</ k >
		< currentFunction > File-Scope </ currentFunction >
		if notBool hasIncompleteType(T:Type) --- I'd like to get rid of this cleanly
		andBool hasFunctionType(T:Type)
		: KSentence [metadata "structural"] .
	--- fixme there are still no nested functions though, right?
	mb rule
		< k > declare(typedDeclaration(T:Type, X:Id), NoInit) 
			=> addToEnv(X:Id, Loc:Nat)
			~> giveType(X:Id, unqualifyType(T:Type))
		...</ k >
		< externalLocations >... X:Id |-> Loc:Nat ...</ externalLocations > 
		< currentFunction > F:K </ currentFunction >
		if notBool hasIncompleteType(T:Type) --- I'd like to get rid of this cleanly
		andBool hasFunctionType(T:Type)
		andBool F:K =/=Bool File-Scope
		: KSentence [metadata "structural"] .
	mb rule
		< k > declare(typedDeclaration(T:Type, X:Id), K:K)
			=> declareExternalVariable(X:Id, T:Type, K:K)
		...</ k >
		< currentFunction > File-Scope </ currentFunction >
		--- if notBool hasIncompleteType(T:Type) --- I'd like to get rid of this cleanly
		if notBool hasFunctionType(T:Type)
		: KSentence [metadata "structural"] .
	mb rule
		< k > declare(typedDeclaration(T:Type, X:Id), K:K) 
			=> declareInternalVariable(X:Id, T:Type, K:K)
		...</ k >
		< currentFunction > F:K </ currentFunction >
		--- if notBool hasIncompleteType(T:Type) --- I'd like to get rid of this cleanly
		if notBool hasFunctionType(T:Type)
		andBool F:K =/=Bool File-Scope
		: KSentence [metadata "structural"] .
		
	---- external variables
	--- feature request : nice to have MapList
	
	mb rule
		< k > declareFunction(X:Id, T:Type, K:K)
			=> declareWithLinkage(X:Id, T:Type, K:K, external)
		...</ k >
		if notBool hasStaticType(T:Type)
		: KSentence [metadata "structural"] .
	mb rule
		< k > declareFunction(X:Id, T:Type, K:K)
			=> declareWithLinkage(X:Id, T:Type, K:K, internal)
		...</ k >
		< currentFunction > File-Scope </ currentFunction >
		if hasStaticType(T:Type)
		: KSentence [metadata "structural"] .
	
	op declareWithLinkage : Id Type K K -> K . --- id, type, possible init, linkage (external, internal, noLinkage)
	
	---- internal variables
	
	--- fixme need to look for bad use
	mb rule
		< k > declareInternalVariable(X:Id, T:Type, K:K)
			=> declareWithLinkage(X:Id, T:Type, K:K, noLinkage)
		...</ k >
		if notBool hasStaticType(T:Type)
		andBool notBool hasExternType(T:Type)
		: KSentence [metadata "structural"] .
	mb rule
		< k > declareInternalVariable(X:Id, T:Type, K:K)
			=> addToEnv(X:Id, Loc:Nat)
			~> giveType(X:Id, unqualifyType(T:Type))
		...</ k >
		< internalLocations >... Tu:K |-> Map((? kpair(X:Id, BlockNum:Nat) |-> Loc:Nat)) ...</ internalLocations >
		< currentBlock > BlockNum:Nat </ currentBlock >
		< currentTranslationUnit >... Tu:K ...</ currentTranslationUnit >
		if hasStaticType(T:Type)
		andBool notBool hasExternType(T:Type)
		: KSentence [metadata "structural"] .
		
	mb rule
		< k > declareInternalVariable(X:Id, T:Type, NoInit)
			=> allocateType(Loc:Nat, T:Type)
			~> addToEnv(X:Id, Loc:Nat)
			~> giveType(X:Id, unqualifyType(T:Type))
			~> zero(X:Id)
		...</ k >
		< internalLocations >... Tu:K |-> Map((Locs:Map => Locs:Map[Loc:Nat / kpair(X:Id, BlockNum:Nat)])) ...</ internalLocations >
		< currentBlock > BlockNum:Nat </ currentBlock >
		< nextLoc > Loc:Nat => inc(Loc:Nat) </ nextLoc >
		< currentTranslationUnit >... Tu:K ...</ currentTranslationUnit >
		if hasStaticType(T:Type)
		andBool notBool hasExternType(T:Type)
		andBool notBool $hasMapping(Locs:Map, kpair(X:Id, BlockNum:Nat))
		: KSentence [metadata "structural"] .
	mb rule
		< k > declareInternalVariable(X:Id, T:Type, K:K)
			=> defineAndInit(X:Id, unqualifyType(T:Type), figureInitializer(X:Id, unqualifyType(T:Type), K:K), Loc:Nat)
		...</ k >
		< internalLocations >... Tu:K |-> Map((Locs:Map => Locs:Map[Loc:Nat / kpair(X:Id, BlockNum:Nat)])) ...</ internalLocations >
		< currentBlock > BlockNum:Nat </ currentBlock >
		< nextLoc > Loc:Nat => inc(Loc:Nat) </ nextLoc >
		< currentTranslationUnit >... Tu:K ...</ currentTranslationUnit >
		if hasStaticType(T:Type)
		andBool notBool hasExternType(T:Type)
		andBool K:K =/=Bool NoInit
		andBool notBool $hasMapping(Locs:Map, kpair(X:Id, BlockNum:Nat))
		: KSentence [metadata "structural"] .
	mb rule
		< k > declareInternalVariable(X:Id, T:Type, NoInit)
			=> addToEnv(X:Id, Loc:Nat)
			~> giveType(X:Id, unqualifyType(T:Type))
		...</ k >
		< externalLocations >... X:Id |-> Loc:Nat ...</ externalLocations >
		if notBool hasIncompleteType(T:Type)
		andBool notBool hasStaticType(T:Type)
		andBool hasExternType(T:Type)
		: KSentence [metadata "structural"] .
		
	
	---- external variables
	mb rule
		< k > declareExternalVariable(X:Id, T:Type, K:K)
			=> declareWithLinkage(X:Id, T:Type, K:K, external)
		...</ k >
		if notBool hasStaticType(T:Type)
		andBool notBool hasExternType(T:Type)
		--- andBool notBool $hasMapping(Ext:Map, X:Id)
		: KSentence [metadata "structural"] .
	mb rule
		< k > declareExternalVariable(X:Id, T:Type, K:K)
			=> declareWithLinkage(X:Id, T:Type, K:K, external)
		...</ k >
		< preLinkage > Linkage:Map </ preLinkage >
		< currentTranslationUnit > Tu:K </ currentTranslationUnit >
		if notBool hasStaticType(T:Type)
		andBool hasExternType(T:Type)
		andBool notBool $hasMapping(Linkage:Map, kpair(X:Id, Tu:K))
		: KSentence [metadata "structural"] .
	mb rule
		< k > declareExternalVariable(X:Id, T:Type, K:K)
			=> declareWithLinkage(X:Id, T:Type, K:K, Linkage:Map(kpair(X:Id, Tu:K)))
		...</ k >
		< preLinkage > Linkage:Map </ preLinkage >
		< currentTranslationUnit > Tu:K </ currentTranslationUnit >
		if notBool hasStaticType(T:Type)
		andBool hasExternType(T:Type)
		andBool $hasMapping(Linkage:Map, kpair(X:Id, Tu:K))
		: KSentence [metadata "structural"] .
	mb rule
		< k > declareExternalVariable(X:Id, T:Type, K:K)
			=> declareWithLinkage(X:Id, T:Type, K:K, internal)
		...</ k >
		if hasStaticType(T:Type)
		andBool notBool hasExternType(T:Type)
		: KSentence [metadata "structural"] .
		
	op declareOnly : Id Type K -> K .
	op declareAndDefine : Id Type K K -> K .
	mb rule
		< k > declareWithLinkage(X:Id, T:Type, NoInit, L:K) => declareOnly(X:Id, T:Type, L:K) ...</ k >
		< declarationOrder >... Tu:K |-> ListToK(? (. => ListItem(X:Id))) ...</ declarationOrder >
		< currentTranslationUnit > Tu:K </ currentTranslationUnit >
		: KSentence [metadata "structural"] .
	mb rule
		< k > declareWithLinkage(X:Id, T:Type, K:K, L:K) => declareAndDefine(X:Id, T:Type, K:K, L:K) ...</ k >
		< declarationOrder >... Tu:K |-> ListToK(? (. => ListItem(X:Id))) ...</ declarationOrder >
		< currentTranslationUnit > Tu:K </ currentTranslationUnit >
		if K:K =/=Bool NoInit
		: KSentence [metadata "structural"] .
	
	---  
	mb rule
		< k > declareOnly(X:Id, T:Type, external)
			=> (.).K
		...</ k >
		< declarations >... (.).Set => SetItem(X:Id) ...</ declarations >
		< preLinkage >... Tu:K |-> Map((Linkage:Map => Linkage:Map[external / X:Id])) ...</ preLinkage >
		< preTypes >... Tu:K |-> Map((Types:Map => Types:Map[T:Type / X:Id])) ...</ preTypes >
		< currentTranslationUnit > Tu:K </ currentTranslationUnit >
		if notBool $hasMapping(Linkage:Map, kpair(X:Id, Tu:K)) 
		orBool Linkage:Map(kpair(X:Id, Tu:K)) ==Bool external
		: KSentence [metadata "structural"] .
	--- fixme haven't thought about this much, is it right?
	mb rule
		< k > declareOnly(X:Id, T:Type, internal)
			=> (.).K
		...</ k >
		< declarations >... (.).Set => SetItem(X:Id) ...</ declarations >
		< preLinkage >... Tu:K |-> Map((Linkage:Map => Linkage:Map[internal / X:Id])) ...</ preLinkage >
		< preTypes >... Tu:K |-> Map((Types:Map => Types:Map[T:Type / X:Id])) ...</ preTypes >
		< currentTranslationUnit > Tu:K </ currentTranslationUnit >
		if notBool $hasMapping(Linkage:Map, kpair(X:Id, Tu:K)) 
		orBool Linkage:Map(kpair(X:Id, Tu:K)) ==Bool internal
		: KSentence [metadata "structural"] .
	mb rule
		< k > declareOnly(X:Id, T:Type, noLinkage)
			=> allocateType(Loc:Nat, T:Type)
			~> addToEnv(X:Id, Loc:Nat)
			~> giveType(X:Id, T:Type)
		...</ k >
		< nextLoc > Loc:Nat => inc(Loc:Nat) </ nextLoc >
		< localVariables > Vars:Set (. => SetItem(X:Id)) </ localVariables >
		if notBool hasIncompleteType(T:Type)
		andBool notBool hasStaticType(T:Type)
		andBool notBool hasExternType(T:Type)
		andBool notBool X:Id in Vars:Set
		: KSentence [metadata "structural"] .
	
	mb rule
		< k > declareAndDefine(X:Id, T:Type, K:K, external)
			=> (.).K
		...</ k >
		< declarations >... (.).Set => SetItem(X:Id) ...</ declarations >
		< externalDefinitions > Def:Map => Def:Map[declarationObject(unqualifyType(T:Type), Tu:K, K:K) / X:Id] </ externalDefinitions >
		< preLinkage >... Tu:K |-> Map((Linkage:Map => Linkage:Map[external / X:Id])) ...</ preLinkage >
		< preTypes >... Tu:K |-> Map((Types:Map => Types:Map[T:Type / X:Id])) ...</ preTypes >
		< currentTranslationUnit > Tu:K </ currentTranslationUnit >
		if notBool $hasMapping(Def:Map, X:Id)
		andBool (notBool $hasMapping(Linkage:Map, kpair(X:Id, Tu:K)) orBool Linkage:Map(kpair(X:Id, Tu:K)) ==Bool external)
		: KSentence [metadata "structural"] .
		
	mb rule
		< k > declareAndDefine(X:Id, T:Type, K:K, internal)
			=> (.).K
		...</ k >
		< declarations >... (.).Set => SetItem(X:Id) ...</ declarations >
		< internalDefinitions >... Tu:K |-> Map((Def:Map => Def:Map[declarationObject(unqualifyType(T:Type), Tu:K, K:K) / X:Id])) ...</ internalDefinitions >
		< preLinkage >... Tu:K |-> Map((Linkage:Map => Linkage:Map[internal / X:Id])) ...</ preLinkage >
		< preTypes >... Tu:K |-> Map((Types:Map => Types:Map[T:Type / X:Id])) ...</ preTypes >
		< currentTranslationUnit > Tu:K </ currentTranslationUnit >
		if notBool $hasMapping(Def:Map, kpair(X:Id, Tu:K))
		andBool (notBool $hasMapping(Linkage:Map, kpair(X:Id, Tu:K)) orBool Linkage:Map(kpair(X:Id, Tu:K)) ==Bool internal)
		: KSentence [metadata "structural"] .
	op defineAndInit : Id Type K Nat -> K [metadata "strict(3)"] .
	mb rule
		< k > declareAndDefine(X:Id, T:Type, K:K, noLinkage)
			=> defineAndInit(X:Id, T:Type, figureInitializer(X:Id, T:Type, K:K), Loc:Nat)
		...</ k >
		< nextLoc > Loc:Nat => inc(Loc:Nat) </ nextLoc >
		< localVariables > Vars:Set (. => SetItem(X:Id)) </ localVariables >
		if notBool X:Id in Vars:Set
		: KSentence [metadata "structural"] .
	mb rule
		< k > defineAndInit(X:Id, ?, initializerValue(X:Id, T:Type, K:K), Loc:Nat)
			=> allocateTypeIfAbsent(Loc:Nat, T:Type)
			~> addToEnv(X:Id, Loc:Nat)
			~> giveType(X:Id, T:Type)
			~> initialize(X:Id, T:Type, K:K)
		...</ k >
		: KSentence [metadata "structural"] .
		
	mb rule
		< k > figureInitializer-aux(?, (incompleteArrayType(T:Type) => arrayType(T:Type, N:Nat)), initializer(K:K))
		...</ k >
		< incompleteLength > N:Nat </ incompleteLength >
		: KSentence [metadata "structural"] .

	op allocateAndZeroIfAbsent : Type Id -> K .
	op addToLinkage : Id Type -> K .
	op addToGlobalEnv : K Nat -> K .
	op addToLocalEnv : K Nat -> K .
	
	mb rule
		< k > addToEnv(X:Id, Loc:Nat) => addToGlobalEnv(X:Id, Loc:Nat) ...</ k >
		< currentFunction > File-Scope </ currentFunction >
		: KSentence .
	mb rule
		< k > addToEnv(X:Id, Loc:Nat) => addToLocalEnv(X:Id, Loc:Nat) ...</ k >
		< currentFunction > F:K </ currentFunction >
		if F:K =/=Bool File-Scope
		: KSentence .
		
	mb rule
		< k > addToGlobalEnv(X:Id, Loc:Nat) => . ...</ k >
		< genv >... Tu:K |-> Map((M':Map => M':Map[Loc:Nat / X:Id])) ...</ genv >
		< currentTranslationUnit > Tu:K </ currentTranslationUnit >
		< env > E:Map => E:Map[Loc:Nat / X:Id] </ env >
		: KSentence .
	mb rule
		< k > addToLocalEnv(X:Id, Loc:Nat) => . ...</ k >
		< env > E:Map => E:Map[Loc:Nat / X:Id] </ env >
		: KSentence .
			
	mb rule
		< k > DeclarationDefinition(InitNameGroup(T:Type, Nil)) => (.).K ...</ k >
		: KSentence [metadata "structural"] .
	
	op defineUsingOldDeclaration : Type Id K -> K .
	
	--- op defineFunctionUsingOldDeclaration : Type Id K -> K .
	--- FIXME check prototypes
	mb [function-definition]: rule
		< k > FunctionDefinition(typedDeclaration(T:Type, X:Id), Block:K) 
			=> declareFunction(X:Id, T:Type, initializer((X:Id := tv(functionObject(X:Id, unqualifyType(T:Type), Block:K), T:Type) ~> discard)))
		...</ k >
		if hasFunctionType(T:Type)
		: KSentence [metadata "structural"] .
		
	--- mb [function-definition]: rule
		--- < k > defineFunctionUsingOldDeclaration(T:Type, X:Id, Block:K)
			--- => store tv(functionObject(X:Id, T:Type, Block:K), T:Type) atLoc Loc:Nat 
			--- ~> calculateGotoMap(X:Id, Block:K)
		--- ...</ k >
		--- < env >... X:Id |-> Loc:Nat ...</ env >
		--- --- < genv > GEnv:Map => GEnv:Map[Loc:Nat / X:Id] </ genv >
		--- --- < types > Types:Map => Types:Map[T:Type / X:Id] </ types >
		--- --- < gtypes > GTypes:Map => GTypes:Map[T:Type / X:Id] </ gtypes >
		--- --- < nextLoc > Loc:Nat => inc(Loc:Nat) </ nextLoc >
		--- : KSentence [metadata "structural"] .
endm

mod C-SEMANTICS-MISC is
	including COMMON-INCLUDE .
	
	
	eq inc(sym(N:Nat) +Nat M:Nat) = sym(N:Nat +Nat 1) +Nat M:Nat .
	eq sNat(sym(N:Nat) +Nat M:Nat) = sym(N:Nat) +Nat (M:Nat +Nat 1) .
	ceq I:Int +Int (N:Nat +Nat sym(M:Nat))
		= absInt(N:Nat +Int I:Int) +Nat sym(M:Nat) 
		if N:Nat +Int I:Int >=Int 0 .
		
	ceq (N:Nat +Nat sym(M:Nat)) -Int I:Int
		= absInt(N:Nat -Int I:Int) +Nat sym(M:Nat) 
		if N:Nat -Int I:Int >=Int 0 .
	--- eq N:Nat +Nat bito(M:Nat) +Int I:Int = (N:Nat +Int I:Int) +Nat bito(M:Nat) .
	
	--- --- fixme can do a much better job than this
	--- eq 0 |Nat N:Nat = N:Nat .
	--- --- eq ? &Nat unknown = unknown .
	--- --- eq ? |Nat unknown = unknown .
	--- --- eq ? *Float unknownF = unknownF .
	--- --- eq unknownF *Float ? = unknownF .
	--- --- eq ? +Float unknownF = unknownF .
	--- --- eq unknownF +Float ? = unknownF .
	--- --- --- eq float2ratConversion(unknownF) = unknown .
	--- --- eq _-Float_(?, unknownF) = unknownF .
	--- --- eq _-Float_(unknownF, ?) = unknownF .
	--- --- eq _/Float_(?, unknownF) = unknownF .
	--- --- eq _/Float_(unknownF, ?) = unknownF .
	--- --- eq -Float(unknownF) = unknownF .
	--- --- eq expFloat(unknownF) = unknownF .
	--- --- eq logFloat(unknownF) = unknownF .
	--- --- ceq logFloat(F:Float) = unknownF 
		--- --- if F:Float <Float 0.0 .
	
	--- --- need to be careful about simplifying these into one rule because there may be variables with the same name as a typedef?
	--- --- fixme typedef should take precedence over variable
	--- mb rule 
		--- < k > [X:Id => T:Type] ...</ k >
		--- < types >... typedefName(X:Id) |-> T:Type ...</ types > 
		--- : KSentence [metadata "structural"] .
	--- mb rule 
		--- < k > [struct(X:Id) => T:Type] ...</ k > 
		--- < types >... struct(X:Id) |-> T:Type ...</ types > 
		--- : KSentence [metadata "structural"] .
	--- mb rule 
		--- < k > [union(X:Id) => T:Type] ...</ k > 
		--- < types >... union(X:Id) |-> T:Type ...</ types > 
		--- : KSentence [metadata "structural"] .
	--- mb rule 
		--- < k > [enum(X:Id) => T:Type] ...</ k > 
		--- < types >... enum(X:Id) |-> T:Type ...</ types > 
		--- : KSentence [metadata "structural"] .
		
	mb rule
		< k > sequencePoint => (.).K ...</ k >
		< locsWrittenTo > ? => (.).Bag </ locsWrittenTo >
		: KSentence [metadata "structural"] .
		
	--- ---C99 6.5.3.2 (p79) footnote 90) Thus, &*E == E; &(E1[E2]) == (E1 + E2)
	
	--- ---C99 6.5.3.2 90) ... It is always true that if E is a function designator or an lvalue that is a valid operand of the u of the unary & operator, *&E is a function designator or an lvalue equal to E.

	eq calculateLength(Nil) = 0 .
	eq calculateLength(T:Type :: L:List{Type}) = calculateLength(T:Type) + calculateLength(L:List{Type}) .
	eq calculateLength(typedDeclaration(T:Type, ?)) = bitSizeofType(T:Type) .
	
	op extractField-pre : List{K} Type K K -> K [metadata "strict(3 4)"] .
	op extractField-aux : List{K} Type Nat Nat List{K} -> K .
	
	--- figureOffset(loc(0, 0), calcStructSize-aux(L1:List{KResult}, 0), T:Type)
	mb [extractField-from-struct-start]: rule
		< k > extractField(L:List{K}, structType(S:Id), F:Id)
			=> extractField-pre(L:List{K}, T:Type, calculateLength(L:List{Type}), bitSizeofType(T:Type)) ...</ k >
		< structs >... S:Id |-> (L:List{Type} :: typedDeclaration(T:Type, F:Id) :: ?:List{Type}) ...</ structs >
		: KSentence [metadata "structural"] .
		
	mb [extractField-from-union-start]: rule
		< k > extractField(L:List{K}, unionType(S:Id), F:Id)
			=> extractField-pre(L:List{K}, T:Type, tv(0, unsigned-long-int), bitSizeofType(T:Type)) ...</ k >
		< structs >... S:Id |-> (?:List{Type} :: typedDeclaration(T:Type, F:Id) :: ?:List{Type}) ...</ structs >
		: KSentence [metadata "structural"] .
		
	mb rule
		< k > extractField-pre(L:List{K}, T:Type, tv(Offset:Nat, ?), tv(Len:Nat, ?))
			=> concretize(T:Type, fillToBytes(extractBitsFromList(dataList(L:List{K}), Offset:Nat, Len:Nat)))
		...</ k >
		: KSentence [metadata "structural"] .
				
	mb [writeToFD-char] : rule
		< k > writeToFD(FD:Nat, N:Nat) => (.).K ...</ k >
		< openFiles >... FD:Nat |-> Filename:String ...</ openFiles >
		< files >... Filename:String |-> (S:String => S:String +String charString(N:Nat %Nat 256)) ...</ files >
		: KSentence [metadata "structural"] .
	mb [writeToFD-string] : rule
		< k > writeToFD(FD:Nat, S':String) => (.).K ...</ k >
		< openFiles >... FD:Nat |-> Filename:String ...</ openFiles >
		< files >... Filename:String |-> (S:String => S:String +String S':String) ...</ files >
		: KSentence [metadata "structural"] .
	--- mb [readFromFD-char] : rule
		--- < k > [readFromFD(FD:Nat) => tv(charToAscii(firstChar(S:String)), int)]  ...</ k >
		--- < openFiles >... FD:Nat |-> Filename:String ...</ openFiles >
		--- < files >... Filename:String |-> [S:String => butFirstChar(S:String)] ...</ files >
		--- if S:String =/=Bool ""
		--- : KSentence [metadata "structural"] .
		
	--- mb rule
		--- < k > [readFromFD(FD:Nat, Offset:Nat) => tv(charToAscii(nthChar(S:String, Offset:Nat)), int)]  ...</ k >
		--- < openFiles >... FD:Nat |-> Filename:String ...</ openFiles >
		--- < files >... Filename:String |-> S:String ...</ files >
		--- if lengthString(S:String) >Nat Offset:Nat
		--- : KSentence [metadata "structural"] .
	--- mb rule
		--- < k > [readFromFD(FD:Nat, Offset:Nat) => tv(-1, int)]  ...</ k >
		--- < openFiles >... FD:Nat |-> Filename:String ...</ openFiles >
		--- < files >... Filename:String |-> S:String ...</ files >
		--- if lengthString(S:String) <=Nat Offset:Nat
		--- : KSentence [metadata "structural"] .

	eq listToK(K:K) = klistToK(getList{K}(K:K)) .
	eq klistToK((K:K,, L:List{K})) = K:K ~> klistToK(L:List{K}) .
	--- eq klistToK((K:K)) = K:K .
	--- eq klistToK(.) = . .
	eq klistToK(.List{K}) = . .
	
	eq CabsLoc("cabs loc unknown", -10, -10, 0) = UnknownCabsLoc .
	
	op canonicalizeTranslationUnitVariables : -> K .
	mb rule
		< k > TranslationUnit(Name:String, L:List{C}, P:String) 
			=> listToK(L:List{C})
			--- ~> canonicalizeTranslationUnitVariables
		...</ k >
		< currentTranslationUnit > ? => Name:String </ currentTranslationUnit >
		< declarationOrder > DeclOrder:Map => DeclOrder:Map[ListToK((.).List) / Name:String] </ declarationOrder >
		< internalLocations > ExtLoc:Map => ExtLoc:Map[Map(.) / Name:String] </ internalLocations >
		< functionTranslationUnits > Funs:Map => Funs:Map[Map(.) / Name:String] </ functionTranslationUnits > 
		< translationUnits >... . => BagItem(Name:String) ...</ translationUnits >
		< preLinkage > Linkage:Map => Linkage:Map[Map(.) / Name:String] </ preLinkage >
		< preTypes > Types:Map => Types:Map[Map(.) / Name:String] </ preTypes >
		< internalDefinitions > Def:Map => Def:Map[Map(.) / Name:String] </ internalDefinitions >
		< genv > Env:Map => Env:Map[Map(.) / Name:String] </ genv >
		< gtypes > Gtypes:Map => Gtypes:Map[Map(.) / Name:String]</ gtypes >
		< programText > M:Map => M:Map[P:String / Name:String] </ programText >
		if notBool $hasMapping(Env:Map, Name:String)
		: KSentence .
	
	op resolve : K -> K .
	mb rule
		< k > (. => resolve(Tu:K)) ~> resolveReferences ...</ k >
		< translationUnits >... BagItem(Tu:K) => . ...</ translationUnits >
		: KSentence .
	mb rule
		< k > resolveReferences => . ...</ k >
		< translationUnits > (.).Bag </ translationUnits >
		: KSentence .
		
	op resolveInternal : Id K K -> K .
	op resolveExternal : Id K Bag K -> K .
	op resolveExternal-aux : Id K Bag K Nat K -> K [metadata "strict(6)"] .
	--- op resolveExternal-alloc : Id K Bag K Nat K -> K [metadata "strict(6)"] .
	
	op recordFunctionTranslationUnitInformation : K Type K K -> K . --- name, type, context, where defined
	mb rule
		< k > recordFunctionTranslationUnitInformation(X:Id, T:Type, Tu:K, DefTu:K) => . ...</ k >
		< functionTranslationUnits >... Tu:K |-> Map((Funs:Map => Funs:Map[DefTu:K / X:Id])) ...</ functionTranslationUnits >
		if hasFunctionType(T:Type)
		: KSentence .
	mb rule
		< k > recordFunctionTranslationUnitInformation(?, T:Type, ?, ?) => . ...</ k >
		if notBool hasFunctionType(T:Type)
		: KSentence .
	
	--- fixme
	--- should be adding to env after figuring initializer
	--- should be changing env to be correct env before figuring initializer
	op allocateWithInit : K Nat -> K [metadata "strict"] .
	op noAllocateWithInit : K Nat -> K [metadata "strict"] .
	op resolveInternal-aux : Id K K K -> K [metadata "strict(4)"] .
	mb rule
		< k > resolveInternal(X:Id, Tu:K, declarationObject(T:Type, Tu:K, K:K))
			=> resolveInternal-aux(X:Id, Tu:K, declarationObject(T:Type, Tu:K, K:K), figureInitializer(X:Id, T:Type, K:K))
		...</ k >
		< currentTranslationUnit > ? => Tu:K </ currentTranslationUnit >
		: KSentence .
	mb rule
		< k > resolveInternal-aux(X:Id, Tu:K, declarationObject(?, Tu:K, ?), initializerValue(X:Id, T:Type, K:K))
			=> allocateType(Loc:Nat, T:Type)
			~> addToEnv(X:Id, Loc:Nat)
			~> giveType(X:Id, T:Type)
			~> initialize(X:Id, T:Type, K:K)
			~> recordFunctionTranslationUnitInformation(X:Id, T:Type, Tu:K, Tu:K)
		...</ k >
		< nextLoc > Loc:Nat => inc(Loc:Nat) </ nextLoc >
		< currentTranslationUnit > ? => Tu:K </ currentTranslationUnit >
		: KSentence .
		
		--- < internalLocations >... Tu:K |-> Map((Locs:Map => Locs:Map[Loc:Nat / kpair(X:Id, BlockNum:Nat)])) ...</ internalLocations > 		--- < currentBlock > BlockNum:Nat </ currentBlock > 		--- if notBool $hasMapping(Locs:Map, kpair(X:Id, BlockNum:Nat))
		
	mb rule
		< k > resolveExternal(X:Id, Tu:K, Units:Bag, declarationObject(T:Type, DefTu:K, K:K))
			=> resolveExternal-aux(X:Id, Tu:K, Units:Bag, declarationObject(T:Type, DefTu:K, K:K), Loc:Nat, figureInitializer(X:Id, T:Type, K:K))
		...</ k >
		< nextLoc > Loc:Nat => inc(Loc:Nat) </ nextLoc >
		: KSentence .
	mb rule
		< k > (.
			=> addToEnv(X:Id, Loc:Nat)
			~> giveType(X:Id, T:Type)
			~> recordFunctionTranslationUnitInformation(X:Id, T:Type, Tu':K, DefTu:K)
			) ~> resolveExternal-aux(X:Id, Tu:K, ((BagItem(Tu':K) => .) Units:Bag), declarationObject(?, DefTu:K, ?), Loc:Nat, initializerValue(X:Id, T:Type, K:K))
		...</ k >
		< currentTranslationUnit > ? => Tu':K </ currentTranslationUnit >
		< preLinkage >... Tu':K |-> Map((? (X:Id |-> external => .))) ...</ preLinkage >
		: KSentence .
	mb rule
		< k > resolveExternal-aux(X:Id, Tu:K, (.).Bag, declarationObject(?, DefTu:K, ?), Loc:Nat, initializerValue(X:Id, T:Type, K:K))
			=> allocateType(Loc:Nat, T:Type)
			~> addToEnv(X:Id, Loc:Nat)
			~> giveType(X:Id, T:Type)
			~> initialize(X:Id, T:Type, K:K)
			~> recordFunctionTranslationUnitInformation(X:Id, T:Type, Tu:K, DefTu:K)
		...</ k >
		< currentTranslationUnit > ? => Tu:K </ currentTranslationUnit >
		< externalLocations > Locs:Map => Locs:Map[Loc:Nat / X:Id] </ externalLocations >
		if notBool $hasMapping(Locs:Map, X:Id)
		: KSentence .
	mb rule
		< k > resolveExternal-aux(X:Id, ?, ((BagItem(Tu:K) => .) Units:Bag), ?, ?, ?) ...</ k >
		< preLinkage >... Tu:K |-> Map(M:Map) ...</ preLinkage >
		if notBool $hasMapping(M:Map, X:Id)
		: KSentence .
	mb rule
		< k > resolveExternal-aux(X:Id, ?, ((BagItem(Tu:K) => .) Units:Bag), ?, ?, ?) ...</ k >
		< preLinkage >... Tu:K |-> Map((? X:Id |-> internal)) ...</ preLinkage >
		: KSentence .
	
	--- 
	mb rule
		< k > (. => resolveInternal(X:Id, Tu:K, K:K)) ~> resolve(Tu:K) ...</ k >
		< preLinkage >... Tu:K |-> Map((? (X:Id |-> internal => .))) ...</ preLinkage >
		< internalDefinitions >... Tu:K |-> Map((? (X:Id |-> K:K => .))) ...</ internalDefinitions >
		< declarationOrder >... Tu:K |-> ListToK((ListItem(X:Id) => .) ?) ...</ declarationOrder >
		: KSentence .
		
	--- static variable without an initializer
	mb rule
		< k > (. => resolveInternal(X:Id, Tu:K, declarationObject(unqualifyType(T:Type), Tu:K, initializer(zero(X:Id))))) ~> resolve(Tu:K) ...</ k >
		< preLinkage >... Tu:K |-> Map((? (X:Id |-> internal => .))) ...</ preLinkage >
		< internalDefinitions >... Tu:K |-> Map(Defs:Map) ...</ internalDefinitions >
		< declarationOrder >... Tu:K |-> ListToK((ListItem(X:Id) => .) ?) ...</ declarationOrder >
		< preTypes >... Tu:K |-> Map((? (X:Id |-> T:Type => .))) ...</ preTypes >
		if notBool $hasMapping(Defs:Map, X:Id)
		: KSentence .
		
	mb rule
		< k > (. => resolveExternal(X:Id, Tu:K, Units:Bag, K:K)) ~> resolve(Tu:K) ...</ k >
		< preLinkage >... Tu:K |-> Map((? (X:Id |-> external => .))) ...</ preLinkage >
		< externalDefinitions >... X:Id |-> K:K => . ...</ externalDefinitions >
		< declarationOrder >... Tu:K |-> ListToK((ListItem(X:Id) => .) ?) ...</ declarationOrder >
		< translationUnits > Units:Bag </ translationUnits >
		: KSentence .
	op toString : K -> K .
	eq toString(Identifier(S:String)) = S:String .
	eq toString(S:String) = S:String .
	--- < messages >... . => ListItem(toString(Tu:K) +String ": undefined reference to `" +String toString(X:Id) +String "'") </ messages >
	
	--- fixme this means we've declared it twice (like a prototype maybe?), but already handled it.  happening with getc in clib.c
	mb rule
		< k > resolve(Tu:K) ...</ k >
		< preLinkage >... Tu:K |-> Map(Linkage:Map) ...</ preLinkage >
		< declarationOrder >... Tu:K |-> ListToK((ListItem(X:Id) => .) ?) ...</ declarationOrder >
		< externalDefinitions > ExtDefs:Map </ externalDefinitions >
		< internalDefinitions > IntDefs:Map </ internalDefinitions >
		if notBool $hasMapping(Linkage:Map, X:Id)
		andBool notBool $hasMapping(ExtDefs:Map, X:Id)
		andBool notBool $hasMapping(IntDefs:Map, X:Id)
		: KSentence .
	
	--- function prototypes
	mb rule
		< k > resolve(Tu:K) ...</ k >
		< preLinkage >... Tu:K |-> Map((? (X:Id |-> external => .))) ...</ preLinkage >
		< preTypes >... Tu:K |-> Map((? X:Id |-> T:Type)) ...</ preTypes >
		< declarationOrder >... Tu:K |-> ListToK((ListItem(X:Id) => .) ?) ...</ declarationOrder >
		< externalDefinitions > Defs:Map </ externalDefinitions >
		if hasFunctionType(T:Type)
		andBool notBool $hasMapping(Defs:Map, X:Id)
		: KSentence .
	--- mb rule --- maybe unnecessary if i always init internals
		--- < k > resolve(Tu:K) ...</ k >
		--- < preLinkage >... Tu:K |-> Map((? (X:Id |-> internal => .))) ...</ preLinkage >
		--- < preTypes >... Tu:K |-> Map((? X:Id |-> T:Type)) ...</ preTypes >
		--- < internalDefinitions > Tu:K |-> Map((Defs:Map)) </ internalDefinitions >
		--- if hasFunctionType(T:Type)
		--- andBool notBool $hasMapping(Defs:Map, X:Id)
		--- : KSentence .
		
	--- c1x 6.9.2:2 A declaration of an identifier for an object that has file scope without an initializer, and without a storage-class specifier or with the storage-class specifier static, constitutes a tentative definition. If a translation unit contains one or more tentative definitions for an identifier, and the translation unit contains no external definition for that identifier, then the behavior is exactly as if the translation unit contains a file scope declaration of that identifier, with the composite type as of the end of the translation unit, with an initializer equal to 0.
	mb rule
		< k > (. 
			=> allocateType(Loc:Nat, unqualifyType(T:Type))
			~> addToEnv(X:Id, Loc:Nat)
			~> giveType(X:Id, unqualifyType(T:Type))
			--- ~> X:Id := Constant(IntLiteral(NoSuffix(DecimalConstant(0))))
			--- ~> discard
			~> zero(X:Id)
			) ~> resolve(Tu:K)
		...</ k >
		< preLinkage >... Tu:K |-> Map((? (X:Id |-> external => .))) ...</ preLinkage >
		< preTypes >... Tu:K |-> Map((? X:Id |-> T:Type)) ...</ preTypes >
		< declarationOrder >... Tu:K |-> ListToK((ListItem(X:Id) => .) ?) ...</ declarationOrder >
		< externalDefinitions > Defs:Map </ externalDefinitions >
		< currentTranslationUnit > ? => Tu:K </ currentTranslationUnit >
		< nextLoc > Loc:Nat => inc(Loc:Nat) </ nextLoc >
		< externalLocations > Locs:Map => Locs:Map[Loc:Nat / X:Id] </ externalLocations >
		if notBool $hasMapping(Locs:Map, X:Id)
		andBool notBool hasFunctionType(T:Type)
		andBool notBool hasIncompleteType(T:Type)
		andBool notBool hasExternType(T:Type)
		andBool notBool $hasMapping(Defs:Map, X:Id)
		: KSentence .
	mb rule
		< k > resolve(Tu:K) ...</ k >
		< preLinkage >... Tu:K |-> Map((? (X:Id |-> external => .))) ...</ preLinkage >
		< preTypes >... Tu:K |-> Map((? X:Id |-> T:Type)) ...</ preTypes >
		< declarationOrder >... Tu:K |-> ListToK((ListItem(X:Id) => .) ?) ...</ declarationOrder >
		< externalDefinitions > Defs:Map </ externalDefinitions >
		if notBool hasFunctionType(T:Type)
		andBool hasExternType(T:Type)
		andBool notBool $hasMapping(Defs:Map, X:Id)
		: KSentence .
		
	mb rule
		< k > resolve(Tu:K) => . ...</ k >
		< preLinkage >... Tu:K |-> Map(.) ...</ preLinkage >
		< internalDefinitions >... Tu:K |-> Map(.) ...</ internalDefinitions >
		< declarationOrder >... Tu:K |-> ListToK((.).List) ...</ declarationOrder >
		: KSentence .
				
	--- need to worry about things that don't have definitions that may override externs
	--- want to make it so env is always correct local env, so need to have a set of global envs, one for each tu
	
	--- TODO nicely handle loc range instead of ignoring L2
	mb rule
		< k > DefinitionLocRange(K:K, L1:CabsLoc, L2:CabsLoc) => K:K ...</ k >
		< currentProgramLoc > ? => L1:CabsLoc </ currentProgramLoc >
		: KSentence .
	mb [DefinitionLoc]: rule
		< k > DefinitionLoc(K:K, L:CabsLoc) => K:K ...</ k >
		< currentProgramLoc > ? => L:CabsLoc </ currentProgramLoc >
		: KSentence .
	mb [StatementLoc]: rule
		< k > StatementLoc(K:K, L:CabsLoc) => K:K ...</ k >
		< currentProgramLoc > ? => L:CabsLoc </ currentProgramLoc >
		: KSentence .
	mb [EnumItemLoc]: rule
		< k > EnumItemLoc(K:K, L:CabsLoc) => K:K ...</ k >
		< currentProgramLoc > ? => L:CabsLoc </ currentProgramLoc >
		: KSentence .
		
	mb [Attributes]: rule
		< k > Attribute(S:String, L:List{C}) => AttributeValue(S:String, L:List{C}) ...</ k >
		: KSentence .	
		
	eq AttributeWrapper(K:K, ?) = K:K .
	eq NameLoc(K:K, ?) = K:K .
	
	ceq N:Nat +Nat bito(M:Nat) = N:Nat +Nat (M:Nat /Nat numBitsPerByte) +Nat bito(M:Nat %Nat numBitsPerByte)
		if M:Nat >=Nat numBitsPerByte .
		
	
	--- op enumDef : Id List{C} -> K .
	--- fixme can you have enums be negative?
	op fillEnums : K -> K .
	op fillEnums : K Nat -> K .
	mb rule
		< k > EnumDef(X:Id, L:List{C}) => fillEnums(EnumDef(X:Id, L:List{C})) ...</ k >
		: KSentence .
	mb rule < k > fillEnums(K:K) => fillEnums(K:K, 0) ...</ k > : KSentence .
	mb rule
		< k > fillEnums(EnumDef(X:Id, enumItem(E:Id, emptyValue) :: L:List{C}), N:Nat) 
			=> declare(typedDeclaration(int, E:Id), SingleInit(tv(N:Nat, int)))
			~> fillEnums(EnumDef(X:Id, L:List{C}), sNat(N:Nat)) 
		...</ k >
		: KSentence .
	mb rule
		< k > fillEnums(EnumDef(X:Id, enumItem(E:Id, tv(N:Nat, int)) :: L:List{C}), ?) 
			=> declare(typedDeclaration(int, E:Id), SingleInit(tv(N:Nat, int)))
			~> fillEnums(EnumDef(X:Id, L:List{C}), sNat(N:Nat))
		...</ k >
		: KSentence .
	mb rule
		< k > fillEnums(EnumDef(X:Id, Nil), ?) => (.).K ...</ k > : KSentence .
	
	--- this maintains byte order
	op fillToBytes-aux : K List{K} -> K .
	eq fillToBytes(dataList(L:List{K})) = fillToBytes-aux(dataList(L:List{K}), .List{K}) .
	ceq fillToBytes-aux(dataList((L:List{K},, piece(N:Nat, Len:Nat))), L':List{K}) 
		= fillToBytes-aux(dataList(L:List{K}), (piece(N:Nat, Len:Nat),, L':List{K}))
		if Len:Nat ==Bool numBitsPerByte .
	
	ceq fillToBytes-aux(dataList(piece(N:Nat, Len:Nat)), L':List{K})
		= fillToBytes-aux(dataList((piece(0, 1),, piece(N:Nat, Len:Nat))), L':List{K})
		if Len:Nat <Nat numBitsPerByte .
		
	ceq fillToBytes-aux(dataList((L:List{K},, piece(N:Nat, Len:Nat),, piece(N':Nat, Len':Nat))), L':List{K}) 
		= fillToBytes-aux(dataList((L:List{K},, piece(_bit::_(piece(N:Nat, Len:Nat), piece(N':Nat, Len':Nat)), Len:Nat +Nat Len':Nat))), L':List{K})
		if Len:Nat +Nat Len':Nat <=Nat numBitsPerByte .
				
	eq fillToBytes-aux(dataList(.List{K}), L:List{K})
		= dataList(L:List{K}) .
		
	--- coallesce bitranges that are adjacent
	ceq _bit::_(piece(bitRange(N:Nat, sNat(To:Nat), To':Nat), Len:Nat), piece(bitRange(N:Nat, From:Nat, To:Nat), Len':Nat)) 
		= piece(bitRange(N:Nat, From:Nat, To':Nat), Len:Nat +Nat Len':Nat) 
		if Len:Nat +Nat Len':Nat <=Nat numBitsPerByte .
	
	eq piece(N:Nat bit:: N':Nat, Len:Nat) bit:: piece(N'':Nat, Len':Nat)
		= piece(N:Nat bit:: N':Nat bit:: piece(N'':Nat, Len':Nat), Len:Nat +Nat Len':Nat) .
	--- eq piece(N':Nat, Len:Nat) bit:: piece(N'':Nat, Len':Nat)
		--- = piece(N':Nat bit:: N'':Nat, Len:Nat +Nat Len':Nat) .
		
	eq piece(N'':Nat, Len':Nat) bit:: piece(N:Nat bit:: N':Nat, Len:Nat)
		= piece(piece(N'':Nat, Len':Nat) bit:: N:Nat bit:: N':Nat, Len:Nat +Nat Len':Nat) .
	--- eq piece(N'':Nat, Len':Nat) bit:: piece(N':Nat, Len:Nat)
		--- = piece(N'':Nat bit:: N':Nat, Len:Nat +Nat Len':Nat) .	
	
	--- ceq bitRange((N:Nat bit:: piece(bitRange(?, Start':Nat, End':Nat), Len':Nat)), Start:Nat, End:Nat)
	--- = bitRange(N:Nat, absInt(Start:Nat -Int (sNat(End':Nat) -Int Start':Nat)), absInt(End:Nat -Int (sNat(End':Nat) -Int Start':Nat)))
	--- if End':Nat <Nat Start:Nat
	--- andBool (sNat(End':Nat) -Int Start':Nat) >=Int 1
	--- andBool (Start:Nat -Int (sNat(End':Nat) -Int Start':Nat)) >=Int 0
	--- andBool (End:Nat -Int (sNat(End':Nat) -Int Start':Nat)) >=Int 0
	--- andBool (Start':Nat +Nat End':Nat ==Bool Len':Nat) .
	
	ceq bitRange(N:Nat bit:: piece(?, Len:Nat), Pos:Nat, Pos:Nat)
		= bitRange(N:Nat, absInt(Pos:Nat -Int Len:Nat), absInt(Pos:Nat -Int Len:Nat))
		if Pos:Nat >Nat 0
		andBool Pos:Nat -Int Len:Nat >=Int 0 .
		
	eq bitRange(? bit:: piece(N:Nat, 1), 0, 0) = piece(N:Nat, 1) .
	eq bitRange(piece(N:Nat, 1), 0, 0) = piece(N:Nat, 1) .
	--- ceq bitRange(piece(N:Nat, Len:Nat), 0, 0) 
		--- = bitRange(piece(N:Nat, Len:Nat), 0, 0) piece(N:Nat, 1) 
		--- if Len:Nat >=Nat 1 .
		
	ceq bitRange(piece(bitRange(N:Nat, Start:Nat, End:Nat), Len:Nat), 0, 0)
		= bitRange(piece(bitRange(N:Nat, Start:Nat, Start:Nat), 1), 0, 0) 
		if Start:Nat +Nat Len:Nat ==Bool sNat(End:Nat) .
	
	ceq bitRange(N:Nat, Pos:Nat, Pos:Nat) = 1 &Nat (N:Nat >>Nat Pos:Nat)
		if N:Nat >=Nat 0 .
	ceq bitRange(piece(N:Nat, 1), Pos:Nat, Pos:Nat) = 1 &Nat (N:Nat >>Nat Pos:Nat)
		if N:Nat >=Nat 0 .
		
	ceq bitRange(N:Nat, 0, To:Nat) = N:Nat
		if sNat(To:Nat) ==Bool numBitsPerByte .
	
	ceq bitRange(? bit:: piece(N:Nat, Len:Nat), Start:Nat, End:Nat) 
		= bitRange(piece(N:Nat, Len:Nat), Start:Nat, End:Nat)
		if sNat(End:Nat) <=Nat Len:Nat .
***(
piece(bitRange(piece(3, 2) bit:: piece(bitRange(unknown(8), 5, 5), 1) bit:: piece(15, 4), 0, 0), 1)
***)
	
	eq bitRange(piece(N:Nat, sNat(End:Nat)), 0, End:Nat)
		= piece(N:Nat, sNat(End:Nat)) .
	eq bitRange(? bit:: piece(N:Nat, sNat(End:Nat)), 0, End:Nat)
		= piece(N:Nat, sNat(End:Nat)) .
		
	ceq bitRange(piece(N:Nat, Len:Nat), Pos:Nat, Pos:Nat) = (N:Nat >>Nat Pos:Nat) &Nat 1
		if N:Nat >=Nat 0 .
	--- ceq _bit::_(piece(N:Nat, Len:Nat), piece(N':Nat, Len':Nat)) 
		--- = piece((N:Nat <<Nat Len':Nat) |Nat N':Nat, Len:Nat +Nat Len':Nat)
		--- if N:Nat >=Nat 0 andBool N':Nat >=Nat 0 .
		
	--- ceq piece(piece(N:Nat bit:: N':Nat, Len:Nat) bit:: piece(M:Nat, Len':Nat), Len'':Nat)
		--- = piece(N:Nat bit:: N':Nat bit:: M:Nat, Len'':Nat)
	--- if Len:Nat +Nat Len':Nat ==Bool Len'':Nat .
		
	eq Identifier("___missing_field_name") = #NoName .
endm

load common-c-conversions
load common-c-expressions
load common-c-statements
load common-c-standard-lib
load common-c-typing
load common-c-memory

mod COMMON-C-SEMANTICS is
	including COMMON-INCLUDE .
	including C-SEMANTICS-MISC .
	including COMMON-C-TYPING .
	including COMMON-INITIALIZATION .
	including COMMON-GLOBAL-DECLARATION .
	including COMMON-C-MEMORY .
	including COMMON-C-STATEMENTS .
	including COMMON-C-EXPRESSIONS .
	including COMMON-PARAMETER-BINDING .
	including COMMON-C-CONVERSIONS .
	including COMMON-C-STANDARD-LIBRARY .
	---including COMMON-LOCAL-DECLARATION .
	
	op eval : K -> Bag .
	op eval : K List{K} String -> Bag .
endm