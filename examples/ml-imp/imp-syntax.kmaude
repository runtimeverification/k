load ml-prelude.maude


kmod IMP-SYNTAX is including ML-K
  sort Val Exp
  sort Void NvExpType ExpType
  sort Stmt Stmts
  sort StmtAnnot DeclAnnot DeclAnnots
  sort Decl Decls
  subsort Void NvExpType < ExpType
  subsort Int++ < Val
  subsort Id Val < Exp
  subsort StmtAnnot Decl < Stmt
  subsort Stmt Decls < Stmts
  subsort DeclAnnot < DeclAnnots
  subsort Decl < Decls


  op NULL : -> Exp
  op void : -> Void
  op int : -> NvExpType

  op *_ : Exp -> Exp [prec 10 metadata "strict"]
  op _+_ : Exp Exp -> Exp [prec 33 gather (E e) metadata "strict"]
  op _-_ : Exp Exp -> Exp [prec 33 gather (E e) metadata "strict"]
  op _*_ : Exp Exp -> Exp [prec 31 gather (E e) metadata "strict"]
  op _/_ : Exp Exp -> Exp [prec 31 gather (E e) metadata "strict"]
  op _%_ : Exp Exp -> Exp [prec 29 gather (E e) metadata "strict"]
  op -_ : Exp -> Exp  [metadata "strict"]
  op _>=_ : Exp Exp -> Exp  [prec 35 metadata "strict"]
  op _>_ : Exp Exp -> Exp  [prec 35 metadata "strict"]
  op _<=_ : Exp Exp -> Exp  [prec 35 metadata "strict"]
  op _<_ : Exp Exp -> Exp  [prec 35 metadata "strict"]
  op _==_ : Exp Exp -> Exp  [prec 35 metadata "strict"]
  op _!=_ : Exp Exp -> Exp  [prec 35]
  op !_ : Exp -> Exp [prec 5 metadata "strict"]
  op _&&_ : Exp Exp -> Exp [prec 55 gather(E e) metadata "strict(1)"]
  op _||_ : Exp Exp -> Exp [prec 57 gather(E e) metadata "strict(1)"]
  op _?_:_ : Exp Exp Exp -> Exp [prec 59 metadata "strict(1)"]

  op _=_; : Exp Exp -> Stmt [prec 60 metadata "strict(2)"]
  op {} : -> Stmt
  op {_} : Stmts -> Stmt [gather(&)]
  op __ : Stmts Stmts -> Stmts [prec 100 gather(e E)]
  op __ : Decls Decls -> Decls [ditto]
  ---op __ : DeclAnnots DeclAnnots -> DeclAnnots [prec 100 gather(e E)]
  op __; : ExpType List{Id} -> Stmt
  op _; : Exp -> Stmt [prec 65 metadata "strict"]
  op if`(_`)_else_ : Exp Stmt Stmt -> Stmt [prec 93 metadata "strict(1)"]
  op if`(_`)_ : Exp Stmt -> Stmt [prec 95]
  op while`(_`)_ : Exp Stmt -> Stmt
  op __`(`)_`{_`} : ExpType Id DeclAnnot Stmts -> Decl
  op __`(_`)_`{_`} : ExpType Id List{Id} DeclAnnot Stmts -> Decl
  op _`(`) : Id -> Exp
  op _`(_`) : Id List{Exp} -> Exp [prec 2 metadata "strict(2)"]
  op return; : -> Stmt
  op return_; : Exp -> Stmt [metadata "strict"]

  ---op alloc`(_`) : List{KLabel} -> Stmt [metadata "strict"]
  ---op free`(_`) : Exp -> Exp [metadata "strict"]

  ops //`assume_ //`assert_ //`invariant_ : Bag -> StmtAnnot [prec 99 strat(0)]
  op //`pre_//`post_ : Bag Bag -> DeclAnnot [prec 99 strat(0)]

  op load : Int++ -> Exp
  op store : Int++ Exp -> Exp [metadata "strict"]
  op return : ExpType -> Exp
  op functionEnd : -> Stmt

  op breakpoint; : -> Stmt
  op watch; : -> Stmt


  sort List{Id}
  subsorts Id < List{Id}
  op .List{Id} : -> List{Id}
  op _`,`,`,_ : List{Id} List{Id} -> List{Id} [assoc id: .List{Id}]
  sort List{Val}
  subsorts Val < List{Val}
  op _`,`,`,_ : List{Val} List{Val} -> List{Val} [ditto]
  sort List{Exp}
  subsorts Exp List{Id} List{Val} < List{Exp}
  op _`,`,`,_ : List{Exp} List{Exp} -> List{Exp} [ditto]
endkm

kmod IMP-DESUGARED-SYNTAX is including IMP-SYNTAX
--------------------------------------------------------------------------------
--- This module desugars some of IMP's language constructs into core ones    ---
--- The idea is that we only want to give semantics to core constructs,      ---
--- so we get rid of the derived ones before we start the semantics          ---
--------------------------------------------------------------------------------
  kvar T : ExpType
  kvar F : Id
  kvar E E1 E2 : Exp
  kvar S : Stmt
  kvar Ss : Stmts
  kvar DA : DeclAnnot
  eq NULL = 0
  eq E1 != E2 = !(E1 == E2)
  eq if (E) S = if(E) S else {}

  eq T F() DA { Ss } = T F(.List{Id}) DA { Ss }
  eq F() = F(.List{Id})
endkm

