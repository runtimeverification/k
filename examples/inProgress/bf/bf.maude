load ../../k-prelude
mod BF is
	including K-PROPER .
	including K-MAP-EXTRAS .
	including K-RULES .
	including K-CONFIG .
	including PL-INT .
	including PL-STRING .
	including K .
--- Syntax
	op memory : -> CellLabel .
	op output : -> CellLabel .
	op result : -> CellLabel .
	op input : -> CellLabel .
	op k : -> CellLabel .

	--- comments from http://en.wikipedia.org/wiki/Brainfuck
	op Seq : -> KProperLabel [metadata "arity 2"] .
	op GoRight : -> KProperLabel [metadata "arity 0"] . --- increment the data pointer (to point to the next cell to the right).
	op GoLeft : -> KProperLabel [metadata "arity 0"] . --- decrement the data pointer (to point to the next cell to the left).
	op Increase : -> KProperLabel [metadata "arity 0"] . --- increment (increase by one) the byte at the data pointer.
	op Decrease : -> KProperLabel [metadata "arity 0"] . --- decrement (decrease by one) the byte at the data pointer.
	op Print : -> KProperLabel [metadata "arity 0"] . --- output the value of the byte at the data pointer.
	op Read : -> KProperLabel [metadata "arity 0"] . --- accept one byte of input, storing its value in the byte at the data pointer.
	op While : -> KProperLabel [metadata "arity 1"] .
	--- [ 	if the byte at the data pointer is zero, then instead of moving 
	---		the instruction pointer forward to the next command, jump it 
	---		forward to the command after the matching ] command*.
	--- ] 	if the byte at the data pointer is nonzero, then instead of moving 
	---		the instruction pointer forward to the next command, jump it back 
	---		to the command after the matching [ command*.
	
--- Semantics
	op sentinel : -> KLabel .
	op eval : K -> Bag .
	op eval : K K -> Bag .
	op inject : Int -> KResultLabel .
	op inject : String -> KResultLabel .
	
	--- helper functions.  can the basic ones be auto generated?
	op eightbit : -> KLabel .
	mb rule [
		eightbit(inject(I:Int)(.List{K})) 
		=> inject((((I:Int %Int 256) +Int 256) %Int 256))(.List{K})
	] : KSentence .
	
	op kcharString : -> KLabel .
	mb rule [
		kcharString(inject(N:Nat)(.List{K})) 
		=> inject(charString(N:Nat))(.List{K})
	] : KSentence .

	op +String : -> KLabel .
	mb rule [
		+String(inject(S1:String)(.List{K}),, inject(S2:String)(.List{K})) 
		=> inject(S1:String +String S2:String)(.List{K})
	] : KSentence .
	
	op firstChar : -> KProperLabel [metadata "arity 1"] .
	op butFirstChar : -> KProperLabel [metadata "arity 1"] .
	op charToAscii : -> KProperLabel [metadata "arity 1"] .
	
	mb [firstChar]: rule
		[firstChar(inject(S:String)(.List{K})) => inject(substrString(S:String, 0, 1))(.List{K})]
		: KSentence [metadata "structural"] .
	mb [charToAscii]: rule
		[charToAscii(inject(C:Char)(.List{K})) => inject(asciiString(C:Char))(.List{K})]
		: KSentence [metadata "structural"] .
	mb [butFirstChar]: rule
		[butFirstChar(inject(S:String)(.List{K})) => inject(substrString(S:String, 1, lengthString(S:String)))(.List{K})]
		: KSentence [metadata "structural"] .
	--- end helper functions
	
	mb configuration 
		< T >
			< k > K:K </ k >
			< memory > L:List </ memory >
			< output > K:K </ output >
			< input > K:K </ input >
		</ T >  
		< result > K:K </ result > 
		: KSentence .
	
	eq [Start]: eval(K:K) =
		< T >
			< k > K:K </ k >
			< memory > ListItem(sentinel(.List{K})) </ memory >
			< output > inject("")(.List{K}) </ output >
			< input > inject("")(.List{K}) </ input >
		</ T > .
		
	eq [Start-With-Input]: eval(K:K, K':K) = 
		< T >
			< k > K:K </ k >
			< memory > ListItem(sentinel(.List{K})) </ memory >
			< output > inject("")(.List{K}) </ output >
			< input > K':K </ input >
		</ T > .

	mb [Finish]: rule [
		< T > S:Bag < k > .K </ k > < output > K:K </ output > </ T > 
			=> < result > K:K </ result >
		] : KSentence [metadata "structural"] .
		
	mb rule
		< memory > [ListItem(sentinel(.List{K})) => ListItem(inject(0)(.List{K})) ListItem(sentinel(.List{K}))] ...</ memory > 
		: KSentence [metadata "structural"] .
		
	mb [Sequence]: rule
		[Seq(K1:K,, K2:K) => K1:K ~> K2:K]
		: KSentence [metadata "structural"] .
		
	mb [Increase]: rule 
		< k > [Increase(.List{K}) => .K] ...</ k >
		< memory > ListItem([inject(I:Int)(.List{K}) => (inject(I:Int +Int 1))(.List{K})]) ...</ memory > 
		: KSentence [metadata "structural"] .
	mb [Decrease]: rule 
		< k > [Decrease(.List{K}) => .K] ...</ k >
		< memory > ListItem([inject(I:Int)(.List{K}) => (inject(I:Int -Int 1))(.List{K})]) ...</ memory > 
		: KSentence [metadata "structural"] .
	
	mb [WhileNZ-NZ]: rule 
		< k > [While(K:K) => K:K ~> While(K:K)] ...</ k > 
		< memory > ListItem(inject(I:Int)(.List{K})) ...</ memory > 
		if (I:Int =/=Bool 0) 
		: KSentence [metadata "structural"] .
	mb [WhileNZ-Z]: rule 
		< k > [While(K:K) => .K] ...</ k >
		< memory > ListItem(inject(0)(.List{K})) ...</ memory > 
		: KSentence [metadata "structural"] .
		
	mb [GoRight]: rule 
		< k > [GoRight(.List{K}) => .K] ...</ k > 
		< memory > [Li:ListItem L:List => L:List Li:ListItem] </ memory > 
		: KSentence [metadata "structural"] .
	mb [GoLeft]: rule 
		< k > [GoLeft(.List{K}) => .K] ...</ k > 
		< memory > [L:List Li:ListItem => Li:ListItem L:List] </ memory > 
		: KSentence [metadata "structural"] .
		
	mb [Output]: rule 
		< k > [Print(.List{K}) => .K] ...</ k > 
		< memory > ListItem(I:K) ...</ memory > 
		< output > [S:K => +String(S:K,, kcharString(eightbit(I:K)))] </ output > 
		: KSentence [metadata "structural"] .
	mb [Input]: rule
		< k > [Read(.List{K}) => .K] ...</ k >
		< memory > ListItem([inject(I:Int)(.List{K}) => charToAscii(firstChar(Input:K))]) ...</ memory > 
		< input > [Input:K => butFirstChar(Input:K)] </ input > 
		: KSentence [metadata "structural"] .
endm

