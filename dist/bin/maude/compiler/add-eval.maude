fmod ADD-EVAL is
  including  K-META-CONFIG .
  including META-K-WRAPPERS .
  including META-K-STREAMS .

  op evalS : -> Qid .
  eq evalS = '#eval_ .

  ops stdinVariable noIOVariable : -> Variable .
  eq stdinVariable = mkVariable('$stdin,K) .
  eq noIOVariable = mkVariable('$noIO,List) .


  op addEval : Qid Module Term ~> Module .
  eq addEval(O, M, T) 
   = setName(addEval(M, T, noDuplicates(getVars(T))), O) .

  op addEval : Module Term TermList ~> Module .
  eq addEval(M, T, Tl) 
   = addSubsorts((subsort String < K .),
       addEqs(defaultEvalEqs(Tl,stdinVariable,noIOVariable)
              mainEvalEq(evalCleanConf(T), evalMap(Tl)),
              M)) .


  op defaultEvalEqs_ : TermList -> EquationSet .
  eq defaultEvalEqs(empty) = none . 
  eq defaultEvalEqs(V,Tl)
   = (ceq evalS[mkVariable('M,Map)]
       = evalS[ctor(Map)[itemCtor(Map)[stringCt(string(getName(V))),wrap2K(emptyCt(getType(V)))],mkVariable('M,Map)]]
       if '_in_[stringCt(string(getName(V))), 'keys_[mkVariable('M,Map)]] = falseCt 
       [none] .)
      defaultEvalEqs(Tl) .


  op evalMap_ : TermList -> TermList .
  eq evalMap(empty) = itemCtor(Map)[stringCt(string(getName(stdinVariable))), wrap2K(stdinVariable)],
                      itemCtor(Map)[stringCt(string(getName(noIOVariable))), wrap2K(noIOVariable)],
                        mkVariable('AndTheOthers, Map) .
  eq evalMap(V, Tl) = itemCtor(Map)[stringCt(string(getName(V))),wrap2K(V)],evalMap(Tl) .

  op mainEvalEq : TermList TermList -> Equation .
  eq mainEvalEq(empty, Tl) = mainEvalEq(emptyCt(Bag), Tl) .
  eq mainEvalEq(T, Tl)  
   = (eq evalS[mkCollection(Map,Tl)] = T  [none] .) .

  op evalCleanConf : Term -> TermList .
  eq evalCleanConf(T) = evalCleanConf(T,splitKCell(T)) .
  op evalCleanConf : Term [SplitCell] -> TermList .
  eq evalCleanConf(T, SC')
   = if SC' :: SplitCell then if getMultiplicity(SC') == maybe or  getMultiplicity(SC') == any then checkEmpty(SC', evalCleanConf(getContents(SC'), getConnection(SC')))
     else plugCell(setAttributes(setContents(SC',evalCleanConf(getContents(SC'), getConnection(SC'))),initialCellAttrs)) fi
     else $evalCleanConf(T) fi .
  op $evalCleanConf : Term -> TermList .
  eq $evalCleanConf(Ct) = Ct .
  eq $evalCleanConf(V) = V .
  eq $evalCleanConf(Q[Tl]) = $checkEmpty(Q,$evalCleanConfL(Tl)) .
  op $evalCleanConfL_ : TermList -> TermList .
  eq $evalCleanConfL(T,Tl) = evalCleanConf(T),$evalCleanConfL(Tl) .
  eq $evalCleanConfL(empty) = empty .


  op evalCleanConf : Term [String] -> TermList .
  eq evalCleanConf(T, "stdin") = mkCollection(List, (T, ioBuffer(stdinVariable), noIOVariable, stdinStream)) .
  eq evalCleanConf(T, "stdout") = mkCollection(List, (stdoutStream, noIOVariable, ioBuffer(nilK),T)) .
  eq evalCleanConf(T, S:[String]) = evalCleanConf(T) [owise] .

 
  eq setContents(SC, empty) = setContents(SC, emptyCt(Bag)) .

  op checkEmpty : SplitCell TermList -> TermList [strat (2 0 1)] . 
  eq checkEmpty(SC, empty) = empty . 
  eq checkEmpty(SC, T) 
   = if getVars(T) == empty
     then empty 
     else plugCell(setAttributes(setContents(SC,T),initialCellAttrs))
     fi . 

  op $checkEmpty : Qid TermList -> TermList .
  eq $checkEmpty(Q, empty) = empty .
  ceq $checkEmpty(Q, T) = T if Q == ctor(Bag) .
  eq $checkEmpty(Q, Tl) = Q[Tl] [owise] .

  var O Q : Qid . var T : Term . var Tl : TermList .  var V : Variable .
  var Ct : Constant .
  var M : Module . 
  var SC' : [SplitCell] .  var SC : SplitCell .
endfm

