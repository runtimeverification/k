mod #REXP is protecting #BOOL .

  sort Set{Obj} .
  op emptyObj : -> Set{Obj} .
  op _;;_ : Set{Obj} Set{Obj} -> Set{Obj} [assoc comm id: emptyObj] .

  sorts #Var #Alph #Rexp .
  subsort #Var < #Alph < #Rexp .
  vars A B : #Alph .
  vars R R1 R2 : #Rexp . 
  var DRL RL : List{Rexp} .

  ops epsilon empty : -> #Rexp .
  ops (_++_) (_x_) : #Rexp #Rexp -> #Rexp [assoc comm] .
  ops (_#_) : #Rexp #Rexp -> #Rexp [gather (E e)] .
  op _* : #Rexp -> #Rexp .
  op !_ : #Var -> #Alph .

  op _==Rexp_ : #Rexp #Rexp -> #Bool .

  *** derivatives
  op _`{_`} : #Rexp #Alph -> #Rexp .
  ceq B { A } = epsilon if (A ==Rexp B) .
  ceq B { A } = empty if notBool (A ==Rexp B) .
---  eq epsilon { A } = empty .
---  eq empty { A } = empty .
  ceq ( R1 # R2 ){ A } = ((R1 { A }) # R2) ++ (R2 { A })
     if epsIn R1 = true .
  ceq ( R1 # R2 ){ A } = (R1 { A }) # R2 
     if epsIn R1 = false .
  eq ( R1 ++ R2 ){ A } = (R1 { A }) ++ (R2 { A }) .
  eq (R1 x R2) { A } = (R1 { A }) x (R2 {A}) .
  eq R * { A } = (R { A }) # (R *) .     


  op epsIn_ : #Rexp -> #Bool . 
  eq epsIn A = false .
  eq epsIn epsilon = true .
  eq epsIn empty = false .
  eq epsIn ! A = notBool epsIn A .  
  eq epsIn ( R1 # R2 ) =  epsIn R1 andBool  epsIn R2 .
  eq epsIn ( R1 ++ R2 ) = epsIn R1 orBool  epsIn R2 .
  eq epsIn (R1 x R2) = epsIn R1 andBool  epsIn R2 . 
  eq epsIn R * = true .


  *** auxiliary data structures
  sort List{Rexp} .
  subsort #Rexp < List{Rexp} .
  op emptyList : -> List{Rexp} .
  op _;;;_ : List{Rexp} List{Rexp} -> List{Rexp} [assoc comm id: emptyList] .
  op _==List{Rexp}_ : List{Rexp} List{Rexp} -> #Bool .

  op _in_ : #Rexp List{Rexp} -> #Bool .
  eq R in emptyList = false .
  eq R in (R1 ;;; RL) = (R ==Rexp R1) orBool (R in RL ) . 

  op !_ : List{Rexp} -> List{Rexp} .
  eq !(emptyList) = emptyList .
  ceq !(R ;;; RL) = !(R) ;;; !(RL) if notBool (RL ==List{Rexp} emptyList) .

endm

 
