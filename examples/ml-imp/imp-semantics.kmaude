load imp-syntax.kmaude

mod UTILS is including PL-INT .
  op isInt : Int -> Bool .
  var I : Int .
---  eq isInt(I) = I :: Int .
endm

kmod IMP-SEMANTICS is including IMP-DESUGARED-SYNTAX + UTILS
  subsort Val <  KResult
  subsort Stmts Exp < K

  kvar M N N1 N2 : Nat
  kvar I I' I1 I2 : Int++
  kvar NzI : NzInt
  kvar F X : Id
  ---var Xl : List{Id}
  kvar V V1 V2 : Val
  ---var Vl : List{Val}
  kvar E E1 E2 : Exp
  kvar S S1 S2 : Stmt
  kvar Ss : Stmts
  kvar K : K
  kvar Phi Phi' : Formula
  kvar Subst Subst' : Subst
  kvar Cfg : BagItem
  kvar Cfgs CfgItems : Bag


  configuration <T> 
                  <feasible > 0 </feasible>
                  <infeasible > 0 </infeasible>
                  <config>
                    <k> .K </k>
                    <env> .Map </env>
                    <heap> .Map </heap>
                    <form>  TrueFormula </form>
                    <subst> .K </subst>
                    <newSym>  0 </newSym>
                    <newImpl> 0 </newImpl>
                  </config>
                </T>


  rule I1 + I2 => I1 +Int I2
  rule _-_(I1, I2) => _-Int_(I1, I2)
  rule _*_(I1, I2) => I1 *Int I2
  rule I1 / I2 => I1 /Int I2
  rule I1 % I2 => I1 %Int I2
  rule - I => -Int I
  rule I1 >= I2 => ?_(I1 >=Int I2)
  rule I1 > I2 => ?_(I1 >Int I2)
  rule I1 <= I2 => ?_(I1 <=Int I2)
  rule I1 < I2 => ?_(I1 <Int I2)
  rule I1 == I2 => ?_(I1 ==Int I2)

---  rule I && E => (I ? 1 : 0) && E if notBool(isInt(I))
  rule NzI && E => E
  rule 0 && E => 0
---  rule I || E => (I ? 1 : 0) || E if notBool(I :: Int)
  rule NzI || E => NzI
  rule 0 || E => E
---  rule ! I => I ? 0 : 1 if notBool(I :: Int)
  rule ! NzI => 1
  rule ! 0 => 1

  rule
    < config >
      < k > (I ? E1 : E2) ~> K </ k >
      < form > Phi </ form >
      CfgItems
    </ config >
  =>
    < config >
      < k > E1 ~> K </ k >
      < form > Phi /\ ~(I === 0) </ form >
      CfgItems
    </ config >
    < config >
      < k > E2 ~> K </ k >
      < form > Phi /\ I === 0 </ form >
      CfgItems
    </config>
  rule NzI ? E1 : E2 => E1
  rule 0 ? E1 : E2 => E2

  rule V ; => .K
  rule {} => .K
  rule { Ss } => Ss
  rule S1 S2 => S1 ~> S2

  rule
    <k> X => V <_/k> 
    <env_> X |-> V <_/env>
  rule
    <k> X = V ; => .K <_/k>
    <env_> X |-> (_ => V) <_/env>

  rule <k> * I => derive(I) ~> load(I) <_/k>
  context (* [HOLE]) = _ ;
  rule <k> (* I) = V ; => derive(I) ~> store(I, V) <_/k>
  rule
    <k> derive(I) => .K <_/k>
    <heap_> I |-> _ <_/heap>
  rule
    <k> load(I) => V <_/k>
    <heap_> I |-> V <_/heap>
  rule
    <k> store(I, V) => .K <_/k>
    <heap_> I |-> (_ => V) <_/heap>


---  rule if (I) S1 else S2 => if (I ? 1 : 0) S1 else S2 if notBool(I :: Int)
  rule if (NzI) S else _ => S
  rule if (0) _ else S => S

  rule
    <k>
      (// invariant Cfgs ~> while (E) S ~> K)
    =>
      (// assert Cfgs ~> 'if`(_`)_else_(E,, { S // assert Cfgs },, K))
    </k>

  rule
    <config_> 
      <k>
        // assume <config> <form> Phi' </form> CfgItems </config> Cfgs ~> K
      =>
        // assume Cfgs ~> K
      </k>
      <form> Phi </form>
      <subst> Subst </subst>
      <newSym> M </newSym>
      <newImpl> N </newImpl>
    <_/config>
    (
      .Bag
    =>
      <config>
        <k> K </k>
        <form> Phi /\ Phi'[Subst] </form>
        <subst> Subst </subst>
        <newSym> M </newSym>
        <newImpl> N </newImpl>
        CfgItems
      </config>
    )

  rule <config_> <k> // assume .Bag <_/k> <_/config> => .Bag

  rule
    < config >
      < k > // assert Cfgs => // assume Cfgs <_/ k >
      < subst > Subst => Subst' </ subst >
      < newSym > M </ newSym >
      < newImpl > N => N +Int 1 </ newImpl >
      (CfgItems => skolemize(N, CfgItems))
    </ config >
  if search(
    < config >
      < subst > Subst </ subst >
      < newImpl > N </ newImpl >
      CfgItems
    </ config >
    ===>
    Cfgs
  =>
    < config >
      < form > TrueFormula </ form >
      < subst > Subst' </ subst >
    </ config >
  )
endkm

