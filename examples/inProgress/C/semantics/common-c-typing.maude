--- FIXME need to automatically pad structs
mod COMMON-SEMANTICS-TYPE-INCLUDE is
	including COMMON-INCLUDE .
	
	op isAType_ : K -> Bool .
	op extractActualType : Type -> Type . --- rules that use specifier should be careful to use extractActualType if going to be used in a typed name
	op evalToType : -> K .
endm

mod COMMON-SEMANTICS-TYPE-DECLARATIONS is
	including COMMON-SEMANTICS-TYPE-INCLUDE .

	op giveGlobalType : K Type -> K .
	op giveLocalType : K Type -> K .
	
	--- FIXME these are here until I decide how to handle qualified types
	eq qualifiedType(T:Type, Volatile) = T:Type .
	eq qualifiedType(T:Type, Restrict) = T:Type .
	eq qualifiedType(T:Type, Const) = T:Type .
	eq qualifiedType(T:Type, Auto) = T:Type .
	eq qualifiedType(T:Type, Register) = T:Type .
	
	
	mb rule
		< k > giveType(X:Id, T:Type) => 
			if (Fun:Id ==Bool File-Scope) then giveGlobalType(X:Id, T:Type) else giveLocalType(X:Id, T:Type) fi
			...</ k >
		< currentFunction > Fun:Id </ currentFunction >
		if notBool hasStaticType(T:Type)
		: KSentence [metadata "structural"] .
	--- mb rule
		--- < k > giveType(X:Id, (qualifiedType(T:Type, Static) => T:Type)) ...</ k >
		--- : KSentence [metadata "structural"] .
		
	mb rule
		< k > giveGlobalType(X:Id, T:Type) => (.).K ...</ k >
		< types > M:Map => M:Map[T:Type / X:Id] </ types >
		--- < gtypes > M':Map => M':Map[T:Type / K:K] </ gtypes >
		< gtypes >... Tu:K |-> Map((M':Map => M':Map[T:Type / X:Id])) ...</ gtypes >
		< currentTranslationUnit > Tu:K </ currentTranslationUnit >
		: KSentence [metadata "structural"] .
	mb rule
		< k > giveLocalType(X:Id, T:Type) => (.).K ...</ k >
		< types > M:Map => M:Map[T:Type / X:Id] </ types >
		: KSentence [metadata "structural"] .		
			
	--- --- fixme hack for (int )(b705 + 0)->b6[0].b4.b1
	--- mb rule 
		--- < type > [X:Id + I:Int => X:Id] ...</ type >
		--- : KSentence [metadata "structural"] .
	--- mb rule 
		--- < type > [X:Id - I:Int => X:Id] ...</ type >
		--- : KSentence [metadata "structural"] .
endm

mod COMMON-SEMANTICS-TYPE-STRICTNESS is
	including COMMON-SEMANTICS-TYPE-INCLUDE .
	
	op waitingOnDeclType : -> K .
	mb [type-Cast-heat]: rule
		< k > (. => DeclType(Specifier:K, DeclType:K)) ~> evalToType ...</ k >
		< type > Cast(Specifier:K, DeclType:K, ?) => waitingOnDeclType ...</ type >
		: KSentence [metadata "structural"] .
		
	mb [type-Cast-cool]: rule
		< k > (T:Type => .) ~> evalToType ...</ k >
		< type > waitingOnDeclType => T:Type ...</ type >
		: KSentence [metadata "structural"] .
	
	mb [type-arrow-heat]: rule
		< type > Kp:KProper -> F:Id => Kp:KProper ~> HOLE -> F:Id ...</ type >
		: KSentence [metadata "structural"] .
	mb [type-arrow-cool]: rule
		< type > T:Type ~> HOLE -> F:Id => T:Type -> F:Id ...</ type >
		: KSentence [metadata "structural"] .
	mb [type-plus-heat]: rule
		< type > K:K + K':K => K:K ~> HOLE + K':K ...</ type >
		if notBool isAType(K:K)
		: KSentence [metadata "structural"] .
	mb [type-plus-cool]: rule
		< type > T:Type ~> HOLE + K:K => T:Type + K:K ...</ type >
		if isAType(T:Type)
		: KSentence [metadata "structural"] .
	mb [type-plus-heat]: rule
		< type > K:K + K':K => K':K ~> K:K + HOLE ...</ type >
		if notBool isAType(K':K)
		: KSentence [metadata "structural"] .
	mb [type-plus-cool]: rule
		< type > T:Type ~> K:K + HOLE => K:K + T:Type ...</ type >
		if isAType(T:Type)
		: KSentence [metadata "structural"] .
		
	mb [type-dot-heat]: rule
		< type > K:K . X:Id => K:K ~> HOLE . X:Id ...</ type >
		if notBool isAType(K:K)
		: KSentence [metadata "structural"] .
	mb [type-dot-cool]: rule
		< type > T:Type ~> HOLE . X:Id => T:Type . X:Id ...</ type >
		if isAType(T:Type)
		: KSentence [metadata "structural"] .
	--- mb rule
		--- < type > ['_`[_`](Kp:KProper,, E:Expression) => Kp:KProper ~> Deref(HOLE)] ...</ type >
		--- : KSentence [metadata "structural"] .
	mb rule
		< type > T:Type ~> *(HOLE) => *(T:Type) ...</ type >
		if isAType(T:Type)
		: KSentence [metadata "structural"] .
	mb [type-heat-deref]: rule
		< type > *(K:K) => K:K ~> *(HOLE) ...</ type >
		if notBool isAType(K:K)
		: KSentence [metadata "structural"] .
		
	mb [type-heat-call]: rule
		< type > Call(K:K, L:List{C}) => K:K ~> Call(HOLE, L:List{C}) ...</ type >
		if notBool isAType(K:K)
		: KSentence [metadata "structural"] .
	mb [type-cool-call]: rule
		< type > T:Type ~> Call(HOLE, L:List{C}) => Call(T:Type, L:List{C}) ...</ type >
		if isAType(T:Type)
		: KSentence [metadata "structural"] .
	--- mb context Call(?:K,, (?,, `[HOLE`]:K,, ?)) : KSentence .
endm

mod COMMON-SEMANTICS-TYPE-CANONICALIZATION is
	including COMMON-SEMANTICS-TYPE-INCLUDE .
	
	op canonicalizeType : Bag -> K .
	op canonicalizeType : Bag K Bag Bag Bag -> K [metadata "strict(2)"] .
		
	mb rule
		< k > canonicalizeType(B:Bag) => canonicalizeType(B:Bag, (.).K, (.).Bag, (.).Bag, (.).Bag) ...</ k >
		: KSentence .
		
	--- specifier, modifier, storage
	mb rule
		< k > canonicalizeType((B:Bag (BagItem(T:K) => (.).Bag)), ?, (? ((.).Bag => BagItem(T:K))), ?, ?) ...</ k >
		if false
		orBool (T:K ==Bool Void)
		orBool (T:K ==Bool Char)
		orBool (T:K ==Bool Short)
		orBool (T:K ==Bool Int)
		orBool (T:K ==Bool Long)
		orBool (T:K ==Bool Float)
		orBool (T:K ==Bool Double)
		orBool (T:K ==Bool Signed)
		orBool (T:K ==Bool Unsigned)
		orBool (getKLabel(T:K) ==Bool 'StructDef)
		orBool (getKLabel(T:K) ==Bool 'UnionDef)
		orBool (getKLabel(T:K) ==Bool 'EnumDef)
		orBool (getKLabel(T:K) ==Bool 'StructRef)
		orBool (getKLabel(T:K) ==Bool 'UnionRef)
		orBool (getKLabel(T:K) ==Bool 'EnumRef)
		orBool (getKLabel(T:K) ==Bool 'Named)
		orBool (getKLabel(T:K) ==Bool 'AttributeValue)
		--- orBool (T:K ==Bool Complex)
		: KSentence .
	
	mb rule
		< k > canonicalizeType(B:Bag (BagItem(T:K) => (.).Bag), ?, ?, (? (.).Bag => BagItem(T:K)), ?) ...</ k >
		if (T:K ==Bool SpecTypedef)
		orBool (T:K ==Bool Inline)
		: KSentence .

	mb rule
		< k > canonicalizeType(B:Bag (BagItem(T:K) => (.).Bag), ?, ?, ?, (? (.).Bag => BagItem(T:K))) ...</ k >
		if T:K ==Bool Extern
		orBool T:K ==Bool Static
		orBool T:K ==Bool Const
		orBool T:K ==Bool Volatile
		orBool T:K ==Bool Restrict
		orBool T:K ==Bool Auto
		orBool T:K ==Bool Register
		: KSentence .
		
	mb rule
		< k > canonicalizeType((.).Bag, (T:Type => qualifiedType(T:Type, Q:K)), (.).Bag, (.).Bag, (? BagItem(Q:K) => (.).Bag)) ...</ k >
		if Q:K ==Bool Extern
		orBool Q:K ==Bool Static
		orBool Q:K ==Bool Const
		orBool Q:K ==Bool Volatile
		orBool Q:K ==Bool Restrict
		orBool Q:K ==Bool Auto
		orBool Q:K ==Bool Register
		: KSentence .
	
	--- fixme? getting rid of typedefs here.  this seems valid by c1x 6.7.7:3
	--- mb rule
		--- < k > canonicalizeSpecifier(BagItem(Named(X:Id)))
			--- => T:Type
		--- ...</ k >
		--- < types >... typedef(X:Id) |-> T:Type ...</ types >
		--- if X:Id =/=Bool Identifier("")
		--- : KSentence .
	mb rule
		< k > canonicalizeSpecifier(BagItem(Named(X:Id)))
			=> typedefType(X:Id, T:Type)
		...</ k >
		< types >... typedef(X:Id) |-> T:Type ...</ types >
		if X:Id =/=Bool Identifier("")
		: KSentence .
		
	mb rule
		< k > canonicalizeSpecifier(BagItem(StructRef(X:Id)))
			=> structType(X:Id)
		...</ k >
		if X:Id =/=Bool Identifier("")
		: KSentence .
	mb rule
		< k > canonicalizeSpecifier(BagItem(EnumRef(X:Id)))
			=> enumType(X:Id)
		...</ k >
		if X:Id =/=Bool Identifier("")
		: KSentence .
	mb rule
		< k > canonicalizeSpecifier(BagItem(UnionRef(X:Id)))
			=> unionType(X:Id)
		...</ k >
		if X:Id =/=Bool Identifier("")
		: KSentence .
		
	mb rule
		< k > canonicalizeSpecifier(BagItem(EnumDef(X:Id, L:List{C})))
			=> EnumDef(X:Id, L:List{C})
			~> enumType(X:Id)
		...</ k >
		if X:Id =/=Bool Identifier("")
		: KSentence .
	
	mb rule
		< k > canonicalizeSpecifier(BagItem(L:KLabel((Identifier("") => unnamed(N:Nat)),, L:List{C}))) ...</ k >
		< freshNat > N:Nat => sNat(N:Nat) </ freshNat >
		if L:KLabel ==Bool 'StructDef
		orBool L:KLabel ==Bool 'EnumDef
		orBool L:KLabel ==Bool 'UnionDef
		: KSentence .
	
	mb rule
		< k > canonicalizeSpecifier(BagItem(StructDef(X:Id, L:List{C})))
			=> StructDef(X:Id, L:List{C})
			~> structType(X:Id)
		...</ k >
		if X:Id =/=Bool Identifier("")
		: KSentence .
	mb rule
		< k > canonicalizeSpecifier(BagItem(UnionDef(X:Id, L:List{C})))
			=> UnionDef(X:Id, L:List{C})
			~> unionType(X:Id)
		...</ k >
		if X:Id =/=Bool Identifier("")
		: KSentence .
		
		
	--- FIXME what good is this?
	eq BagItem(SpecTypedef) = (.).Bag .
	--- fixme ignoring inlines since they shouldn't change the semantics?
	eq BagItem(Inline) = (.).Bag .
	--- fixme should save these for later use
	eq BagItem(AttributeValue(?, ?)) = (.).Bag .

	mb rule 
		< k > canonicalizeType((.).Bag, ((.).K => canonicalizeSpecifier(B:Bag)), (B:Bag => (.).Bag), ?, ?) ...</ k >
		if B:Bag =/=Bool (.).Bag
		: KSentence .
	--- fixme not sure where this is specified, but if i say "static x;" i think it means int
	mb rule 
		< k > canonicalizeType((.).Bag, ((.).K => canonicalizeSpecifier(BagItem(Int))), (.).Bag, ?, ?) ...</ k >
		: KSentence .
		
	mb rule
		< k > canonicalizeType((.).Bag, T:Type, (.).Bag, (.).Bag, (.).Bag) => T:Type ...</ k >
		: KSentence .
		
	op canonicalizeSpecifier : Bag -> K .
	--- C99 6.7.2:2
	eq canonicalizeSpecifier(BagItem(Void)) = void .
	eq canonicalizeSpecifier(BagItem(Char)) = char .
	eq canonicalizeSpecifier(BagItem(Signed) BagItem(Char)) = signed-char .
	eq canonicalizeSpecifier(BagItem(Unsigned) BagItem(Char)) = unsigned-char .
	
	eq canonicalizeSpecifier(BagItem(Double)) = double .
	eq canonicalizeSpecifier(BagItem(Float)) = float .
	eq canonicalizeSpecifier(BagItem(Long) BagItem(Double)) = long-double .
	
	ceq canonicalizeSpecifier(B:Bag) = short-int
		if B:Bag ==Bool BagItem(Short)
		orBool B:Bag ==Bool BagItem(Signed) BagItem(Short)
		orBool B:Bag ==Bool BagItem(Short) BagItem(Int)
		orBool B:Bag ==Bool BagItem(Signed) BagItem(Short) BagItem(Int) .
		
	ceq canonicalizeSpecifier(B:Bag) = unsigned-short-int
		if B:Bag ==Bool BagItem(Unsigned) BagItem(Short)
		orBool B:Bag ==Bool BagItem(Unsigned) BagItem(Short) BagItem(Int) .
	
	ceq canonicalizeSpecifier(B:Bag) = int
		if B:Bag ==Bool BagItem(Int)
		orBool B:Bag ==Bool BagItem(Signed)
		orBool B:Bag ==Bool BagItem(Signed) BagItem(Int) .
		
	ceq canonicalizeSpecifier(B:Bag) = unsigned-int
		if B:Bag ==Bool BagItem(Unsigned)
		orBool B:Bag ==Bool BagItem(Unsigned) BagItem(Int) .

	ceq canonicalizeSpecifier(B:Bag) = long-int
		if B:Bag ==Bool BagItem(Long)
		orBool B:Bag ==Bool BagItem(Signed) BagItem(Long)
		orBool B:Bag ==Bool BagItem(Long) BagItem(Int)
		orBool B:Bag ==Bool BagItem(Signed) BagItem(Long) BagItem(Int) .
		
	ceq canonicalizeSpecifier(B:Bag) = unsigned-long-int
		if B:Bag ==Bool BagItem(Unsigned) BagItem(Long)
		orBool B:Bag ==Bool BagItem(Unsigned) BagItem(Long) BagItem(Int) .
	
	ceq canonicalizeSpecifier(B:Bag) = long-long-int
		if B:Bag ==Bool BagItem(Long) BagItem(Long)
		orBool B:Bag ==Bool BagItem(Signed) BagItem(Long) BagItem(Long)
		orBool B:Bag ==Bool BagItem(Long) BagItem(Long) BagItem(Int)
		orBool B:Bag ==Bool BagItem(Signed) BagItem(Long) BagItem(Long) BagItem(Int) .
	
	ceq canonicalizeSpecifier(B:Bag) = unsigned-long-long-int
		if B:Bag ==Bool BagItem(Unsigned) BagItem(Long) BagItem(Long)
		orBool B:Bag ==Bool BagItem(Unsigned) BagItem(Long) BagItem(Long) BagItem(Int) .
		
endm

mod COMMON-C-TYPING is
	including COMMON-INCLUDE .
	including COMMON-SEMANTICS-TYPE-INCLUDE .
	including COMMON-SEMANTICS-TYPE-STRICTNESS .
	including COMMON-SEMANTICS-TYPE-DECLARATIONS .
	including COMMON-SEMANTICS-TYPE-CANONICALIZATION .
	
	--- op preBitfieldType : Nat -> Type .
	--- op preArrayType : Nat -> Type .
	--- op prePointerType : -> Type .
	op structDefType : Id List{Type} -> Type .
	
	op BitFieldType : K K -> K [metadata "strict"] .
	
	mb rule
		< k > Specifier(L:List{Type}) => canonicalizeType(Bag(getList{K}(L:List{Type}))) ...</ k >
		: KSentence .
	mb rule
		< k > StructRef(X:Id) => structType(X:Id) ...</ k >
		: KSentence .
		

	eq BitFieldType(T:Type, tv(N:Nat, ?)) = bitfieldType(T:Type, N:Nat) .
	
	--- op helpReverseArrayTypes : Type Nat -> Type .
	--- eq helpReverseArrayTypes(arrayType(T:Type, N:Nat), N':Nat) = arrayType(helpReverseArrayTypes(T:Type, N':Nat), N:Nat) .
	--- ceq helpReverseArrayTypes(T:Type, N:Nat) = arrayType(T:Type, N:Nat)
		--- if notBool hasArrayType(T:Type) .
	
	--- eq ArrayType(T:BaseType, N:Nat) = arrayType(T:Type, N:Nat) .
	
	op makeArrayType : Nat -> KLabel .
	op makeFunctionType : List{Type} -> KLabel .
	op pushTypeDown : Type KLabel -> Type .
	
	eq ArrayType(T:Type, tv(N:Nat, ?)) = pushTypeDown(T:Type, makeArrayType(N:Nat)) .
	eq ArrayType(T:Type, emptyValue) = pushTypeDown(T:Type, 'incompleteArrayType) .
	eq PointerType(T:Type) = pushTypeDown(T:Type, 'pointerType) .
	--- eq FunctionType(T:Type) = pushTypeDown(T:Type, 'preFunctionType) .
	--- fixme I'm assuming functiontype is always below a prototype 
	eq FunctionType(T:Type) = T:Type .
	eq Prototype(T:Type, L:List{Type}, false) = pushTypeDown(T:Type, makeFunctionType(L:List{Type})) .
	eq Prototype(T:Type, L:List{Type}, true) = pushTypeDown(T:Type, makeFunctionType((L:List{Type} :: variadic))) .
	--- eq Prototype(T:Type, L:List{Type}, false) = functionType(T:Type, L:List{Type}) .
	--- eq Prototype(T:Type, L:List{Type}, true) = functionType(T:Type, (L:List{Type} :: variadic)) .

	
	eq pushTypeDown(arrayType(T:Type, N:Nat), K:KLabel) = arrayType(pushTypeDown(T:Type, K:KLabel), N:Nat) .
	eq pushTypeDown(incompleteArrayType(T:Type), K:KLabel) = incompleteArrayType(pushTypeDown(T:Type, K:KLabel)) .
	eq pushTypeDown(pointerType(T:Type), K:KLabel) = pointerType(pushTypeDown(T:Type, K:KLabel)) .
	--- eq pushTypeDown(preFunctionType(T:Type), K:KLabel) = preFunctionType(pushTypeDown(T:Type, K:KLabel)) .
	eq pushTypeDown(qualifiedType(T:Type, K:K), K:KLabel) = qualifiedType(pushTypeDown(T:Type, K:KLabel), K:K) .
	eq pushTypeDown(functionType(T:Type, L:List{Type}), K:KLabel) = functionType(pushTypeDown(T:Type, K:KLabel), L:List{Type}) .
	eq pushTypeDown(flexibleArrayType(T:Type), K:KLabel) = flexibleArrayType(pushTypeDown(T:Type, K:KLabel)) .
	eq pushTypeDown(structType(X:Id), K:KLabel) = K:KLabel(structType(X:Id)) .
	eq pushTypeDown(unionType(X:Id), K:KLabel) = K:KLabel(unionType(X:Id)) .
	eq pushTypeDown(enumType(X:Id), K:KLabel) = K:KLabel(enumType(X:Id)) .
	
	eq pushTypeDown(typedefType(X:Id, T:Type), K:KLabel) = K:KLabel(T:Type) .
	
	eq pushTypeDown(T:BaseType, K:KLabel) = K:KLabel(T:BaseType) .
	
	eq makeArrayType(N:Nat)(T:Type) = arrayType(T:Type, N:Nat) .
	eq makeFunctionType(L:List{Type})(T:Type) = functionType(T:Type, L:List{Type}) .
	
	--- ceq ArrayType(T:Type, tv(N:Nat, ?)) = arrayType(T:Type, N:Nat)
		--- if notBool hasArrayType(T:Type) .
	--- eq ArrayType(arrayType(T:Type, M:Nat), tv(N:Nat, ?)) 
		--- = helpReverseArrayTypes(arrayType(T:Type, M:Nat), N:Nat) .
		
	
	--- eq ArrayType(incompleteArrayType(T:Type), tv(N:Nat, ?)) = incompleteArrayType(arrayType(T:Type, N:Nat)) .
	--- eq ArrayType(T:Type, emptyValue) = incompleteArrayType(T:Type) .
	--- ceq PointerType(T:Type) = pointerType(T:Type)
		--- if notBool hasFunctionType(T:Type) .
	--- eq PointerType(functionType(T:Type, L:List{Type})) = functionType(pointerType(T:Type), L:List{Type}) .
	--- eq FunctionType(T:Type) = preFunctionType(T:Type) . --- FIXME looks a little weird
	
	eq isTypeCompatible(T:Type, T:Type) = true .
	eq isTypeCompatible(pointerType(?), pointerType(?))
		= true .
	--- ceq isTypeCompatible(pointerType(T:Type), pointerType(T':Type))
		--- = isTypeCompatible(T:Type, T':Type)
		--- if T:Type =/=Bool void andBool T':Type =/=Bool void
		--- andBool notBool hasArrayType(T:Type)
		--- andBool notBool hasArrayType(T':Type) .
	--- ceq isTypeCompatible(pointerType(T:Type), pointerType(T':Type))
		--- = true
		--- if T:Type ==Bool void orBool T':Type ==Bool void .
	eq isTypeCompatible(typedDeclaration(T:Type, ?), typedDeclaration(T':Type, ?))
		= isTypeCompatible(T:Type, T':Type) .
	eq isTypeCompatible(prototype(T:Type), prototype(T':Type)) 
		= isTypeCompatible(T:Type, T':Type) .
		
	--- eq isTypeCompatible(arrayType(T:Type, ?), T':Type)
		--- = isTypeCompatible(pointerType(T:Type), T':Type) .
	--- eq isTypeCompatible(incompleteArrayType(T:Type), T':Type)
		--- = isTypeCompatible(pointerType(T:Type), T':Type) .
		
	--- eq isTypeCompatible(T:Type, pointerType(arrayType(T':Type, ?)))
		--- = isTypeCompatible(T:Type, pointerType(T':Type)) .
	--- eq isTypeCompatible(T:Type, arrayType(arrayType(T':Type, ?), ?))
		--- = isTypeCompatible(T:Type, arrayType(T':Type, 0)) .
	--- ceq isTypeCompatible(T:Type, arrayType(T':Type, ?))
		--- = isTypeCompatible(T:Type, pointerType(T':Type))
		--- if notBool hasArrayType(T':Type) .
	eq isTypeCompatible(T:Type, arrayType(T':Type, ?))
		= isTypeCompatible(T:Type, pointerType(T':Type)) .
		
	eq isTypeCompatible(functionType(T1:Type, (T':Type :: L:List{Type})), functionType(T2:Type, (T'':Type :: L':List{Type})))
		= isTypeCompatible(functionType(T1:Type, L:List{Type}), functionType(T2:Type, L':List{Type}))
		andBool isTypeCompatible(T':Type, T'':Type) .
	ceq isTypeCompatible(T:Type, T':Type) = true
		if (hasIntegerType(T:Type) orBool hasFloatType(T:Type))
		andBool (hasIntegerType(T':Type) orBool hasFloatType(T':Type)) .
	
	--- op cast : K K -> K [metadata "strict"] .
	mb rule 
		< k > Cast(T:Type, K:K, V:Value) => cast(DeclType(T:Type, K:K), V:Value) ...</ k >
		: KSentence .
		
	mb rule 
		< k > JustBase => T:Type ...</ k >
		< declarationTypeHolder > T:Type => . ...</ declarationTypeHolder >
		: KSentence .

	op extractActualTypeFreezer : -> K .
	mb rule
		< k > DeclType(T:Type, K:K) => K:K ~> extractActualTypeFreezer ...</ k >
		< declarationTypeHolder > (. => T:Type) ...</ declarationTypeHolder >
		: KSentence .
	
	mb rule
		< k > T:Type ~> extractActualTypeFreezer 
			=> extractActualType(T:Type)
		...</ k >
		: KSentence .
		
	op fillBitHoles : List{Type} -> List{Type} .
	op fillBitHoles : Nat List{Type} -> List{Type} .
	eq fillBitHoles(Nil) = Nil .
	--- if we haven't seen bitfields
	ceq fillBitHoles((typedDeclaration(T:Type, X:Id) :: L:List{Type})) 
		= typedDeclaration(T:Type, X:Id) :: fillBitHoles(L:List{Type})
	if notBool hasBitfieldType(T:Type) .
	
	ceq fillBitHoles((typedDeclaration(T:Type, X:Id) :: L:List{Type})) 
		= fillBitHoles(0, typedDeclaration(T:Type, X:Id) :: L:List{Type})
	if hasBitfieldType(T:Type) .
	
	--- if we have seen bitfields
	ceq fillBitHoles(N:Nat, (typedDeclaration(T:Type, X:Id) :: L:List{Type})) 
		= typedDeclaration(bitfieldType(unsigned-int, absInt(numBitsPerByte -Int (N:Nat %Nat numBitsPerByte)) %Nat numBitsPerByte), #NoName)
		:: fillBitHoles(typedDeclaration(T:Type, X:Id) :: L:List{Type})
	if notBool hasBitfieldType(T:Type) .
	
	ceq fillBitHoles(N:Nat, (typedDeclaration(bitfieldType(T:Type, N':Nat), X:Id) :: L:List{Type})) 
		= typedDeclaration(bitfieldType(T:Type, N':Nat), X:Id)
		:: fillBitHoles(N:Nat +Nat N':Nat, L:List{Type})
		if N':Nat =/=Bool 0 .
		
	ceq fillBitHoles(N:Nat, (typedDeclaration(bitfieldType(T:Type, N':Nat), ?) :: L:List{Type})) 
		= typedDeclaration(bitfieldType(unsigned-int, absInt(numBitsPerByte -Int (N:Nat %Nat numBitsPerByte)) %Nat numBitsPerByte), #NoName)
		:: fillBitHoles(L:List{Type})
		if N':Nat ==Bool 0 .
	
	eq fillBitHoles(N:Nat, Nil) = typedDeclaration(bitfieldType(unsigned-int, absInt(numBitsPerByte -Int (N:Nat %Nat numBitsPerByte)) %Nat numBitsPerByte), #NoName) .

	
	eq typedDeclaration(bitfieldType(?, N:Nat), #NoName) :: typedDeclaration(bitfieldType(?, N':Nat), #NoName) 
		= typedDeclaration(bitfieldType(unsigned-int, N:Nat +Nat N':Nat), #NoName) .
	
	--- fixme chould check for some struct contraints here
	op incompleteToFlexibleArrayMember : List{Type} -> List{Type} .
	---eq incompleteToFlexibleArrayMember(L:List{Type} :: incompleteArrayType(T:Type)) = L:List{Type} :: flexibleArrayType(T:Type) .
	ceq incompleteToFlexibleArrayMember(typedDeclaration(T:Type, X:Id) :: L:List{Type}) 
		= typedDeclaration(T:Type, X:Id) :: incompleteToFlexibleArrayMember(L:List{Type}) 
		if notBool hasIncompleteType(T:Type) .
	eq incompleteToFlexibleArrayMember(typedDeclaration(incompleteArrayType(T:Type), X:Id)) = typedDeclaration(flexibleArrayType(T:Type), X:Id) .
	eq incompleteToFlexibleArrayMember(Nil) = Nil .
	
	mb rule
		< k > StructDef(X:Id, L:List{Type})
			=> addAggregate(X:Id, fillBitHoles(incompleteToFlexibleArrayMember(L:List{Type})))
			~> giveType(X:Id, structType(X:Id))
			--- ~> structType(X:Id)
		...</ k >
		: KSentence .
	mb rule
		< k > UnionDef(X:Id, L:List{Type})
			=> addAggregate(X:Id, L:List{Type})
			~> giveType(X:Id, unionType(X:Id))
			--- ~> structType(X:Id)
		...</ k >
		: KSentence .

	--- FIXME what good is this?
	mb rule
		< k > OnlyTypedef(?) => . ...</ k >
		: KSentence .
			
	op addAggregate : Id List{Type} -> K .
	op addGlobalAggregate : Id List{Type} -> K .
	op addLocalAggregate : Id List{Type} -> K .
	mb rule
		< k > addAggregate(X:Id, L:List{Type}) 
			=> if (F:Id ==Bool File-Scope) then 
				(addGlobalAggregate(X:Id, L:List{Type})) 
			else
				(addLocalAggregate(X:Id, L:List{Type}))
			fi
		...</ k >
		< currentFunction > F:Id </ currentFunction >
		: KSentence .
	mb rule
		< k > addGlobalAggregate(X:Id, L:List{Type}) => . ...</ k >
		< structs > M:Map => M:Map[L:List{Type} / X:Id] </ structs >
		< gstructs > M:Map => M:Map[L:List{Type} / X:Id] </ gstructs >
		: KSentence .
	mb rule
		< k > addLocalAggregate(X:Id, L:List{Type}) => . ...</ k >
		< structs > M:Map => M:Map[L:List{Type} / X:Id] </ structs >
		: KSentence .
		
	mb rule
		NameAndType(X:Id, T:Type) => typedDeclaration(T:Type, X:Id)
		--- if notBool hasTypedefType(T:Type)
		: KSentence .
	--- mb rule
		--- NameAndType(X:Id, T:Type) => typedDeclaration(extractActualType(T:Type), X:Id)
		--- if hasTypedefType(T:Type)
		--- : KSentence .	
	
	eq extractActualType(typedefType(?, T:Type)) = T:Type .
	eq extractActualType(qualifiedType(T:Type, K:K)) = qualifiedType(extractActualType(T:Type), K:K) .
	ceq extractActualType(T:Type) = T:Type 
		if getKLabel(T:Type) =/=Bool 'typedefType
		andBool getKLabel(T:Type) =/=Bool 'qualifiedType .
		
	op NameAndType : K K -> K [metadata "strict(2)"] .
	
	mb rule
		SingleName(T:Type, Name(X:Id, K:K)) => NameAndType(X:Id, DeclType(T:Type, K:K))
		: KSentence .
	mb [Separate-FieldGroups]: rule
		FieldGroup(K:K, (C:C :: C':C :: L:List{C})) => FieldGroup(K:K, C:C) :: FieldGroup(K:K, (C':C :: L:List{C}))
		: KSentence [metadata "structural"] .
	mb rule
		FieldGroup(K:K, Nil) => Nil
		: KSentence [metadata "structural"] .
	mb rule
		FieldGroup(T:Type, Name(X:Id, K:K)) => NameAndType(X:Id, DeclType(T:Type, K:K))
		: KSentence .
	mb rule
		FieldGroup(T:Type, BitFieldName(Name(X:Id, K:K), Size:K))
		=> NameAndType(X:Id, DeclType(T:Type, BitFieldType(K:K, Size:K)))
		: KSentence .
	eq FieldName(K:K) = K:K .
	
	
	ceq isAType T:Type = true
		if setOfTypes contains l(getKLabel(T:Type)) .
	eq isAType T:BaseType = true .
	ceq isAType K:K = false
		if notBool setOfTypes contains l(getKLabel(K:K))
		andBool notBool isABaseType K:K .
		
	eq isABaseType T:BaseType = true .
	eq isABaseType ? = false [owise] .
	***(
	op normalizeType : K K -> K .
	op typedef : K K -> K .
	
	
	--- fixme ignoring qualifiers
	mb rule [qualifiedType(T:Type, ?) => T:Type] : KSentence [metadata "structural"] .
	
	mb rule [unsigned-short => unsigned-short-int] : KSentence [metadata "structural"] .
	mb rule [unsigned-long => unsigned-long-int] : KSentence [metadata "structural"] .
	mb rule [unsigned-long-long => unsigned-long-long-int] : KSentence [metadata "structural"] .
	mb rule [short => short-int] : KSentence [metadata "structural"] .
	mb rule [long => long-int] : KSentence [metadata "structural"] .
	mb rule [long-long => long-long-int] : KSentence [metadata "structural"] .
	***)
			
	--- eq byteSizeofType(T:Type) = bitsToBytes(bitSizeofType(T:Type)) .
			
	--- FIXME most of these don't take into consideration modifiers

	eq hasFloatType(float) = true .
	eq hasFloatType(double) = true .
	eq hasFloatType(long-double) = true .
	ceq hasFloatType(T:Type) = false
		if T:Type =/=Bool float
		andBool T:Type =/=Bool double
		andBool T:Type =/=Bool long-double
		andBool getKLabel(T:Type) =/=Bool 'qualifiedType .
	
	eq hasCharType(char) = true .
	eq hasCharType(unsigned-char) = true .
	eq hasCharType(signed-char) = true .
	ceq hasCharType(T:Type) = false
		if T:Type =/=Bool char
		andBool T:Type =/=Bool unsigned-char
		andBool T:Type =/=Bool signed-char
		andBool getKLabel(T:Type) =/=Bool 'qualifiedType .
	
	eq hasPointerType(pointerType(?)) = true .
	eq hasPointerType(qualifiedType(T:Type, ?)) = hasPointerType(T:Type) .
	ceq hasPointerType(T:Type) = false
		if getKLabel(T:Type) =/=Bool 'pointerType
		andBool getKLabel(T:Type) =/=Bool 'qualifiedType .
	
	eq hasTypedefType(typedefType(?, ?)) = true .
	eq hasTypedefType(qualifiedType(T:Type, ?)) = hasTypedefType(T:Type) .
	ceq hasTypedefType(T:Type) = false
		if getKLabel(T:Type) =/=Bool 'typedefType 
		andBool getKLabel(T:Type) =/=Bool 'qualifiedType .
	
	eq hasArrayType(arrayType(?, ?)) = true .
	eq hasArrayType(incompleteArrayType(?)) = true .
	eq hasArrayType(qualifiedType(T:Type, ?)) = hasArrayType(T:Type) .
	ceq hasArrayType(T:Type) = false
		if getKLabel(T:Type) =/=Bool 'arrayType 
		andBool getKLabel(T:Type) =/=Bool 'incompleteArrayType 
		andBool getKLabel(T:Type) =/=Bool 'qualifiedType .
		
	eq hasAggregateType(T:Type) = hasArrayType(T:Type) orBool hasStructType(T:Type) .
		
	eq hasStructType(structType(?)) = true .
	eq hasStructType(qualifiedType(T:Type, ?)) = hasStructType(T:Type) .
	ceq hasStructType(T:Type) = false
		if getKLabel(T:Type) =/=Bool 'structType
		andBool getKLabel(T:Type) =/=Bool 'qualifiedType .
		
	eq hasUnionType(unionType(?)) = true .
	eq hasUnionType(qualifiedType(T:Type, ?)) = hasUnionType(T:Type) .
	ceq hasUnionType(T:Type) = false
		if getKLabel(T:Type) =/=Bool 'unionType
		andBool getKLabel(T:Type) =/=Bool 'qualifiedType .
				
	eq hasIncompleteType(incompleteArrayType(?)) = true .
	eq hasIncompleteType(qualifiedType(T:Type, ?)) = hasIncompleteType(T:Type) .
	ceq hasIncompleteType(T:Type) = false
		if getKLabel(T:Type) =/=Bool 'incompleteArrayType
		andBool getKLabel(T:Type) =/=Bool 'qualifiedType .
		
	eq hasExternType(qualifiedType(T:Type, K:K)) = if (K:K ==Bool Extern) then (true) else (hasExternType(T:Type)) fi .
	ceq hasExternType(T:Type) = false
		if getKLabel(T:Type) =/=Bool 'qualifiedType .
		
	eq hasStaticType(qualifiedType(T:Type, K:K)) = if (K:K ==Bool Static) then (true) else (hasStaticType(T:Type)) fi .
	ceq hasStaticType(T:Type) = false
		if getKLabel(T:Type) =/=Bool 'qualifiedType .
		
	eq hasBitfieldType(bitfieldType(?, ?)) = true .
	ceq hasBitfieldType(T:Type) = false
		if getKLabel(T:Type) =/=Bool 'bitfieldType .	
		
	eq hasFunctionType(functionType(?, ?)) = true .
	eq hasFunctionType(prototype(T:Type)) = hasFunctionType(T:Type) .
	eq hasFunctionType(qualifiedType(T:Type, ?)) = hasFunctionType(T:Type) .
	ceq hasFunctionType(T:Type) = false
		if getKLabel(T:Type) =/=Bool 'functionType
		andBool getKLabel(T:Type) =/=Bool 'qualifiedType
		andBool getKLabel(T:Type) =/=Bool 'prototype .
		
	eq hasFunctionPointerType(pointerType(functionType(?, ?))) = true .
	ceq hasFunctionPointerType(T:Type) = false
		if getKLabel(T:Type) =/=Bool 'pointerType .
	ceq hasFunctionPointerType(pointerType(T:Type)) = false
		if getKLabel(T:Type) =/=Bool 'functionType .
		
	op HOLE : -> K .
	mb rule
		< k > typeof(E:Expression) => evalToType ~> typeof(HOLE) ...</ k >
		((.).Bag => < type > E:Expression </ type >)
		: KSentence [metadata "structural"] .
	mb rule
		< k > evalToType ~> typeof(HOLE) => T:Type ...</ k >
		(< type > T:Type </ type > => (.).Bag)
		if isAType T:Type
		: KSentence [metadata "structural"] .
		
	mb rule
		< type > functionObject(?, T:Type, ?) => T:Type ...</ type >
		: KSentence [metadata "structural"] .
		
	--- mb rule
		--- < type > Cast(, ?) =>  ...</ type >
		--- : KSentence [metadata "structural"] .	
	mb rule
		< type > K:K[K':K] => K':K ~> K:K[HOLE] ...</ type >
		if notBool isAType K':K
		: KSentence [metadata "structural"] .
	mb rule
		< type > K:K[K':K] => K:K ~> HOLE[K':K] ...</ type >
		if notBool isAType K:K
		: KSentence [metadata "structural"] .
	mb rule
		< type > tv(?, T:Type) => T:Type ...</ type >
		: KSentence [metadata "structural"] .
	mb rule
		< type > T:Type ~> HOLE[K:K] => T:Type[K:K] ...</ type >
		if isAType T:Type
		: KSentence [metadata "structural"] .
	mb rule
		< type > T:Type ~> K:K[HOLE] => K:K[T:Type] ...</ type >
		if isAType T:Type
		: KSentence [metadata "structural"] .
	mb rule
		< type > arrayType(T:Type, ?)[T':Type] => T:Type ...</ type >
		if hasIntegerType(T':Type)
		: KSentence [metadata "structural"] .
	mb rule
		< type > pointerType(T:Type)[T':Type] => T:Type ...</ type >
		if hasIntegerType(T':Type)
		: KSentence [metadata "structural"] .
	mb rule
		< type > arrayType(T:Type, ?) + T':Type => pointerType(T:Type) ...</ type >
		if hasIntegerType(T':Type)
		: KSentence [metadata "structural"] .
	--- mb rule
		--- < type > [F:Float => double] </ type >
		--- : KSentence [metadata "structural"] .
	--- --- why did this suddenly become necessary?
	--- mb rule
		--- < type > [atv(?, T:Type) => T:Type] </ type >
		--- : KSentence [metadata "structural"] .
	--- c99 6.4.5
	mb rule
		< type > Constant(StringLiteral(S:String)) => arrayType(char, lengthString(S:String) +Nat 1) </ type >
		: KSentence [metadata "structural"] .
	mb rule
		< type > K:K => T:Type ...</ type >
		< types >... K:K |-> T:Type ...</ types >
		: KSentence [metadata "structural"] .

	mb [type-call]: rule
		< type > Call(functionType(T:Type, ?), L:List{C}) => T:Type ...</ type >
		: KSentence [metadata "structural"] .
	mb [type-call]: rule
		< type > Call(pointerType(functionType(T:Type, ?)), ?) => T:Type ...</ type >
		: KSentence [metadata "structural"] .
		 		
	mb [type-struct-dot]: rule
		< type > structType(S:Id) . F:Id => T:Type ...</ type >
		< structs >... S:Id |-> (? :: typedDeclaration(T:Type, F:Id) :: ?) ...</ structs >
		: KSentence [metadata "structural"] .
	mb [type-union-dot]: rule
		< type > unionType(S:Id) . F:Id => T:Type ...</ type >
		< structs >... S:Id |-> (? :: typedDeclaration(T:Type, F:Id) :: ?) ...</ structs >
		: KSentence [metadata "structural"] .
		
	mb [type-struct-arrow]: rule
		< type > pointerType(structType(S:Id)) -> F:Id => T:Type ...</ type >
		< structs >... S:Id |-> (? :: typedDeclaration(T:Type, F:Id) :: ?) ...</ structs >
		: KSentence [metadata "structural"] .
	mb [type-union-arrow]: rule
		< type > pointerType(unionType(S:Id)) -> F:Id => T:Type ...</ type >
		< structs >... S:Id |-> (? :: typedDeclaration(T:Type, F:Id) :: ?) ...</ structs >
		: KSentence [metadata "structural"] .

	mb rule < type > N:Nat => cfg:largestUnsigned ...</ type > : KSentence .

	--- mb rule
		--- < type > ['Pointer(Kp:KProper) => Kp:KProper ~> 'Pointer(HOLE)] ...</ type >
		--- : KSentence [metadata "structural"] .
	--- mb rule
		--- < type > [T:Type ~> 'Pointer(HOLE) => 'Pointer(T:Type)] ...</ type >
		--- : KSentence [metadata "structural"] .

	--- mb [type-deref-value]: rule
		--- < type > *(tv(?, pointerType(T:Type))) => T:Type ...</ type >
		--- : KSentence [metadata "structural"] .
	mb [type-deref-type]: rule
		< type > *(pointerType(T:Type)) => T:Type ...</ type >
		: KSentence [metadata "structural"] .
	mb [type-deref-type]: rule
		< type > *(arrayType(T:Type, ?)) => T:Type ...</ type >
		: KSentence [metadata "structural"] .
	--- mb [type-deref-array]: rule
		--- < type > ['Deref(arrayType(T:Type, ?)) => T:Type] ...</ type >
		--- : KSentence [metadata "structural"] .

	eq unqualifyType(qualifiedType(T:Type, ?)) = T:Type .
	ceq unqualifyType(T:Type) = T:Type
		if getKLabel(T:Type) =/=Bool 'qualifiedType .
	
endm
