# Overview

K is an executable semantic framework in which programming languages, 
calculi, as well as type systems or formal analysis tools can be 
defined making use of configurations, computations and rules.

* *Configurations* organize the system/program state in units called cells, 
which are labeled and can be nested.
* *Computations* carry "computational meaning" as special nested list 
structures sequentializing computational tasks, such as fragments of 
program; in particular, computations extend the original language or 
calculus syntax.
* *K (rewrite) rules* generalize conventional rewrite rules by making it 
explicit which parts of the term they read-only, write-only, or do not 
care about. This distinction makes K a suitable framework for defining 
truly concurrent languages or calculi even in the presence of sharing.

Since computations can be handled like any other terms in a rewriting 
environment, that is, they can be matched, moved from one place to another 
in the original term, modified, or even deleted, K is particularly suitable 
for defining control-intensive language features such as abrupt termination, 
exceptions or call/cc.

## The K Prototype

The K Framework project is a prototype implementation of the K Framework 
written in Maude and using Maude to give a rewriting executable semantics 
to K definitions.

The K prototype is developed by a joint team of faculty and students from 
University of Illinois at Urbana-Champaign (the FSL group, led by 
professor Grigore Rosu), and University Alexandru Ioan Cuza, Iasi, Romania 
(the FMSE group, led by professor Dorel Lucanu).

A current list of the people involved in the project and their specific roles
can be accessed at http://code.google.com/p/k-framework/people/list.


# Installation

For detailed installation instructions, please see the INSTALL file. 

As the tool is still under active development, it is recommended that you 
install K directly form the svn repository and update it regularly using 

  svn up 

from the base directory to benefit of the latest fixes and features. 


# Usage

The languages defined so far using the K framework can be found in the 
examples directory. For example, the directory 
 examples/languages/research/simple 
contains 2 directories, untyped containing the definition of the 
untyped version of the language, and typed which in turn contains three 
directories with definitions: static, for the static semantics, i.e., 
the type checker, dynamic, for the dynamically typed version of simple, 
and dynamic-typed-locations which is a variant of dynamic, in which the 
type information is maintained in the environment. 

## When writing new definitions 

All semantics modules should include directly or indirectly the K module. 
It is recommended that the name of the main module of a definition 
is the capitalized version of the name of the file containing it. 

When adding new rules to a definition, keep in mind the following 
important restrictions: (1) avoid defining constructs with the same 
name (but different arities), and (2) any construct should be applied on 
terms of the syntactic types the construct was declared to accept (that is, no
subterm appearing in the definition should parse to a kind; if desired, 
overload the operations to extend their range). 

To compile a definition: execute the `kompile` script passing as 
parameter the name of the file containing the main module. If the 
compilation succeeds, the output would be placed in 
name-of-the-file-compiled.maude . Currently, the script has only 
been tested on Unix-like systems, including MacOSX. 

Recommendations on running the script:
* The Maude executable should be on the path and should be named `maude`;
moreover, the environment variable `MAUDE_LIB` should point to the location
where `prelude.maude` resides
* The `kompile` script should also be on the path
* The `kompile` script should not be moved from the core directory
* The `kompile` script should be run from the directory where the definition 
resides. 

Assuming the above suggestions were followed, to compile the untyped version 
of the simple language mentioned above, execute

  kompile simple-untyped

in the `examples/research/simple/untyped` directory.


# How It Works

In order to actually interpret (or perform state-space search on) 
programs using a semantics written in K, there needs to be a way to give 
the programs to the tool. The simplest way to do this is by introducing 
a new module that defines programs as macros, letting the K tool turn 
this into its internal representation, and then use Maude on the 
generated code. We briefly outline the process below.

(For more information, see the language examples in the /examples 
directory; in particular, take a look at /examples/languages/classic/imp 
and /examples/languages/research/simple/untyped, as these are 
particularly well-documented, familiar, and small.) 

For example, for a language LANGUAGE, we can introduce a module of the form: 

  kmod LANGUAGE-PROGRAMS is including LANGUAGE-SYNTAX
    syntax Id ::= f | i | t | x | y | ...
    syntax Stmts ::= pFactorial | ...

    macro pFactorial =
      var x;
      function f(y) {
        var t=1;
        for i = 1 to y do
          t = t*i;
        return t;
      }
      function main() {
        x = 5;
        write(f(x));
      }

    ...
  endkm

Obviously, the above program is just an example (borrowed from 
examples/languages/research/simple/untyped); you'll have to write 
programs using the syntax of the language you are defining. In this 
approach, unfortunately, the user has to declare all these syntactic 
constants by hand, as above. One can avoid this issue by using an 
external parser, but this is a more advanced technique, and we do not 
describe it here. You should contact info@k-framework.org if you want to 
know more about how to get this to work. 

One quick piece of technical information: syntax for some operator "op" 
gets turned into a KLabel of the form 'op by the K tool. There are some 
exceptions about how this process works (for example, quotes in the 
operator itself need to be escaped), but as long as you simply name your 
programs using an alphanumeric name, they will just have a single-quote 
applied to them. In addition, in our current implementation of K, the 
internal representation of the syntactic terms follows the simple 
abstract-syntax-tree (AST) syntax: 

  K ::= KLabel(List{K}) 

We use ".List{K}" for the unit of List{K}. For example, the internal 
representation of the syntactic program constant pFactorial above is 
'pFactorial(.List{K}). As a more complex example showing elements that 
need to be escaped, the program term itself is represented internally 
by:

  '__('var_;('_`,_(Id x(.List{K}))),,'__('function_`(_`)_(Id 
  f(.List{K}), ,'_`,_(Id y(.List{K})),,'`{_`}('__('var_;('_`,_('_=_(Id 
  t(.List{K}),,Int 1(.List{ K})))),,'__('for_=_to_do_(Id i(.List{K}),,Int 
  1(.List{K}),,Id y(.List{K}),,'_;( '_=_(Id t(.List{K}),,'_*_(Id 
  t(.List{K}),,Id i(.List{K}))))),,'return_;(Id t(.List{ 
  K})))))),,'function_`(`)_(Id main(.List{K}),,'`{_`}('__('_;('_=_(Id 
  x(.List{K}),, Int 5(.List{K}))),,'write`(_`);('_`(_`)(Id 
  f(.List{K}),,'_`,_('_`(_`)(Id f(.List{ K}),,'_`,_(Id 
  x(.List{K})))))))))))

One needs to create initial configurations holding the programs one 
wants to execute and possibly other data, such as, for example, the 
program input. The two configuration generator operations below are 
meant to help users initialize the configuration when executing 
programs, and not to be regarded as part of the theoretical semantics: 

  syntax Bag ::= run( KLabel ) | run( KLabel , List ) 

  macro run(PgmName:KLabel) =
        <T_> <k> PgmName(.List{K}) ~> execute </k> <_/T>
  macro run(PgmName:KLabel, Input:List) = 
        <T_> <k> PgmName(.List{K}) ~> execute <k> <input> Input <input> <_/T>

Note that the configurations above use ruptured cells, so they take 
advantage of K's configuration abstraction mechanism. They will be 
automatically completed and initialized to match the declared 
configuration of LANGUAGE. 

These helper operators are placed in a module, together with the 
inclusion of the programs and semantics. 

  kmod LANGUAGE is 
    including LANGUAGE-SEMANTICS 
    including LANGUAGE-PROGRAMS 
    ...[above configuration macros]... 
  endkm 

The idea now is that we will use the K tool to compile LANGUAGE, and 
then use the Maude backend to execute the program using the semantics. 

To run our sample program "pFactorial", all we need to do is something 
like this: 

  $ kompile language.k $ maude language-compiled.maude 
                       \||||||||||||||||||/
                     --- Welcome to Maude ---
                       /||||||||||||||||||\
              Maude 2.6 built: Dec  9 2010 18:28:39
              Copyright 1997-2010 SRI International
                     Fri Jun 10 13:25:37 2011
  Maude> rewrite run('pFactorial) .

After which we see: 

  rewrite in LANGUAGE : run('pFactorial) . 
  rewrites: 6419 in 99ms cpu (99ms real) (64199 rewrites/second) 
  result BagItem: < T > < out > ListItem(Int 120(.List{K})) </ out > ...
  [We omit here the contents of the other cells that exist at program 
  termination, and show only the output.]... </ T > 

If, instead, one wants to search for all possible final states which 
could be obtained upon running the program, then one would need to use 
the command 

  Maude> search run('pFactorial) =>! Final:Bag . 

And we get the result: 

  search in SIMPLE-UNTYPED : run('pFactorial) =>! Final:Bag . 

  Solution 1 (state 28364) 
  states: 28416 
  rewrites: 224116 in 3089ms cpu (3091ms real) (72540 rewrites/second) 
  Final:Bag --> < T > < out > 
  ListItem(Int 120(.List{K})) </ out > ... </ T > 

  No more solutions. 
  states: 28416 rewrites: 224454 in 3093ms cpu (3095ms real) 
  (72555 rewrites/second) 

You can also put those commands into a single file, and then 
simply call maude on that file. See
examples/languages/classic/imp/imp-test.m and 
examples/languages/research/simple/untyped/simple-untyped-test.m for 
examples of this. 


# Reporting Issues/Bugs/Feature requests

Please report issues here: http://k-framework.googlecode.com

If you are an end user of K and do not have write permissions to our 
repository, you can simply post your test case, or explain your problem, 
under "issues" at http://k-framework.googlecode.com.  For those users 
who have write permissions to our repository, Please add a test case
to the repository yourself using the directions that follow.

## Test cases:

When filing a bug, it is important to add an automated test case that 
exhibits the bug. This allows us to test our fixes and helps catch 
regressions in the future. We use a simple Makefile based test system 
that is set up in the following way. If you use our example Makefile 
(provided in the example directory and described below) it should be 
very easy to add a new test to the system. Just copy and edit. Detailed 
descriptions follow. 

Test cases for new bugs should be placed in `/trunk/test/issues` in the 
following manner:

  $ cd trunk/tests/issues
  $ svn cp example issueXXX

This copies the example test to a new directory so you can edit it.
XXX is intended to be the # of the issue you post on google code.

Now, edit the files in the `issueXXX` directory to reflect your bug.
You must keep the `Makefile`, which you can adjust to suit the filenames 
you use.  In your `test.m` file, writing

  rew test1(.List{K}) . ---@ foo 'SomeLabel(.List{K})

causes the test to reduce `test1(.List{K})` and ensures that the result
contains the substring `'SomeLabel(.List{K})`, in addition to naming
the test "foo".  It's parsed like this:

  [rew|red|etc] [testString] . ---@ [testNameWithNoSpaces] [resultString]

Writing:

  rew test1(.List{K}) .

simply checks that it reduces at all.  It's not a very strong test.

Your test is in the correct form if you can type "make true-test" 
and an .xml file is created.

  $ cd trunk/tests/issues/issueXXX
  $ make true-test
  $ cat *.xml
  <?xml version='1.0' encoding='UTF-8' ?>
  <testsuite name='issuexxx.test' time='0'>
    <testcase name='test1' time='0'>
      <failure>Failure</failure>
    </testcase>
    <testcase name='test2' time='0'>
      Success
    </testcase>
  </testsuite>

Since you are adding this test because you have a bug, at least one of
your individual tests should give a failure message.

