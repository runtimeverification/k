mod COMMON-SEMANTICS-PROMOTIONS is
	including COMMON-INCLUDE .
	
	--- "integer promotions" are used when doing arithmetic conversions, and for unary ~, +, -.
	--- "usual arithmetic conversions" are used when doing binary arithmetic on numbers, and are used to find a common type
	--- there is another set of promotions called "default argument promotions" used when calling functions where the type information is not complete.  This is equivalent to integer promotions + (float => double) .
	
	--- op arithConversion : KLabel K K -> K [metadata "strict"] .
	op arithConversion-int : KLabel K K -> K . --- [metadata "strict"] .
	op isArithBinOp : KLabel -> Bool .
	op isArithBinConversionOp : KLabel -> Bool .
	op arithBinOps : -> Set [memo] .
	op arithBinConversionOps : -> Set [memo] .
	eq arithBinOps = arithBinConversionOps Set(l('_<<_),, l('_>>_)) .
	eq arithBinConversionOps = Set(
		l('_*_),, l('_/_),, l('_%_),,
		l('_+_),, l('_-_),,
		l('_<_),, l('_>_),, l('_<=_),, l('_>=_),,
		l('_==_),, l('_!=_),,
		l('_&_),, l('_|_),, l('_^_)
	) .
	
	eq isArithBinOp(KL:KLabel) = if arithBinOps contains l(KL:KLabel) then true else false fi .
	eq isArithBinConversionOp(KL:KLabel) = if arithBinConversionOps contains l(KL:KLabel)  then true else false fi .

	op arithUnaryOps : -> Set [memo] .
	eq arithUnaryOps = Set(l('-_),, l('+_),, l('~_)) .
	op isArithUnaryOp : KLabel -> Bool .
	eq isArithUnaryOp(KL:KLabel) = if arithUnaryOps contains l(KL:KLabel) then true else false fi .
	
	ceq hasBeenPromoted(T:Type) = true
		if rank(T:Type) >=Int rank(int)
		andBool notBool hasBitfieldType(T:Type) .
	ceq hasBeenPromoted(T:Type) = false
		if rank(T:Type) <Int rank(int)
		orBool hasBitfieldType(T:Type) .
	
	mb rule
		< k > L:KLabel((tv(V:BaseValue, T:Type) => promote(tv(V:BaseValue, T:Type)))) ...</ k > 
		if     isArithUnaryOp(L:KLabel)
		andBool (rank(T:Type) <Int rank(int) orBool hasBitfieldType(T:Type))
		andBool hasIntegerType(T:Type)
		: KSentence [metadata "structural"] .
	mb rule
		< k > L:KLabel((tv(V:BaseValue, T:Type) => promote(tv(V:BaseValue, T:Type))),, ?) ...</ k > 
		if     isArithBinOp(L:KLabel)
		andBool (rank(T:Type) <Int rank(int) orBool hasBitfieldType(T:Type))
		andBool hasIntegerType(T:Type)
		: KSentence [metadata "structural"] .
	mb rule
		< k > L:KLabel(?,, (tv(V:BaseValue, T:Type) => promote(tv(V:BaseValue, T:Type)))) ...</ k > 
		if     isArithBinOp(L:KLabel)
		andBool (rank(T:Type) <Int rank(int) orBool hasBitfieldType(T:Type))
		andBool hasIntegerType(T:Type)
		: KSentence [metadata "structural"] .
	mb rule
		arithConversion-int(?, tv(?, (enumType(?) => int)), ?)
		: KSentence .
	mb rule
		arithConversion-int(?, ?, tv(?, (enumType(?) => int)))
		: KSentence .
	mb rule
		< k > L:KLabel(tv(V:BaseValue, T:Type),, tv(V':BaseValue, T':Type)) 
			=> arithConversion-int(L:KLabel, tv(V:BaseValue, T:Type), tv(V':BaseValue, T':Type))
		...</ k >
		if     isArithBinConversionOp(L:KLabel)
		andBool T:Type =/=Bool T':Type
		andBool hasIntegerType(T:Type)
		andBool hasIntegerType(T':Type)
		andBool rank(T:Type) >=Int rank(int)
		andBool rank(T':Type) >=Int rank(int)
		: KSentence [metadata "structural"] .
	
	--- fixme these could be done more cleanly
	--- long-double
	mb rule
		< k > L:KLabel(tv(V:BaseValue, long-double),, tv(V':BaseValue, T':Type)) 
			=> L:KLabel(tv(V:BaseValue, long-double),, cast(long-double, tv(V':BaseValue, T':Type))) 
		...</ k >
		if     isArithBinConversionOp(L:KLabel)
		andBool long-double =/=Bool T':Type
		: KSentence [metadata "structural"] .
	mb rule
		< k > L:KLabel(tv(V:BaseValue, T:Type),, tv(V':BaseValue, long-double)) 
			=> L:KLabel(cast(long-double, tv(V:BaseValue, T:Type)),, tv(V':BaseValue, long-double)) 
		...</ k >
		if     isArithBinConversionOp(L:KLabel)
		andBool long-double =/=Bool T:Type
		: KSentence [metadata "structural"] .
	--- double
	mb rule
		< k > L:KLabel(tv(V:BaseValue, double),, tv(V':BaseValue, T':Type)) 
			=> L:KLabel(tv(V:BaseValue, double),, cast(double, tv(V':BaseValue, T':Type))) 
		...</ k >
		if     isArithBinConversionOp(L:KLabel)
		andBool long-double =/=Bool T':Type
		andBool double =/=Bool T':Type
		: KSentence [metadata "structural"] .
	mb rule
		< k > L:KLabel(tv(V:BaseValue, T:Type),, tv(V':BaseValue, double)) 
			=> L:KLabel(cast(double, tv(V:BaseValue, T:Type)),, tv(V':BaseValue, double)) 
		...</ k >
		if     isArithBinConversionOp(L:KLabel)
		andBool long-double =/=Bool T:Type
		andBool double =/=Bool T:Type
		: KSentence [metadata "structural"] .
	--- float
	mb rule
		< k > L:KLabel(tv(V:BaseValue, float),, tv(V':BaseValue, T':Type)) 
			=> L:KLabel(tv(V:BaseValue, float),, cast(float, tv(V':BaseValue, T':Type))) 
		...</ k >
		if     isArithBinConversionOp(L:KLabel)
		andBool long-double =/=Bool T':Type
		andBool double =/=Bool T':Type
		andBool float =/=Bool T':Type
		: KSentence [metadata "structural"] .
	mb rule
		< k > L:KLabel(tv(V:BaseValue, T:Type),, tv(V':BaseValue, float)) 
			=> L:KLabel(cast(float, tv(V:BaseValue, T:Type)),, tv(V':BaseValue, float)) 
		...</ k >
		if     isArithBinConversionOp(L:KLabel)
		andBool long-double =/=Bool T:Type
		andBool double =/=Bool T:Type
		andBool float =/=Bool T:Type
		: KSentence [metadata "structural"] .
	--- ---C99 6.3.1.8
	--- --- First, if the corresponding real type of either operand is long double, the other operand is converted, without change of type domain, to a type whose corresponding real type is long double.
	--- --- mb rule
		--- --- < k > [arithConversion(tv(V1:BaseValue, long-double), tv(V2:BaseValue, T2:Type)) => 
		--- --- converted(tv(V1:BaseValue, long-double), tv(V2:BaseValue, long-double))] ...</ k >
		--- --- : KSentence .
		
	--- --- Otherwise, if the corresponding real type of either operand is double, the other operand is converted, without change of type domain, to a type whose corresponding real type is double.
	--- --- mb rule
		--- --- < k > [arithConversion(tv(V1:BaseValue, double), tv(V2:BaseValue, T2:Type)) => 
		--- --- converted(tv(V1:BaseValue, double), tv(V2:BaseValue, double))] ...</ k >
		--- --- if T2:Type =/=Bool long-double
		--- --- : KSentence .
		
	--- --- Otherwise, if the corresponding real type of either operand is float, the other operand is converted, without change of type domain, to a type whose corresponding real type is float. 53) For example, addition of a double _Complex and a float entails just the conversion of the float operand to double (and yields a double _Complex result).
	--- --- mb rule
		--- --- < k > [arithConversion(tv(V1:BaseValue, float), tv(V2:BaseValue, T2:Type)) => 
		--- --- converted(tv(V1:BaseValue, float), tv(V2:BaseValue, float))] ...</ k >
		--- --- if T2:Type =/=Bool long-double
		--- --- andBool T2:Type =/=Bool double
		--- --- : KSentence .
		
	--- --- Otherwise, the integer promotions are performed on both operands ...
	
	---C99 6.3.1.1:2 For objects or expressions with an integer type  whose integer conversion rank is less than or equal to the rank of int and unsigned int, and a bit field of type _Bool, int, signed int, or unsigned int, If an int can represent all values of the original type, the value is converted to an int; otherwise, it is converted to an unsigned int.  These are called the integer promotions.  All other types are unchanged by the integer promotions.
	---C99 6.3.1.1:3 The integer promotions preserve value including sign. As discussed earlier, whether a "plain" char is treated as signed is implementation-defined.
	mb rule
		promote(tv(V:BaseValue, T:Type)) => tv(V:BaseValue, int)
		if     hasIntegerType(T:Type)
		andBool rank(T:Type) <=Int rank(int)
		andBool min(int) <=Int min(T:Type) 
		andBool max(int) >=Int max(T:Type)		
		: KSentence [metadata "structural"] .

	mb rule
		promote(tv(V:BaseValue, T:Type)) => tv(V:BaseValue, T:Type)
		if     hasIntegerType(T:Type)
		andBool rank(T:Type) >Int rank(int)
		andBool notBool hasBitfieldType(T:Type)
		: KSentence [metadata "structural"] .		

	mb rule
		promote(tv(V:BaseValue, bitfieldType(T:Type, Len:Nat))) => tv(V:BaseValue, int)
		if     (T:Type ==Bool bool orBool T:Type ==Bool int orBool T:Type ==Bool unsigned-int)
		andBool min(int) <=Int min(bitfieldType(T:Type, Len:Nat))
		andBool max(int) >=Int max(bitfieldType(T:Type, Len:Nat))
		: KSentence [metadata "structural"] .
	--- fixme unclear what 6.3.1.1:3 means
	mb rule
		promote(tv(V:BaseValue, T:Type)) => cast(unsigned-int, tv(V:BaseValue, T:Type))
		if     hasIntegerType(T:Type)
		andBool rank(T:Type) <=Int rank(int)
		andBool notBool (
			min(int) <=Int min(T:Type) 
			andBool max(int) >=Int max(T:Type)		
		)
		: KSentence [metadata "structural"] .
	mb rule
		promote(tv(V:BaseValue, bitfieldType(T:Type, Len:Nat))) => cast(unsigned-int, tv(V:BaseValue, T:Type))
		if     (T:Type ==Bool bool orBool T:Type ==Bool int orBool T:Type ==Bool unsigned-int)
		andBool notBool (
			min(int) <=Int min(bitfieldType(T:Type, Len:Nat))
			andBool max(int) >=Int max(bitfieldType(T:Type, Len:Nat))	
		)
		: KSentence [metadata "structural"] .
	
	mb rule
		promote(tv(F:Float, float)) => tv(F:Float, double)
		: KSentence [metadata "structural"] .
	
	--- Then the following rules are applied to the promoted operands:
	
	--- If both operands have the same type, then no further conversion is needed.
	mb rule
		< k > arithConversion-int(L:KLabel, tv(V:BaseValue, T:Type), tv(V':BaseValue, T:Type)) 
			=> L:KLabel(tv(V:BaseValue, T:Type),, tv(V':BaseValue, T:Type))
		...</ k >
		: KSentence [metadata "structural"] .
		
	ceq maxType(T:Type, T':Type) = T:Type
		if rank(T:Type) >=Int rank(T':Type) .
	ceq maxType(T:Type, T':Type) = T':Type
		if rank(T':Type) >=Int rank(T:Type) .
			
	--- Otherwise, if both operands have signed integer types or both have unsigned integer types, the operand with the type of lesser integer conversion rank is converted to the type of the operand with greater rank.
	mb rule
		< k > arithConversion-int(L:KLabel, tv(V:BaseValue, T:Type), tv(V':BaseValue, T':Type)) 
			=> L:KLabel(cast(maxType(T:Type, T':Type), tv(V:BaseValue, T:Type)),, cast(maxType(T:Type, T':Type), tv(V':BaseValue, T':Type)))
		...</ k >
		if T:Type =/=Bool T':Type
		andBool (
			(hasSignedIntegerType(T:Type) andBool hasSignedIntegerType(T':Type))
			orBool
			(hasUnsignedIntegerType(T:Type) andBool hasUnsignedIntegerType(T':Type))
		)
		: KSentence [metadata "structural"] .
		
	--- Otherwise, if the operand that has unsigned integer type has rank greater or equal to the rank of the type of the other operand, then the operand with signed integer type is converted to the type of the operand with unsigned integer type.
	mb rule
		< k > arithConversion-int(L:KLabel, tv(V:BaseValue, T:Type), tv(V':BaseValue, T':Type)) 
			=> L:KLabel(cast(T':Type, tv(V:BaseValue, T:Type)),, tv(V':BaseValue, T':Type))
		...</ k >
		if T:Type =/=Bool T':Type
		andBool hasSignedIntegerType(T:Type) 
		andBool hasUnsignedIntegerType(T':Type) 
		andBool rank(T':Type) >=Int rank(T:Type)
		: KSentence [metadata "structural"] .
	mb rule
		< k > arithConversion-int(L:KLabel, tv(V:BaseValue, T:Type), tv(V':BaseValue, T':Type)) 
			=> L:KLabel(tv(V:BaseValue, T:Type),, cast(T:Type, tv(V':BaseValue, T':Type)))
		...</ k >
		if T:Type =/=Bool T':Type
		andBool hasUnsignedIntegerType(T:Type) 
		andBool hasSignedIntegerType(T':Type) 
		andBool rank(T:Type) >=Int rank(T':Type)
		: KSentence [metadata "structural"] .
		
	--- Otherwise, if the type of the operand with signed integer type can represent all of the values of the type of the operand with unsigned integer type, then the operand with unsigned integer type is converted to the type of the operand with signed integer type.
	mb rule
		< k > arithConversion-int(L:KLabel, tv(V:BaseValue, T:Type), tv(V':BaseValue, T':Type)) 
			=> L:KLabel(tv(V:BaseValue, T:Type),, cast(T:Type, tv(V':BaseValue, T':Type)))
		...</ k >
		if T:Type =/=Bool T':Type
		andBool hasSignedIntegerType(T:Type) 
		andBool hasUnsignedIntegerType(T':Type) 
		andBool rank(T':Type) <Int rank(T:Type)
		andBool min(T:Type) <=Int min(T':Type)
		andBool max(T:Type) >=Int max(T':Type)
		: KSentence [metadata "structural"] .
	mb rule
		< k > arithConversion-int(L:KLabel, tv(V:BaseValue, T:Type), tv(V':BaseValue, T':Type)) 
			=> L:KLabel(cast(T':Type, tv(V:BaseValue, T:Type)),, tv(V':BaseValue, T':Type))
		...</ k >
		if T:Type =/=Bool T':Type
		andBool hasUnsignedIntegerType(T:Type) 
		andBool hasSignedIntegerType(T':Type) 
		andBool rank(T:Type) <Int rank(T':Type)
		andBool min(T':Type) <=Int min(T:Type)
		andBool max(T':Type) >=Int max(T:Type)
		: KSentence [metadata "structural"] .
		
	--- Otherwise, both operands are converted to the unsigned integer type corresponding to the type of the operand with signed integer type.
	mb rule
		< k > arithConversion-int(L:KLabel, tv(V:BaseValue, T:Type), tv(V':BaseValue, T':Type)) 
			=> L:KLabel(cast(correspondingUnsignedType(T:Type), tv(V:BaseValue, T:Type)),, cast(correspondingUnsignedType(T:Type), tv(V':BaseValue, T':Type)))
		...</ k >
		if T:Type =/=Bool T':Type
		andBool hasSignedIntegerType(T:Type) 
		andBool hasUnsignedIntegerType(T':Type) 
		andBool rank(T':Type) <Int rank(T:Type)
		andBool (min(T:Type) >Int min(T':Type) orBool max(T:Type) <Int max(T':Type))
		: KSentence [metadata "structural"] .
	mb rule
		< k > arithConversion-int(L:KLabel, tv(V:BaseValue, T:Type), tv(V':BaseValue, T':Type)) 
			=> L:KLabel(cast(correspondingUnsignedType(T':Type), tv(V:BaseValue, T:Type)),, cast(correspondingUnsignedType(T':Type), tv(V':BaseValue, T':Type)))
		...</ k >
		if T:Type =/=Bool T':Type
		andBool hasUnsignedIntegerType(T:Type) 
		andBool hasSignedIntegerType(T':Type) 
		andBool rank(T:Type) <Int rank(T':Type)
		andBool (min(T':Type) >Int min(T:Type) orBool max(T':Type) <Int max(T:Type))
		: KSentence [metadata "structural"] .
		
		
	op correspondingUnsignedType : Type -> Type .
	
	eq correspondingUnsignedType(int) = unsigned-int .
	eq correspondingUnsignedType(long-int) = unsigned-long-int .
	eq correspondingUnsignedType(long-long-int) = unsigned-long-long-int .
	
endm

mod COMMON-SEMANTICS-CAST is 
	including COMMON-INCLUDE .
	
	---- switch assumes casts can happen anywhere
	
	--- mb rule ['Cast(T:Type,, E:Expression) => cast(T:Type, E:Expression)] : KSentence [metadata "structural"] .
	mb rule 
		cast(void, ?) => skipval
		: KSentence [metadata "structural"] .
	
	--- fixme not sure about this, doesn't concretize, and in turn interpret, assume things about the list?
	mb rule
		cast(T:Type, tv(L:List{K}, structType(?))) 
			=> concretize(T:Type, dataList(L:List{K}))
		: KSentence [metadata "structural"] .
	
	--- fixme just temporarily, until we handle qualifiers properly
	mb rule
		cast(T:Type, tv(L:List{K}, T':Type)) => cast(T:Type, tv(L:List{K}, unqualifyType(T':Type)))
		if hasStaticType(T':Type)
		: KSentence [metadata "structural"] .
	
	mb rule
		cast(T:Type, tv(L:List{K}, T:Type)) => tv(L:List{K}, T:Type)
		: KSentence [metadata "structural"] .
	
	---c99 6.3.1.2:1 to _Bool
	--- fixme worried about qualifiers
	mb rule
		cast(T:Type, tv(I:Int, T':Type)) => if I:Int ==Bool 0 then tv(0, bool) else tv(1, bool) fi
		if hasBoolType (T:Type)
		andBool hasIntegerType(T':Type)
		: KSentence [metadata "structural"] .
	mb rule
		cast(T:Type, tv(I:Int, T':Type)) => cast(bool, tv(0, int) == tv(I:Int, T':Type))
		if hasBoolType (T:Type)
		andBool notBool hasIntegerType(T':Type)
		: KSentence [metadata "structural"] .
	
	---c99 6.3.1.3:1 When a value with integer type is converted to another integer type other than _Bool, if the value can be represented by the new type, it is unchanged. 
	mb rule
		cast(T:Type, tv(I:Int, T':Type)) => tv(I:Int, T:Type)
		if min(T:Type) <=Int I:Int andBool max(T:Type) >=Int I:Int 
		andBool hasIntegerType(T':Type)
		andBool hasIntegerType(T:Type)
		andBool notBool hasBoolType (T:Type)
		: KSentence [metadata "structural"] .
		
	---c99 6.3.1.3:2 Otherwise, if the new type is unsigned, the value is converted by repeatedly adding or subtracting one more than the maximum value that can be represented in the new type until the value is in the range of the new type.
	mb rule
		cast(T:Type, tv(I:Int, T':Type)) => cast(T:Type, tv(I:Int +Int max(T:Type) +Int 1, T':Type))
		if unsignedIntegerTypes contains T:Type 
		andBool I:Int <Int min(T:Type)
		andBool hasIntegerType(T':Type)
		andBool notBool hasBoolType (T:Type)
		: KSentence [metadata "structural"] .
		
	--- fixme does this extra check for looping need to be done elsewhere?
	mb rule
		cast(T:Type, tv(I:Int, T':Type)) => tv(I:Int %Int (max(T:Type) +Int 1), T:Type)
		if unsignedIntegerTypes contains T:Type 
		andBool I:Int >Int max(T:Type)
		andBool hasIntegerType(T':Type)
		andBool notBool hasBoolType (T:Type)
		: KSentence [metadata "structural"] .
	
	---c99 6.3.1.3:3 Otherwise, the new type is signed and the value cannot be represented in it; either the result is implementation-defined or an implementation-defined signal is raised.
	--- choice
	mb rule
		cast(T:Type, tv(I:Int, T':Type)) 
			=> cast(T:Type, tv(I:Int +Int (2 ^Nat absInt(numBits(T:Type))), T':Type)) 
		if I:Int <Int min(T:Type)
		andBool notBool(unsignedIntegerTypes contains T:Type)
		andBool hasIntegerType(T:Type)
		andBool hasIntegerType(T':Type)
		andBool notBool hasBoolType (T:Type)
		: KSentence [metadata "structural"] .
	mb rule
		cast(T:Type, tv(I:Int, T':Type)) 
			=> cast(T:Type, tv(_-Int_(I:Int, (2 ^Nat absInt(numBits(T:Type)))), T':Type)) 
		if I:Int >Int max(T:Type)
		andBool notBool(unsignedIntegerTypes contains T:Type)
		andBool hasIntegerType(T:Type)
		andBool hasIntegerType(T':Type)
		andBool notBool hasBoolType (T:Type)
		: KSentence [metadata "structural"] .

	
	---C99 6.3.1.4:1 When a finite value of real floating type is converted to an integer type other than _Bool, the fractional part is discarded (i.e., the value is truncated toward zero). If the value of the integral part cannot be represented by the integer type, the behavior is undefined.52) The remaindering operation performed when a value of integer type is converted to unsigned type need not be performed when a value of real floating type is converted to unsigned type. Thus, the range of portable real floating values is (-1, Utype_MAX+1).
	--- fixme
	mb rule
		cast(T:Type, tv(V:Float, double)) => cast(T:Type, tv(truncRat(Float2Rat(V:Float)), long-long-int))
		if hasIntegerType(T:Type)
		andBool notBool hasBoolType (T:Type)
		: KSentence [metadata "structural"] .
	mb rule
		cast(T:Type, tv(V:Float, float)) => cast(T:Type, tv(truncRat(Float2Rat(V:Float)), long-long-int))
		if hasIntegerType(T:Type)
		andBool notBool hasBoolType (T:Type)
		: KSentence [metadata "structural"] .
	mb rule
		cast(T:Type, tv(V:Float, long-double)) => cast(T:Type, tv(truncRat(Float2Rat(V:Float)), long-long-int))
		if hasIntegerType(T:Type)
		andBool notBool hasBoolType (T:Type)
		: KSentence [metadata "structural"] .
	
	---C99 6.3.1.4:2 When a value of integer type is converted to a real floating type, if the value being converted can be represented exactly in the new type, it is unchanged. If the value being converted is in the range of values that can be represented but cannot be represented exactly, the result is either the nearest higher or nearest lower representable value, chosen in an implementation-defined manner. If the value being converted is outside the range of values that can be represented, the behavior is undefined.

	mb rule
		cast(T':Type, tv(I:Int, T:Type)) => tv(Rat2Float(I:Int), T':Type)
		if hasIntegerType(T:Type)
		andBool (T':Type ==Bool float orBool T':Type ==Bool double orBool T':Type ==Bool long-double)
		: KSentence [metadata "structural"] .
	
	--- fixme all floats same precision
	mb rule
		cast(T':Type, tv(F:Float, T:Type)) => tv(F:Float, T':Type)
		if (T:Type ==Bool float orBool T:Type ==Bool double orBool T:Type ==Bool long-double)
		andBool (T':Type ==Bool float orBool T':Type ==Bool double orBool T':Type ==Bool long-double)
		: KSentence [metadata "structural"] .
	
	--- --- fixme 6.3.2.3 not handling this correctly
	--- mb rule
		--- < k > cast(T:Type, tv(loc(N:Nat, M:Nat), T':Type)) => tv(loc(N:Nat, M:Nat), T:Type) ...</ k >
		--- if hasIntegerType(T:Type) andBool hasIntegerType(T':Type)
		--- : KSentence [metadata "structural"] .
	
	--- fixme might lose potential of finding errors if we use 0?
	--- choice implementation defined behavior
	mb rule
		cast(pointerType(T:Type), tv(N:Nat, T':Type)) => tv(N:Nat, pointerType(T:Type))
		if hasIntegerType(T':Type)
		andBool N:Nat =/=Bool NullPointerConstant
		: KSentence [metadata "structural"] .
	mb rule
		cast(pointerType(T:Type), tv(N:Nat, T':Type)) => tv(NullPointer, pointerType(T:Type))
		if hasIntegerType(T':Type)
		andBool N:Nat ==Bool NullPointerConstant
		: KSentence [metadata "structural"] .

	--- fixme there should only be casts to scalars, but these are generated when assigning to array types
	--- mb rule
		--- < k > cast((arrayType(T:Type, N:Nat) => pointerType(T:Type)), ?) ...</ k >
		--- : KSentence [metadata "structural"] .
		
	mb rule
		cast(?, tv(?, (arrayType(T:Type, ?) => pointerType(T:Type))))
		: KSentence [metadata "structural"] .
	mb rule
		cast(?, tv(?, (incompleteArrayType(T:Type) => pointerType(T:Type))))
		: KSentence [metadata "structural"] .
	
	--- fixme needs to check size
	mb rule
		cast(T:Type, tv(N:Nat, pointerType(?)))
			=> tv(N:Nat, T:Type)
		if hasIntegerType(T:Type)
		: KSentence [metadata "structural"] .
		
	--- mb rule
		--- < k > cast(T:Type, tv(N:Nat, pointerType(?)))
			--- => tv(N:Nat, T:Type)
		--- ...</ k >
		--- if hasIntegerType(T:Type)
		--- --- andBool notBool(N:Nat ==Bool 0 andBool M:Nat ==Bool 0)
		--- : KSentence [metadata "structural"] .
	
	--- --- fixme
	--- mb rule
		--- < k > [cast(T:Type, tv(loc(N:Nat, M:Nat), pointerType(T':Type))) => tv(loc(N:Nat, M:Nat), T:Type)] ...</ k > 
		--- if hasIntegerType(T:Type)
		--- andBool notBool(N:Nat ==Bool 0 andBool M:Nat ==Bool 0)
		--- : KSentence [metadata "structural"] .
	--- --- fixme maybe only for void?
	--- mb rule
		--- < k > [cast(T:Type, tv(N:Nat, pointerType(T':Type))) => cast(T:Type, tv(N:Nat, unsigned-long-int))] ...</ k > 
		--- if hasIntegerType(T:Type)
		--- andBool N:Nat >Nat 0
		--- : KSentence [metadata "structural"] .
	
	--- --- fixme special rules for null pointer
	--- mb rule
		--- < k > [cast(pointerType(T:Type), tv(0, T':Type)) => tv(loc(0, 0), pointerType(T:Type))] ...</ k >
		--- if hasIntegerType(T':Type)
		--- : KSentence [metadata "structural"] .
	--- --- fixme
	--- mb rule
		--- < k > [cast(T:Type, tv(loc(0, 0), pointerType(T':Type))) => tv(0, T:Type)] ...</ k > 
		--- if hasIntegerType(T:Type)
		--- : KSentence [metadata "structural"] .
		
	--- fixme
	--- possibly not true with other endiannesses
	--- choice
	--- needs to handle alignment
	mb rule
		cast(pointerType(T:Type), tv(N:Nat, pointerType(?))) => tv(N:Nat, pointerType(T:Type))
		: KSentence [metadata "structural"] .
				
	--- mb rule
		--- < k > [cast(pointerType(bitfieldType(T:Type, Len:Nat)), tv(bitloc(B:Nat, N:Nat, O:Nat), pointerType(?)))
		--- => tv(bitloc(B:Nat, N:Nat, O:Nat), pointerType(bitfieldType(T:Type, Len:Nat)))] ...</ k > 
		--- : KSentence [metadata "structural"] .
endm

mod COMMON-C-CONVERSIONS is
	including COMMON-INCLUDE .
	including COMMON-SEMANTICS-CAST .
	including COMMON-SEMANTICS-PROMOTIONS .
	
	--- this seems implementation defined at best
	--- eq bitfieldType(enumType(X:Id), N:Nat) = bitfieldType(int, N:Nat) .
	
	--- fixme generalize this should be done generically
	mb rule < k > *(tv(?, (arrayType(T:Type, ?) => pointerType(T:Type)))) ...</ k > 
		: KSentence [metadata "structural"] .
	mb rule < k > *(tv(?, (incompleteArrayType(T:Type) => pointerType(T:Type)))) ...</ k > 
		: KSentence [metadata "structural"] .
		
	mb rule < k > _+_(tv(?, (incompleteArrayType(T:Type) => pointerType(T:Type))), ?) ...</ k > 
		: KSentence [metadata "structural"] .
	mb rule < k > _+_(?, tv(?, (incompleteArrayType(T:Type) => pointerType(T:Type)))) ...</ k > 
		: KSentence [metadata "structural"] .
	mb rule < k > _+_(tv(?, (arrayType(T:Type, ?) => pointerType(T:Type))), ?) ...</ k > 
		: KSentence [metadata "structural"] .
	mb rule < k > _+_(?, tv(Loc:Nat, (arrayType(T:Type, ?) => pointerType(T:Type)))) ...</ k > 
		: KSentence [metadata "structural"] .	

	--- eq bitFlatten(N:Nat |Nat M:Nat) = bitFlatten(N:Nat) |Nat bitFlatten(M:Nat) .
	--- eq bitFlatten(N:Nat &Nat M:Nat) = bitFlatten(N:Nat) &Nat bitFlatten(M:Nat) .
	--- eq bitFlatten(N:Nat <<Nat M:Nat) = bitFlatten(N:Nat) <<Nat M:Nat .
	--- eq bitFlatten(N:Nat >>Nat M:Nat) = bitFlatten(N:Nat) >>Nat M:Nat .
	--- eq bitFlatten(unknown(Len:Nat)) = bitlist(Len:Nat, nTimes(Len:Nat, unknownBit)) .
	--- eq bitFlatten(0) = bitlist(1, 0) .
	--- eq bitFlatten(1) = bitlist(1, 1) .
	
	--- eq bitUnflatten(bitlist(1, N:Nat)) = N:Nat .
	--- eq bitUnflatten(bitlist(sNat(sNat(Len:Nat)), N:Nat)) = N:Nat .
	--- ceq bitFlatten(N:Nat) = (bitFlatten(N:Nat >>Nat 1) <<Nat 1) |Nat bitlist(1, N:Nat &Nat 1)
		--- if N:Nat >Int 1 .
	
	--- ceq bitFlatten(I:Int) = I:Int
		--- if I:Int >=Int 0 orBool I:Int <=Int 0 .
	
	ceq unknown(Len:Nat) >>Nat N:Nat = unknown(absInt(Len:Nat -Int N:Nat))
		if N:Nat <=Nat Len:Nat .
		
	eq (N:Nat bit:: piece(?, 1)) >>Nat 1 = N:Nat .
	--- FIXME this seems ominously perilous
	--- ceq N:Nat |Nat unknown(M:Nat) = unknown(M:Nat)
		--- if absInt(Float2Int(logFloat(Int2Float(N:Nat)) /Float logFloat(2.0))) <=Nat M:Nat .
	--- eq unknown(N:Nat) |Nat unknown(N':Nat) = unknown(maxNat(N:Nat, N':Nat)) .
	--- eq unknown(N:Nat) &Nat unknown(N':Nat) = unknown(maxNat(N:Nat, N':Nat)) .
	--- eq unknown(N:Nat) <<Nat M:Nat = unknown(N:Nat +Nat M:Nat) . --- too conservative
	--- eq unknown(0) = 0 .
	--- eq 0 |Nat N:Nat = N:Nat .
	--- eq 1 &Nat unknown(Len:Nat) = unknown(1) .
	--- eq 0 &Nat unknown(Len:Nat) = 0 .
	--- eq (N:Nat <<Nat 1) >>Nat 1 = N:Nat .
	
	--- op bitlist : Nat List{K} -> Nat .
	--- op unknownBit : -> K .
	--- op nTimes : Nat K -> List{K} .
	--- eq nTimes(sNat(N:Nat), K:K) = (K:K,, nTimes(N:Nat, K:K)) .
	--- eq nTimes(0, K:K) = .List{K} .
	
	--- eq unknown(Len:Nat) = bitlist(Len:Nat, nTimes(Len:Nat, unknownBit)) .
	--- eq unknown(Len:Nat) = bitlist(Len:Nat, innerUnknown(Len:Nat)) .
	--- eq bitlist(sNat(Len:Nat), L:List{K}) >>Nat N:Nat = eq bitlist(Len:Nat, dropLowest
	--- bitlist(8, (('unknownBit).KProperLabel(.List{K}),,('unknownBit).KProperLabel(.List{K}),,('unknownBit).KProperLabel(.List{K}),,('unknownBit).KProperLabel(.List{K}),,('unknownBit).KProperLabel(.List{K}),,('unknownBit).KProperLabel(.List{K}),,('unknownBit).KProperLabel(.List{K}),,('unknownBit).KProperLabel(.List{K}))) >>Nat 1 
	
	--- fixme not sure about this
	--- interpret is used to "cast" values read from memory
	--- shouldn't need to do the < min one since values start positive
	op interpret-aux : Type K -> K .
	--- op bitFlatten : K -> Nat .
	--- op bitUnflatten : K -> Nat .
	--- op collapseBits : K K -> K .
	--- mb rule 
		--- < k > interpret(T:Type, N:Int >>Nat M:Nat)
			--- => interpret-aux(T:Type, I:Int)
		--- ...</ k >
		--- if I:Int <=Int 0 orBool I:Int >=Int 0
		--- : KSentence [metadata "structural"] .
	--- mb rule 
		--- < k > interpret(T:Type, N:Nat)
			--- => interpret-aux(T:Type, bitUnflatten(bitFlatten(N:Nat)))
		--- ...</ k >
		--- : KSentence [metadata "structural"] .
	--- mb rule < k > collapseBits(bitlist(0, .List{K}), N:Nat) ~> interpret(T:Type, HOLE) => interpret-aux(T:Type, N:Nat) ...</ k > : KSentence [metadata "structural"] .
	
	
	--- eq collapseBits(bitlist(sNat(N:Nat), (M:Nat,, L:List{K})), N:Nat) = collapseBits(bitlist(N:Nat, L:List{K}), (N:Nat <<Nat 1) |Nat M:Nat) .
	--- eq interpret(T:Type, piece(N:Nat, ?)) = interpret-aux(T:Type, N:Nat) .
	ceq interpret(T:Type, piece(N:Nat, ?)) = interpret-aux(T:Type, N:Nat)
		if N:Nat >=Nat 0 .
	
	mb rule interpret-aux(T:Type, I:Int) => tv(I:Int, T:Type)
		if min(T:Type) <=Int I:Int andBool max(T:Type) >=Int I:Int
		andBool hasIntegerType(T:Type)
		--- andBool notBool hasBitfieldType(T:Type)
		: KSentence [metadata "structural"] .
	mb rule
		interpret-aux(T:Type, I:Int) => interpret-aux(T:Type, _-Int_(I:Int, (2 ^Nat absInt(numBits(T:Type)))))
		if I:Int >Int max(T:Type)
		andBool hasIntegerType(T:Type)
		andBool _-Int_(I:Int, (2 ^Nat absInt(numBits(T:Type)))) >=Int min(T:Type)
		--- andBool notBool hasBitfieldType(T:Type)
		: KSentence [metadata "structural"] .
		
	mb rule arithInterpret(T:Type, I:Int) => tv(I:Int, T:Type)
		if min(T:Type) <=Int I:Int andBool max(T:Type) >=Int I:Int
		andBool hasIntegerType(T:Type)
		--- andBool notBool hasBitfieldType(T:Type)
		: KSentence [metadata "structural"] .
	
	mb rule arithInterpret(bignum, I:Int) => tv(I:Int, bignum)
		: KSentence [metadata "structural"] .	
		
	--- --- fixme there should be a more controlled way of doing this
	--- --- it's also wrong
	--- mb rule [tv(I:Int, bitfieldType(T:Type, N:Nat)) => tv(I:Int, T:Type)] : KSentence [metadata "structural"] .
		
	--- c99 6.5.7:4 The result of E1 << E2 is E1 left-shifted E2 bit positions; vacated bits are filled with zeros. If E1 has an unsigned type, the value of the result is E1 times 2^(E2), reduced modulo one more than the maximum value representable in the result type. If E1 has a signed type and nonnegative value, and E1 times 2^(E2) is representable in the result type, then that is the resulting value; otherwise, the behavior is undefined. 
	--- e1 = 2147483647; e1 * 2^(1) = 2147483647 * 2 = 4294967294
	mb rule leftShiftInterpret(T:Type, I:Int, tv(E1:Int, T:Type)) => tv(I:Int %Int (max(T:Type) +Int 1), T:Type)
		if unsignedIntegerTypes contains T:Type
		: KSentence [metadata "structural"] .
	mb rule leftShiftInterpret(T:Type, I:Int, tv(E1:Nat, T:Type)) => interpret-aux(T:Type, I:Int)
		if hasIntegerType(T:Type)
		andBool notBool (unsignedIntegerTypes contains T:Type)
		andBool I:Int <=Int (2 ^Nat absInt(numBits(T:Type)))
		: KSentence [metadata "structural"] .
		
	--- c99 6.5.7:5 The result of E1 >> E2 is E1 right-shifted E2 bit positions. If E1 has an unsigned type or if E1 has a signed type and a nonnegative value, the value of the result is the integral part of the quotient of E1 / 2^(E2). If E1 has a signed type and a negative value, the resulting value is implementation-defined.
	mb rule rightShiftInterpret(T:Type, I:Int) => tv(I:Int, T:Type)
		if integerTypes contains T:Type
		: KSentence [metadata "structural"] .
	
	--- fixme
	mb rule arithInterpret(T:Type, F:Float) => tv(F:Float, T:Type)
		if (T:Type ==Bool double)
		orBool T:Type ==Bool float
		orBool T:Type ==Bool long-double
		: KSentence [metadata "structural"] .
	--- signed arithmetic isn't supposed to overflow
	mb rule
		arithInterpret(T:Type, I:Int) => 
		tv(I:Int %Int (max(T:Type) +Int 1), T:Type)
		if unsignedIntegerTypes contains T:Type
		andBool I:Int >Int max(T:Type)
		: KSentence [metadata "structural"] .
	mb rule
		arithInterpret(T:Type, I:Int) => arithInterpret(T:Type, _+Int_(I:Int, (max(T:Type) +Int 1)))
		if unsignedIntegerTypes contains T:Type
		andBool I:Int <Int min(T:Type)
		andBool _+Int_(I:Int, (max(T:Type) +Int 1)) <=Int max(T:Type)
		: KSentence [metadata "structural"] .

	eq integerTypes = signedIntegerTypes unsignedIntegerTypes .
	eq unsignedIntegerTypes = Set(bool,, unsigned-char,, unsigned-short-int,, unsigned-int,, unsigned-long-int,, unsigned-long-long-int) .
	eq signedIntegerTypes = Set(char,, signed-char,, short-int,, int,, long-int,, long-long-int,, bignum) .
endm
