package org.kframework.backend.ocaml;

import com.google.inject.Inject;
import org.kframework.Rewriter;
import org.kframework.attributes.Source;
import org.kframework.builtin.Sorts;
import org.kframework.definition.Module;
import org.kframework.kompile.CompiledDefinition;
import org.kframework.kompile.KompileOptions;
import org.kframework.kore.K;
import org.kframework.main.GlobalOptions;
import org.kframework.utils.errorsystem.KEMException;
import org.kframework.utils.errorsystem.KExceptionManager;
import org.kframework.utils.file.FileUtil;
import org.kframework.utils.inject.DefinitionScoped;

import java.io.IOException;
import java.util.Optional;
import java.util.function.Function;

/**
 * Created by dwightguth on 5/27/15.
 */
@DefinitionScoped
public class OcamlRewriter implements Function<Module, Rewriter> {

    private final KExceptionManager kem;
    private final FileUtil files;
    private final GlobalOptions globalOptions;
    private final KompileOptions kompileOptions;
    private final CompiledDefinition def;
    private final DefinitionToOcaml converter;

    @Inject
    public OcamlRewriter(KExceptionManager kem, FileUtil files, GlobalOptions globalOptions, KompileOptions kompileOptions, CompiledDefinition def) {
        this.kem = kem;
        this.files = files;
        this.globalOptions = globalOptions;
        this.kompileOptions = kompileOptions;
        this.def = def;
        this.converter = new DefinitionToOcaml(kem, files, globalOptions, kompileOptions);
        converter.convert(def);
    }

    @Override
    public Rewriter apply(Module module) {
        if (!module.equals(def.executionModule())) {
            throw KEMException.criticalError("Invalid module specified for rewriting. Ocaml backend only supports rewriting over" +
                    " the definition's main module.");
        }
        return new Rewriter() {
            @Override
            public K execute(K k, Optional<Integer> depth) {
                String ocaml = converter.convert(k, depth.orElse(-1));
                files.saveToTemp("pgm.ml", ocaml);
                try {
                    ProcessBuilder pb = files.getProcessBuilder();
                    if (DefinitionToOcaml.fastCompilation) {
                        pb = pb.command("ocamlc.opt", "-g", "zarith.cma", "str.cma", files.resolveKompiled("def.cmo").getAbsolutePath(), "-I", "+zarith", "-I", files.resolveKompiled(".").getAbsolutePath(), "pgm.ml");
                    } else {
                        pb = pb.command("ocamlopt.opt", "zarith.cmxa", "str.cmxa", files.resolveKompiled("def.cmx").getAbsolutePath(), "-I", "+zarith", "-I", files.resolveKompiled(".").getAbsolutePath(), "pgm.ml");
                    }
                    Process p = pb.directory(files.resolveTemp("."))
                            .redirectError(files.resolveTemp("compile.err"))
                            .redirectOutput(files.resolveTemp("compile.out"))
                            .start();
                    int exit = p.waitFor();
                    if (exit != 0) {
                        System.err.println(files.loadFromTemp("compile.err"));
                        throw KEMException.criticalError("Failed to compile program to ocaml. See output for error information.");
                    }
                    p = files.getProcessBuilder()
                            .command("./a.out")
                            .directory(files.resolveTemp("."))
                            .redirectError(files.resolveTemp("run.err"))
                            .redirectOutput(files.resolveTemp("run.out"))
                            .start();
                    exit = p.waitFor();
                    if (exit != 0) {
                        System.err.println(files.loadFromTemp("run.err"));
                        throw KEMException.criticalError("Failed to execute program in ocaml. See output for error information.");
                    }
                    String output = files.loadFromTemp("run.out");
                    return def.getParser(def.getParsedDefinition().getModule("KSEQ-SYMBOLIC").get(), Sorts.K(), kem).apply(output, Source.apply("generated by ocaml output"));
                } catch (IOException e) {
                    throw KEMException.criticalError("Failed to start ocamlopt: " + e.getMessage(), e);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    throw KEMException.criticalError("Ocaml process interrupted.", e);
                }
            }
        };
    }
}
