// Let us now consider a program which continues to read a number n and print
// the sum of numbers up to n, until n is less then or equal to zero.
// As seen in the previous variants of this program, there are different ways
// to configure the IMP++ K semantics.  We demonstrate a combination of these.
//
// Probably the most natural way to configure the semantics for interpretation
// reasons is to connect the <in/> and <out/> cells to the standard input and
// standard output, respectively.  For this, modify these cells as follows:
//
//     <in color="magenta" stream="stdin"> .List </in>
//     <out color="Orchid" stream="stdout"> .List </out>
//
// After kompilation, we can run the semantics like any realistic interpreter:
//
// bash$ krun programs/sumPgm3.imppp --no-config
// Add numbers up to (<= 0 to quit)? 10
// Sum = 55
// Add numbers up to (<= 0 to quit)? 100
// Sum = 5050
// Add numbers up to (<= 0 to quit)? 0
// bash$ 
//
// or
//
// bash$ echo 10 100 0 25 | krun programs/sumPgm3.imppp --no-config
// Add numbers up to (<= 0 to quit)? Sum = 55
// Add numbers up to (<= 0 to quit)? Sum = 5050
// Add numbers up to (<= 0 to quit)? bash$ 
//
// If we want to BOTH pass some initial items in the <in/> cell AND continue
// to read more items from the standard input, then we can BOTH connect the
// <in/> cell to the standard input AND use a configuration variable.
// For example:
//
//     <in color="magenta" stream="stdin"> $IN:List </in>
//
// and then, after kompilation,
//
// bash$ krun programs/sumPgm3.imppp --no-config --IN="ListItem(10) ListItem(100)"
// Add numbers up to (<= 0 to quit)? Sum = 55
// Add numbers up to (<= 0 to quit)? Sum = 5050
// Add numbers up to (<= 0 to quit)? 24
// Sum = 300
// Add numbers up to (<= 0 to quit)? 0
// bash$

var n,s;
while true do {
  print("Add numbers up to (<= 0 to quit)? ");
  n:=read();
  if n<=0 then halt
  else {
    s:=0;
    while not(n<=0) do {
      s:=s+n;
      n:=n+-1
    } ;
    print("Sum = "); print(s); print("\n")
  }
}
