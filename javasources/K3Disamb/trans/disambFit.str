module disambFit

imports
	libstratego-lib
	libstratego-gpp
	libstratego-aterm
	libstratego-sglr

	include/K3Disamb

	disambSup
	starter
	disambCells

strategies

	chooseBestFitRec =
		bottomup(try(chooseBestFit(getFitnessUnit2|)))
		; bottomup(try(chooseBestFit(getFitnessUnit3|)))

	chooseBestFit(getFitnessUnit|):
		amb(x) -> rez2
		where rez := <filterSize(getFitnessUnit|)> x
		where rez2 := <if <lt>(<length> rez, 2) then  !<last> rez else !amb(rez) end>

	filterSize(getFitnessUnit|):
		xs -> xs2
		where mymax := <foldr(!-2147483600, max)> (<all(getFitness2(getFitnessUnit|))> xs)		// calculate the size of the smallest term
		where xs2 := <filter(findLargest(getFitnessUnit|mymax))> xs							// filter terms that are of a greater size

	findLargest(getFitnessUnit|size) =
		where(currSize := <getFitness2(getFitnessUnit|)> ;
		<eq>(currSize, size))

	// ------------- new type filter that goes deeper
	getFitness2(getFitnessUnit|):
		a#(_) -> 0
		where <string-ends-with(|"Var") <+
		       string-ends-with(|"Const") <+
		       string-ends-with(|"Empty") <+
		       string-ends-with(|"Hole")> a
		       
	getFitness2(getFitnessUnit|):
		[] -> 0
		
	getFitness2(getFitnessUnit|):
		a#(b) -> <add> (score1, score2)
		where <string-ends-with(|"Syn") <+ string-ends-with(|"Builtin")> a
		where score1 := <all(getFitness2(getFitnessUnit|)) ; foldr(!0,add)> b
		where MemoMyCons ; one(?(a, _, terms))
		where score2 := <zip ; all(getFitnessUnit) ; foldr(!0,add)> (terms, <all(getSortFromTerm)> b)

	getFitness2(getFitnessUnit|):
		a#([x, y]) -> <foldr(!0,add)> [score1, score2, scorea, scoreb]
		where <string-ends-with(|"Rewrite") <+
		       string-ends-with(|"List") <+
		       string-ends-with(|"K1Seq")> a
		where score1 := <getFitness2(getFitnessUnit|)> x // calculate subtree score
		where score2 := <getFitness2(getFitnessUnit|)> y
		where scorea := <getFitnessUnit> (<getSort> a, <getSortFromTerm> x) // calculate local score
		where scoreb := <getFitnessUnit> (<getSort> a, <getSortFromTerm> y)

	getFitness2(getFitnessUnit|):
		a#(x) -> score
		where <string-ends-with(|"Item")> a
		// don't calculate the local score as it requires only K
		where score := <all(getFitness2(getFitnessUnit|)) ; foldr(!0,add)> x

	getFitness2(getFitnessUnit|):
		amb(x) -> <add> (score, 0)
		where score := <all(getFitness2(getFitnessUnit|)) ; foldr(!0,add)> x

	getFitness2(getFitnessUnit|):
		Bag1ClosedCell(x1, x2, x3, x4) -> <add> (score1, score2)
		where score1 := <getFitness2(getFitnessUnit|)> x3
		where MemoMyCells ; one(?(x1, expected2))
		where score2 := <getFitnessUnit> (expected2, <getSortFromTerm> x3)

	getFitness2(getFitnessUnit|):
		K1App(a, b) -> <foldr(!0,add)> [score1, score2, scorea, scoreb]
		where score1 := <getFitnessUnit> ("KLabel", <getSortFromTerm> a)
		where score2 := <getFitnessUnit> ("List{K}", <getSortFromTerm> b)
		where scorea := <getFitness2(getFitnessUnit|)> a // calculate subtree score
		where scoreb := <getFitness2(getFitnessUnit|)> b

	getFitnessUnit2:
		(expect, []) -> 0

	getFitnessUnit2:
		(expect, place) -> score
		where score :=  <(	isSubsortEq(|expect, place) ; !0 <+		// if the sort is a subsort then put 0
							isSubsortEq(|"K", expect) ; (<?"K"> place <+ <?"K"> expect); !0 <+ // if the sort is K then score it as 0, only if the expected sort is a subsort of K
							!-1								// if none of the above, then put -1
						)>
		//where <lt> (score, 0) ; <debug(!"Score: ")> (expect, place, score) <+ id

	getFitnessUnit3:
		(expect, []) -> 0

	getFitnessUnit3:
		(expect, place) -> score
		where score :=  <(	isSubsortEq(|expect, place) ; !0 <+		// if the sort is a subsort then put 1
							isSubsortEq(|"K", expect) ; <?"K"> place ; !-1 <+ // if the sort is K then score it as 0, only if the expected sort is a subsort of K
							!-1								// if none of the above, then put -1
						)>

	getSortFromTerm:
		amb(_) -> []
	getSortFromTerm:
		x#(_) -> y
		where y := <string-trim-last-one ; string-unescape-sort> x









 