load imp-syntax.kmaude


kmod IMP-SEMANTICS is including IMP-DESUGARED-SYNTAX
  subsort Int++ < Builtins KResult
  subsort List{Val} Type < KResult
  subsort DeclAnnot Stmts List{Exp} < K

  kvar M N N1 N2 : Nat
  kvar I J I1 I2 : Int++
  kvar NzI : NzInt
  kvar T : Type
  kvar NvT : NvType
  kvar F X : Id
  kvar Xl : List{Id}
  kvar V : Val
  kvar Vl : List{Val}
  kvar E E' E1 E2 : Exp
  kvar El El' : List{Exp}
  kvar S S1 S2 : Stmt
  kvar Ss : Stmts
  kvar K : K
  kvar NeK : NeK
  kvar L : KLabel
  kvar Phi Phi' : Formula
  kvar NtPhi : NtFormula
  kvar Subst Subst' : Subst
  kvar Env Env' : Map
  kvar Cfg : BagItem
  kvar Cfgs Cfgs' CfgItems : Bag


  op __`(_`):_=>_ : Type Id List{Id} Bag Bag -> MapItem


  configuration <T> 
                  <feasible > 0 </feasible>
                  <infeasible > 0 </infeasible>
                  <spec> .Map </spec>
                  <config>
                    <k> .K </k>
                    <env> .Map </env>
                    <heap> .Map </heap>
                    <form> TrueFormula </form>
                    <subst> .Subst </subst>
                    <newSym> 0 </newSym>
                    <newImpl> 0 </newImpl>
                  </config>
                </T>


  rule I1 + I2 => I1 +Int I2
  rule _-_(I1, I2) => _-Int_(I1, I2)
  rule _*_(I1, I2) => I1 *Int I2
  rule I1 / I2 => I1 /Int I2
  rule I1 % I2 => I1 %Int I2
  rule - I => -Int I
  rule I1 >= I2 => ?_(I1 >=Int I2)
  rule I1 > I2 => ?_(I1 >Int I2)
  rule I1 <= I2 => ?_(I1 <=Int I2)
  rule I1 < I2 => ?_(I1 <Int I2)
  rule I1 == I2 => ?_(I1 ==Int I2)

  rule I && E => (I ? 1 : 0) && E if notBool(I :: Int) [metadata "structural"]
  rule NzI && E => E
  rule 0 && E => 0
  rule I || E => (I ? 1 : 0) || E if notBool(I :: Int) [metadata "structural"]
  rule NzI || E => NzI
  rule 0 || E => E
  rule ! I => I ? 0 : 1 if notBool(I :: Int) [metadata "structural"]
  rule ! NzI => 1
  rule ! 0 => 1

  rule
    < config >
      < k > (I ? E1 : E2) ~> K </ k >
      < form > Phi </ form >
      CfgItems
    </ config >
  =>
    < config >
      < k > E1 ~> K </ k >
      < form > Phi /\ ~(I === 0) </ form >
      CfgItems
    </ config >
    < config >
      < k > E2 ~> K </ k >
      < form > Phi /\ I === 0 </ form >
      CfgItems
    </config>
  rule NzI ? E1 : E2 => E1
  rule 0 ? E1 : E2 => E2

  rule
    <k> int Xl ; => .K <_/k>
    <env_> .Map => Xl |-> range(N, length,,,(Xl)) <_/env>
    <newSym> N => N +Int length,,,(Xl) </newSym>
  rule I ; => .K [metadata "structural"]
  rule {} => .K [metadata "structural"]
  rule { Ss } => Ss [metadata "structural"]
  rule S1 S2 => S1 ~> S2 [metadata "structural"]

  rule
    <k> X => I <_/k> 
    <env_> X |-> I <_/env>
  rule
    <k> X = I ; => .K <_/k>
    <env_> X |-> (_ => I) <_/env>

  rule <k> * I => derive(I) ~> load(I) <_/k>
  [metadata "structural"]
  context (* [HOLE]) = _ ;
  rule <k> (* I) = J ; => derive(I) ~> store(I, J) <_/k>
  [metadata "structural"]
  rule
    <k> derive(I) => .K <_/k>
    <heap_> I |-> _ : _ <_/heap>
  [metadata "structural"]
  rule
    <k> derive(I) <_/k>
    <form> NtPhi => FalseFormula </form>
  if check-sat(NtPhi) ==Bool "unsat" 
  rule
    <k> load(I) => J <_/k>
    <heap_> I |-> J : L <_/heap>
  rule
    <k> store(I, J) => .K <_/k>
    <heap_> I |-> (_ => J) : L <_/heap>
  rule
    <k> return I ; => .K <_/k>
    <form> Phi => Phi /\ ?return === I </form>

  rule if (I) S1 else S2 => if (I ? 1 : 0) S1 else S2 if notBool(I :: Int)
  [metadata "structural"]
  rule if (NzI) S else _ => S
  rule if (0) _ else S => S

  rule
    <k>
      (// invariant Cfgs ~> while (E) S ~> K)
    =>
      (// assert Cfgs ~> 'if`(_`)_else_(E,, { S // assert Cfgs },, K))
    </k>
  [metadata "structural"]

  rule
    <config_> 
      <k>
        // assume
          <config>
            <env> Env' </env>
            <form> Phi' </form>
            CfgItems
          </config>
          Cfgs
        ~> K
      =>
        // assume Cfgs ~> K
      </k>
      <env> Env </env>
      <form> Phi </form>
      <subst> Subst </subst>
      <newSym> M </newSym>
      <newImpl> N </newImpl>
    <_/config>
    (
      .Bag
    =>
      <config>
        <k> K </k>
        (
          <env> Env[Env'] </env>
          <form> Phi /\ Phi' </form>
          CfgItems
        )[Subst]
        <subst> Subst </subst>
        <newSym> M </newSym>
        <newImpl> N </newImpl>
      </config>
    )
  [metadata "structural"]

  rule <config_> <k> // assume .Bag <_/k> <_/config> => .Bag
  [metadata "structural"]

  rule
    <config>
      <k> // assert Cfgs => // assume Cfgs <_/k>
      <subst> Subst => Subst' </subst>
      <newSym> M </newSym>
      <newImpl> N => sNat N </newImpl>
      (CfgItems => skolemize(N, CfgItems))
    </config>
  if search(
    <config>
      <subst> Subst </subst>
      <newImpl> N </newImpl>
      CfgItems
    </config>
    ===>
    Cfgs
  =>
    <config>
      <form> TrueFormula </form>
      <subst> Subst' </subst>
    </config>
  )

  rule
    <spec_> T F(Xl) : Cfgs => Cfgs' <_/spec>
    <config>
      <k> _`(_`)(F, Vl) => // assume Cfgs'[Subst'] ~> return(T) <_/k>
      (<env> Env </env> => skolemize(N, <env> Env </env>))
      <subst> Subst </subst>
      <newSym> M </newSym>
      <newImpl> N => sNat N </newImpl>
      (CfgItems => skolemize(N, CfgItems))
    </config>
  if search(
    <config>
      <env> Xl |-> Vl </env>
      <subst> Subst </subst>
      <newImpl> N </newImpl>
      CfgItems
    </config>
    ===>
    Cfgs
  =>
    <config>
      <form> TrueFormula </form>
      <subst> Subst' </subst>
    </config>
  )
  rule
    <k> return(NvT) => I <_/k>
    <form> Phi /\ ?return === I => Phi </form>
  [metadata "structural"]
  rule <k> return(void) => NULL <_/k> [metadata "structural"]

  rule
      __`(_`)_`{_`}(T, F, Xl, (//pre Cfgs //post Cfgs'), Ss)
    =>
      //assume Cfgs ~> Ss ~> //assert Cfgs'


  op mkSpec : K -> Map
  rule
      mkSpec((__`(_`)_`{_`}(T, F, Xl, (//pre Cfgs //post Cfgs'), Ss) ~> K))
    =>
      T F(Xl) : co-skolemize(Cfgs) => co-skolemize(rmEnv(Cfgs')) mkSpec(K)
  [metadata "structural"]
  rule mkSpec(.K) => .Map [metadata "structural"]

  op rmEnv : Bag -> Bag
  rule
      rmEnv(<config> <env> Env </env> CfgItems </config> Cfgs)
    =>
      <config> <env> .Map </env> CfgItems </config> rmEnv(Cfgs)
  [metadata "structural"]
  rule rmEnv(.Bag) => .Bag [metadata "structural"]

  rule E,,, El |-> E',,, El' => E |-> E' El |-> El' [metadata "structural"]
  rule .List{Id} |-> .List{Id} => .Map [metadata "structural"]

  op length`,`,`,_ : List{Exp} -> Nat
  rule length,,,(X,,, Xl) => sNat length,,,(Xl) [metadata "structural"]
  rule length,,,(.List{Id}) => 0 [metadata "structural"]

  op range : Nat Nat -> List{Val}
  rule range(N, sNat(M)) => ?Int(N),,, range(sNat N, M) [metadata "structural"]
  rule range(N, 0) => .List{Id} [metadata "structural"]
endkm

