\setlength{\parindent}{1em}
\title{KOOL --- Untyped}
\author{Grigore Ro\c{s}u and 
        Traian Florin \c{S}erb\u{a}nu\c{t}\u{a}
        (\texttt{\{grosu,tserban2\}@illinois.edu})}
\organization{University of Illinois at Urbana-Champaign}

\maketitle

\begin{latexComment}
\section{Abstract}
This is the \K semantic definition of the untyped KOOL language.
KOOL is aimed at being a pedagogical and research language that
captures the essence of the object-oriented programming paradigm.
Its untyped variant discussed here is simpler than the typed one,
ignoring several intricate aspects of types in the
presence of objects.  A program consists of a set of class declarations.
Each class can extend at most one other class (KOOL is single-inheritance).
A class can declare a set of fields and a set of methods, all public and
called the class' members.
Specifically, KOOL includes the following features:
\begin{itemize}
\item Class declarations, where a class may or may not extend another class.
In case a class does not explicitly extend another class, then it is assumed
that it extends the default top-most and empty (i.e., no members)
class called \texttt{object}.  Each class is required to declare precisely one
homonymous method, called its constructor.  Each valid program should contain
one class called \texttt{main}, whose constructor, \texttt{main()}, takes no
arguments.  The execution of a program consists of creating an object instance
of class \texttt{main} and invoking the constructor \texttt{main()} on it,
that is, of executing ``\texttt{new main();}''.
\item All features of SIMPLE (see
{\footnotesize\texttt{examples/languages/research/simple/untyped}}),
that is, multidimensional arrays, function (or rather method) abstractions
with call-by-value parameter passing style and static scoping, blocks with
locals, input/output, parametric exceptions, and concurrency via dynamic
thread creation/termination and synchronization.  The only change in the
syntax of SIMPLE when imported in KOOL is the function declaration keyword,
\texttt{function}, which is changed into \texttt{method}.  The exact same
desugaring macros from SIMPLE are also included in KOOL.  One can think of
KOOL's classes as embedding SIMPLE programs (extended with OO constructs,
as discussed next).
\item Object creation using the ``\texttt{new C(e1,...,en)}'' expression
construct.  An object instance of class \texttt{C} is first created and then
the constructor \texttt{C(e1,...,en)} is called on that object.  KOOL only
allows (and requires) one constructor per class.
\item An expression construct \texttt{this}, which evaluates to the current
object.
\item An expression construct \texttt{super}, which is used (only) in
combination with member lookup (see next) to refer to a superclass field or
method.
\item A member lookup expression construct \texttt{e.x}, where \texttt{e}
is an expression (either an expression expected to evaluate to an object
or the \texttt{super} construct) and \texttt{x} is a class member name,
that is, a field or a method name.
\item Expression constructs ``\texttt{e instanceOf C}'' and
``\texttt{cast e to C}'', where \texttt{e} is an expression expected to evaluate
to an object and \texttt{C} a class name.  The former tells whether the class
of \texttt{e} is a subclass of \texttt{C}, that is, whether can be used as an
instance of \texttt{C}, and the latter changes the class of \texttt{e} to
\texttt{C}.  The former always succeeds and returns a Boolean value, while
the latter gets stuck if \texttt{e} cannot be cast to \texttt{C}.
\end{itemize}

There are some specific aspects of KOOL that need to be discussed.

First, KOOL is higher-order, allowing function abstractions to be treated like
any other values in the language.  For example, if \texttt{m} is a method of
object \texttt{e} then \texttt{e.m} evaluates to the corresponding function
abstraction.  The function abstraction is in fact a closure, because in addition
to the method parameters and body it also encapsulates the object value that
\texttt{e} evaluates to.  This way, function abstractions can be invoked
anywhere and have the capability to change the state of their object.

Second, since all the fields and methods are public in KOOL and since
they can be redeclared in subclasses, it is not immediately
clear how to lookup the member \texttt{x} when we write \texttt{e.x}
and \texttt{e} is different from \texttt{super}.
We distingush two cases, depending on whether \texttt{e.x} occurs in a
method invocation context or not.  KOOL has dynamic method
dispatch, so if \texttt{e.x} is invoked as a method then \texttt{x}
will be searched starting with the instance class of the object value
to which \texttt{e} evaluates.  If \texttt{e.x} occurs in a
non-method-invocation context then \texttt{x} will be searched
starting with the current class of the object value of \texttt{e}
(which, because of \texttt{this} and casting, may be different from
its instance class).  In order to achieve the above, each object value
will consist of a pair holding the current class of the object and an
environment stack with one layer for each class in the object's
instance class hierarchy.

In what follows, we limit our comments to the new, KOOL-specific aspects of the
language.  We refer the reader to the untyped SIMPLE language for documentation
on the the remaining features, because those were all borrowed from SIMPLE.
\end{latexComment}

\vspace*{3ex}
