in ../../../k-prelude
in fun-untyped-syntax.kmaude
in ../fun-programs


mod FUN-UNTYPED-SEMANTICS is including FUN-DESUGARED-SYNTAX + K 
--- We need values when we define the semantics
  sort Val 
  subsort Int Bool < Val < Exp 

--- We have to subsort all the syntactic categories to K, and the lists of values
--- to KResult.  Recall that the second argument of a function application is a list
--- of expressions, so that becomes a result when it becomes a list of values
  subsort List{Exp} Binding < K 
  subsort List{Val} < KResult 

  configuration <T>
                     <k> .K </k>
                     <env> .Map </env>
                     <store> .Map </store>
                     <nextLoc> 0 </nextLoc>
                   </T> 

  rule <k> X:Id => V:Val <_/k> <env_> X |-> L:Nat <_/env> <store_> L |-> V <_/store> 
  rule I1:Int + I2:Int => I1 +Int I2 
  rule _-_(I1,I2) => _-Int_(I1,I2) 
  rule I1 * I2 => I1 *Int I2 
  rule I1 / I2 => I1 /Int I2 if I2 =/=Bool 0 
  rule I1 % I2 => I1 %Int I2 if I2 =/=Bool 0
  rule - I:Int => -Int I 
  rule I1 < I2 => I1 <Int I2 
  rule I1 <= I2 => I1 <=Int I2 
  rule I1 > I2 => I1 >Int I2 
  rule I1 >= I2 => I1 >=Int I2 
  rule V1:Val == V2:Val => V1 ==Bool V2 
  rule V1 != V2 => V1 =/=Bool V2 
  rule T1:Bool and T2:Bool => T1 andBool T2 
  rule T1 or T2 => T1 orBool T2 
  rule not(T:Bool) => notBool(T) 
  op closure : Map List{Id} Exp -> Val 
  rule <k> fun Xl:List`{Id`} -> E:Exp => closure(Env:Map,Xl,E) <_/k> <env> Env </env> 
  rule <k> closure(Env,Xl,E) Vl:List`{Val`} => [Vl] ~> bindTo(Xl) ~> E ~> env(Env') <_/k> <env> Env':Map =>  Env </env> 
  rule <k> let Xl = El:List`{Exp`} in E => [El] ~> bindTo(Xl) ~> E ~> env(Env) <_/k> <env> Env </env> 
  rule <k> letrec Xl = El in E => bindTo(Xl) ~> [El] ~> writeTo(Xl) ~> E ~> env(Env) <_/k> <env> Env </env> 
  op cc : Map K -> Val 
  rule <k> (callcc V => V cc(Env,K)) ~> K </k> <env> Env </env> 
  rule <k> cc(Env,K:K) V ~>  _  => V ~> K </k> <env>  _  => Env </env> 
  rule if true then E else  _  => E 
  rule if false then  _  else E => E 
  rule car [V,Vl] => V 
  rule cdr [V,Vl] => [Vl] 
  rule null? [.List{Id}] => true 
  rule null? [V,Vl] => false 
  rule cons V [Vl] => [V,Vl] 
  rule <k> ref V => L <_/k> <store_> .Map => L |-> V <_/store> <nextLoc> L => sNat L </nextLoc> 
  rule <k> & X => L <_/k> <env_> X |-> L <_/env> 
  rule <k> * L => V <_/k> <store_> L |-> V <_/store> 
  rule <k> L := V => V  <_/k> <store_> L |-> ( _  => V) <_/store> 
  rule V1 ; V2 => V2 

----------------------------------------------
--- Auxilliary declarations and operations ---
----------------------------------------------
--- List{Val}
  sort List{Val} 
  subsort Val < List{Val} < List{Exp} 
  op _`,_ : List{Val} List{Val} -> List{Val} [ditto] 
--- length
  op |_| : List{Id} -> Nat  [metadata "latex(renameTo \\ensuremath|_\\ensuremath|)"]
  eq | .List{Id} | = 0   eq | X,Xl | = sNat(| Xl |) 
--- generate sequence of locations
  op _from_ : Nat Nat -> List{K}   eq 0 from N1:Nat = .List{K}  eq sNat N2:Nat from N1 = (N1,,(N2 from sNat N1)) 
--- environment recovery
  op env : Map -> K 
  rule (env( _ ) ~> env(Env) => env(Env)) [structural] 
  rule <k> env(Env) => .K <_/k> <env>  _  => Env </env> [structural] 
  rule <k> V ~> (env(Env) => .K) <_/k> <env>  _  => Env </env> [structural] 
--- bindTo and writeTo
  ops bindTo writeTo : List{Id} -> K 
  rule <k> [Vl] ~> bindTo(Xl) => .K <_/k>
          <env> Env =>  Env[| Xl | from N:Nat / getList{K}(Xl)] </env>
          <store_> .Map => | Xl | from N |-> getList{K}(Vl) <_/store>
          <nextLoc> N => N +Nat | Xl | </nextLoc> 
  rule <k> bindTo(Xl) => .K <_/k>
          <env> Env =>  Env[| Xl | from N / getList{K}(Xl)] </env>
          <nextLoc> N => N +Nat | Xl | </nextLoc> 
  rule <k> [Vl] ~> writeTo(Xl) => .K <_/k>
          <env> Env </env>
          <store> Sigma:Map => Sigma[getList{K}(Vl) / Env(getList{K}(Xl))] </store> 
endm


mod FUN-UNTYPED is including FUN-UNTYPED-SEMANTICS + FUN-PROGRAMS 
--- make sure the name of the final module is the capitalized version of the file name
  op run : KLabel -> Bag 
  eq run(KL:KLabel) = run(KL,.List{K}) 
  op run : KLabel List{K} -> Bag 
  eq run(KL,L:List`{K`}) = <T> <k> KL(L) </k> <env> .Map </env> <store> .Map </store> <nextLoc> 0 </nextLoc> </T> 
endm
