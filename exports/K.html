
<!DOCTYPE html>
<html>
  <head>
    <title>K</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
    .markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview .pagebreak,.markdown-preview .newpage{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers>code{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center !important}.markdown-preview:not([for="preview"]) .code-chunk .btn-group{display:none}.markdown-preview:not([for="preview"]) .code-chunk .status{display:none}.markdown-preview:not([for="preview"]) .code-chunk .output-div{margin-bottom:16px}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,0.66);border:4px solid rgba(150,150,150,0.66);background-clip:content-box}html body[for="html-export"]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0}@media screen and (min-width:914px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px + 2em)}}@media screen and (max-width:914px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{font-size:14px !important;padding:1em}}@media print{html body[for="html-export"]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for="html-export"]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,0.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,0.66);border:4px solid rgba(150,150,150,0.66);background-clip:content-box}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc ul{padding:0 1.6em;margin-top:.8em}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc li{margin-bottom:.8em}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc ul{list-style-type:none}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% -  300px);padding:2em calc(50% - 457px -  150px);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for="html-export"]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for="html-export"]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none}/**
 * prism.js Github theme based on GitHub's theme.
 * @author Sam Clarke
 */
code[class*="language-"],
pre[class*="language-"] {
  color: #333;
  background: none;
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  text-align: left;
  white-space: pre;
  word-spacing: normal;
  word-break: normal;
  word-wrap: normal;
  line-height: 1.4;

  -moz-tab-size: 8;
  -o-tab-size: 8;
  tab-size: 8;

  -webkit-hyphens: none;
  -moz-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
}

/* Code blocks */
pre[class*="language-"] {
  padding: .8em;
  overflow: auto;
  /* border: 1px solid #ddd; */
  border-radius: 3px;
  /* background: #fff; */
  background: #f5f5f5;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
  padding: .1em;
  border-radius: .3em;
  white-space: normal;
  background: #f5f5f5;
}

.token.comment,
.token.blockquote {
  color: #969896;
}

.token.cdata {
  color: #183691;
}

.token.doctype,
.token.punctuation,
.token.variable,
.token.macro.property {
  color: #333;
}

.token.operator,
.token.important,
.token.keyword,
.token.rule,
.token.builtin {
  color: #a71d5d;
}

.token.string,
.token.url,
.token.regex,
.token.attr-value {
  color: #183691;
}

.token.property,
.token.number,
.token.boolean,
.token.entity,
.token.atrule,
.token.constant,
.token.symbol,
.token.command,
.token.code {
  color: #0086b3;
}

.token.tag,
.token.selector,
.token.prolog {
  color: #63a35c;
}

.token.function,
.token.namespace,
.token.pseudo-element,
.token.class,
.token.class-name,
.token.pseudo-class,
.token.id,
.token.url-reference .token.variable,
.token.attr-name {
  color: #795da3;
}

.token.entity {
  cursor: help;
}

.token.title,
.token.title .token.punctuation {
  font-weight: bold;
  color: #1d3e81;
}

.token.list {
  color: #ed6a43;
}

.token.inserted {
  background-color: #eaffea;
  color: #55a532;
}

.token.deleted {
  background-color: #ffecec;
  color: #bd2c00;
}

.token.bold {
  font-weight: bold;
}

.token.italic {
  font-style: italic;
}


/* JSON */
.language-json .token.property {
  color: #183691;
}

.language-markup .token.tag .token.punctuation {
  color: #333;
}

/* CSS */
code.language-css,
.language-css .token.function {
  color: #0086b3;
}

/* YAML */
.language-yaml .token.atrule {
  color: #63a35c;
}

code.language-yaml {
  color: #183691;
}

/* Ruby */
.language-ruby .token.function {
  color: #333;
}

/* Markdown */
.language-markdown .token.url {
  color: #795da3;
}

/* Makefile */
.language-makefile .token.symbol {
  color: #795da3;
}

.language-makefile .token.variable {
  color: #183691;
}

.language-makefile .token.builtin {
  color: #0086b3;
}

/* Bash */
.language-bash .token.keyword {
  color: #0086b3;
}

/* highlight */
pre[data-line] {
  position: relative;
  padding: 1em 0 1em 3em;
}
pre[data-line] .line-highlight-wrapper {
  position: absolute;
  top: 0;
  left: 0;
  background-color: transparent;
  display: block;
  width: 100%;
}

pre[data-line] .line-highlight {
  position: absolute;
  left: 0;
  right: 0;
  padding: inherit 0;
  margin-top: 1em;
  background: hsla(24, 20%, 50%,.08);
  background: linear-gradient(to right, hsla(24, 20%, 50%,.1) 70%, hsla(24, 20%, 50%,0));
  pointer-events: none;
  line-height: inherit;
  white-space: pre;
}

pre[data-line] .line-highlight:before, 
pre[data-line] .line-highlight[data-end]:after {
  content: attr(data-start);
  position: absolute;
  top: .4em;
  left: .6em;
  min-width: 1em;
  padding: 0 .5em;
  background-color: hsla(24, 20%, 50%,.4);
  color: hsl(24, 20%, 95%);
  font: bold 65%/1.5 sans-serif;
  text-align: center;
  vertical-align: .3em;
  border-radius: 999px;
  text-shadow: none;
  box-shadow: 0 1px white;
}

pre[data-line] .line-highlight[data-end]:after {
  content: attr(data-end);
  top: auto;
  bottom: .4em;
}.emoji {
  height: 0.8em;
}html body{font-family:"Helvetica Neue",Helvetica,"Segoe UI",Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body>:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body>p{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body>ul,html body>ol{margin-bottom:16px}html body ul,html body ol{padding-left:2em}html body ul.no-list,html body ol.no-list{padding:0;list-style-type:none}html body ul ul,html body ul ol,html body ol ol,html body ol ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li>p{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;background-color:#f0f0f0;border-left:4px solid #d6d6d6}html body blockquote>:first-child{margin-top:0}html body blockquote>:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:bold;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:bold}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em !important;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::before,html body code::after{letter-spacing:-0.2em;content:"\00a0"}html body pre>code{padding:0;margin:0;font-size:.85em !important;word-break:normal;white-space:pre;background:transparent;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;font-size:.85em !important;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:before,html body pre tt:before,html body pre code:after,html body pre tt:after{content:normal}html body p,html body blockquote,html body ul,html body ol,html body dl,html body pre{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body pre,html body code{word-wrap:break-word;white-space:pre}}
    /* Please visit the URL below for more information: */
/*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */

    </style>
    <link rel="stylesheet" href="file:////home/runner/work/k/k/gh-pages/web/node_modules/@shd101wyy/mume/dependencies/katex/katex.min.css">
  </head>
  <body for="html-export">
    <div class="mume markdown-preview">
    <html><head></head><body><div><h1 class="mume-header" id="k" ebook-toc-level-1 heading="K">K</h1>

<h1 class="mume-header" id="table-of-contents" ebook-toc-level-1 heading="Table of Contents">Table of Contents</h1>

<ul>
<li><a href="#ebook-heading-homepage">Homepage</a></li>
<li><a href="#ebook-heading-install-k">Install K</a></li>
<li><a href="#ebook-heading-pyk-documentation">Pyk Documentation</a></li>
<li><a href="#ebook-heading-k-tutorial">K Tutorial</a>
<ul>
<li><a href="#ebook-heading-section-1-basic-k-concepts">Section 1: Basic K Concepts</a>
<ul>
<li><a href="#ebook-heading-lesson-11-setting-up-a-k-environment">Lesson 1.1: Setting up a K Environment</a></li>
<li><a href="#ebook-heading-lesson-12-basics-of-functional-k">Lesson 1.2: Basics of Functional K</a></li>
<li><a href="#ebook-heading-lesson-13-bnf-syntax-and-parser-generation">Lesson 1.3: BNF Syntax and Parser Generation</a></li>
<li><a href="#ebook-heading-lesson-14-disambiguating-parses">Lesson 1.4: Disambiguating Parses</a></li>
<li><a href="#ebook-heading-lesson-15-modules-imports-and-requires">Lesson 1.5: Modules, Imports, and Requires</a></li>
<li><a href="#ebook-heading-lesson-16-integers-and-booleans">Lesson 1.6: Integers and Booleans</a></li>
<li><a href="#ebook-heading-lesson-17-side-conditions-and-rule-priority">Lesson 1.7: Side Conditions and Rule Priority</a></li>
<li><a href="#ebook-heading-lesson-18-literate-programming-with-markdown">Lesson 1.8: Literate Programming with Markdown</a></li>
<li><a href="#ebook-heading-lesson-19-unparsing-and-the-format-and-color-attributes">Lesson 1.9: Unparsing and the format and color attributes</a></li>
<li><a href="#ebook-heading-lesson-110-strings">Lesson 1.10: Strings</a></li>
<li><a href="#ebook-heading-lesson-111-casting-terms">Lesson 1.11: Casting Terms</a></li>
<li><a href="#ebook-heading-lesson-112-syntactic-lists">Lesson 1.12: Syntactic Lists</a></li>
<li><a href="#ebook-heading-lesson-113-basics-of-k-rewriting">Lesson 1.13: Basics of K Rewriting</a></li>
<li><a href="#ebook-heading-lesson-114-defining-evaluation-order">Lesson 1.14: Defining Evaluation Order</a></li>
<li><a href="#ebook-heading-lesson-115-configuration-declarations-and-cell-nesting">Lesson 1.15: Configuration Declarations and Cell Nesting</a></li>
<li><a href="#ebook-heading-lesson-116-maps-semantic-lists-and-sets">Lesson 1.16: Maps, Semantic Lists, and Sets</a></li>
<li><a href="#ebook-heading-lesson-117-cell-multiplicity-and-cell-collections">Lesson 1.17: Cell Multiplicity and Cell Collections</a></li>
<li><a href="#ebook-heading-lesson-118-term-equality-and-the-ternary-operator">Lesson 1.18: Term Equality and the Ternary Operator</a></li>
<li><a href="#ebook-heading-lesson-119-debugging-with-gdb-or-lldb">Lesson 1.19: Debugging with GDB or LLDB</a></li>
<li><a href="#ebook-heading-lesson-120-k-backends-and-the-haskell-backend">Lesson 1.20: K Backends and the Haskell Backend</a></li>
<li><a href="#ebook-heading-lesson-121-unification-and-symbolic-execution">Lesson 1.21: Unification and Symbolic Execution</a></li>
<li><a href="#ebook-heading-lesson-122-k-deductive-verification">Lesson 1.22: K Deductive Verification</a></li>
</ul>
</li>
<li><a href="#ebook-heading-section-2-intermediate-k-concepts">Section 2: Intermediate K Concepts</a>
<ul>
<li><a href="#ebook-heading-lesson-21-macros-aliases-and-anywhere-rules">Lesson 2.1: Macros, Aliases, and Anywhere Rules</a></li>
<li><a href="#ebook-heading-lesson-22-fresh-constants">Lesson 2.2: Fresh Constants</a></li>
<li><a href="#ebook-heading-lesson-23-klabels-and-abstract-syntax">Lesson 2.3: KLabels and Abstract Syntax</a></li>
<li><a href="#ebook-heading-lesson-24-overloaded-symbols">Lesson 2.4: Overloaded Symbols</a></li>
<li><a href="#ebook-heading-lesson-25-matching-logic-connectives-and-or-patterns">Lesson 2.5: Matching Logic Connectives and #Or Patterns</a></li>
<li><a href="#ebook-heading-lesson-26-function-context">Lesson 2.6: Function Context</a></li>
<li><a href="#ebook-heading-lesson-27-record-productions-and-named-nonterminals">Lesson 2.7: Record Productions and Named Nonterminals</a></li>
<li><a href="#ebook-heading-lesson-28-fun-and-let">Lesson 2.8: #fun and #let</a></li>
<li><a href="#ebook-heading-lesson-29-as-patterns">Lesson 2.9: #as Patterns</a></li>
<li><a href="#ebook-heading-lesson-210-the-matching-operators-k-and-k">Lesson 2.10: The Matching Operators, :=K and :/=K</a></li>
<li><a href="#ebook-heading-lesson-211-uncommon-evaluation-order-concepts">Lesson 2.11: Uncommon Evaluation Order Concepts</a></li>
<li><a href="#ebook-heading-lesson-212-ieee-754-floating-point-and-fixed-width-integers">Lesson 2.12: IEEE 754 Floating Point and Fixed Width Integers</a></li>
<li><a href="#ebook-heading-lesson-213-alpha-renaming-aware-substitution">Lesson 2.13: Alpha-renaming-aware Substitution</a></li>
<li><a href="#ebook-heading-lesson-214-file-io">Lesson 2.14: File I/O</a></li>
<li><a href="#ebook-heading-lesson-215-string-buffers-and-byte-sequences">Lesson 2.15: String Buffers and Byte Sequences</a></li>
<li><a href="#ebook-heading-lesson-216-the-intermediate-language-of-k-kore">Lesson 2.16: The Intermediate Language of K, KORE</a></li>
<li><a href="#ebook-heading-lesson-217-debugging-proofs-using-the-haskell-backend-repl">Lesson 2.17: Debugging Proofs using the Haskell Backend REPL</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#ebook-heading-k-user-manual">K User Manual</a></li>
<li><a href="#ebook-heading-k-cheat-sheet">K Cheat Sheet</a></li>
<li><a href="#ebook-heading-k-tool-reference">K Tool Reference</a></li>
<li><a href="#ebook-heading-k-builtins">K Builtins</a>
<ul>
<li><a href="#ebook-heading-domains">domains</a></li>
<li><a href="#ebook-heading-kast">kast</a></li>
<li><a href="#ebook-heading-prelude">prelude</a></li>
<li><a href="#ebook-heading-ffi">ffi</a></li>
<li><a href="#ebook-heading-json">json</a></li>
<li><a href="#ebook-heading-rat">rat</a></li>
<li><a href="#ebook-heading-substitution">substitution</a></li>
<li><a href="#ebook-heading-unification">unification</a></li>
</ul>
</li>
<li><a href="#ebook-heading-k-pl-tutorial">K PL Tutorial</a>
<ul>
<li><a href="#ebook-heading-k-overview">K Overview</a></li>
<li><a href="#ebook-heading-learning-k">Learning K</a>
<ul>
<li><a href="#ebook-heading-part-1-defining-lambda">Part 1: Defining LAMBDA</a>
<ul>
<li><a href="#ebook-heading-lesson-1-lambda-syntax-modules-and-basic-k-commands">Lesson 1, LAMBDA: Syntax Modules and Basic K Commands</a></li>
<li><a href="#ebook-heading-lesson-2-lambda-module-importing-rules-variables">Lesson 2, LAMBDA: Module Importing, Rules, Variables</a></li>
<li><a href="#ebook-heading-lesson-3-lambda-evaluation-strategies-using-strictness">Lesson 3, LAMBDA: Evaluation Strategies using Strictness</a></li>
<li><a href="#ebook-heading-lesson-4-lambda-generating-documentation-latex-attributes">Lesson 4, LAMBDA: Generating Documentation; Latex Attributes</a></li>
<li><a href="#ebook-heading-lesson-5-lambda-adding-builtins-side-conditions">Lesson 5, LAMBDA: Adding Builtins; Side Conditions</a></li>
<li><a href="#ebook-heading-lesson-6-lambda-selective-strictness-anonymous-variables">Lesson 6, LAMBDA: Selective Strictness; Anonymous Variables</a></li>
<li><a href="#ebook-heading-lesson-7-lambda-derived-constructs-extending-predefined-syntax">Lesson 7, LAMBDA: Derived Constructs; Extending Predefined Syntax</a></li>
<li><a href="#ebook-heading-lesson-8-lambda-multiple-binding-constructs">Lesson 8, LAMBDA: Multiple Binding Constructs</a></li>
<li><a href="#ebook-heading-lesson-9-lambda-a-complete-and-commented-definition">Lesson 9, LAMBDA: A Complete and Commented Definition</a></li>
</ul>
</li>
<li><a href="#ebook-heading-part-2-defining-imp">Part 2: Defining IMP</a>
<ul>
<li><a href="#ebook-heading-lesson-1-imp-defining-a-more-complex-syntax">Lesson 1, IMP: Defining a More Complex Syntax</a></li>
<li><a href="#ebook-heading-lesson-2-imp-defining-a-configuration">Lesson 2, IMP: Defining a Configuration</a></li>
<li><a href="#ebook-heading-lesson-3-imp-computations-results-strictness-rules-involving-cells">Lesson 3, IMP: Computations, Results, Strictness; Rules Involving Cells</a></li>
<li><a href="#ebook-heading-lesson-4-imp-configuration-abstraction-part-1-types-of-rules">Lesson 4, IMP: Configuration Abstraction, Part 1; Types of Rules</a></li>
<li><a href="#ebook-heading-lesson-5-imp-completing-and-documenting-imp">Lesson 5, IMP: Completing and Documenting IMP</a></li>
</ul>
</li>
<li><a href="#ebook-heading-part-3-defining-lambda">Part 3: Defining LAMBDA++</a>
<ul>
<li><a href="#ebook-heading-lesson-1-lambda-abrupt-changes-of-control">Lesson 1, LAMBDA++: Abrupt Changes of Control</a></li>
<li><a href="#ebook-heading-lesson-2-lambda-semantic-non-syntactic-computation-items">Lesson 2, LAMBDA++: Semantic (Non-Syntactic) Computation Items</a></li>
<li><a href="#ebook-heading-lesson-3-lambda-reusing-existing-semantics">Lesson 3, LAMBDA++: Reusing Existing Semantics</a></li>
<li><a href="#ebook-heading-lesson-4-lambda-do-not-reuse-blindly">Lesson 4, LAMBDA++: Do Not Reuse Blindly!</a></li>
<li><a href="#ebook-heading-lesson-5-lambda-more-semantic-computation-items">Lesson 5, LAMBDA++: More Semantic Computation Items</a></li>
<li><a href="#ebook-heading-lesson-6-lambda-wrapping-up-and-documenting-lambda-environment-based">Lesson 6, LAMBDA++: Wrapping Up and Documenting LAMBDA++ (environment-based)</a></li>
</ul>
</li>
<li><a href="#ebook-heading-part-4-defining-imp">Part 4: Defining IMP++</a>
<ul>
<li><a href="#ebook-heading-lesson-1-imp-extendingchanging-an-existing-language-syntax">Lesson 1, IMP++: Extending/Changing an Existing Language Syntax</a></li>
<li><a href="#ebook-heading-lesson-2-imp-configuration-refinement-freshness">Lesson 2, IMP++: Configuration Refinement; Freshness</a></li>
<li><a href="#ebook-heading-lesson-3-imp-tagging-superheatsupercool-kompilation-options">Lesson 3, IMP++: Tagging; Superheat/Supercool Kompilation Options</a></li>
<li><a href="#ebook-heading-lesson-4-imp-semantic-lists-inputoutput-streaming">Lesson 4, IMP++: Semantic Lists; Input/Output Streaming</a></li>
<li><a href="#ebook-heading-lesson-5-imp-deleting-saving-and-restoring-cell-contents">Lesson 5, IMP++: Deleting, Saving and Restoring Cell Contents</a></li>
<li><a href="#ebook-heading-lesson-6-imp-addingdeleting-cells-dynamically-configuration-abstraction-part-2">Lesson 6, IMP++: Adding/Deleting Cells Dynamically; Configuration Abstraction, Part 2</a></li>
<li><a href="#ebook-heading-lesson-7-imp-everything-changes-syntax-configuration-semantics">Lesson 7, IMP++: Everything Changes: Syntax, Configuration, Semantics</a></li>
<li><a href="#ebook-heading-lesson-8-imp-wrapping-up-larger-languages">Lesson 8, IMP++: Wrapping up Larger Languages</a></li>
</ul>
</li>
<li><a href="#ebook-heading-part-5-defining-type-systems">Part 5: Defining Type Systems</a>
<ul>
<li><a href="#ebook-heading-lesson-1-type-systems-imperative-environment-based-type-systems">Lesson 1, Type Systems: Imperative, Environment-Based Type Systems</a></li>
<li><a href="#ebook-heading-lesson-2-type-systems-substitution-based-higher-order-type-systems">Lesson 2, Type Systems: Substitution-Based Higher-Order Type Systems</a></li>
<li><a href="#ebook-heading-lesson-3-type-systems-environment-based-higher-order-type-systems">Lesson 3, Type Systems: Environment-Based Higher-Order Type Systems</a></li>
<li><a href="#ebook-heading-lesson-4-type-systems-a-naive-substitution-based-type-inferencer">Lesson 4, Type Systems: A Naive Substitution-Based Type Inferencer</a></li>
<li><a href="#ebook-heading-lesson-5-type-systems-a-naive-environment-based-type-inferencer">Lesson 5, Type Systems: A Naive Environment-Based Type Inferencer</a></li>
<li><a href="#ebook-heading-lesson-6-type-systems-parallel-type-checkersinferencers">Lesson 6, Type Systems: Parallel Type Checkers/Inferencers</a></li>
<li><a href="#ebook-heading-lesson-7-type-systems-a-naive-substitution-based-polymorphic-type-inferencer">Lesson 7, Type Systems: A Naive Substitution-based Polymorphic Type Inferencer</a></li>
<li><a href="#ebook-heading-lesson-8-type-systems-a-naive-environment-based-polymorphic-type-inferencer">Lesson 8, Type Systems: A Naive Environment-based Polymorphic Type Inferencer</a></li>
<li><a href="#ebook-heading-lesson-9-type-systems-let-polymorphic-type-inferencer-damas-hindley-milner">Lesson 9, Type Systems: Let-Polymorphic Type Inferencer (Damas-Hindley-Milner)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#ebook-heading-learning-language-design-and-semantics-using-k">Learning Language Design and Semantics using K</a>
<ul>
<li><a href="#ebook-heading-part-7-simple-designing-imperative-programming-languages">Part 7: SIMPLE: Designing Imperative Programming Languages</a>
<ul>
<li><a href="#ebook-heading-lesson-1-simple-untyped">Lesson 1, SIMPLE untyped</a></li>
<li><a href="#ebook-heading-lesson-2-simple-typed-static">Lesson 2, SIMPLE typed static</a></li>
<li><a href="#ebook-heading-lesson-3-simple-typed-dynamic">Lesson 3, SIMPLE typed dynamic</a></li>
</ul>
</li>
<li><a href="#ebook-heading-part-8-kool-designing-object-oriented-programming-languages">Part 8: KOOL: Designing Object-Oriented Programming Languages</a>
<ul>
<li><a href="#ebook-heading-lesson-1-kool-untyped">Lesson 1, KOOL untyped</a></li>
<li><a href="#ebook-heading-lesson-2-kool-typed-dynamic">Lesson 2, KOOL typed dynamic</a></li>
<li><a href="#ebook-heading-lesson-3-kool-typed-static">Lesson 3, KOOL typed static</a></li>
</ul>
</li>
<li><a href="#ebook-heading-part-9-fun-designing-functional-programming-languages">Part 9: FUN: Designing Functional Programming Languages</a>
<ul>
<li><a href="#ebook-heading-lesson-1-fun-untyped-environment-based">Lesson 1, FUN untyped, Environment-Based</a></li>
<li><a href="#ebook-heading-lesson-2-fun-untyped-substitution-based">Lesson 2, FUN untyped, Substitution-Based</a></li>
<li>Lesson 3, FUN polymorphic type inferencer</li>
</ul>
</li>
<li><a href="#ebook-heading-part-10-logik-designing-logic-programming-languages">Part 10: LOGIK: Designing Logic Programming Languages</a>
<ul>
<li><a href="#ebook-heading-lesson-1-logik">Lesson 1, LOGIK</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#ebook-heading-projects-using-k">Projects using K</a></li>
</ul>
<div class="pagebreak"> </div>
</div><div id="ebook-heading-homepage" ebook-toc-level-1 heading="Homepage"><div><p><b style="font-size: 36px; line-height: 1;">K</b> is a rewrite-based<br>
executable semantic framework in which programming languages, type<br>
systems and formal analysis tools can be defined using configurations<br>
and rules.  Configurations organize the state in units called cells,<br>
which are labeled and can be nested.  K rewrite rules make it explicit<br>
which parts of the term are read-only, write-only, read-write, or<br>
unused.  This makes K suitable for defining truly concurrent languages<br>
even in the presence of sharing.  Computations are represented as<br>
syntactic extensions of the original language abstract syntax, using a<br>
nested list structure which sequentializes computational tasks, such<br>
as program fragments.  Computations are like any other terms in a<br>
rewriting environment: they can be matched, moved from one place to<br>
another, modified, or deleted.  This makes K suitable for defining<br>
control-intensive features such as abrupt termination, exceptions, or<br>
call/cc.</p>
<h2 class="mume-header" id="k-tool-download">K Tool Download</h2>

<ul>
<li>Install from the latest <a href="https://github.com/runtimeverification/k/releases/latest">K GitHub Release</a>.</li>
<li>Install <a href="https://github.com/runtimeverification/k/tree/master/pyk">pyk</a>, K&apos;s scripting interface for Python. Check the <a href="https://kframework.org/pyk/">API documentation</a> for a complete reference of supported features.</li>
<li>Try our <a href="file:///home/runner/work/k/k/gh-pages/web/pages/editor_support.md">Editor Support</a> page for links to K syntax highlighting definitions for various popular editors/IDEs. Please feel free to contribute.</li>
<li>Build or browse the code <a href="https://github.com/runtimeverification/k">on GitHub</a>, where you can also <a href="http://github.com/runtimeverification/k/issues">report bugs</a>.</li>
</ul>
<h2 class="mume-header" id="learn-k">Learn K</h2>

<ul>
<li><a href="#ebook-heading-k-tutorial">Do the K Tutorial!</a></li>
<li><a href="#ebook-heading-k-user-manual">Reference Documentation</a></li>
<li><a href="#ebook-heading-k-cheat-sheet">K Cheat Sheet</a></li>
<li><a href="#ebook-heading-k-tool-reference">K Tool Reference</a></li>
<li><a href="file:///home/runner/work/k/k/gh-pages/k-distribution/include/kframework/builtin/README.md">K Builtins</a></li>
</ul>
<h2 class="mume-header" id="support">Support</h2>

<ul>
<li><a href="https://discord.com/invite/CurfmXNtbN">Discord Server</a>: Most direct way to get support.</li>
<li><a href="https://matrix.to/#/#k:matrix.org">Matrix Room</a>: Another way to get support.</li>
<li><a href="https://t.me/rv_inc">Telegram</a>: for newsletters and general announcements.</li>
</ul>
<h2 class="mume-header" id="resources">Resources</h2>

<ul>
<li>K Approach and Vision (2020): <a href="https://drive.google.com/file/d/1iXda2NyGzKVWxkd02IlXj5Tq5cOM_gNd/view">slide presentation</a></li>
<li>A set of <a href="#ebook-heading-k-pl-tutorial">reference implementations and tutorials</a> for common programming language features and paradigms is available, although parts of these implementations may not be fully up to date with modern K features.</li>
<li>Read some papers about K on the <a href="https://fsl.cs.illinois.edu/publications/">Formal Systems Laboratory (FSL)</a>.</li>
<li><a href="http://matching-logic.org/">Matching logic</a> webpage at UIUC (USA).</li>
<li>A ten-minute overview video <a href="#ebook-heading-k-overview">slide presentation</a>.</li>
<li>A ninety-minute <a href="https://youtu.be/3ovulLNCEQc?list=PLQMvp5V6ZQjOm4JZK15s-WJtQHxOmb2h7">tutorial video</a>, given at ETAPS&apos;16.</li>
<li>[Optional] A high-level <a href="http://channel9.msdn.com/posts/ICSE-2011-Grigore-Rosu-The-Art-and-Science-of-Program-Verification">interview</a> about rewrite-based semantics (Wolfram Schulte interviews Grigore Rosu at <a href="http://2011.icse-conferences.org/">ICSE&apos;11</a>.</li>
<li><a href="file:///home/runner/work/k/k/gh-pages/web/pages/faq.md">FAQ</a></li>
</ul>
</div></div><div id="ebook-heading-install-k" ebook-toc-level-1 heading="Install K"><div></div></div><div id="ebook-heading-pyk-documentation" ebook-toc-level-1 heading="Pyk Documentation"><div></div></div><div id="ebook-heading-k-tutorial" ebook-toc-level-1 heading="K Tutorial"><div><h1 class="mume-header" id="k-tutorial">K Tutorial</h1>

<p>K is a framework which allows you to define a language formally and extract<br>
a set of tools (e.g., interpreter, parser, symbolic verifier) for it<br>
automatically.</p>
<p>In this series of lessons you will learn how to program in K.<br>
Since the tutorial is addressed mainly to developers,<br>
we assume you have a firm grounding in computer science broadly, as<br>
well as experience writing code in functional programming languages.</p>
<p>For a more detailed tutorial explaining the basic principles of programming<br>
language design, refer to<br>
<a href="https://www.github.com/runtimeverification/pl-tutorial">K PL Tutorial</a>.<br>
Keep in mind that it might be out of date.</p>
<p>To start the K tutorial, begin with<br>
<a href="#ebook-heading-section-1-basic-k-concepts">Section 1: Basic Programming in K</a>.</p>
</div></div><div id="ebook-heading-section-1-basic-k-concepts" ebook-toc-level-2 heading="Section 1: Basic K Concepts"><div><h1 class="mume-header" id="section-1-basic-k-concepts">Section 1: Basic K Concepts</h1>

<p>In this first section you&apos;ll learn the basic principles of K.<br>
We assume you&apos;ve got no prior experience with K as programming language, so<br>
we teach you everything.</p>
<p>By the end of this section, you&apos;ll be able to define a simple language in K<br>
and use its specifications to generate a fast interpreter for it.<br>
You&apos;ll also know how to write basic deductive program verification proofs over<br>
programs writen in your language.<br>
You&apos;ll be all set to dwelve into more advanced stuff coming up in<br>
the next section <a href="#ebook-heading-section-2-intermediate-k-concepts">Section 2: Intermediate K Concepts</a>.</p>
<p>First things first, you need to set up K environment on your machine.<br>
<a href="#ebook-heading-lesson-11-setting-up-a-k-environment">Lesson 1.1: Setting up K Environment</a>.</p>
</div></div><div id="ebook-heading-lesson-11-setting-up-a-k-environment" ebook-toc-level-3 heading="Lesson 1.1: Setting up a K Environment"><div><h1 class="mume-header" id="lesson-11-setting-up-a-k-environment">Lesson 1.1: Setting up a K Environment</h1>

<p>The first step to learning K is to install K on your system, and configure your<br>
editor for K development.</p>
<h2 class="mume-header" id="installing-k">Installing K</h2>

<p>You have two options for how to install K, depending on how you intend to<br>
interact with the K codebase. If you are solely a user of K, and have no<br>
interest in developing or making changes to K, you most likely will want to<br>
install one of our binary releases of K. However, if you are going to be a K<br>
developer, or simply want to build K from source, you should follow the<br>
instructions for a source build of K.</p>
<h3 class="mume-header" id="installing-k-from-a-binary-release">Installing K from a binary release</h3>

<p>K is developed as a rolling release, with each change to K that passes our<br>
CI infrastructure being deployed on GitHub for download. The latest release of<br>
K can be downloaded <a href="https://github.com/runtimeverification/k/releases/latest">here</a>.<br>
This page also contains information on how to install K. It is recommended<br>
that you fully uninstall the old version of K prior to installing the new one,<br>
as K does not maintain entries in package manager databases, with the exception<br>
of Homebrew on MacOS.</p>
<h3 class="mume-header" id="installing-k-from-source">Installing K from source</h3>

<p>You can clone K from GitHub with the following Git command:</p>
<pre data-role="codeBlock" data-info class="language-"><code>git clone https://github.com/runtimeverification/k --recursive
</code></pre><p>Instructions on how to build K from source can be found<br>
<a href="https://github.com/runtimeverification/k/blob/master/README.md">here</a>.</p>
<h2 class="mume-header" id="configuring-your-editor">Configuring your editor</h2>

<p>K maintains a set of scripts for a variety of text editors, including vim and<br>
emacs, in various states of maintenance. You can download these scripts with<br>
the following Git command:</p>
<pre data-role="codeBlock" data-info class="language-"><code>git clone https://github.com/kframework/k-editor-support
</code></pre><p>Because K allows users to define their own grammars for parsing K itself,<br>
not all features of K can be effectively highlighted. However, at the cost of<br>
occasionally highlighting things incorrectly, you can get some pretty good<br>
results in many cases. With that being said, some of the editor scripts in the<br>
above repository are pretty out of date. If you manage to improve them, we<br>
welcome pull requests into the repository.</p>
<h2 class="mume-header" id="troubleshooting">Troubleshooting</h2>

<p>If you have problems installing K, we encourage you to reach out to us. If you<br>
follow the above install instructions and run into a problem, you can<br>
<a href="https://github.com/runtimeverification/k/issues/new?assignees=&amp;labels=bug&amp;template=bug-report.md&amp;title=%5BBug%5D+%5Bkompile%7Ckast%7Ckrun%7Ckprove%7Cksearch%5D+-+DESCRIPTION">Create a bug report on GitHub</a></p>
<h2 class="mume-header" id="next-lesson">Next lesson</h2>

<p>Once you have set up K on your system to your satisfaction, you can continue to<br>
<a href="#ebook-heading-lesson-12-basics-of-functional-k">Lesson 1.2: Basics of Functional K</a>.</p>
</div></div><div id="ebook-heading-lesson-12-basics-of-functional-k" ebook-toc-level-3 heading="Lesson 1.2: Basics of Functional K"><div><h1 class="mume-header" id="lesson-12-basics-of-functional-k">Lesson 1.2: Basics of Functional K</h1>

<p>In this lesson you will learn about basic K syntactic constructs, how<br>
to write simple K definitions, and how to compile and run them.</p>
<h2 class="mume-header" id="your-first-k-program">Your first K program</h2>

<p>Now that you&apos;ve installed K on your system, you&apos;re ready for your first<br>
program in K.</p>
<p>Copy the code below into your editor and save it as <code>lesson-02-a.k</code>.<br>
K files end with the <code>.k</code> extension.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">02</span><span class="token operator">-</span>A

  <span class="token keyword keyword-syntax">syntax</span> Color <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Yellow<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">|</span> Blue<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-syntax">syntax</span> Fruit <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Banana<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">|</span> Blueberry<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-syntax">syntax</span> Color <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> colorOf<span class="token punctuation">(</span>Fruit<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> colorOf<span class="token punctuation">(</span>Banana<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Yellow<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> colorOf<span class="token punctuation">(</span>Blueberry<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Blue<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>Note that the name of the module and name of the file match. While the name of<br>
the module has to be written in capitals, the file name can have any<br>
capitalization. It is not a requirement that the file carries the module<br>
name, but merely a convention. If you choose to name your file differenly, you will<br>
need to compile it with attribute <code>--main-module</code> followed by the name of<br>
the module, to point the compiler to the <em>main</em> module of the definition. More<br>
about naming conventions and main modules will follow in<br>
<a href="#ebook-heading-lesson-15-modules-imports-and-requires">Lesson 1.5</a>.</p>
<p>Now, save the file and, from within the directory where you saved it, run:</p>
<pre data-role="codeBlock" data-info class="language-"><code>kompile lesson-02-a.k
</code></pre><p><code>kompile</code> is K&apos;s compiler. It takes a <strong>K definition</strong> and compiles it into an<br>
interpreter. Right now, you are compiling a single-file K definition, but<br>
we&apos;ll cover multiple-file K definitions later on.</p>
<p>You should get the following output:</p>
<pre data-role="codeBlock" data-info class="language-"><code>[Warning] Compiler: Could not find main syntax module with name
LESSON-02-A-SYNTAX in definition.  Use --syntax-module to specify one. Using
LESSON-02-A as default.
</code></pre><p>It&apos;s a warning highlighting a K convention of splitting the syntactic<br>
definitions from the actual implementation into different modules. In<br>
<a href="#ebook-heading-lesson-15-modules-imports-and-requires">Lesson 1.5</a> you will learn how to do it the proper<br>
way, as the examples will get bigger. For the smaller examples we work on<br>
now, we can just ignore it.</p>
<p><code>kompile</code> will also output a directory containing everything needed to execute<br>
programs and perform proofs using the K definition given as input.<br>
Check your working directory and you&apos;ll see directory <code>lesson-02-a-kompiled</code><br>
has beed created inside. If you&apos;re curious, have a look at its contents and<br>
inspect the generated documentation.</p>
<p>This directory not only contains all the basic tools produced by a K<br>
definition, e.g., parser, interpreter, or verifier, but also all sorts of<br>
files that can be used as input to execute these tools. More about K&apos;s parser<br>
will come in the next lesson, more on the other tools in due time.</p>
<p>Now, save the program below in the file <code>banana.color</code> in the same directory as<br>
<code>lesson-02-a.k</code>:</p>
<pre data-role="codeBlock" data-info class="language-"><code>colorOf(Banana())
</code></pre><p>Note that we use <code>color</code> as file extension, but merely because this is the<br>
sort returned by function <code>colorOf</code>. The file name gives us a better<br>
understanding of what the file contains.</p>
<p>We can now evaluate this K term by running (from the same directory):</p>
<pre data-role="codeBlock" data-info class="language-"><code>krun banana.color
</code></pre><p><code>krun</code> is a tool which uses the interpreter generated by <code>kompile</code> to execute<br>
this program.</p>
<p>You should get the following output:</p>
<pre data-role="codeBlock" data-info class="language-"><code>&lt;k&gt;
  Yellow ( ) ~&gt; .K
&lt;/k&gt;
</code></pre><p>For now, don&apos;t worry about the <code>&lt;k&gt;</code>, <code>&lt;/k&gt;</code>, or <code>~&gt; .K</code> portions of this<br>
output file. We&apos;ll come back to them later.</p>
<p>You can also execute small programs directly on the command line instead of<br>
putting them in a file. For example, the same program above<br>
could have been executed by running the following command:</p>
<pre data-role="codeBlock" data-info class="language-"><code>krun -cPGM=&apos;colorOf(Banana())&apos;
</code></pre><p>Or by running the command below:</p>
<pre data-role="codeBlock" data-info class="language-"><code>krun -cPGM=&apos;colorOf(Banana())&apos; --definition &apos;lesson-02-a-kompiled&apos;
</code></pre><p><code>-cPGM=&apos;colorOf(Banana())&apos;</code> simply sets variable <code>PGM</code> responsible for holding<br>
the program to execute to value <code>colorOf(Banana())</code>.<br>
Attribute <code>--definition</code> points to the <em>directory</em> containing the compiled version<br>
of <code>LESSON-02-A</code>.</p>
<h3 class="mume-header" id="exercise">Exercise</h3>

<p>Use <code>krun</code> to compute the return value of the <code>colorOf</code> function on a<br>
<code>Blueberry()</code>.</p>
<h2 class="mume-header" id="structure-of-a-k-file">Structure of a K file</h2>

<p>A K file consists of one or more <strong>modules</strong>, of which only one is the<br>
<em>main</em> one, in the sense that no other module defined in that file <strong>imports</strong><br>
it. The name of this <em>main</em> module will also be the one given as argument to<br>
attribute <code>main-module</code> at compile time.<br>
Modules residing in other K files are imported instead through <strong>requires</strong><br>
statements (similar to <code>include</code> in C/C++). You&apos;ll learn more about <strong>imports</strong> and<br>
<strong>requires</strong> in <a href="#ebook-heading-lesson-15-modules-imports-and-requires">Lesson 1.5</a>.<br>
In this lesson we continue with a closer look to a K module structure.</p>
<p>A K module is formed of sentences (and <strong>imports</strong>), and sentences<br>
come in different forms. For example, <strong>productions</strong> and <strong>rules</strong> are two<br>
types of sentences you have seen already in example <code>lesson-02-a.k</code>.<br>
We&apos;ll discuss each separately.</p>
<h3 class="mume-header" id="productions-constructors-and-functions">Productions, constructors, and functions</h3>

<p>Productions are introduced with the <strong>syntax</strong> keyword and our first K module<br>
<code>LESSON-02-A</code> contains 5 productions defining <strong>sorts</strong> <code>Color</code> and <code>Fruit</code>.<br>
You can think of them as <code>enums</code> in C or <code>data</code> constructs in Haskell, although<br>
you&apos;ll find that they encompass other behaviors too.</p>
<p>Most of productions above are <strong>constructor</strong> productions (e.g., <code>Yellow()</code>,<br>
<code>Blue()</code>, or <code>Blueberry()</code>), while the last one is a <strong>function</strong> production<br>
(<code>colorOf(Fruit) [function]</code>). It&apos;s easy to distinguish the two as the latter<br>
production has additional attribute <code>function</code>.<br>
There are other types of productions&#x2014;tokens, brackets, lists, macros,<br>
or aliases&#x2014;but you&apos;ll learn about them in due time.<br>
There are other types of attributes too, and a sentence can carry several,<br>
in which case they will be separated by comma between square brackets.<br>
We will discuss them throughout the tutorial.</p>
<p>Constructors can have arguments, but these ones do not. We will cover the<br>
syntax of productions in detail in the next lesson, but for now, you can write<br>
a production with no arguments as an uppercase or lowercase identifier followed<br>
by the <code>()</code> operator. Sorts must always start with uppercase letter.</p>
<p>Returning to the syntax of a K module instead, note that individual productions<br>
of the same sort are separated by pipe operator <code>|</code>.<br>
For example, we can write an equivalent K definition of <code>lesson-02-a.k</code><br>
as definition <code>lesson-02-b.k</code> as follows:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">02</span><span class="token operator">-</span>B

  <span class="token keyword keyword-syntax">syntax</span> Color <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Yellow<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-syntax">syntax</span> Color <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Blue<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-syntax">syntax</span> Fruit <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Banana<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-syntax">syntax</span> Fruit <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Blueberry<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-syntax">syntax</span> Color <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> colorOf<span class="token punctuation">(</span>Fruit<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> colorOf<span class="token punctuation">(</span>Banana<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Yellow<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> colorOf<span class="token punctuation">(</span>Blueberry<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Blue<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>We can be even more compact, as in definition <code>lesson-02-c.k</code>:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">02</span><span class="token operator">-</span>C

  <span class="token keyword keyword-syntax">syntax</span> Color <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Yellow<span class="token punctuation">(</span><span class="token punctuation">)</span>
                 <span class="token operator">|</span> Blue<span class="token punctuation">(</span><span class="token punctuation">)</span>
                 <span class="token operator">|</span> colorOf<span class="token punctuation">(</span>Fruit<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Fruit <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Banana<span class="token punctuation">(</span><span class="token punctuation">)</span>
                 <span class="token operator">|</span> Blueberry<span class="token punctuation">(</span><span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> colorOf<span class="token punctuation">(</span>Banana<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Yellow<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> colorOf<span class="token punctuation">(</span>Blueberry<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Blue<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>You can try compiling and running both <code>lesson-02-b.k</code> and <code>lesson-02-c.k</code> to<br>
see that they produce the same output as <code>lesson-02-a.k</code>.<br>
If you run them from the same directory, remember to run with argument<br>
<code>--definition</code> to specify where the compiled version of the specific K<br>
definition is:</p>
<pre data-role="codeBlock" data-info class="language-"><code>kompile lesson-02-b.k
krun -cPGM=&apos;colorOf(Banana())&apos; --definition &apos;lesson-02-b-kompiled&apos;
</code></pre><p>and</p>
<pre data-role="codeBlock" data-info class="language-"><code>kompile lesson-02-c.k
krun -cPGM=&apos;colorOf(Banana())&apos; --definition &apos;lesson-02-c-kompiled&apos;
</code></pre><h3 class="mume-header" id="rules-matching-and-variables">Rules, matching, and variables</h3>

<p>We learned that <strong>functions</strong> are a type of productions carrying attribute<br>
<code>function</code>. However, the function production only introduces a specific<br>
function, it does not define it. For defining the behavior of a function in K,<br>
we use rules.</p>
<p>A rule begins with the <code>rule</code> keyword, which is followed by a <strong>left-hand side</strong>,<br>
<strong>rewrite operator</strong> <code>=&gt;</code>, and a <strong>right-hand side</strong>. The left-hand side<br>
contains the name of the function and zero or more <strong>patterns</strong> corresponding<br>
to the parameters of the function. The right-hand side is another pattern.<br>
It specifies the function behavior for those parameters. Then, we can read the<br>
rule as follows: if the function is called with arguments that <strong>match</strong> the<br>
patterns on the left-hand side, then the function will return the value of the<br>
rewritten pattern on the right-hand side.</p>
<p>For example, in the above example, if the argument of the <code>colorOf</code> function<br>
is <code>Banana()</code>, then the return value of the function is <code>Yellow()</code>.</p>
<p>Note that a function&apos;s definition can be expressed through several rules and that<br>
functions in K can be partial.</p>
<p>Let&apos;s add a new fruit constructor <code>Kiwi()</code> in <code>lesson-02-d.k</code></p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">02</span><span class="token operator">-</span>D

  <span class="token keyword keyword-syntax">syntax</span> Color <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Yellow<span class="token punctuation">(</span><span class="token punctuation">)</span>
                 <span class="token operator">|</span> Blue<span class="token punctuation">(</span><span class="token punctuation">)</span>
                 <span class="token operator">|</span> Kiwi<span class="token punctuation">(</span><span class="token punctuation">)</span>
                 <span class="token operator">|</span> colorOf<span class="token punctuation">(</span>Fruit<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Fruit <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Banana<span class="token punctuation">(</span><span class="token punctuation">)</span>
                 <span class="token operator">|</span> Blueberry<span class="token punctuation">(</span><span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> colorOf<span class="token punctuation">(</span>Banana<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Yellow<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> colorOf<span class="token punctuation">(</span>Blueberry<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Blue<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>and compile:</p>
<pre data-role="codeBlock" data-info class="language-"><code>kompile lesson-02-d.k
</code></pre><p>You will notice that the new K definition compiled just fine.<br>
Now, execute the following:</p>
<pre data-role="codeBlock" data-info class="language-"><code>krun -cPGM=&apos;colorOf(Kiwi())&apos; --definition &apos;lesson-02-d-kompiled&apos;
</code></pre><p>and observe the error:</p>
<pre data-role="codeBlock" data-info class="language-"><code>[Error] krun: lesson-02-d-kompiled/interpreter 
/tmp/.krun-2025-04-14-20-41-45-bxhfwDNT0t/tmp.in.LwwPb4Jo9W -1 
/tmp/.krun-2025-04-14-20-41-45-bxhfwDNT0t/result.kore
colorOf ( Kiwi ( ) )
</code></pre><p>The function is undefined for this value, i.e., there is no rule for function<br>
<code>colorOf</code> whose left-hand side can be pattern-matched to <code>Kiwi()</code>, thus no<br>
right-hand side pattern either, and no output value.</p>
<p>We said that the left- and right-hand sides of a <code>rule</code> are <strong>patterns</strong>.<br>
Thus, constructors are a type of pattern. We will introduce more complex patterns<br>
later, but before we proceed to the next lesson, let us briefly<br>
discuss one more type of pattern&#x2014;<strong>variables</strong>.</p>
<p>A variable, syntactically, consists of an uppercase identifier. It differs from<br>
a constructor in that it matches <strong>any</strong> pattern with one exception: two<br>
variables with the same name must match the same pattern.</p>
<p>Take the more complex example below (<code>lesson-02-e.k</code>):</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">02</span><span class="token operator">-</span>E

  <span class="token keyword keyword-syntax">syntax</span> Container <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Jar<span class="token punctuation">(</span>Fruit<span class="token punctuation">)</span>
  <span class="token keyword keyword-syntax">syntax</span> Fruit <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Apple<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">|</span> Pear<span class="token punctuation">(</span><span class="token punctuation">)</span>

  <span class="token keyword keyword-syntax">syntax</span> Fruit <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> contentsOfJar<span class="token punctuation">(</span>Container<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> contentsOfJar<span class="token punctuation">(</span>Jar<span class="token punctuation">(</span>F<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> F

<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>Note that <code>Jar</code> is a constructor with a single argument. Multiple arguments<br>
are separated by comma.</p>
<p>In this example, <code>F</code> is a variable. It will match either <code>Apple()</code> or <code>Pear()</code>.<br>
The return value of the function is created by <strong>substituting</strong> the matched<br>
values of all of the variables into the variables on the right-hand side of<br>
the rule.</p>
<p>To demonstrate, compile this definition and execute the following program with<br>
krun:</p>
<pre data-role="codeBlock" data-info class="language-"><code>kompile lesson-02-e.k 
krun -cPGM=&apos;contentsOfJar(Jar(Apple()))&apos; --definition &apos;lesson-02-e-kompiled&apos;
</code></pre><p>The program returns <code>Apple()</code>, because that is the pattern that was matched by<br>
<code>F</code>.</p>
<h3 class="mume-header" id="exercise-1">Exercise</h3>

<p>Extend the definition of function <code>colorOf</code> in <code>lesson-02-d.k</code> to return a<br>
pattern for <code>Kiwi()</code>.</p>
<h2 class="mume-header" id="exercises">Exercises</h2>

<ol>
<li>Extend the definition in <code>lesson-02-d.k</code> with the addition of blackberries.<br>
For simplicity, consider blackberries to be black and kiwis to be green. Then<br>
compile your definition and test that your additional fruits are correctly<br>
handled by the <code>colorOf</code> function.</li>
<li>Create a new definition which defines an outfit as a multi-argument constructor<br>
consisting of a hat, shirt, pants, and shoes. Define a new sort<br>
<code>Boolean</code> with two constructors, true and false. Productions for hat, shirt, pants,<br>
and shoes will have a single argument each&#x2014;a color, either black or<br>
white. Then define an <code>outfitMatching</code> function that will return true if all<br>
the pieces of the outfit are the same color. You do not need to define the<br>
case that returns false. Execute your program on different values to see that<br>
your function behaves the way you expect.</li>
</ol>
<h2 class="mume-header" id="next-lesson">Next lesson</h2>

<p>Once you have completed the above exercises, you can continue to<br>
<a href="#ebook-heading-lesson-13-bnf-syntax-and-parser-generation">Lesson 1.3: BNF Syntax and Parser Generation</a>.</p>
</div></div><div id="ebook-heading-lesson-13-bnf-syntax-and-parser-generation" ebook-toc-level-3 heading="Lesson 1.3: BNF Syntax and Parser Generation"><div><h1 class="mume-header" id="lesson-13-bnf-syntax-and-parser-generation">Lesson 1.3: BNF Syntax and Parser Generation</h1>

<p>In this lesson we will introduce more key aspects of the syntax and<br>
semantics of <strong>productions</strong> in K, and show how these, along with other<br>
syntactic <strong>sentences</strong> can be used to define grammars for parsing both rules<br>
and programs. In this context, you&apos;ll also learn about two additional types<br>
of productions, <strong>brakets</strong> and <strong>tokens</strong>.</p>
<h2 class="mume-header" id="ks-approach-to-parsing">K&apos;s approach to parsing</h2>

<p>K&apos;s grammar is divided into two components: the <strong>outer syntax</strong> of K and the<br>
<strong>inner syntax</strong> of K. Outer syntax refers to the parsing of <strong>requires</strong>,<br>
<strong>modules</strong>, <strong>imports</strong>, and <strong>sentences</strong> in a K definition. Inner syntax<br>
refers to the parsing of <strong>rules</strong> and <strong>programs</strong>. Unlike the outer syntax of<br>
K, which is predetermined, much of the inner syntax of K is defined by you, the<br>
developer. When rules or programs are parsed, they are parsed within the<br>
context of a module. Rules are parsed in the context of the module in which<br>
they exist, whereas programs are parsed in the context of the<br>
<strong>main syntax module</strong> of a K definition.</p>
<p>Recall that a K definition consists of several modules, which in turn consist<br>
each of several sentences (productions, rules, etc.). Sentences within a<br>
module form the grammar of that module, and this grammar is used for parsing<br>
programs in the language you defined.</p>
<h2 class="mume-header" id="basic-bnf-productions">Basic BNF productions</h2>

<p>To illustrate how this works, let&apos;s consider the K module below which defines<br>
a calculator for evaluating Boolean expressions containing operations AND, OR,<br>
NOT, and XOR.</p>
<p>Save the code below in file <code>lesson-03-a.k</code>:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">03</span><span class="token operator">-</span>A

  <span class="token keyword keyword-syntax">syntax</span> Boolean <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;true&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;false&quot;</span>
                   <span class="token operator">|</span> <span class="token string">&quot;!&quot;</span> Boolean <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
                   <span class="token operator">|</span> Boolean <span class="token string">&quot;&amp;&amp;&quot;</span> Boolean <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
                   <span class="token operator">|</span> Boolean <span class="token string">&quot;^&quot;</span> Boolean <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
                   <span class="token operator">|</span> Boolean <span class="token string">&quot;||&quot;</span> Boolean <span class="token punctuation">[</span>function<span class="token punctuation">]</span>

<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>Observe that the productions in this module look a little different than<br>
what we have seen in the previous lesson. The reason is that K has two<br>
mechanisms for defining productions. A more generic one using a variant<br>
of <a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form">BNF notation</a><br>
and its special case we have seen in <a href="#ebook-heading-lesson-12-basics-of-functional-k">Lesson 1.2</a>.<br>
There the <code>::=</code> symbol was followed by an alphanumeric identifier and a<br>
(possibly empty) comma-separated list of sorts in parentheses. In this<br>
lesson, we focus on the former.</p>
<p>Recall the set of productions from the previous lesson:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">03</span><span class="token operator">-</span>B

  <span class="token keyword keyword-syntax">syntax</span> Color <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Yellow<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">|</span> Blue<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-syntax">syntax</span> Fruit <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Banana<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">|</span> Blueberry<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-syntax">syntax</span> Color <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> colorOf<span class="token punctuation">(</span>Fruit<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>

<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>We can write an equivalent definition in BNF notation as follows:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">03</span><span class="token operator">-</span>C

  <span class="token keyword keyword-syntax">syntax</span> Color <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;Yellow&quot;</span> <span class="token string">&quot;(&quot;</span> <span class="token string">&quot;)&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;Blue&quot;</span> <span class="token string">&quot;(&quot;</span> <span class="token string">&quot;)&quot;</span>
  <span class="token keyword keyword-syntax">syntax</span> Fruit <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;Banana&quot;</span> <span class="token string">&quot;(&quot;</span> <span class="token string">&quot;)&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;Blueberrry&quot;</span> <span class="token string">&quot;(&quot;</span> <span class="token string">&quot;)&quot;</span>
  <span class="token keyword keyword-syntax">syntax</span> Color <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;colorOf&quot;</span> <span class="token string">&quot;(&quot;</span> Fruit <span class="token string">&quot;)&quot;</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>

<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>Note that sort <code>Fruit</code> of the function&apos;s argument is unchanged, but<br>
everything else has been wrapped in double quotation marks. This is because<br>
in BNF notation, we distinguish between two types of <strong>production items</strong>:<br>
<strong>terminals</strong> and <strong>non-terminals</strong>. A terminal denotes a fixed sequence of<br>
characters that is a verbatim part of the syntax of that production. For<br>
example, <code>Banana</code>, <code>(</code>, <code>)</code>, or <code>colorOf</code> are such sequences of characters and<br>
all considered terminals. Conversely, non-terminals, refer to a sort name,<br>
like <code>Fruit</code>, and the syntax of the production they belong to accepts any valid<br>
term of that sort at that position.</p>
<p>In the previous lesson we executed successfully the program <code>colorOf(Banana())</code><br>
using <code>krun</code>. That is because the program represented a term of sort <code>Color</code>:<br>
indeed, <code>Banana()</code> is a term of sort <code>Fruit</code>, hence a valid argument for<br>
function <code>colorOf</code>. <code>krun</code> parses and interprets terms according to the grammar<br>
you define. Under the hood, the term is automatically converted into an AST<br>
(abstract syntax tree), and then the function <code>colorOf</code> is evaluated using the<br>
function rules provided in the definition.</p>
<p>How does K match the strings between the double quotes? The answer is that K<br>
uses <a href="https://github.com/westes/flex">Flex</a> to generate a<br>
scanner for the grammar. Remember that a scanner, or lexical analyzer or lexer,<br>
is a component of an interpreter that breaks down source code into tokens,<br>
which are units such as keywords, variables, and operators. These tokens are<br>
then processed by the parser, which interprets the structure of the code<br>
according to the grammar rules. Flex looks for the longest possible match of a<br>
regular expression in the input. If there are ambiguities between two or more<br>
regular expressions, it will pick the one with the highest <code>prec</code> attribute.<br>
You can learn more about how Flex matching works in the<br>
<a href="https://westes.github.io/flex/manual/Matching.html#Matching">Flex Manual | Matching</a>.</p>
<p>Returning to module <code>LESSON-03-A</code>, we can see that it defines a simple BNF<br>
grammar for expressions over Booleans. We have defined constructors<br>
corresponding to the Boolean values <em>true</em> and <em>false</em>, and functions<br>
corresponding to the Boolean operators AND, OR, NOT, and XOR. We have also<br>
given a syntax for each of these functions based on their syntax in the <code>C</code><br>
programming language. As such, we can now write programs in the simple language<br>
we have defined!</p>
<p>Save the code below in file  <code>and.bool</code>:</p>
<pre data-role="codeBlock" data-info class="language-"><code>true &amp;&amp; false
</code></pre><p>Now, let&apos;s compile our grammar first:</p>
<pre data-role="codeBlock" data-info class="language-"><code>kompile lesson-03-a.k
</code></pre><p>Recall that compilation produces a parser, interpreter, and verifier for the<br>
grammar specified in the K definition. Interpreting the program by executing</p>
<pre data-role="codeBlock" data-info class="language-"><code>krun and.bool
</code></pre><p>will raise an error:</p>
<pre data-role="codeBlock" data-info class="language-"><code>terminate called after throwing an instance of &apos;std::runtime_error&apos;
  what():  No tag found for symbol Lbl&apos;UndsAnd-And-UndsUnds&apos;LESSON-03-A&apos;Unds&apos;Boolean&apos;Unds&apos;Boolean&apos;Unds&apos;Boolean{}. Maybe attempted to evaluate a symbol with no rules?

/nix/store/2av44963lcqsmkj7hwmjhrg9pzpbkr1i-k-7.1.232-88c9c766d76f624329400cd554fafd3beec16a15/bin-unwrapped/../lib/kframework/k-util.sh: line 114: 384286 Aborted                 (core dumped) &quot;$@&quot;
[Error] krun: ./lesson-03-a-kompiled/interpreter 
/tmp/.krun-2025-04-29-12-58-55-lb8wwXcWVv/tmp.in.0nVZCuXTXv -1 
/tmp/.krun-2025-04-29-12-58-55-lb8wwXcWVv/result.kore
Syntax error at /tmp/.krun-2025-04-29-12-58-55-lb8wwXcWVv/result.kore:1.1: Expected: [&lt;id&gt;, &lt;string&gt;] Actual: &lt;EOF&gt;
[Error] krun: kore-print --definition ./lesson-03-a-kompiled --output pretty 
/tmp/.krun-2025-04-29-12-58-55-lb8wwXcWVv/result.kore --color on
</code></pre><p>This is expected, as we have not given rules defining the meaning of the <code>&amp;&amp;</code><br>
function, and the error message highlights exactly this&#x2014;<em>Maybe attempted<br>
to evaluate a symbol with no rules?</em></p>
<p>While we cannot interpret the program just yet, we can <em>parse</em> it. To do this,<br>
run the command below from the same directory:</p>
<pre data-role="codeBlock" data-info class="language-"><code>kast --output kore and.bool
</code></pre><p>You should see the following AST printed on standard output, minus the<br>
formatting:</p>
<pre data-role="codeBlock" data-info class="language-"><code>inj{SortBoolean{}, SortKItem{}}(
  Lbl&apos;UndsAnd-And-UndsUnds&apos;LESSON-03-A&apos;Unds&apos;Boolean&apos;Unds&apos;Boolean&apos;Unds&apos;Boolean{}(
    Lbltrue&apos;Unds&apos;LESSON-03-A&apos;Unds&apos;Boolean{}(),
    Lblfalse&apos;Unds&apos;LESSON-03-A&apos;Unds&apos;Boolean{}()
  )
)
</code></pre><p><code>kast</code> is K&apos;s just-in-time parser, just another tool generated at compile time.<br>
It produces a grammar from the K definition on the fly and uses it to parse<br>
the program passed on the command line.</p>
<p>K allows for several AST representations and you can choose a specific one by<br>
setting the <code>--output</code> flag. You can see all possible value options by running<br>
<code>kast --help</code>. <code>kore</code> used above is one of them and denotes KORE, the<br>
intermediate representation of K. You can learn more about KORE in another<br>
<a href="https://github.com/runtimeverification/haskell-backend/blob/master/docs/kore-syntax.md">tutorial</a>,<br>
currently work-in-progress.<br>
Value <code>kast</code> for the flag gives us an AST in a more direct representation of<br>
the original K definition.</p>
<p>Executing</p>
<pre data-role="codeBlock" data-info class="language-"><code>kast --output kast and.bool
</code></pre><p>yields the following output, minus the formatting:</p>
<pre data-role="codeBlock" data-info class="language-"><code>`_&amp;&amp;__LESSON-03-A_Boolean_Boolean_Boolean`(
  `true_LESSON-03-A_Boolean`(.KList),
  `false_LESSON-03-A_Boolean`(.KList)
)
</code></pre><p>Comparing both outputs, you can observe that the former is largely a<br>
name-mangled version of the latter. A notable difference is the presence of the<br>
<code>inj</code> symbol in the KORE output and you can learn more about it in the<br>
<a href="https://github.com/runtimeverification/haskell-backend/blob/master/docs/kore-syntax.md">KORE tutorial</a>.</p>
<p>Note that <code>kast</code> also takes expressions as arguments, not only file names,<br>
but not both at the same time. If you want to parse an expression, you need to<br>
use flag <code>-e</code> or <code>--expression</code>:</p>
<pre data-role="codeBlock" data-info class="language-"><code>kast --output kast -e &quot;true &amp;&amp; false&quot;
</code></pre><h3 class="mume-header" id="exercise">Exercise</h3>

<p>Parse the expression <code>false || true</code> with <code>--output kast</code>. See if you can<br>
predict approximately what the corresponding output would be with<br>
<code>--output kore</code>, then run the command and compare it to your prediction.</p>
<h2 class="mume-header" id="ambiguities">Ambiguities</h2>

<p>Now let&apos;s try a slightly more advanced example. Save the following program as<br>
<code>and-or.bool</code>:</p>
<pre data-role="codeBlock" data-info class="language-"><code>true &amp;&amp; false || false
</code></pre><p>If you try to parse it, you will see the following error:</p>
<pre data-role="codeBlock" data-info class="language-"><code>[Error] Inner Parser: Parsing ambiguity.
1: syntax Boolean ::= Boolean &quot;&amp;&amp;&quot; Boolean [function]
    `_&amp;&amp;__LESSON-03-A_Boolean_Boolean_Boolean`(`true_LESSON-03-A_Boolean`(.KList),`_||__LESSON-03-A_Boolean_Boolean_Boolean`(`false_LESSON-03-A_Boolean`(.KList),`false_LESSON-03-A_Boolean`(.KList)))
2: syntax Boolean ::= Boolean &quot;||&quot; Boolean [function]
    `_||__LESSON-03-A_Boolean_Boolean_Boolean`(`_&amp;&amp;__LESSON-03-A_Boolean_Boolean_Boolean`(`true_LESSON-03-A_Boolean`(.KList),`false_LESSON-03-A_Boolean`(.KList)),`false_LESSON-03-A_Boolean`(.KList))
	Source(./and-or.bool)
	Location(1,1,1,23)
	1 |	true &amp;&amp; false || false
	  .	^~~~~~~~~~~~~~~~~~~~~~
</code></pre><p>The error is saying that <code>kast</code> was unable to parse the program because it is<br>
ambiguous. K&apos;s just-in-time parser is a GLL (<u>g</u>eneralized<br>
<u>l</u>eft-to-right, <u>l</u>eftmost derivation) parser, which means it can handle<br>
the full generality of context-free grammars, including those grammars which<br>
are ambiguous. An ambiguous grammar is one where the same string can be parsed<br>
as multiple distinct ASTs. In this example, it can&apos;t decide whether it should<br>
be parsed as <code>(true &amp;&amp; false) || false</code> (Fig. 3-A) or as <code>true &amp;&amp; (false || false)</code><br>
(Fig. 3-B).</p>
<p>Fig. 3-A</p>
<pre data-role="codeBlock" data-info class="language-"><code>         ||
       /    \
     &amp;&amp;    false
   /    \
true   false
</code></pre><p>Fig. 3-B</p>
<pre data-role="codeBlock" data-info class="language-"><code>    &amp;&amp;
  /    \
true    ||              
      /    \
   false  false    
</code></pre><p>In Boolean logic and other programming languages such as C, logical AND has<br>
precedence over logical OR, rendering the AST in Fig. 3-A the only valid one.<br>
However, grammars defined in K assume all operators to have the same priority<br>
in evaluation, unless specified otherwise. Both ASTs in Fig. 3-A and Fig. 3-B<br>
are possible with the grammar we defined in module <code>LESSON-3-A</code>, hence the<br>
ambiguity reported by the parser. You will learn in the next lesson how to set<br>
up precendence of some operators over others and define the logical connectives<br>
<em>the usual way</em>. We continue this lesson by showing how to reduce ambiguity<br>
through the use of <strong>brackets</strong>.</p>
<h2 class="mume-header" id="brackets">Brackets</h2>

<p>With the grammar defined in module <code>LESSON-03-A</code> there is no way of resolving<br>
this ambiguity, making it impossible to write complex expressions in our small<br>
language. The standard solution in most programming languages to this problem<br>
is to use parentheses to indicate the appropriate grouping. K generalizes this<br>
notion into a type of production called <strong>bracket</strong>.</p>
<p>A bracket production is any production with the <code>bracket</code> attribute. It is<br>
required that such a production only have a single non-terminal, and the sort<br>
of the production must equal the sort of that non-terminal. K does not<br>
otherwise impose any restrictions on the grammar provided for a bracket.</p>
<p>Like in other languages, the most common type of bracket is one in which a<br>
non-terminal is surrounded by terminals representing one of the following<br>
symbols <code>()</code>, <code>[]</code>, <code>{}</code>, or <code>&lt;&gt;</code>. For example, we can define the most common<br>
type of bracket, the parentheses, quite simply. Consider the following modified<br>
definition and save it to file <code>lesson-03-d.k</code>:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">03</span><span class="token operator">-</span>D

  <span class="token keyword keyword-syntax">syntax</span> Boolean <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;true&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;false&quot;</span>
                   <span class="token operator">|</span> <span class="token string">&quot;(&quot;</span> Boolean <span class="token string">&quot;)&quot;</span> <span class="token punctuation">[</span><span class="token class-name">bracket</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;!&quot;</span> Boolean <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
                   <span class="token operator">|</span> Boolean <span class="token string">&quot;&amp;&amp;&quot;</span> Boolean <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
                   <span class="token operator">|</span> Boolean <span class="token string">&quot;^&quot;</span> Boolean <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
                   <span class="token operator">|</span> Boolean <span class="token string">&quot;||&quot;</span> Boolean <span class="token punctuation">[</span>function<span class="token punctuation">]</span>

<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>With this augmented definition, you are now able to parse more complex programs<br>
by explicitly grouping subterms with the bracket we have just defined.</p>
<p>Consider <code>and-or-left.bool</code>:</p>
<pre data-role="codeBlock" data-info class="language-"><code>(true &amp;&amp; false) || false
</code></pre><p>and <code>and-or-right.bool</code>:</p>
<pre data-role="codeBlock" data-info class="language-"><code>true &amp;&amp; (false || false)
</code></pre><p>When parsing these programs with <code>kast</code>, you get a unique AST with no error.<br>
If you check the output carefully, you will notice that the bracket itself does<br>
not appear in the AST. In fact, this is a property unique to bracket<br>
productions: they are not represented in the parsed AST of a term, and the<br>
child of the bracket is folded immediately into the parent term. This is why we<br>
have the requirement mentioned above, that a bracket production must have a<br>
single non-terminal of the same sort as the production itself.</p>
<h3 class="mume-header" id="exercise-1">Exercise</h3>

<p>Write out the AST you expect to be arising from parsing the two programs above<br>
with <code>--output kast</code>, then parse them and compare the result to the AST you<br>
expected. Confirm for yourself that the bracket production does not appear in<br>
the AST.</p>
<h2 class="mume-header" id="tokens">Tokens</h2>

<p>So far we have seen how to define the grammar of a language and we have<br>
implicitly been using K&apos;s automatic lexer generation to produce a token for<br>
each terminal in our grammar. However, the grammar is not the only relevant<br>
part of parsing a language. Also relevant is the lexical syntax of the<br>
language, i.e., how the tokens are defined and recognized.</p>
<p>Sometimes we need to define more complex lexical syntax. Consider, for<br>
instance, integers in C. They consist of a decimal, octal, or hexadecimal<br>
number, followed by an optional suffix that specifies the type of the literal.<br>
While it&#x2019;s theoretically possible to define this syntax using a grammar, doing<br>
so would be cumbersome and tedious. Additionally, you&apos;d be faced with an AST<br>
generated for the literal, which is not particularly convenient to work with.<br>
As an alternative, K allows you to define <strong>token</strong> productions, which consist<br>
of a <a href="https://en.wikipedia.org/wiki/Regular_expression">regular expressions</a><br>
followed by the <code>token</code> attribute. The resulting AST would then consist of a<br>
typed string containing the value recognized by the regular expression.</p>
<p>For example, the built-in integers in K are defined using the following<br>
production:</p>
<pre data-role="codeBlock" data-info="{.k .exclude}" class="language- k exclude"><code>syntax Int ::= r&quot;[\\+\\-]?[0-9]+&quot; [token]
</code></pre><p>An integer is thus an optional sign followed by a nonzero sequence of digits.<br>
The <code>r</code> preceding the terminal indicates that what appears inside the double<br>
quotes is a regular expression, and the <code>token</code> attribute indicates that terms<br>
which parse as this production should be converted into a token.</p>
<p>Before looking at how integers in C can be defined in K, let us mention that it<br>
is also possible to define tokens that do not use regular expressions. This can<br>
be useful when you wish to declare particular identifiers for use in your<br>
semantics later. For example:</p>
<pre data-role="codeBlock" data-info="{.k .exclude}" class="language- k exclude"><code>syntax Id ::= &quot;main&quot; [token]
</code></pre><p>Here, we declare <code>main</code> as a token of sort <code>Id</code>. Instead of being parsed as a<br>
symbol, it gets parsed as a token, generating a typed string in the AST.<br>
This can be useful in a semantics of C because the parser typically doesn&apos;t<br>
handle the <code>main</code> function in any special way; it&apos;s only the semantics that<br>
gives it special treatment.</p>
<p>The syntax of integers in C has a more complex lexical structure than the one<br>
of built-in integers in K, and a production defining them could look as<br>
follows:</p>
<pre data-role="codeBlock" data-info="{.k .exclude}" class="language- k exclude"><code>syntax IntConstant ::= r&quot;(([1-9][0-9]*)|(0[0-7]*)|(0[xX][0-9a-fA-F]+))(([uU][lL]?)|([uU]((ll)|(LL)))|([lL][uU]?)|(((ll)|(LL))[uU]?))?&quot; [token]
</code></pre><p>This is a long and complex regular expression, hard to read. In addition,<br>
unlike a grammar, it is not particularly modular. However, we can get around<br>
this restriction by declaring <em>explicit</em> regular expressions, giving them a<br>
name, and referring to them in productions.</p>
<p>Consider the following (equivalent) way to define the lexical syntax of<br>
integers in C:</p>
<pre data-role="codeBlock" data-info="{.k .exclude}" class="language- k exclude"><code>syntax IntConstant ::= r&quot;({DecConstant}|{OctConstant}|{HexConstant})({IntSuffix}?)&quot; [token]
syntax lexical DecConstant = r&quot;{NonzeroDigit}({Digit}*)&quot;
syntax lexical OctConstant = r&quot;0({OctDigit}*)&quot;
syntax lexical HexConstant = r&quot;{HexPrefix}({HexDigit}+)&quot;
syntax lexical HexPrefix = r&quot;0x|0X&quot;
syntax lexical NonzeroDigit = r&quot;[1-9]&quot;
syntax lexical Digit = r&quot;[0-9]&quot;
syntax lexical OctDigit = r&quot;[0-7]&quot;
syntax lexical HexDigit = r&quot;[0-9a-fA-F]&quot;
syntax lexical IntSuffix = r&quot;{UnsignedSuffix}({LongSuffix}?)|{UnsignedSuffix}{LongLongSuffix}|{LongSuffix}({UnsignedSuffix}?)|{LongLongSuffix}({UnsignedSuffix}?)&quot;
syntax lexical UnsignedSuffix = r&quot;[uU]&quot;
syntax lexical LongSuffix = r&quot;[lL]&quot;
syntax lexical LongLongSuffix = r&quot;ll|LL&quot;
</code></pre><p>As you can see, this is rather more verbose, but it has the benefit of being<br>
easier to read and understand, as well as providing increased modularity.</p>
<p>Note that we refer to a named regular expression by putting the name in curly<br>
brackets. Note also that only the first sentence actually declares a new piece<br>
of syntax in the language. <code>syntax lexical</code> only declares an explicit regular<br>
expression.</p>
<p>Finally, recall that K uses <a href="https://github.com/westes/flex">Flex</a> to implement<br>
its lexical analysis. As such, you can refer to the<br>
<a href="http://westes.github.io/flex/manual/Patterns.html#Patterns">Flex Manual | Patterns</a><br>
for a detailed description of the regular expression syntax supported. For<br>
performance reasons, Flex&apos;s regular expressions are actually a regular<br>
language, and thus lack some of the syntactic convenience of modern &quot;regular<br>
expression&quot; libraries. If you need features that are not part of the syntax of<br>
Flex regular expressions, you are encouraged to express them via a grammar<br>
instead.</p>
<h2 class="mume-header" id="ahead-of-time-parser-generation">Ahead-of-time parser generation</h2>

<p>So far we have been entirely focused on K&apos;s support for just-in-time parsing,<br>
where the parser is generated on the fly prior to being used. This method<br>
offers faster parser generation, but its performance suffers if you have to<br>
repeatedly parse strings with the same parser. For this reason, when parsing<br>
programs, it is generally recommended to use K&apos;s ahead-of-time parser<br>
generation based on <a href="https://www.gnu.org/software/bison/">GNU Bison</a>.</p>
<p>You can enable ahead-of-time parsing via the <code>--gen-bison-parser</code> flag to<br>
<code>kompile</code>. This will make use of Bison&apos;s<br>
<a href="https://en.wikipedia.org/wiki/Canonical_LR_parser">LR(1) parser</a> generator. As<br>
such, if your grammar is not LR(1), it may not parse exactly the same as if<br>
you were to use the just-in-time parser because Bison will automatically pick<br>
one of the possible branches whenever it encounters a shift-reduce or<br>
reduce-reduce conflict. In this case, you can either modify your grammar to be<br>
LR(1), or you can use Bison&apos;s GLR support by passing flag<br>
<code>--gen-glr-bison-parser</code> to <code>kompile</code> instead. Note that if your grammar is ambiguous,<br>
the ahead-of-time parser will not provide you with particularly readable error<br>
messages at this time.</p>
<p><code>kompile --gen-bison-parser &apos;lesson-03-a.k&apos;</code> gives</p>
<pre data-role="codeBlock" data-info class="language-"><code>[Warning] Compiler: Could not find main syntax module with name
LESSON-03-A-SYNTAX in definition.  Use --syntax-module to specify one. Using
LESSON-03-A as default.
[Warning] Inner Parser: Skipping modules [ML-SYNTAX] tagged as not-lr1 which
are not supported by Bison.
</code></pre><p>We have seen the first warning before, and we discussed it in<br>
<a href="#ebook-heading-lesson-12-basics-of-functional-k">Lesson 1.2</a>. The second warning we get is a side<br>
effect of the first one, informing that certain modules&#x2014;e.g., for<br>
parsing&#x2014;were excluded from the grammar generation because they were<br>
known to cause Bison to crash or behave incorrectly.</p>
<p>Next, run</p>
<p><code>lesson-03-a-kompiled/parser_PGM and-or.bool</code></p>
<p>to see that now you don&apos;t get an error when parsing. Even though our grammar<br>
is ambiguous, the LR(1) algorithm generates a single parse tree. The output,<br>
minus formatting, is the following:</p>
<pre data-role="codeBlock" data-info class="language-"><code>inj{SortBoolean{}, SortKItem{}}(
  Lbl&apos;UndsAnd-And-UndsUnds&apos;LESSON-03-A&apos;Unds&apos;Boolean&apos;Unds&apos;Boolean&apos;Unds&apos;Boolean{}(
    Lbltrue&apos;Unds&apos;LESSON-03-A&apos;Unds&apos;Boolean{}(),
    Lbl&apos;UndsPipePipeUndsUnds&apos;LESSON-03-A&apos;Unds&apos;Boolean&apos;Unds&apos;Boolean&apos;Unds&apos;Boolean{}(
      Lblfalse&apos;Unds&apos;LESSON-03-A&apos;Unds&apos;Boolean{}(),
      Lblfalse&apos;Unds&apos;LESSON-03-A&apos;Unds&apos;Boolean{}()
    )
  )
)
</code></pre><p>At closer look, you see it is the AST where <code>||</code> has higher priority (Fig. 3-B).</p>
<p>Compare this with the output given when running the same command, but when the<br>
ahead-of-time parser has been enabled with flag <code>--gen-glr-bison-parser</code>:</p>
<pre data-role="codeBlock" data-info class="language-"><code>inj{SortBoolean{}, SortKItem{}}(
  Lblamb{SortBoolean{}}(
    Lbl&apos;UndsAnd-And-UndsUnds&apos;LESSON-03-A&apos;Unds&apos;Boolean&apos;Unds&apos;Boolean&apos;Unds&apos;Boolean{}(
      Lbltrue&apos;Unds&apos;LESSON-03-A&apos;Unds&apos;Boolean{}(),
      Lbl&apos;UndsPipePipeUndsUnds&apos;LESSON-03-A&apos;Unds&apos;Boolean&apos;Unds&apos;Boolean&apos;Unds&apos;Boolean{}(
        Lblfalse&apos;Unds&apos;LESSON-03-A&apos;Unds&apos;Boolean{}(),
        Lblfalse&apos;Unds&apos;LESSON-03-A&apos;Unds&apos;Boolean{}()
      )
    ),
    Lbl&apos;UndsPipePipeUndsUnds&apos;LESSON-03-A&apos;Unds&apos;Boolean&apos;Unds&apos;Boolean&apos;Unds&apos;Boolean{}(
      Lbl&apos;UndsAnd-And-UndsUnds&apos;LESSON-03-A&apos;Unds&apos;Boolean&apos;Unds&apos;Boolean&apos;Unds&apos;Boolean{}(
        Lbltrue&apos;Unds&apos;LESSON-03-A&apos;Unds&apos;Boolean{}(),
        Lblfalse&apos;Unds&apos;LESSON-03-A&apos;Unds&apos;Boolean{}()
      ),
      Lblfalse&apos;Unds&apos;LESSON-03-A&apos;Unds&apos;Boolean{}()
    )
  )
)
</code></pre><p>In this case, we get both ASTs. Since our grammar is ambiguous, the GLR<br>
algorithm produces the complete parse forest. The ambiguity is indicated in the<br>
above KORE output by node <code>Lblamb</code> and its two children, each a possible AST of<br>
the term <code>true &amp;&amp; false || false</code>.</p>
<p>Finally, note that, for a K definition named <code>foo.k</code>, and directory<br>
<code>foo-kompiled</code> created when running <code>kompile</code>, you can invoke the ahead-of-time<br>
parser you generated by executing <code>foo-kompiled/parser_PGM &lt;file&gt;</code> on a file.</p>
<h2 class="mume-header" id="exercises">Exercises</h2>

<ol>
<li>
<p>Compile <code>lesson-03-d.k</code> with ahead-of-time parsing enabled. Then compare<br>
how long it takes to run <code>kast --output kore and-or-left.bool</code> with how long it<br>
takes to run <code>lesson-03-d-kompiled/parser_PGM and-or-left.bool</code>. Confirm for<br>
yourself that both produce the same result, but that the latter is faster.</p>
</li>
<li>
<p>Define a simple grammar consisting of integers, brackets, addition,<br>
subtraction, multiplication, division, and unary negation. Integers should be<br>
in decimal form and lexically without a sign, whereas negative numbers can be<br>
represented via unary negation. Ensure that you are able to parse some basic<br>
arithmetic expressions using a generated ahead-of-time parser. Do not worry<br>
about disambiguating the grammar or about writing rules to implement the<br>
operations in this definition.</p>
</li>
<li>
<p>Write a program where the meaning of the arithmetic expression based on<br>
the grammar you defined above is ambiguous, and then write programs that<br>
express each individual intended meaning using brackets.</p>
</li>
</ol>
<h2 class="mume-header" id="next-lesson">Next lesson</h2>

<p>Once you have completed the exercises above, you can continue to<br>
<a href="#ebook-heading-lesson-14-disambiguating-parses">Lesson 1.4: Disambiguating Parses</a>.</p>
</div></div><div id="ebook-heading-lesson-14-disambiguating-parses" ebook-toc-level-3 heading="Lesson 1.4: Disambiguating Parses"><div><h1 class="mume-header" id="lesson-14-disambiguating-parses">Lesson 1.4: Disambiguating Parses</h1>

<p>In this lesson you will learn how to use K&apos;s built-in features to transform<br>
an ambiguous grammar into an unambiguous one that expresses the intended AST.<br>
You will learn how to define the precedence and associativity of operators<br>
and how to favor certain parses over others.</p>
<h2 class="mume-header" id="priority-blocks">Priority blocks</h2>

<p>Parsing unambiguous languages is asymptotically faster than parsing ambiguous<br>
languages. That&apos;s why in practice, very few formal languages outside the domain<br>
of natural language processing are ambiguous.</p>
<p>Cluttering the code with brackets to remove ambiguity is not an ideal solution.<br>
Instead, programming language designers have developed methods for<br>
disambiguating language expressions by making use of operator precedence and<br>
associativity. It is often possible to remove <em>all</em> ambiguities in a grammar<br>
with these methods, as they instruct the parser to accept some ASTs instead<br>
of others.</p>
<p>In general, grammars can be rewritten to remove unwanted parses. However,<br>
in K, the grammar specification and AST generation are intrinsically linked,<br>
so we discourage this approach. You will still learn how to remove unwanted<br>
parses in K towards the end of this lesson. Now we continue with showing you<br>
how to explicitly express the relative precedence of operators in different<br>
situations in order to resolve grammar ambiguity.</p>
<p>Recall that in C, <code>&amp;&amp;</code> binds tighter than <code>||</code>, i.e., it has higher<br>
precedence, meaning that the expression <code>true &amp;&amp; false || false</code> has only one<br>
valid AST: <code>(true &amp;&amp; false) || false</code>.</p>
<p>Consider, then, the third iteration on the grammar of Boolean expressions and<br>
save the code below in file <code>lesson-04-a.k</code>:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">04</span><span class="token operator">-</span>A

  <span class="token keyword keyword-syntax">syntax</span> Boolean <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;true&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;false&quot;</span>
                   <span class="token operator">|</span> <span class="token string">&quot;(&quot;</span> Boolean <span class="token string">&quot;)&quot;</span> <span class="token punctuation">[</span><span class="token class-name">bracket</span><span class="token punctuation">]</span>
                   &gt; <span class="token string">&quot;!&quot;</span> Boolean <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
                   &gt; Boolean <span class="token string">&quot;&amp;&amp;&quot;</span> Boolean <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
                   &gt; Boolean <span class="token string">&quot;^&quot;</span> Boolean <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
                   &gt; Boolean <span class="token string">&quot;||&quot;</span> Boolean <span class="token punctuation">[</span>function<span class="token punctuation">]</span>

<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>In this example, some of the pipe symbols <code>|</code> separating productions have been<br>
replaced with <code>&gt;</code>. This serves to describe the <strong>priority groups</strong> associated<br>
with a block of productions. The first priority group consists of the atoms<br>
of the language: <code>true</code>, <code>false</code>, and the bracket operator. In general, a<br>
priority group starts either at the <code>::=</code> or <code>&gt;</code> operator and extends until<br>
either the next <code>&gt;</code> operator, or the end of the production block. Thus, we can<br>
see that the second, third, fourth, and fifth priority groups in this grammar<br>
all consist of a single production.</p>
<p>The meaning of these priority groups becomes apparent when parsing programs:<br>
A symbol with a <strong>lesser priority</strong>, (i.e., one that <strong>binds looser</strong>), cannot<br>
appear as the <strong>direct child</strong> of a symbol with a <strong>greater priority</strong> (i.e.,<br>
one that <strong>binds tighter</strong>). In this case, the <code>&gt;</code> operator can be seen as a<br>
<strong>greater-than</strong> operator describing a transitive partial ordering on the<br>
productions in the production block, expressing their relative priority.</p>
<p>To see this more concretely, let&apos;s look again at the program<br>
<code>true &amp;&amp; false || false</code> with possible ASTs depicted in Figures 3-A and 3-B<br>
in previous lesson. As noted before, this program was ambiguous because the<br>
parser could either choose <code>&amp;&amp;</code> to be the child of <code>||</code> or vice versa.<br>
However, because a symbol with lesser priority (i.e., <code>||</code>) cannot appear as<br>
the <em>direct</em> child of a symbol with greater priority (i.e., <code>&amp;&amp;</code>), the parser<br>
will <strong>reject</strong> the parse where <code>||</code> is under the <code>&amp;&amp;</code> operator (Fig. 3-B).<br>
As a result, we are left with the unambiguous parse<br>
<code>(true &amp;&amp; false) || false</code>. Conversely, if the user wants the other parse,<br>
they can express this with brackets by explicitly writing<br>
<code>true &amp;&amp; (false || false)</code>. This still parses successfully because the <code>||</code><br>
operator is no longer the <strong>direct</strong> child of the <code>&amp;&amp;</code> operator, but of the<br>
<code>()</code> operator, even if the bracket is not explicitly depicted in the AST.<br>
Internally, <code>&amp;&amp;</code> operator is viewed as an <strong>indirect</strong> parent, which is not<br>
subject to the priority restriction.</p>
<p>You must have noticed that <code>()</code> has been defined as having greater priority<br>
than <code>||</code>. However, in example <code>true &amp;&amp; (false || false)</code>, <code>||</code> appears as<br>
a direct child of <code>()</code>, in what seems to be a contradiction to the priority<br>
rule. What we have not mentioned is that the priority rule is more complex<br>
and applies only <em>conditionally</em>. Specifically, it applies in cases where the<br>
child is either the first or last production item in the parent&apos;s<br>
production. For example, in production <code>Boolean &quot;&amp;&amp;&quot; Boolean</code>, the first<br>
<code>Boolean</code> non-terminal is not preceded by any terminals, and the last<br>
<code>Boolean</code> is not followed by any terminals. As a result, we apply the priority<br>
rule to both children of <code>&amp;&amp;</code>. In production <code>&quot;(&quot; Boolean &quot;)&quot;</code>, the<br>
non-terminal is both preceded and followed by terminals <code>&quot;(&quot;</code> and <code>&quot;)&quot;</code>.<br>
Thus, the priority rule is not applied when <code>()</code> is the parent. Because of<br>
this, program <code>true &amp;&amp; (false || false)</code> parses successfully.</p>
<h3 class="mume-header" id="exercise">Exercise</h3>

<p>Parse the program <code>true &amp;&amp; false || false</code> using <code>kast</code>, and confirm that the<br>
AST places <code>||</code> as the top-level symbol. Then modify the definition so that you<br>
will get the alternative parse.</p>
<h2 class="mume-header" id="associativity">Associativity</h2>

<p>Sometimes, even after breaking the expression grammar into priority blocks we<br>
still get an ambiguous grammar. Let&apos;s try to parse the following program<br>
(<code>assoc.bool</code>):</p>
<pre data-role="codeBlock" data-info class="language-"><code>true &amp;&amp; false &amp;&amp; false
</code></pre><p>Priority blocks will not help us here. We have two possible parses with a<br>
direct parent and child which are within a single priority block (in this case,<br>
<code>&amp;&amp;</code> is in the same block as itself):</p>
<p>Fig. 4-A</p>
<pre data-role="codeBlock" data-info class="language-"><code>         &amp;&amp;
       /    \
     &amp;&amp;    false
   /    \
true   false
</code></pre><p>Fig. 4-B</p>
<pre data-role="codeBlock" data-info class="language-"><code>    &amp;&amp;
  /    \
true    &amp;&amp;              
      /    \
   false  false    
</code></pre><p>This is where the notion of associativity comes into play. Associativity<br>
applies the following additional rules to parses:</p>
<ul>
<li>a left-associative symbol cannot appear as a direct rightmost child of a<br>
symbol with equal priority;</li>
<li>a right-associative symbol cannot appear as a direct leftmost child of a<br>
symbol with equal priority; and</li>
<li>a non-associative symbol cannot appear as a direct leftmost <strong>or</strong> rightmost<br>
child of a symbol with equal priority.</li>
</ul>
<p>In C, binary operators are all left-associative, meaning that the expression<br>
<code>true &amp;&amp; false &amp;&amp; false</code> parses unambiguously as <code>(true &amp;&amp; false) &amp;&amp; false</code>.<br>
Since <code>&amp;&amp;</code> cannot appear as the rightmost child of itself, only the AST in<br>
Fig. 4-A is valid.</p>
<p>Consider, then, the fourth iteration on the grammar of this definition<br>
(<code>lesson-04-b.k</code>):</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">04</span><span class="token operator">-</span>B

  <span class="token keyword keyword-syntax">syntax</span> Boolean <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;true&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;false&quot;</span>
                   <span class="token operator">|</span> <span class="token string">&quot;(&quot;</span> Boolean <span class="token string">&quot;)&quot;</span> <span class="token punctuation">[</span><span class="token class-name">bracket</span><span class="token punctuation">]</span>
                   &gt; <span class="token string">&quot;!&quot;</span> Boolean <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
                   &gt; <span class="token class-name">left</span><span class="token punctuation">:</span> Boolean <span class="token string">&quot;&amp;&amp;&quot;</span> Boolean <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
                   &gt; <span class="token class-name">left</span><span class="token punctuation">:</span> Boolean <span class="token string">&quot;^&quot;</span> Boolean <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
                   &gt; <span class="token class-name">left</span><span class="token punctuation">:</span> Boolean <span class="token string">&quot;||&quot;</span> Boolean <span class="token punctuation">[</span>function<span class="token punctuation">]</span>

<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>Here each priority group, immediately after the <code>::=</code> or <code>&gt;</code> operator, can<br>
be followed by a literal representing the associativity of that priority group:<br>
either <code>left:</code> for left-associativity, <code>right:</code> for right-associativity, or<br>
<code>non-assoc:</code> for non-associativity. In this example, each priority group we<br>
apply associativity to has only a single production, but we could equally well<br>
write a priority block with multiple productions and one associativity.<br>
For example, consider the grammar below (file <code>lesson-04-c.k</code>):</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">04</span><span class="token operator">-</span>C

  <span class="token keyword keyword-syntax">syntax</span> Boolean <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;true&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;false&quot;</span>
                   <span class="token operator">|</span> <span class="token string">&quot;(&quot;</span> Boolean <span class="token string">&quot;)&quot;</span> <span class="token punctuation">[</span><span class="token class-name">bracket</span><span class="token punctuation">]</span>
                   &gt; <span class="token string">&quot;!&quot;</span> Boolean <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
                   &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                     Boolean <span class="token string">&quot;&amp;&amp;&quot;</span> Boolean <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
                   <span class="token operator">|</span> Boolean <span class="token string">&quot;^&quot;</span> Boolean <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
                   <span class="token operator">|</span> Boolean <span class="token string">&quot;||&quot;</span> Boolean <span class="token punctuation">[</span>function<span class="token punctuation">]</span>

<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>In this example, unlike the one above, <code>&amp;&amp;</code>, <code>^</code>, and <code>||</code> have the same<br>
priority, as they are part of the same block. Addionally, the entire group is<br>
left-associative. This means that none of <code>&amp;&amp;</code>, <code>^</code>, and <code>||</code> can appear as the<br>
right child of any of <code>&amp;&amp;</code>, <code>^</code>, or <code>||</code>. Hence, this grammar is also not<br>
ambiguous. However, it expresses a different grammar, and you are encouraged<br>
to think about what the differences are in practice.</p>
<h3 class="mume-header" id="exercise-1">Exercise</h3>

<p>Parse the program <code>true &amp;&amp; false &amp;&amp; false</code> yourself, and confirm that the AST<br>
places the rightmost <code>&amp;&amp;</code> at the top of the expression. Then modify the<br>
definition to generate the alternative parse.</p>
<h2 class="mume-header" id="explicit-priority-and-associativity-declarations">Explicit priority and associativity declarations</h2>

<p>Previously we have only considered the case where all the productions which<br>
you wish to express a priority or associativity relation over are co-located<br>
in the same block of productions. However, in practice this is not always<br>
feasible or desirable, especially as a definition grows in size across<br>
multiple modules. As a result, K provides a second way of declaring priority<br>
and associativity relations.</p>
<p>Consider the following grammar, which we name <code>lesson-04-d.k</code> and which<br>
expresses the exact same grammar as <code>lesson-04-b.k</code>:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">04</span><span class="token operator">-</span>D

  <span class="token keyword keyword-syntax">syntax</span> Boolean <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;true&quot;</span> <span class="token punctuation">[</span>group<span class="token punctuation">(</span>literal<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token string">&quot;false&quot;</span> <span class="token punctuation">[</span>group<span class="token punctuation">(</span>literal<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;(&quot;</span> Boolean <span class="token string">&quot;)&quot;</span> <span class="token punctuation">[</span>group<span class="token punctuation">(</span>atom<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">bracket</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;!&quot;</span> Boolean <span class="token punctuation">[</span>group<span class="token punctuation">(</span>not<span class="token punctuation">)</span><span class="token punctuation">,</span> function<span class="token punctuation">]</span>
                   <span class="token operator">|</span> Boolean <span class="token string">&quot;&amp;&amp;&quot;</span> Boolean <span class="token punctuation">[</span>group<span class="token punctuation">(</span>and<span class="token punctuation">)</span><span class="token punctuation">,</span> function<span class="token punctuation">]</span>
                   <span class="token operator">|</span> Boolean <span class="token string">&quot;^&quot;</span> Boolean <span class="token punctuation">[</span>group<span class="token punctuation">(</span>xor<span class="token punctuation">)</span><span class="token punctuation">,</span> function<span class="token punctuation">]</span>
                   <span class="token operator">|</span> Boolean <span class="token string">&quot;||&quot;</span> Boolean <span class="token punctuation">[</span>group<span class="token punctuation">(</span>or<span class="token punctuation">)</span><span class="token punctuation">,</span> function<span class="token punctuation">]</span>

  <span class="token keyword keyword-syntax priority">syntax priority</span> literal atom &gt; not &gt; and &gt; xor &gt; or
  <span class="token keyword keyword-syntax left">syntax left</span> and
  <span class="token keyword keyword-syntax left">syntax left</span> xor
  <span class="token keyword keyword-syntax left">syntax left</span> or
  
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>This introduces a couple of new features of K. First, the <code>group(_)</code> attribute<br>
of a production is used to conceptually group together sets of sentences under<br>
a common user-defined name. For example, <code>literal</code> in the <code>syntax priority</code><br>
sentence is used to refer to all productions marked with the <code>group(literal)</code><br>
attribute, i.e., <code>true</code> and <code>false</code>, <code>atom</code> to all productions marked with<br>
<code>group(atom)</code>, i.e., braket production, and so on and so forth. A production<br>
can belong to multiple groups using syntax such as <code>group(myGrp1,myGrp2)</code>.</p>
<p>Once we understand this, it becomes relatively straightforward to understand<br>
the meaning of this grammar. Each <code>syntax priority</code> sentence defines a priority<br>
relation where <code>&gt;</code> separates different priority groups. Each priority group is<br>
defined by a list of one or more group names, and consists of all productions<br>
which are members of at least one of those named groups. <code>literal</code> and <code>atom</code><br>
are only separated by space as they have the same precedence.</p>
<p>In the same way, sentences <code>syntax left</code>, <code>syntax right</code>, or <code>syntax non-assoc</code><br>
define an associativity relation among left-, right-, or non-associative<br>
groups, respectively. Specifically, this means that:</p>
<pre data-role="codeBlock" data-info class="language-"><code>syntax left a b
</code></pre><p>is <em>different</em> to:</p>
<pre data-role="codeBlock" data-info class="language-"><code>syntax left a
syntax left b
</code></pre><p><code>syntax left a b</code> places <code>a</code> and <code>b</code> in the same associativity block, meaning<br>
that <code>a</code> and/or <code>b</code> cannot be the rightmost child of <code>a</code> and/or <code>b</code>. The<br>
latter sentences instead mean that <code>a</code> cannot be the rightmost child of <code>a</code> and<br>
<code>b</code> cannot be the rightmost child of <code>b</code>, but place no restriction on <code>a</code><br>
being the rightmost child of <code>b</code> or <code>b</code> being the rightmost child of <code>a</code>.<br>
As a consequence, <code>syntax [left|right|non-assoc]</code> should not be used to<br>
group together labels with different priority.</p>
<h2 class="mume-header" id="preferavoid-productions">Prefer/avoid productions</h2>

<p>Sometimes priority and associativity prove insufficient to disambiguate a<br>
grammar. In particular, sometimes it is desirable to be able to choose between<br>
two ambiguous parses directly while still not rejecting any parses if the term<br>
parsed is unambiguous. A good example of this is the famous &quot;dangling else&quot;<br>
problem in imperative C-like languages.</p>
<p>Consider the following definition (<code>lesson-04-e.k</code>):</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">04</span><span class="token operator">-</span>E

  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;true&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;false&quot;</span>
  <span class="token keyword keyword-syntax">syntax</span> Stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;if&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Stmt
                <span class="token operator">|</span> <span class="token string">&quot;if&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Stmt <span class="token string">&quot;else&quot;</span> Stmt
                <span class="token operator">|</span> <span class="token string">&quot;{&quot;</span> <span class="token string">&quot;}&quot;</span>

<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>and program <code>dangling-else.if</code> below:</p>
<pre data-role="codeBlock" data-info class="language-"><code>if (true) if (false) {} else {}
</code></pre><p>This is ambiguous because it is unclear whether the <code>else</code> clause is part of<br>
the outer <code>if</code> or the inner <code>if</code>. At first we might try to resolve this with<br>
priorities, specifying that the <code>if</code> without an <code>else</code> cannot appear as a child<br>
of the <code>if</code> with an <code>else</code>. However, because the non-terminal in the parent<br>
symbol is both preceded and followed by a terminal, this will not work.</p>
<p>Instead, we can resolve the ambiguity directly by telling the parser to<br>
&quot;prefer&quot; or &quot;avoid&quot; certain productions when ambiguities arise. For example,<br>
when we parse this program with</p>
<pre data-role="codeBlock" data-info class="language-"><code>kompile lesson-04-e.k
kast --output kore dangling-else.if
</code></pre><p>we get the following ambiguity as an error message, minus the formatting:</p>
<pre data-role="codeBlock" data-info class="language-"><code>[Error] Inner Parser: Parsing ambiguity.
1: syntax Stmt ::= &quot;if&quot; &quot;(&quot; Exp &quot;)&quot; Stmt
    `if(_)__LESSON-04-E_Stmt_Exp_Stmt`(
      `true_LESSON-04-E_Exp`(.KList),
      `if(_)_else__LESSON-04-E_Stmt_Exp_Stmt_Stmt`(
        `false_LESSON-04-E_Exp`(.KList),
        `{}_LESSON-04-E_Stmt`(.KList),
        `{}_LESSON-04-E_Stmt`(.KList)
      )
    )

2: syntax Stmt ::= &quot;if&quot; &quot;(&quot; Exp &quot;)&quot; Stmt &quot;else&quot; Stmt
    `if(_)_else__LESSON-04-E_Stmt_Exp_Stmt_Stmt`(
      `true_LESSON-04-E_Exp`(.KList),
      `if(_)__LESSON-04-E_Stmt_Exp_Stmt`(
        `false_LESSON-04-E_Exp`(.KList),
        `{}_LESSON-04-E_Stmt`(.KList)
      ),
      `{}_LESSON-04-E_Stmt`(.KList)
    )

	Source(./dangling-else.if)
	Location(1,1,1,32)
	1 |	if (true) if (false) {} else {}
	  .	^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</code></pre><p>Roughly, we see that the ambiguity is between an <code>if</code> with an <code>else</code> or an <code>if</code><br>
without an <code>else</code>. Since we want to pick the first parse, we can tell K to<br>
<strong>avoid</strong> the second parse with the <code>avoid</code> attribute. Consider the following<br>
modified definition (<code>lesson-04-f.k</code>):</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">04</span><span class="token operator">-</span>F

  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;true&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;false&quot;</span>
  <span class="token keyword keyword-syntax">syntax</span> Stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;if&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Stmt
                <span class="token operator">|</span> <span class="token string">&quot;if&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Stmt <span class="token string">&quot;else&quot;</span> Stmt <span class="token punctuation">[</span><span class="token class-name">avoid</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;{&quot;</span> <span class="token string">&quot;}&quot;</span>

<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>Here we have added the <code>avoid</code> attribute to the <code>else</code> production. As a result,<br>
when an ambiguity occurs and any of the possible parses has that attribute at<br>
the top of the ambiguous part of the parse, we discard those parses, and<br>
consider only the remaining ones. The <code>prefer</code> attribute behaves similarly, but<br>
instead it discards all parses which do not have that attribute. In both cases,<br>
no action is taken if the parse is not ambiguous.</p>
<p>If we parse the program in <code>dangling-else.if</code> with this grammar,</p>
<pre data-role="codeBlock" data-info class="language-"><code>kompile lesson-04-f.k
kast --output kast dangling-else.if
</code></pre><p>we get the following output, minus the formatting:</p>
<pre data-role="codeBlock" data-info class="language-"><code>`if(_)__LESSON-04-F_Stmt_Exp_Stmt`(
	`true_LESSON-04-F_Exp`(.KList),
	`if(_)_else__LESSON-04-F_Stmt_Exp_Stmt_Stmt`(
		`false_LESSON-04-F_Exp`(.KList),
		`{}_LESSON-04-F_Stmt`(.KList),
		`{}_LESSON-04-F_Stmt`(.KList)
	)
)
</code></pre><p>As we expected, the AST where the <code>else</code> corresponds to the first <code>if</code> is<br>
discarded.</p>
<h2 class="mume-header" id="exercises">Exercises</h2>

<ol>
<li>
<p>Parse the program <code>if (true) if (false) {} else {}</code> using <code>lesson-04-f.k</code><br>
and confirm that the <code>else</code> clause is part of the innermost <code>if</code> statement.<br>
Then modify the definition so that you will get the alternative parse.</p>
</li>
<li>
<p>Modify your solution from Lesson 1.3, Exercise 2 so that unary negation should<br>
bind tighter than multiplication and division, which should bind tighter than<br>
addition and subtraction, and each binary operator should be left associative.<br>
Write these priority and associativity declarations explicitly, and then<br>
try to write them inline.</p>
</li>
<li>
<p>Write a simple grammar containing at least one ambiguity that cannot be<br>
resolved via priority or associativity, and then use the <code>prefer</code> attribute to<br>
resolve that ambiguity.</p>
</li>
<li>
<p>Explain why the following grammar is not labeled ambiguous by the K parser<br>
when parsing <code>abb</code>, then make the parser realize the ambiguity.</p>
</li>
</ol>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> EXERCISE4

  <span class="token keyword keyword-syntax">syntax</span> Expr <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;a&quot;</span> Expr <span class="token string">&quot;b&quot;</span>
                <span class="token operator">|</span> <span class="token string">&quot;abb&quot;</span>
                <span class="token operator">|</span> <span class="token string">&quot;b&quot;</span>

<span class="token keyword keyword-endmodule">endmodule</span>
</pre><h2 class="mume-header" id="next-lesson">Next lesson</h2>

<p>Once you have completed the above exercises, you can continue to<br>
<a href="#ebook-heading-lesson-15-modules-imports-and-requires">Lesson 1.5: Modules, Imports, and Requires</a>.</p>
</div></div><div id="ebook-heading-lesson-15-modules-imports-and-requires" ebook-toc-level-3 heading="Lesson 1.5: Modules, Imports, and Requires"><div><h1 class="mume-header" id="lesson-15-modules-imports-and-requires">Lesson 1.5: Modules, Imports, and Requires</h1>

<p>The purpose of this lesson is to explain how K definitions can be broken into<br>
separate modules and files and how these distinct components combine into a<br>
complete K definition.</p>
<h2 class="mume-header" id="ks-outer-syntax">K&apos;s outer syntax</h2>

<p>Recall from <a href="#ebook-heading-lesson-13-bnf-syntax-and-parser-generation">Lesson 1.3</a> that K&apos;s grammar is broken<br>
into two components: the <strong>outer syntax</strong> of K and the <strong>inner syntax</strong> of K.<br>
Outer syntax, as previously mentioned, consists of <strong>requires</strong>, <strong>modules</strong>,<br>
<strong>imports</strong>, and <strong>sentences</strong>. A K semantics is expressed by the set of<br>
sentences contained in the definition. The scope of what is considered<br>
contained in that definition is determined both by the <strong>main semantics<br>
module</strong> of a K definition, as well as the <strong>requires</strong> and <strong>imports</strong> present<br>
in the file that contains that module.</p>
<h2 class="mume-header" id="basic-module-syntax">Basic module syntax</h2>

<p>The basic unit of grouping sentences in K is the module. A module consists<br>
of a <strong>module name</strong>, an optional list of <strong>attributes</strong>, a list of<br>
<strong>imports</strong>, and a list of <strong>sentences</strong>.</p>
<p>A module name consists of one or more groups of letters, numbers, or<br>
underscores, separated by a hyphen. Here are some valid module names: <code>FOO</code>,<br>
<code>FOO-BAR</code>, <code>foo0</code>, <code>foo0_bar-Baz9</code>. Here are some invalid module names: <code>-</code>,<br>
<code>-FOO</code>, <code>BAR-</code>, <code>FOO--BAR</code>. Stylistically, modules names are usually all<br>
uppercase with hyphens separating words, but this is not strictly enforced.</p>
<p>Some example modules include an empty module:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">05</span><span class="token operator">-</span>A

<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>A module with some attributes:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">05</span><span class="token operator">-</span>B <span class="token punctuation">[</span>group<span class="token punctuation">(</span>attr1<span class="token punctuation">,</span>attr2<span class="token punctuation">)</span><span class="token punctuation">,</span> private<span class="token punctuation">]</span>

<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>A module with some sentences:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">05</span><span class="token operator">-</span>C
  <span class="token keyword keyword-syntax">syntax</span> Boolean <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;true&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;false&quot;</span>
  <span class="token keyword keyword-syntax">syntax</span> Boolean <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;not&quot;</span> Boolean <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> not <span class="token boolean">true</span> <span class="token operator">=&gt;</span> <span class="token boolean">false</span>
  <span class="token keyword keyword-rule">rule</span> not <span class="token boolean">false</span> <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><h2 class="mume-header" id="imports">Imports</h2>

<p>Thus far we have only discussed definitions containing a single module.<br>
Definitions can also contain multiple modules, in which one module imports<br>
others.</p>
<p>An import in K appears at the top of a module, prior to any sentences. It can<br>
be specified with the <code>imports</code> keyword, followed by a module name.</p>
<p>For example, here is a simple definition with two modules (<code>lesson-05-d.k</code>):</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">05</span><span class="token operator">-</span>D<span class="token operator">-</span><span class="token number">1</span>
  <span class="token keyword keyword-syntax">syntax</span> Boolean <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;true&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;false&quot;</span>
  <span class="token keyword keyword-syntax">syntax</span> Boolean <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;not&quot;</span> Boolean <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">05</span><span class="token operator">-</span>D
  <span class="token keyword keyword-imports">imports</span> LESSON<span class="token operator">-</span><span class="token number">05</span><span class="token operator">-</span>D<span class="token operator">-</span><span class="token number">1</span>

  <span class="token keyword keyword-rule">rule</span> not <span class="token boolean">true</span> <span class="token operator">=&gt;</span> <span class="token boolean">false</span>
  <span class="token keyword keyword-rule">rule</span> not <span class="token boolean">false</span> <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>This K definition is equivalent to the definition expressed by the single module<br>
<code>LESSON-05-C</code>. Essentially, by importing a module, we include all of the<br>
sentences in the module being imported into the module that we import from.<br>
There are a few minor differences between importing a module and simply<br>
including its sentences in another module directly, but we will cover these<br>
differences later. Essentially, you can think of modules as a way of<br>
conceptually grouping sentences in a larger K definition.</p>
<h3 class="mume-header" id="exercise">Exercise</h3>

<p>Modify <code>lesson-05-d.k</code> to include four modules: one containing the syntax, two<br>
with one rule each that imports the first module, and a final module<br>
<code>LESSON-05-D</code> containing no sentences that imports the second and third module.<br>
Check to make sure the definition still compiles and that you can still evaluate<br>
the <code>not</code> function.</p>
<h2 class="mume-header" id="parsing-in-the-presence-of-multiple-modules">Parsing in the presence of multiple modules</h2>

<p>As you may have noticed, each module in a definition can express a distinct set<br>
of syntax. When parsing the sentences in a module, we use the syntax<br>
<strong>of that module</strong>, enriched with the basic syntax of K, in order to parse<br>
rules in that module. For example, the following definition is a parser error<br>
(<code>lesson-05-e.k</code>):</p>
<pre data-role="codeBlock" data-info="{.k .error}" class="language- k error"><code>module LESSON-05-E-1
  rule not true =&gt; false
  rule not false =&gt; true
endmodule

module LESSON-05-E-2
  syntax Boolean ::= &quot;true&quot; | &quot;false&quot;
  syntax Boolean ::= &quot;not&quot; Boolean [function]
endmodule
</code></pre><p>This is because the syntax referenced in module <code>LESSON-05-E-1</code>, namely, <code>not</code>,<br>
<code>true</code>, and <code>false</code>, is not imported by that module. You can solve this problem<br>
by simply importing the modules containing the syntax you want to use in your<br>
sentences.</p>
<h2 class="mume-header" id="main-syntax-and-semantics-modules">Main syntax and semantics modules</h2>

<p>When we are compiling a K definition, we need to know where to start. We<br>
designate two specific <strong>entry point modules</strong>: the <strong>main syntax module</strong><br>
and the <strong>main semantics module</strong>. The main syntax module, as well as all the<br>
modules it imports recursively, are used to create the parser for programs that<br>
you use to parse programs that you execute with <code>krun</code>. The main semantics<br>
module, as well as all the modules it imports recursively, are used to<br>
determine the rules that can be applied at runtime in order to execute a<br>
program. For example, in the above example, if the main semantics module is<br>
module <code>LESSON-05-D-1</code>, then <code>not</code> is an uninterpreted function (i.e., has no<br>
rules associated with it), and the rules in module <code>LESSON-05-D</code> are not<br>
included.</p>
<p>While you can specify the entry point modules explicitly by passing the<br>
<code>--main-module</code> and <code>--syntax-module</code> flags to <code>kompile</code>, by default, if you<br>
type <code>kompile foo.k</code>, then the main semantics module will be <code>FOO</code> and the<br>
main syntax module will be <code>FOO-SYNTAX</code>.</p>
<h2 class="mume-header" id="splitting-a-definition-into-multiple-files">Splitting a definition into multiple files</h2>

<p>So far, while we have discussed ways to break definitions into separate<br>
conceptual components (modules), K also provides a mechanism for combining<br>
multiple files into a single K definition, namely, the <strong>requires</strong> directive.</p>
<p>In K, the <code>requires</code> keyword has two meanings. The first, the <strong>requires</strong><br>
statement, appears at the top of a K file, prior to any module declarations. It<br>
consists of the keyword <code>requires</code> followed by a double-quoted string. The<br>
second meaning of the <code>requires</code> keyword will be covered in a later lesson,<br>
but it is distinguished because the second case occurs only inside modules.</p>
<p>The string passed to the <strong>requires</strong> statement contains a filename. When you run<br>
<code>kompile</code> on a file, it will look at all of the <code>requires</code> statements in that<br>
file, look up those files on disk, parse them, and then recursively process all<br>
the <strong>requires</strong> statements in those files. It then combines all the modules in all<br>
of those files together, and uses them collectively as the set of modules to<br>
which <code>imports</code> statements can refer.</p>
<h2 class="mume-header" id="putting-it-all-together">Putting it all together</h2>

<p>Putting it all together, here is one possible way in which we could break the<br>
definition <code>lesson-02-c.k</code> from <a href="#ebook-heading-lesson-12-basics-of-functional-k">Lesson 1.2</a> into<br>
multiple files and modules:</p>
<p><code>colors.k</code>:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> COLORS
  <span class="token keyword keyword-syntax">syntax</span> Color <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Yellow<span class="token punctuation">(</span><span class="token punctuation">)</span>
                 <span class="token operator">|</span> Blue<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p><code>fruits.k</code>:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> FRUITS
  <span class="token keyword keyword-syntax">syntax</span> Fruit <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Banana<span class="token punctuation">(</span><span class="token punctuation">)</span>
                 <span class="token operator">|</span> Blueberry<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p><code>colorOf.k</code>:</p>
<pre data-role="codeBlock" data-info="{.k .exclude}" class="language- k exclude"><code>requires &quot;fruits.k&quot;
requires &quot;colors.k&quot;

module COLOROF-SYNTAX
  imports COLORS
  imports FRUITS

  syntax Color ::= colorOf(Fruit) [function]
endmodule

module COLOROF
  imports COLOROF-SYNTAX

  rule colorOf(Banana()) =&gt; Yellow()
  rule colorOf(Blueberry()) =&gt; Blue()
endmodule
</code></pre><p>You would then compile this definition with <code>kompile colorOf.k</code> and use it the<br>
same way as the original, single-module definition.</p>
<h3 class="mume-header" id="exercise-1">Exercise</h3>

<p>Modify the name of the <code>COLOROF</code> module, and then recompile the definition.<br>
Try to understand why you now get a compiler error. Then, resolve this compiler<br>
error by passing the <code>--main-module</code> and <code>--syntax-module</code> flags to kompile.</p>
<h2 class="mume-header" id="include-path">Include path</h2>

<p>One note can be made about how paths are resolved in <code>requires</code> statements.</p>
<p>By default, the path you specify is allowed to be an absolute or a relative<br>
path. If the path is absolute, that exact file is imported. If the path is<br>
relative, a matching file is looked for within all of the<br>
<strong>include directories</strong> specified to the compiler. By default, the include<br>
directories include the current working directory, followed by the<br>
<code>include/kframework/builtin</code> directory within your installation of K. You can<br>
also pass one or more directories to <code>kompile</code> via the <code>-I</code> command line flag,<br>
in which case these directories are prepended to the beginning of the list.</p>
<h2 class="mume-header" id="exercises">Exercises</h2>

<ol>
<li>
<p>Take the solution to Lesson 1.4, Exercise 2 which included the explicit<br>
priority and associativity declarations, and modify the definition so that<br>
the syntax of integers and brackets is in one module, the syntax of addition,<br>
subtraction, and unary negation is in another module, and the syntax of<br>
multiplication and division is in a third module. Make sure you can still parse<br>
the same set of expressions as before. Place priority declarations in the main<br>
module.</p>
</li>
<li>
<p>Modify <code>lesson-02-d.k</code> from Lesson 1.2 so that the rules and syntax are in<br>
separate modules in separate files.</p>
</li>
<li>
<p>Place the file containing the syntax from Exercise 2 in another directory,<br>
then recompile the definition. Observe why a compilation error occurs. Then<br>
fix the compiler error by passing <code>-I</code> to kompile.</p>
</li>
</ol>
<h2 class="mume-header" id="next-lesson">Next lesson</h2>

<p>Once you have completed the above exercises, you can continue to<br>
<a href="#ebook-heading-lesson-16-integers-and-booleans">Lesson 1.6: Integers and Booleans</a>.</p>
</div></div><div id="ebook-heading-lesson-16-integers-and-booleans" ebook-toc-level-3 heading="Lesson 1.6: Integers and Booleans"><div><h1 class="mume-header" id="lesson-16-integers-and-booleans">Lesson 1.6: Integers and Booleans</h1>

<p>The purpose of this lesson is to explain the two most basic types of builtin<br>
sorts in K, the <code>Int</code> sort and the <code>Bool</code> sort, representing<br>
<strong>arbitrary-precision integers</strong> and <strong>Boolean algebra</strong>.</p>
<h2 class="mume-header" id="builtin-sorts-in-k">Builtin sorts in K</h2>

<p>K provides definitions of some useful sorts in<br>
<a href="#ebook-heading-domains">domains.md</a>, found in the<br>
<code>include/kframework/builtin</code> directory of the K installation. This file is<br>
defined via a<br>
<a href="https://en.wikipedia.org/wiki/Literate_programming">Literate programming</a><br>
style that we will discuss in a future lesson. We will not cover all of the<br>
sorts found there immediately, however, this lesson discusses some of the<br>
details surrounding integers and Booleans, as well as providing information<br>
about how to look up more detailed knowledge about builtin functions in K&apos;s<br>
documentation.</p>
<h2 class="mume-header" id="booleans-in-k">Booleans in K</h2>

<p>The most basic builtin sort K provides is the <code>Bool</code> sort, representing<br>
Boolean values (i.e., <code>true</code> and <code>false</code>). You have already seen how we were<br>
able to create this type ourselves using K&apos;s parsing and disambiguation<br>
features. However, in the vast majority of cases, we prefer instead to import<br>
the version of Boolean algebra defined by K itself. Most simply, you can do<br>
this by importing the module <code>BOOL</code> in your definition. For example<br>
(<code>lesson-06-a.k</code>):</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">06</span><span class="token operator">-</span>A
  <span class="token keyword keyword-imports">imports</span> BOOL

  <span class="token keyword keyword-syntax">syntax</span> Fruit <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Blueberry<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">|</span> Banana<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> isBlue<span class="token punctuation">(</span>Fruit<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> isBlue<span class="token punctuation">(</span>Blueberry<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
  <span class="token keyword keyword-rule">rule</span> isBlue<span class="token punctuation">(</span>Banana<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">false</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>Here we have defined a simple <strong>predicate</strong>, i.e., a function returning a<br>
Boolean value. We are now able to perform the usual Boolean operations of<br>
and, or, and not over these values. For example (<code>lesson-06-b.k</code>):&quot;</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">06</span><span class="token operator">-</span>B
  <span class="token keyword keyword-imports">imports</span> BOOL

  <span class="token keyword keyword-syntax">syntax</span> Fruit <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Blueberry<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">|</span> Banana<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> isBlue<span class="token punctuation">(</span>Fruit<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> isBlue<span class="token punctuation">(</span>Blueberry<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
  <span class="token keyword keyword-rule">rule</span> isBlue<span class="token punctuation">(</span>Banana<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">false</span>

  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> isYellow<span class="token punctuation">(</span>Fruit<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
                <span class="token operator">|</span> isBlueOrYellow<span class="token punctuation">(</span>Fruit<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> isYellow<span class="token punctuation">(</span>Banana<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
  <span class="token keyword keyword-rule">rule</span> isYellow<span class="token punctuation">(</span>Blueberry<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">false</span>

  <span class="token keyword keyword-rule">rule</span> isBlueOrYellow<span class="token punctuation">(</span>F<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> isBlue<span class="token punctuation">(</span>F<span class="token punctuation">)</span> orBool isYellow<span class="token punctuation">(</span>F<span class="token punctuation">)</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>In the above example, Boolean <strong>inclusive or</strong> is performed via the <code>orBool</code><br>
function, which is defined in the <code>BOOL</code> module. As a matter of convention,<br>
many functions over builtin sorts in K are suffixed with the name of the<br>
primary sort over which those functions are defined. This happens so that the<br>
syntax of K does not (generally) conflict with the syntax of any other<br>
programming language, which would make it harder to define that programming<br>
language in K.</p>
<h3 class="mume-header" id="exercise">Exercise</h3>

<p>Write a function <code>isBlueAndNotYellow</code> which computes the appropriate Boolean<br>
expression. If you are unsure what the appropriate syntax is to use, you<br>
can refer to the <code>BOOL</code> module in<br>
<a href="#ebook-heading-domains">domains.md</a>. Add a term of<br>
sort <code>Fruit</code> for which <code>isBlue</code> and <code>isYellow</code> both return true, and test that<br>
the <code>isBlueAndNotYellow</code> function behaves as expected on all three <code>Fruit</code>s.</p>
<h3 class="mume-header" id="syntax-modules">Syntax Modules</h3>

<p>For most sorts in <code>domains.md</code>, K defines more than one module that can be<br>
imported by users. For example, for the <code>Bool</code> sort, K defines the <code>BOOL</code><br>
module that has previously already been discussed, but also provides the<br>
<code>BOOL-SYNTAX</code> module. This module, unlike the <code>BOOL</code> module, only declares the<br>
values <code>true</code> and <code>false</code>, but not any of the functions that operate over the<br>
<code>Bool</code> sort. The rationale is that you may want to import this module into the<br>
main syntax module of your definition in some cases, whereas you generally do<br>
not want to do this with the version of the module that includes all the<br>
functions over the <code>Bool</code> sort. For example, if you were defining the semantics<br>
of C++, you might import <code>BOOL-SYNTAX</code> into the syntax module of your<br>
definition, because <code>true</code> and <code>false</code> are part of the grammar of C++, but<br>
you would only import the <code>BOOL</code> module into the main semantics module, because<br>
C++ defines its own syntax for and, or, and not that is different from the<br>
syntax defined in the <code>BOOL</code> module.</p>
<p>Here, for example, is how we might redefine our Boolean expression calculator<br>
to use the <code>Bool</code> sort while maintaining an idiomatic structure of modules<br>
and imports, for the first time including the rules to calculate the values of<br>
expressions themselves (<code>lesson-06-c.k</code>):</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">06</span><span class="token operator">-</span>C<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> BOOL<span class="token operator">-</span>SYNTAX

  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;(&quot;</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token string">&quot;)&quot;</span> <span class="token punctuation">[</span><span class="token class-name">bracket</span><span class="token punctuation">]</span>
                &gt; <span class="token string">&quot;!&quot;</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
                &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                  <span class="token keyword keyword-Bool">Bool</span> <span class="token string">&quot;&amp;&amp;&quot;</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token string">&quot;^&quot;</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token string">&quot;||&quot;</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">06</span><span class="token operator">-</span>C
  <span class="token keyword keyword-imports">imports</span> LESSON<span class="token operator">-</span><span class="token number">06</span><span class="token operator">-</span>C<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> BOOL

  <span class="token keyword keyword-rule">rule</span> <span class="token operator">!</span> B <span class="token operator">=&gt;</span> notBool B
  <span class="token keyword keyword-rule">rule</span> A <span class="token operator">&amp;&amp;</span> B <span class="token operator">=&gt;</span> A andBool B
  <span class="token keyword keyword-rule">rule</span> A <span class="token operator">^</span> B <span class="token operator">=&gt;</span> A xorBool B
  <span class="token keyword keyword-rule">rule</span> A <span class="token operator">||</span> B <span class="token operator">=&gt;</span> A orBool B
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>Note the encapsulation of syntax: the <code>LESSON-06-C-SYNTAX</code> module contains<br>
exactly the syntax of our Boolean expressions, and no more, whereas any other<br>
syntax needed to implement those functions is in the <code>LESSON-06-C</code> module<br>
instead.</p>
<h4 class="mume-header" id="exercise-1">Exercise</h4>

<p>Add an &quot;implies&quot; function to the above Boolean expression calculator, using the<br>
<code>-&gt;</code> symbol to represent implication. You can look up K&apos;s builtin &quot;implies&quot;<br>
function in the <code>BOOL</code> module in <code>domains.md</code>.</p>
<h2 class="mume-header" id="integers-in-k">Integers in K</h2>

<p>Unlike most programming languages, where the most basic integer type is a<br>
fixed-precision integer type, the most commonly used integer sort in K is<br>
the <code>Int</code> sort, which represents the <strong>mathematical</strong> integers, ie,<br>
arbitrary-precision integers.</p>
<p>K provides three main modules for import when using the <code>Int</code> sort. The first,<br>
containing all the syntax of integers as well as all of the functions over<br>
integers, is the <code>INT</code> module. The second, which provides just the syntax<br>
of integer literals themselves, is the <code>INT-SYNTAX</code> module. However, unlike<br>
most builtin sorts in K, K also provides a third module for the <code>Int</code> sort:<br>
the <code>UNSIGNED-INT-SYNTAX</code> module. This module provides only the syntax of<br>
<strong>non-negative integers</strong>, i.e., natural numbers. The reasons for this involve<br>
lexical ambiguity. Generally speaking, in most programming languages, <code>-1</code> is<br>
not a literal, but instead a literal to which the unary negation operator is<br>
applied. K thus provides this module to ease in specifying the syntax of such<br>
languages.</p>
<p>For detailed information about the functions available over the <code>Int</code> sort,<br>
refer to <code>domains.md</code>. Note again how we append <code>Int</code> to the end of most of the<br>
integer operations to ensure they do not collide with the syntax of other<br>
programming languages.</p>
<h2 class="mume-header" id="exercises">Exercises</h2>

<ol>
<li>
<p>Extend your solution from Lesson 1.4, Exercise 2 to implement the rules<br>
that define the behavior of addition, subtraction, multiplication, and<br>
division. Do not worry about the case when the user tries to divide by zero<br>
at this time. Use <code>/Int</code> to implement division. Test your new calculator<br>
implementation by executing the arithmetic expressions you wrote as part of<br>
Lesson 1.3, Exercise 2. Check to make sure each computes the value you expected.</p>
</li>
<li>
<p>Combine the Boolean expression calculator from this lesson with your<br>
solution to Exercise 1, and then extend the combined calculator with the <code>&lt;</code>,<br>
<code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>==</code>, and <code>!=</code> expressions. Write some Boolean expressions<br>
that combine integer and Boolean operations, and test to ensure that these<br>
expressions return the expected truth value.</p>
</li>
<li>
<p>Compute the following expressions using your solution from Exercise 2:<br>
<code>7 / 3</code>, <code>7 / -3</code>, <code>-7 / 3</code>, <code>-7 / -3</code>. Then replace the <code>/Int</code> function in<br>
your definition with <code>divInt</code> instead, and observe how the value of the above<br>
expressions changes. Why does this occur?</p>
</li>
</ol>
<h2 class="mume-header" id="next-lesson">Next lesson</h2>

<p>Once you have completed the above exercises, you can continue to<br>
<a href="#ebook-heading-lesson-17-side-conditions-and-rule-priority">Lesson 1.7: Side Conditions and Rule Priority</a>.</p>
</div></div><div id="ebook-heading-lesson-17-side-conditions-and-rule-priority" ebook-toc-level-3 heading="Lesson 1.7: Side Conditions and Rule Priority"><div><h1 class="mume-header" id="lesson-17-side-conditions-and-rule-priority">Lesson 1.7: Side Conditions and Rule Priority</h1>

<p>The purpose of this lesson is to explain how to write conditional rules in K,<br>
and to explain how to control the order in which rules are tried.</p>
<h2 class="mume-header" id="side-conditions">Side Conditions</h2>

<p>So far, all of the rules we have discussed have been <strong>unconditional rules</strong>.<br>
If the left-hand side of the rule matches the arguments to the function, the<br>
rule applies. However, there is another type of rule, a <strong>conditional rule</strong>.<br>
A conditional rule consists of a <strong>rule body</strong> containing the patterns to<br>
match, and a <strong>side condition</strong> representing a Boolean expression that must<br>
evaluate to true in order for the rule to apply.</p>
<p>Side conditions in K are introduced via the <code>requires</code> keyword immediately<br>
following the rule body. For example, here is a rule with a side condition<br>
(<code>lesson-07-a.k</code>):</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">07</span><span class="token operator">-</span>A
  <span class="token keyword keyword-imports">imports</span> BOOL
  <span class="token keyword keyword-imports">imports</span> INT

  <span class="token keyword keyword-syntax">syntax</span> Grade <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;letter-A&quot;</span>
                 <span class="token operator">|</span> <span class="token string">&quot;letter-B&quot;</span>
                 <span class="token operator">|</span> <span class="token string">&quot;letter-C&quot;</span>
                 <span class="token operator">|</span> <span class="token string">&quot;letter-D&quot;</span>
                 <span class="token operator">|</span> <span class="token string">&quot;letter-F&quot;</span>
                 <span class="token operator">|</span> gradeFromPercentile<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> gradeFromPercentile<span class="token punctuation">(</span>I<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> letter<span class="token operator">-</span>A <span class="token keyword keyword-requires">requires</span> I <span class="token operator">&gt;=</span><span class="token keyword keyword-Int">Int</span> <span class="token number">90</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>In this case, the <code>gradeFromPercentile</code> function takes a single integer<br>
argument. The function evaluates to <code>letter-A</code> if the argument passed is<br>
greater than 90. Note that the side condition is allowed to refer to variables<br>
that appear on the left-hand side of the rule. In the same manner as variables<br>
appearing on the right-hand side, variables that appear in the side condition<br>
evaluate to the value that was matched on the left-hand side. Then the<br>
functions in the side condition are evaluated, which returns a term of sort<br>
<code>Bool</code>. If the term is equal to <code>true</code>, then the rule applies. Bear in mind<br>
that the side condition is only evaluated at all if the patterns on the<br>
left-hand side of the rule match the term being evaluated.</p>
<h3 class="mume-header" id="exercise">Exercise</h3>

<p>Write a rule that evaluates <code>gradeFromPercentile</code> to <code>letter-B</code> if the argument<br>
to the function is in the range [80,90). Test that the function correctly<br>
evaluates various numbers between 80 and 100.</p>
<h2 class="mume-header" id="owise-rules"><code>owise</code> Rules</h2>

<p>So far, all the rules we have introduced have had the same <strong>priority</strong>. What<br>
this means is that K does not necessarily enforce an order in which the rules<br>
are tried. We have only discussed functions so far in K, so it is not<br>
immediately clear why this choice was made, given that a function is not<br>
considered well-defined if multiple rules for evaluating it are capable of<br>
evaluating the same arguments to different results. However, in future lessons<br>
we will discuss other types of rules in K, some of which can be<br>
<strong>non-deterministic</strong>. What this means is that if more than one rule is capable<br>
of matching, then K will explore both possible rules in parallel, and consider<br>
each of their respective results when executing your program. Don&apos;t worry too<br>
much about this right now, but just understand that because of the potential<br>
later for nondeterminism, we don&apos;t enforce a total ordering on the order in<br>
which rules are attempted to be applied.</p>
<p>However, sometimes this is not practical; It can be very convenient to express<br>
that a particular rule applies if no other rules for that function are<br>
applicable. This can be expressed by adding the <code>owise</code> attribute to a rule.<br>
What this means, in practice, is that this rule has lower priority than other<br>
rules, and will only be tried to be applied after all the other,<br>
higher-priority rules have been tried and they have failed.</p>
<p>For example, in the above exercise, we had to add a side condition containing<br>
two Boolean comparisons to the rule we wrote to handle <code>letter-B</code> grades.<br>
However, in practice this meant that we compare the percentile to 90 twice. We<br>
can more efficiently and more idiomatically write the <code>letter-B</code> case for the<br>
<code>gradeFromPercentile</code> rule using the <code>owise</code> attribute (<code>lesson-07-b.k</code>):</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">07</span><span class="token operator">-</span>B
  <span class="token keyword keyword-imports">imports</span> BOOL
  <span class="token keyword keyword-imports">imports</span> INT

  <span class="token keyword keyword-syntax">syntax</span> Grade <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;letter-A&quot;</span>
                 <span class="token operator">|</span> <span class="token string">&quot;letter-B&quot;</span>
                 <span class="token operator">|</span> <span class="token string">&quot;letter-C&quot;</span>
                 <span class="token operator">|</span> <span class="token string">&quot;letter-D&quot;</span>
                 <span class="token operator">|</span> <span class="token string">&quot;letter-F&quot;</span>
                 <span class="token operator">|</span> gradeFromPercentile<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> gradeFromPercentile<span class="token punctuation">(</span>I<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> letter<span class="token operator">-</span>A <span class="token keyword keyword-requires">requires</span> I <span class="token operator">&gt;=</span><span class="token keyword keyword-Int">Int</span> <span class="token number">90</span>
  <span class="token keyword keyword-rule">rule</span> gradeFromPercentile<span class="token punctuation">(</span>I<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> letter<span class="token operator">-</span>B <span class="token keyword keyword-requires">requires</span> I <span class="token operator">&gt;=</span><span class="token keyword keyword-Int">Int</span> <span class="token number">80</span> <span class="token punctuation">[</span>owise<span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>This rule is saying, &quot;if all the other rules do not apply, then the grade is a<br>
B if the percentile is greater than or equal to 80.&quot; Note here that we use both<br>
a side condition and an <code>owise</code> attribute on the same rule. This is not<br>
required (as we will see later), but it is allowed. What this means is that the<br>
side condition is only tried if the other rules did not apply <strong>and</strong> the<br>
left-hand side of the rule matched. You can even use more complex matching on<br>
the left-hand side than simply a variable. More generally, you can also have<br>
multiple higher-priority rules, or multiple <code>owise</code> rules. What this means in<br>
practice is that all of the non-<code>owise</code> rules are tried first, in any order,<br>
followed by all the <code>owise</code> rules, in any order.</p>
<h3 class="mume-header" id="exercise-1">Exercise</h3>

<p>The grades <code>D</code> and <code>F</code> correspond to the percentile ranges [60, 70) and [0, 60)<br>
respectively. Write another implementation of <code>gradeFromPercentile</code> which<br>
handles only these cases, and uses the <code>owise</code> attribute to avoid redundant<br>
Boolean comparisons. Test that various percentiles in the range [0, 70) are<br>
evaluated correctly.</p>
<h2 class="mume-header" id="rule-priority">Rule Priority</h2>

<p>As it happens, the <code>owise</code> attribute is a specific case of a more general<br>
concept we call <strong>rule priority</strong>. In essence, each rule is assigned an integer<br>
priority. Rules are tried in increasing order of priority, starting with a<br>
rule with priority zero, and trying each increasing numerical value<br>
successively.</p>
<p>By default, a rule is assigned a priority of 50. If the rule has the <code>owise</code><br>
attribute, it is instead given the priority 200. You can see why this will<br>
cause <code>owise</code> rules to be tried after regular rules.</p>
<p>However, it is also possible to directly assign a numerical priority to a rule<br>
via the <code>priority</code> attribute. For example, here is an alternative way<br>
we could express the same two rules in the <code>gradeFromPercentile</code> function<br>
(<code>lesson-07-c.k</code>):</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">07</span><span class="token operator">-</span>C
  <span class="token keyword keyword-imports">imports</span> BOOL
  <span class="token keyword keyword-imports">imports</span> INT

  <span class="token keyword keyword-syntax">syntax</span> Grade <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;letter-A&quot;</span>
                 <span class="token operator">|</span> <span class="token string">&quot;letter-B&quot;</span>
                 <span class="token operator">|</span> <span class="token string">&quot;letter-C&quot;</span>
                 <span class="token operator">|</span> <span class="token string">&quot;letter-D&quot;</span>
                 <span class="token operator">|</span> <span class="token string">&quot;letter-F&quot;</span>
                 <span class="token operator">|</span> gradeFromPercentile<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> gradeFromPercentile<span class="token punctuation">(</span>I<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> letter<span class="token operator">-</span>A <span class="token keyword keyword-requires">requires</span> I <span class="token operator">&gt;=</span><span class="token keyword keyword-Int">Int</span> <span class="token number">90</span> <span class="token punctuation">[</span>priority<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> gradeFromPercentile<span class="token punctuation">(</span>I<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> letter<span class="token operator">-</span>B <span class="token keyword keyword-requires">requires</span> I <span class="token operator">&gt;=</span><span class="token keyword keyword-Int">Int</span> <span class="token number">80</span> <span class="token punctuation">[</span>priority<span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>We can, of course, assign a priority equal to any non-negative integer. For<br>
example, here is a more complex example that handles the remaining grades<br>
(<code>lesson-07-d.k</code>):</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">07</span><span class="token operator">-</span>D
  <span class="token keyword keyword-imports">imports</span> BOOL
  <span class="token keyword keyword-imports">imports</span> INT

  <span class="token keyword keyword-syntax">syntax</span> Grade <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;letter-A&quot;</span>
                 <span class="token operator">|</span> <span class="token string">&quot;letter-B&quot;</span>
                 <span class="token operator">|</span> <span class="token string">&quot;letter-C&quot;</span>
                 <span class="token operator">|</span> <span class="token string">&quot;letter-D&quot;</span>
                 <span class="token operator">|</span> <span class="token string">&quot;letter-F&quot;</span>
                 <span class="token operator">|</span> gradeFromPercentile<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> gradeFromPercentile<span class="token punctuation">(</span>I<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> letter<span class="token operator">-</span>A <span class="token keyword keyword-requires">requires</span> I <span class="token operator">&gt;=</span><span class="token keyword keyword-Int">Int</span> <span class="token number">90</span> <span class="token punctuation">[</span>priority<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> gradeFromPercentile<span class="token punctuation">(</span>I<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> letter<span class="token operator">-</span>B <span class="token keyword keyword-requires">requires</span> I <span class="token operator">&gt;=</span><span class="token keyword keyword-Int">Int</span> <span class="token number">80</span> <span class="token punctuation">[</span>priority<span class="token punctuation">(</span><span class="token number">51</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> gradeFromPercentile<span class="token punctuation">(</span>I<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> letter<span class="token operator">-</span>C <span class="token keyword keyword-requires">requires</span> I <span class="token operator">&gt;=</span><span class="token keyword keyword-Int">Int</span> <span class="token number">70</span> <span class="token punctuation">[</span>priority<span class="token punctuation">(</span><span class="token number">52</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> gradeFromPercentile<span class="token punctuation">(</span>I<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> letter<span class="token operator">-</span>D <span class="token keyword keyword-requires">requires</span> I <span class="token operator">&gt;=</span><span class="token keyword keyword-Int">Int</span> <span class="token number">60</span> <span class="token punctuation">[</span>priority<span class="token punctuation">(</span><span class="token number">53</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> gradeFromPercentile<span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> letter<span class="token operator">-</span>F                     <span class="token punctuation">[</span>priority<span class="token punctuation">(</span><span class="token number">54</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>Note that we have introduced a new piece of syntax here: <code>_</code>. This is actually<br>
just a variable. However, as a special case, when a variable is named <code>_</code>, it<br>
does not bind a value that can be used on the right-hand side of the rule, or<br>
in a side condition. Effectively, <code>_</code> is a placeholder variable that means &quot;I<br>
don&apos;t care about this term.&quot;</p>
<p>In this example, we have explicitly expressed the order in which the rules of<br>
this function are tried. Since rules are tried in increasing numerical<br>
priority, we first try the rule with priority 50, then 51, then 52, 53, and<br>
finally 54.</p>
<p>As a final note, remember that if you assign a rule a priority higher than 200,<br>
it will be tried <strong>after</strong> a rule with the <code>owise</code> attribute, and if you assign<br>
a rule a priority less than 50, it will be tried <strong>before</strong> a rule with no<br>
explicit priority.</p>
<h2 class="mume-header" id="exercises">Exercises</h2>

<ol>
<li>
<p>Write a function <code>isEven</code> that returns whether an integer is an even number.<br>
Use two rules and one side condition. The right-hand side of the rules should<br>
be Boolean literals. Refer back to<br>
<a href="#ebook-heading-domains">domains.md</a> for the relevant<br>
integer operations.</p>
</li>
<li>
<p>Modify the calculator application from Lesson 1.6, Exercise 2, so that division<br>
by zero will no longer make <code>krun</code> crash with a &quot;Divison by zero&quot; exception.<br>
Instead, the <code>/</code> function should not match any of its rules if the denominator<br>
is zero.</p>
</li>
<li>
<p>Write your own implementation of <code>==</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code> for integers and modify your solution from Exercise 2 to use it.<br>
You can use any arithmetic operations in the <code>INT</code> module, but do not use any built-in boolean functions for comparing integers.</p>
<p>Hint: Use pattern matching and recursive definitions with rule priorities.</p>
</li>
</ol>
<h2 class="mume-header" id="next-lesson">Next lesson</h2>

<p>Once you have completed the above exercises, you can continue to<br>
<a href="#ebook-heading-lesson-18-literate-programming-with-markdown">Lesson 1.8: Literate Programming with Markdown</a>.</p>
</div></div><div id="ebook-heading-lesson-18-literate-programming-with-markdown" ebook-toc-level-3 heading="Lesson 1.8: Literate Programming with Markdown"><div><h1 class="mume-header" id="lesson-18-literate-programming-with-markdown">Lesson 1.8: Literate Programming with Markdown</h1>

<p>The purpose of this lesson is to teach a paradigm for performing literate<br>
programming in K, and explain how this can be used to create K definitions<br>
that are also documentation.</p>
<h2 class="mume-header" id="markdown-and-k">Markdown and K</h2>

<p>The K tutorial so far has been written in<br>
<a href="https://guides.github.com/features/mastering-markdown/">Markdown</a>. Markdown,<br>
for those not already familiar, is a lightweight plain-text format for styling<br>
text. From this point onward, we assume you are familiar with Markdown and how<br>
to write Markdown code. You can refer to the above link for a tutorial if you<br>
are not already familiar.</p>
<p>What you may not necessarily realize, however, is that the K tutorial is also<br>
a sequence of K definitions written in the manner of<br>
<a href="https://en.wikipedia.org/wiki/Literate_programming">Literate Programming</a>.<br>
For detailed information about Literate Programming, you can read the linked<br>
Wikipedia article, but the short summary is that literate programming is a way<br>
of intertwining documentation and code together in a manner that allows<br>
executable code to also be, simultaneously, a documented description of that<br>
code.</p>
<p>K is provided with built-in support for literate programming using Markdown.<br>
By default, if you pass a file with the <code>.md</code> file extension to <code>kompile</code>, it<br>
will look for any code blocks containing k code in that file, extract out<br>
that K code into pure K, and then compile it as if it were a <code>.k</code> file.</p>
<p>A K code block begins with a line of text containing the keyword <code>```k</code>,<br>
and ends when it encounters another <code>```</code> keyword.</p>
<p>For example, if you view the markdown source of this document, this is a K<br>
code block:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">08</span>
  <span class="token keyword keyword-imports">imports</span> INT
</pre><p>Only the code inside K code blocks will actually be sent to the compiler. The<br>
rest, while it may appear in the document when rendered by a markdown viewer,<br>
is essentially a form of code comment.</p>
<p>When you have multiple K code blocks in a document, K will append each one<br>
together into a single file before passing it off to the outer parser.</p>
<p>For example, the following code block contains sentences that are part of the<br>
<code>LESSON-08</code> module that we declared the beginning of above:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;+&quot;</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">+</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> I2
</pre><h3 class="mume-header" id="exercise">Exercise</h3>

<p><a href="https://raw.githubusercontent.com/runtimeverification/k/master/k-distribution/k-tutorial/1_basic/08_literate_programming/README.md">Compile this file</a> with <code>kompile README.md --main-module LESSON-08</code>. Confirm<br>
that you can use the resulting compiled definition to evaluate the <code>+</code><br>
function.</p>
<h2 class="mume-header" id="markdown-selectors">Markdown Selectors</h2>

<p>On occasion, you may want to generate multiple K definitions from a single<br>
Markdown file. You may also wish to include a block of syntax-highlighted K<br>
code that nonetheless does <strong>not</strong> appear as part of your K definition. It is<br>
possible to accomplish this by means of the built-in support for syntax<br>
highlighting in Markdown. Markdown allows a code block that was begun with<br>
<code>```</code> to be immediately followed by a string which is used to signify what<br>
programming language the following code is written in. However, this feature<br>
actually allows arbitrary text to appear describing that code block. Markdown<br>
parsers are able to parse this text and render the code block differently<br>
depending on what text appears after the backticks.</p>
<p>In K, you can use this functionality to specify one or more<br>
<strong>Markdown selectors</strong> which are used to describe the code block. A Markdown<br>
selector consists of a sequence of characters containing letters, numbers, and<br>
underscores. A code block can be designated with a single selector by appending<br>
the selector immediately following the backticks that open the code block.</p>
<p>For example, here is a code block with the <code>foo</code> selector:</p>
<pre data-role="codeBlock" data-info="foo" class="language-foo"><code>foo bar
</code></pre><p>Note that this is not K code. By convention, K code should have the <code>k</code><br>
selector on it. You can express multiple selectors on a code block by putting<br>
them between curly braces and prepending each with the <code>.</code> character. For<br>
example, here is a code block with the <code>foo</code> and <code>k</code> selectors:</p>
<pre data-role="codeBlock" data-info="{.k .foo}" class="language- k foo"><code>  syntax Int ::= foo(Int) [function]
  rule foo(0) =&gt; 0
</code></pre><p>Because this code block contains the <code>k</code> Markdown selector, by default it is<br>
included as part of the K definition being compiled.</p>
<h3 class="mume-header" id="exercise-1">Exercise</h3>

<p>Confirm this fact by using <code>krun</code> to evaluate <code>foo(0)</code>.</p>
<h2 class="mume-header" id="markdown-selector-expressions">Markdown Selector Expressions</h2>

<p>By default, as previously stated, K includes in the definition any code block<br>
with the <code>k</code> selector. However, this is merely a specific instance of a general<br>
principle, namely, that K allows you to control which selectors get included<br>
in your K definition. This is done by means of the <code>--md-selector</code> flag to<br>
<code>kompile</code>. This flag accepts a <strong>Markdown selector expression</strong>, which you<br>
can essentially think of as a kind of Boolean algebra over Markdown selectors.<br>
Each selector becomes an atom, and you can combine these atoms via the <code>&amp;</code>,<br>
<code>|</code>, <code>!</code>, and <code>()</code> operators.</p>
<p>Here is a grammar, written in K, of the language of Markdown selector<br>
expressions:</p>
<pre data-role="codeBlock" data-info="{.k .selector}" class="language- k selector"><code>  syntax Selector ::= r&quot;[0-9a-zA-Z_]+&quot; [token]
  syntax SelectorExp ::= Selector
                       | &quot;(&quot; SelectorExp &quot;)&quot; [bracket]
                       &gt; right:
                         &quot;!&quot; SelectorExp
                       &gt; right:
                         SelectorExp &quot;&amp;&quot; SelectorExp
                       &gt; right:
                         SelectorExp &quot;|&quot; SelectorExp
</code></pre><p>Here is a selector expression that selects all the K code blocks in this<br>
definition except the one immediately above:</p>
<pre data-role="codeBlock" data-info class="language-"><code>k &amp; (! selector)
</code></pre><h2 class="mume-header" id="addendum">Addendum</h2>

<p>This code block exists in order to make the above lesson a syntactically valid<br>
K definition. Consider why it is necessary.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-endmodule">endmodule</span>
</pre><h3 class="mume-header" id="exercises">Exercises</h3>

<ol>
<li>
<p>Compile this lesson with the selector expression <code>k &amp; (! foo)</code> and confirm<br>
that you get a parser error if you try to evaluate the <code>foo</code> function with the<br>
resulting definition.</p>
</li>
<li>
<p>Compile <a href="https://raw.githubusercontent.com/runtimeverification/k/master/k-distribution/k-tutorial/1_basic/03_parsing/README.md">Lesson 1.3</a><br>
as a K definition. Identify why it fails to compile. Then pass an appropriate<br>
<code>--md-selector</code> to the compiler in order to make it compile.</p>
</li>
<li>
<p>Modify your calculator application from Lesson 1.7, Exercise 2, to be written<br>
in a literate style. Consider what text might be appropriate to turn the<br>
resulting markdown file into documentation for your calculator.</p>
</li>
</ol>
<h2 class="mume-header" id="next-lesson">Next lesson</h2>

<p>Once you have completed the above exercises, you can continue to<br>
<a href="#ebook-heading-lesson-19-unparsing-and-the-format-and-color-attributes">Lesson 1.9: Unparsing and the format and color attributes</a>.</p>
</div></div><div id="ebook-heading-lesson-19-unparsing-and-the-format-and-color-attributes" ebook-toc-level-3 heading="Lesson 1.9: Unparsing and the format and color attributes"><div><h1 class="mume-header" id="lesson-19-unparsing-and-the-format-and-color-attributes">Lesson 1.9: Unparsing and the format and color attributes</h1>

<p>The purpose of this lesson is to teach the user about how terms are<br>
pretty-printed in K, and how the user can make adjustments to the default<br>
settings for how to print specific terms.</p>
<h2 class="mume-header" id="parsing-execution-and-unparsing">Parsing, Execution, and Unparsing</h2>

<p>When you use <code>krun</code> to interpret a program, the tool passes through three major<br>
phases. In the first, parsing, the program itself is parsed using either <code>kast</code><br>
or an ahead-of-time parser generated via Bison, and the resulting AST becomes<br>
the input to the interpreter. In the second phase, execution, K evaluates<br>
functions and (as we will discuss in depth later) performs rewrite steps to<br>
iteratively transform the program state. The third and final phase is called<br>
<strong>unparsing</strong>, because it consists of taking the final state of the application<br>
after the program has been interpreted, and converting it from an AST back into<br>
text that (in theory, anyway) could be parsed back into the same AST that was<br>
the output of the execution phase.</p>
<p>In practice, parsing is not always precisely reversible. It turns out<br>
(although we are not going to cover exactly why this is here), that<br>
constructing a sound algorithm that takes a grammar and an AST and emits text<br>
that could be parsed via that grammar to the original AST is an<br>
<strong>NP-hard problem</strong>. As a result, in the interests of avoiding exponential time<br>
algorithms when users rarely care about unparsing being completely sound, we<br>
take certain shortcuts that provide a linear-time algorithm that <em>approximates</em><br>
a sound solution to the problem while sacrificing the notion that the result<br>
can be parsed into the exact original term in all cases.</p>
<p>This is a lot of theoretical explanation, but at root, the unparsing process<br>
is fairly simple: it takes a K term that is the output of execution and pretty<br>
prints it according to the syntax defined by the user in their K definition.<br>
This is useful because the original AST is not terribly user-readable, and it<br>
is difficult to visualize the entire term or decipher information about the<br>
final state of the program at a quick glance. Of course, in rare cases, the<br>
pretty-printed configuration loses information of relevance, which is why K<br>
allows you to obtain the original AST on request.</p>
<p>As an example of all of this, consider the following K definition<br>
(<code>lesson-09-a.k</code>):</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">09</span><span class="token operator">-</span>A
  <span class="token keyword keyword-imports">imports</span> BOOL

  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span> <span class="token punctuation">[</span><span class="token class-name">bracket</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token keyword keyword-Bool">Bool</span>
               &gt; <span class="token string">&quot;!&quot;</span> Exp
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;&amp;&amp;&quot;</span> Exp
               <span class="token operator">|</span> Exp <span class="token string">&quot;^&quot;</span> Exp
               <span class="token operator">|</span> Exp <span class="token string">&quot;||&quot;</span> Exp

  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> id<span class="token punctuation">(</span>Exp<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> id<span class="token punctuation">(</span>E<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> E
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>This is similar to the grammar we defined in <code>LESSON-06-C</code>, with the difference<br>
that the Boolean expressions are now constructors of sort <code>Exp</code> and we define a<br>
trivial function over expressions that returns its argument unchanged.</p>
<p>We can now parse a simple program in this definition and use it to unparse some<br>
Boolean expressions. For example (<code>exp.bool</code>):</p>
<pre data-role="codeBlock" data-info class="language-"><code>id(true&amp;&amp;false&amp;&amp;!true^(false||true))
</code></pre><p>Here is a program that is not particularly legible at first glance, because all<br>
extraneous whitespace has been removed. However, if we run <code>krun exp.bool</code>, we<br>
see that the result of the unparser will pretty-print this expression rather<br>
nicely:</p>
<pre data-role="codeBlock" data-info class="language-"><code>&lt;k&gt;
  true &amp;&amp; false &amp;&amp; ! true ^ ( false || true ) ~&gt; .
&lt;/k&gt;
</code></pre><p>Notably, not only does K insert whitespace where appropriate, it is also smart<br>
enough to insert parentheses where necessary in order to ensure the correct<br>
parse. For example, without those parentheses, the expression above would parse<br>
equivalent to the following one:</p>
<pre data-role="codeBlock" data-info class="language-"><code>(((true &amp;&amp; false) &amp;&amp; ! true) ^ false) || true
</code></pre><p>Indeed, you can confirm this by passing that exact expression to the <code>id</code><br>
function and evaluating it, then looking at the result of the unparser:</p>
<pre data-role="codeBlock" data-info class="language-"><code>&lt;k&gt;
  true &amp;&amp; false &amp;&amp; ! true ^ false || true ~&gt; .
&lt;/k&gt;
</code></pre><p>Here, because the meaning of the AST is the same both with and without<br>
parentheses, K does not insert any parentheses when unparsing.</p>
<h3 class="mume-header" id="exercise">Exercise</h3>

<p>Modify the grammar of <code>LESSON-09-A</code> above so that the binary operators are<br>
right associative. Try unparsing <code>exp.bool</code> again, and note how the result is<br>
different. Explain the reason for the difference.</p>
<h2 class="mume-header" id="custom-unparsing-of-terms">Custom unparsing of terms</h2>

<p>You may have noticed that right now, the unparsing of terms is not terribly<br>
imaginative. All it is doing is taking each child of the term, inserting it<br>
into the non-terminal positions of the production, then printing the production<br>
with a space between each terminal or non-terminal. It is easy to see why this<br>
might not be desirable in some cases. Consider the following K definition<br>
(<code>lesson-09-b.k</code>):</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">09</span><span class="token operator">-</span>B
  <span class="token keyword keyword-imports">imports</span> BOOL

  <span class="token keyword keyword-syntax">syntax</span> Stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;{&quot;</span> Stmt <span class="token string">&quot;}&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;{&quot;</span> <span class="token string">&quot;}&quot;</span>
                &gt; <span class="token class-name">right</span><span class="token punctuation">:</span>
                  Stmt Stmt
                <span class="token operator">|</span> <span class="token string">&quot;if&quot;</span> <span class="token string">&quot;(&quot;</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token string">&quot;)&quot;</span> Stmt
                <span class="token operator">|</span> <span class="token string">&quot;if&quot;</span> <span class="token string">&quot;(&quot;</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token string">&quot;)&quot;</span> Stmt <span class="token string">&quot;else&quot;</span> Stmt <span class="token punctuation">[</span><span class="token class-name">avoid</span><span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>This is a statement grammar, simplified to the point of meaninglessness, but<br>
still useful as an object lesson in unparsing. Consider the following program<br>
in this grammar (<code>if.stmt</code>):</p>
<pre data-role="codeBlock" data-info class="language-"><code>if (true) {
  if (true) {}
  if (false) {}
  if (true) {
    if (false) {} else {}
  } else {
    if (false) {}
  }
}
</code></pre><p>This is how that term would be unparsed if it appeared in the output of krun:</p>
<pre data-role="codeBlock" data-info class="language-"><code>if ( true ) { if ( true ) { } if ( false ) { } if ( true ) { if ( false ) { } else { } } else { if ( false ) { } } }
</code></pre><p>This is clearly much less legible than we started with! What are we to do?<br>
Well, K provides an attribute, <code>format</code>, that can be applied to any production,<br>
which controls how that production gets unparsed. You&apos;ve seen how it gets<br>
unparsed by default, but via this attribute, the developer has complete control<br>
over how the term is printed. Of course, the user can trivially create ways to<br>
print terms that would not parse back into the same term. Sometimes this is<br>
even desirable. But in most cases, what you are interested in is controlling<br>
the line breaking, indentation, and spacing of the production.</p>
<p>Here is an example of how you might choose to apply the <code>format</code> attribute<br>
to improve how the above term is unparsed (<code>lesson-09-c.k</code>):</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">09</span><span class="token operator">-</span>C
  <span class="token keyword keyword-imports">imports</span> BOOL

  <span class="token keyword keyword-syntax">syntax</span> Stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;{&quot;</span> Stmt <span class="token string">&quot;}&quot;</span> <span class="token punctuation">[</span><span class="token class-name">format</span><span class="token punctuation">(</span><span class="token operator">%</span><span class="token number">1</span><span class="token operator">%</span>i<span class="token operator">%</span>n<span class="token operator">%</span><span class="token number">2</span><span class="token operator">%</span>d<span class="token operator">%</span>n<span class="token operator">%</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token string">&quot;{&quot;</span> <span class="token string">&quot;}&quot;</span> <span class="token punctuation">[</span><span class="token class-name">format</span><span class="token punctuation">(</span><span class="token operator">%</span><span class="token number">1</span><span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
                &gt; <span class="token class-name">right</span><span class="token punctuation">:</span>
                  Stmt Stmt <span class="token punctuation">[</span><span class="token class-name">format</span><span class="token punctuation">(</span><span class="token operator">%</span><span class="token number">1</span><span class="token operator">%</span>n<span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;if&quot;</span> <span class="token string">&quot;(&quot;</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token string">&quot;)&quot;</span> Stmt <span class="token punctuation">[</span><span class="token class-name">format</span><span class="token punctuation">(</span><span class="token operator">%</span><span class="token number">1</span> <span class="token operator">%</span><span class="token number">2</span><span class="token operator">%</span><span class="token number">3</span><span class="token operator">%</span><span class="token number">4</span> <span class="token operator">%</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;if&quot;</span> <span class="token string">&quot;(&quot;</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token string">&quot;)&quot;</span> Stmt <span class="token string">&quot;else&quot;</span> Stmt <span class="token punctuation">[</span><span class="token class-name">avoid</span><span class="token punctuation">,</span> <span class="token class-name">format</span><span class="token punctuation">(</span><span class="token operator">%</span><span class="token number">1</span> <span class="token operator">%</span><span class="token number">2</span><span class="token operator">%</span><span class="token number">3</span><span class="token operator">%</span><span class="token number">4</span> <span class="token operator">%</span><span class="token number">5</span> <span class="token operator">%</span><span class="token number">6</span> <span class="token operator">%</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>If we compile this new definition and unparse the same term, this is the<br>
result we get:</p>
<pre data-role="codeBlock" data-info class="language-"><code>if (true) {
  if (true) {}
  if (false) {}
  if (true) {
    if (false) {} else {}
  } else {
    if (false) {}
  }
}
</code></pre><p>This is the exact same text we started with! By adding the <code>format</code> attributes,<br>
we were able to indent the body of code blocks, adjust the spacing of if<br>
statements, and put each statement on a new line.</p>
<p>How exactly was this achieved? Well, each time the unparser reaches a term,<br>
it looks at the <code>format</code> attribute of that term. That <code>format</code> attribute is a<br>
mix of characters and <strong>format codes</strong>. Format codes begin with the <code>%</code><br>
character. Each character in the <code>format</code> attribute other than a format code is<br>
appended verbatim to the output, and each format code is handled according to<br>
its meaning, transformed (possibly recursively) into a string of text, and<br>
spliced into the output at the position the format code appears in the format<br>
string.</p>
<p>Provided for reference is a table with a complete list of all valid format<br>
codes, followed by their meaning:</p>
<table>
<tbody><tr><th> Format&#xA0;Code </th><th> Meaning                                          </th></tr>
<tr><td> n           </td><td> Insert &apos;\n&apos; followed by the current indentation
                               level                                            </td></tr>
<tr><td> i           </td><td> Increase the current indentation level by 1      </td></tr>
<tr><td> d           </td><td> Decrease the current indentation level by 1      </td></tr>
<tr><td> c           </td><td> Move to the next color in the list of colors for
                               this production (see next section)               </td></tr>
<tr><td> r           </td><td> Reset color to the default foreground color for
                               the terminal (see next section)                  </td></tr>
<tr><td> an&#xA0;integer  </td><td> Print a terminal or non-terminal from the
                               production. The integer is treated as a 1-based
                               index into the terminals and non-terminals of
                               the production.
<br>
<br>                          If the offset refers to a terminal, move to the
                               next color in the list of colors for this
                               production, print the value of that terminal,
                               then reset the color to the default foreground
                               color for the terminal.
<br>
<br>                          If the offset refers to a regular expression
                               terminal, it is an error.
<br>
<br>                          If the offset refers to a non-terminal, unparse
                               the corresponding child of the current term
                               (starting with the current indentation level)
                               and print the resulting text, then set the
                               current color and indentation level to the color
                               and indentation level following unparsing that
                               term.                                            </td></tr>
<tr><td> other&#xA0;char  </td><td> Print that character verbatim                    </td></tr>
</tbody></table>
<h3 class="mume-header" id="exercise-1">Exercise</h3>

<p>Change the format attributes for <code>LESSON-09-C</code> so that <code>if.stmt</code> will unparse<br>
as follows:</p>
<pre data-role="codeBlock" data-info class="language-"><code>if (true)
{
  if (true)
  {
  }
  if (false)
  {
  }
  if (true)
  {
    if (false)
    {
    }
    else
    {
    }
  }
  else
  {
    if (false)
    {
    }
  }
}
</code></pre><h2 class="mume-header" id="output-coloring">Output coloring</h2>

<p>When the output of unparsing is displayed on a terminal supporting colors, K<br>
is capable of coloring the output, similar to what is possible with a syntax<br>
highlighter. This is achieved via the <code>color</code> and <code>colors</code> attributes.</p>
<p>Essentially, both the <code>color</code> and <code>colors</code> attributes are used to construct a<br>
list of colors associated with each production, and then the format attribute<br>
is used to control how those colors are used to unparse the term. At its most<br>
basic level, you can set the <code>color</code> attribute to color all the terminals in<br>
the production a certain color, or you can use the <code>colors</code> attribute to<br>
specify a comma-separated list of colors for each terminal in the production.<br>
At a more advanced level, the <code>%c</code> and <code>%r</code> format codes control how the<br>
formatter interacts with the list of colors specified by the <code>colors</code><br>
attribute. You can essentially think of the <code>color</code> attribute as a way of<br>
specifying that you want all the colors in the list to be the same color.</p>
<p>Note that the <code>%c</code> and <code>%r</code> format codes are relatively primitive in nature.<br>
The <code>color</code> and <code>colors</code> attributes merely maintain a list of colors, whereas<br>
the <code>%c</code> and <code>%r</code> format codes merely control how to advance through that list<br>
and how individual text is colored.</p>
<p>It is an error if the <code>colors</code> attribute does not provide all the colors needed<br>
by the terminals and escape codes in the production. <code>%r</code> does not change the<br>
position in the list of colors at all, so the next <code>%c</code> will advance to the<br>
following color.</p>
<p>As a complete example, here is a variant of LESSON-09-A which colors the<br>
various boolean operators:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">09</span><span class="token operator">-</span>D
  <span class="token keyword keyword-imports">imports</span> BOOL

  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span> <span class="token punctuation">[</span><span class="token class-name">bracket</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token keyword keyword-Bool">Bool</span>
               &gt; <span class="token string">&quot;!&quot;</span> Exp <span class="token punctuation">[</span>color<span class="token punctuation">(</span>yellow<span class="token punctuation">)</span><span class="token punctuation">]</span>
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;&amp;&amp;&quot;</span> Exp <span class="token punctuation">[</span>color<span class="token punctuation">(</span>red<span class="token punctuation">)</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;^&quot;</span> Exp <span class="token punctuation">[</span>color<span class="token punctuation">(</span>blue<span class="token punctuation">)</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;||&quot;</span> Exp <span class="token punctuation">[</span>color<span class="token punctuation">(</span>green<span class="token punctuation">)</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> id<span class="token punctuation">(</span>Exp<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> id<span class="token punctuation">(</span>E<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> E
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>For a complete list of allowed colors, see<br>
<a href="https://github.com/kframework/llvm-backend/blob/master/lib/ast/AST.cpp#L440">here</a>.</p>
<h2 class="mume-header" id="exercises">Exercises</h2>

<ol>
<li>
<p>Use the color attribute on <code>LESSON-09-C</code> to color the keywords <code>true</code> and<br>
<code>false</code> one color, the keywords <code>if</code> and <code>else</code> another color, and the operators<br>
<code>(</code>, <code>)</code>, <code>{</code>, and <code>}</code> a third color.</p>
</li>
<li>
<p>Use the <code>format</code>, <code>color</code>, and <code>colors</code> attributes to tell the unparser to<br>
style the expression grammar from Lesson 1.8, Exercise 3 according to your own<br>
personal preferences for syntax highlighting and code formatting. You can<br>
view the result of the unparser on a function term without evaluating that<br>
function by means of the command <code>kparse &lt;file&gt; | kore-print -</code>.</p>
</li>
</ol>
<h2 class="mume-header" id="next-lesson">Next lesson</h2>

<p>Once you have completed the above exercises, you can continue to<br>
<a href="#ebook-heading-lesson-110-strings">Lesson 1.10: Strings</a>.</p>
</div></div><div id="ebook-heading-lesson-110-strings" ebook-toc-level-3 heading="Lesson 1.10: Strings"><div><h1 class="mume-header" id="lesson-110-strings">Lesson 1.10: Strings</h1>

<p>The purpose of this lesson is to explain how to use the <code>String</code> sort in K to<br>
represent <strong>sequences of characters</strong>, and explain where to find additional<br>
information about builtin functions over strings.</p>
<h2 class="mume-header" id="the-string-sort">The <code>String</code> Sort</h2>

<p>In addition to the <code>Int</code> and <code>Bool</code> sorts covered in<br>
<a href="#ebook-heading-lesson-16-integers-and-booleans">Lesson 1.6</a>, K provides, among others, the<br>
<code>String</code> sort to represent sequences of characters. You can import this<br>
functionality via the <code>STRING-SYNTAX</code> module, which contains the syntax of<br>
string literals in K, and the <code>STRING</code> module, which contains all the functions<br>
that operate over the <code>String</code> type.</p>
<p>Strings in K are double-quoted. The following list of escape sequences is<br>
supported:</p>
<table>
<thead>
<tr>
<th>Escape Sequence</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\&quot;</code></td>
<td>The literal character &quot;</td>
</tr>
<tr>
<td><code>\\</code></td>
<td>The literal character \</td>
</tr>
<tr>
<td><code>\n</code></td>
<td>The newline character (ASCII code 0x0a)</td>
</tr>
<tr>
<td><code>\r</code></td>
<td>The carriage return character (ASCII code 0x0d)</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>The tab character (ASCII code 0x09)</td>
</tr>
<tr>
<td><code>\f</code></td>
<td>The form feed character (ASCII code 0x0c)</td>
</tr>
<tr>
<td><code>\x00</code></td>
<td>\x followed by 2 hexadecimal digits indicates a code point between 0x00 and 0xFF</td>
</tr>
<tr>
<td><code>\u0000</code></td>
<td>\u followed by 4 hexadecimal digits indicates a code point between 0x0000 and 0xFFFF</td>
</tr>
<tr>
<td><code>\U00000000</code></td>
<td>\U followed by 8 hexadecimal digits indicates a code point between 0x000000 and 0x10FFFF</td>
</tr>
</tbody>
</table>
<p>Please note that as of the current moment, K&apos;s unicode support is not fully<br>
complete, so you may run into errors using code points greater than 0xff.</p>
<p>As an example, you can construct a string literal containing the following<br>
block of text:</p>
<pre data-role="codeBlock" data-info class="language-"><code>This is an example block of text.
Here is a quotation: &quot;Hello world.&quot;
	This line is indented.
&#xC1;&#xC9;&#xCD;&#xD3;&#xDA;
</code></pre><p>Like so:</p>
<pre data-role="codeBlock" data-info class="language-"><code>&quot;This is an example block of text.\nHere is a quotation: \&quot;Hello world.\&quot;\n\tThis line is indented.\n\xc1\xc9\xcd\xd3\xda\n&quot;
</code></pre><h2 class="mume-header" id="basic-string-functions">Basic String Functions</h2>

<p>The full list of functions provided for the <code>String</code> sort can be found in<br>
<a href="#ebook-heading-domains">domains.md</a>, but here we<br>
describe a few of the more basic ones.</p>
<h3 class="mume-header" id="string-concatenation">String concatenation</h3>

<p>The concatenation operator for strings is <code>+String</code>. For example, consider<br>
the following K rule that constructs a string from component parts<br>
(<code>lesson-10.k</code>):</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">10</span>
  <span class="token keyword keyword-imports">imports</span> STRING

  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> msg<span class="token punctuation">(</span><span class="token keyword keyword-String">String</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> msg<span class="token punctuation">(</span>S<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token string">&quot;The string you provided: &quot;</span> <span class="token operator">+</span><span class="token keyword keyword-String">String</span> S <span class="token operator">+</span><span class="token keyword keyword-String">String</span> <span class="token string">&quot;\nHave a nice day!&quot;</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>Note that this operator is <code>O(N)</code>, so repeated concatenations are inefficient.<br>
For information about efficient string concatenation, refer to<br>
<a href="file:///home/runner/work/k/k/gh-pages/k-distribution/k-tutorial/2_intermediate/14_string_buffers_and_bytes/README.md">Lesson 2.14</a>.</p>
<h3 class="mume-header" id="string-length">String length</h3>

<p>The function to return the length of a string is <code>lengthString</code>. For example,<br>
<code>lengthString(&quot;foo&quot;)</code> will return 3, and <code>lengthString(&quot;&quot;)</code> will return 0.<br>
The return value is the length of the string in <strong>code points</strong>.</p>
<h3 class="mume-header" id="substring-computation">Substring computation</h3>

<p>The function to compute the substring of a string is <code>substrString</code>. It<br>
takes two string indices, starting from 0, and returns the substring within the<br>
range [start..end). It is only defined if <code>end &gt;= start</code>, <code>start &gt;= 0</code>, and<br>
<code>end &lt;= length of string</code>. Here, for example, we return the first 5 characters<br>
of a string:</p>
<pre data-role="codeBlock" data-info class="language-"><code>substrString(S, 0, 5)
</code></pre><p>Here we return all but the first 3 characters:</p>
<pre data-role="codeBlock" data-info class="language-"><code>substrString(S, 3, lengthString(S))
</code></pre><h2 class="mume-header" id="exercises">Exercises</h2>

<ol>
<li>Write a function that takes a paragraph of text (i.e., a sequence of<br>
sentences, each ending in a period), and constructs a new (nonsense) sentence<br>
composed of the first word of each sentence, followed by a period. Do not<br>
worry about capitalization or periods within the sentence which do not end the<br>
sentence (e.g. &quot;Dr.&quot;). You can assume that all whitespace within the paragraph<br>
are spaces. For more information about the functions over strings required to<br>
implement such a function, refer to <code>domains.md</code>.</li>
</ol>
<h2 class="mume-header" id="next-lesson">Next lesson</h2>

<p>Once you have completed the above exercises, you can continue to<br>
<a href="#ebook-heading-lesson-111-casting-terms">Lesson 1.11: Casting Terms</a>.</p>
</div></div><div id="ebook-heading-lesson-111-casting-terms" ebook-toc-level-3 heading="Lesson 1.11: Casting Terms"><div><h1 class="mume-header" id="lesson-111-casting-terms">Lesson 1.11: Casting Terms</h1>

<p>The purpose of this lesson is to explain how to use <strong>cast</strong> expressions in<br>
order to disambiguate terms using sort information. We also explain how the<br>
variable sort inference algorithm works in K, and how to change the default<br>
behavior by casting variables to a particular sort.</p>
<h2 class="mume-header" id="casting-in-k">Casting in K</h2>

<p>Sometimes the grammar you write for your rules in K can be a little bit<br>
ambiguous on purpose. While grammars for programming languages may be<br>
unambiguous when considered in their entirety, K allows you to write rules<br>
involving arbitrary <strong>fragments</strong> of that grammar, and those fragments can<br>
sometimes be ambiguous by themselves, or similar enough to other fragments<br>
of the grammar to trigger ambiguity. As a result, in addition to the tools<br>
covered in <a href="#ebook-heading-lesson-14-disambiguating-parses">Lesson 1.4</a>, K provides one<br>
additional powerful tool for disambiguation: cast expressions.</p>
<p>K provides three main types of casts: the semantic cast, the strict cast, and<br>
the projection cast. We will cover each of them, and their similarities and<br>
differences, in turn.</p>
<h3 class="mume-header" id="semantic-casts">Semantic casts</h3>

<p>The most basic, and most common, type of cast in K is called the<br>
<strong>semantic cast</strong>. For every sort <code>S</code> declared in a module, K provides the<br>
following (implicit) production for use in sentences:</p>
<pre data-role="codeBlock" data-info class="language-"><code>  syntax S ::= S &quot;:S&quot;
</code></pre><p>Note that <code>S</code> simply represents the name of the sort. For example, if we<br>
defined a sort <code>Exp</code>, the actual production for that sort would be:</p>
<pre data-role="codeBlock" data-info class="language-"><code>  syntax Exp ::= Exp &quot;:Exp&quot;
</code></pre><p>At runtime, this expression will not actually exist; it is merely an annotation<br>
to the compiler describing the sort of the term inside the cast. It is telling<br>
the compiler that the term inside the cast must be of sort <code>Exp</code>. For example,<br>
if we had the following grammar:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">11</span><span class="token operator">-</span>A
  <span class="token keyword keyword-imports">imports</span> INT

  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span> <span class="token operator">|</span> Exp <span class="token string">&quot;+&quot;</span> Exp
  <span class="token keyword keyword-syntax">syntax</span> Stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;if&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Stmt <span class="token operator">|</span> <span class="token string">&quot;{&quot;</span> <span class="token string">&quot;}&quot;</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>Then we would be able to write <code>1:Exp</code>, or <code>(1 + 2):Exp</code>, but not <code>{}:Exp</code>.</p>
<p>You can also restrict the sort that a variable in a rule will match by casting<br>
it. For example, consider the following additional module:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">11</span><span class="token operator">-</span>B
  <span class="token keyword keyword-imports">imports</span> LESSON<span class="token operator">-</span><span class="token number">11</span><span class="token operator">-</span>A
  <span class="token keyword keyword-imports">imports</span> BOOL

  <span class="token keyword keyword-syntax">syntax</span> Term <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Exp <span class="token operator">|</span> Stmt
  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> isExpression<span class="token punctuation">(</span>Term<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> isExpression<span class="token punctuation">(</span>_E<span class="token punctuation">:</span>Exp<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
  <span class="token keyword keyword-rule">rule</span> isExpression<span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">false</span> <span class="token punctuation">[</span>owise<span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>Here we have defined a very simple function that decides whether a term is<br>
an expression or a statement. It does this by casting the variable inside the<br>
<code>isExpression</code> rule to sort <code>Exp</code>. As a result, that variable will only match terms<br>
of sort <code>Exp</code>. Thus, <code>isExpression(1)</code> will return true, as will <code>isExpression(1 + 2)</code>, but<br>
<code>isExpression({})</code> will return false.</p>
<h4 class="mume-header" id="exercise">Exercise</h4>

<p>Verify this fact for yourself by running <code>isExpression</code> on the above examples. Then<br>
write an <code>isStatement</code> function, and test that it works as expected.</p>
<h3 class="mume-header" id="strict-casts">Strict casts</h3>

<p>On occasion, a semantic cast is not strict enough. It might be that you want<br>
to, for disambiguation purposes, say <strong>exactly</strong> what sort a term is. For<br>
example, consider the following definition:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">11</span><span class="token operator">-</span>C
  <span class="token keyword keyword-imports">imports</span> INT

  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span>
               <span class="token operator">|</span> <span class="token string">&quot;add[&quot;</span> Exp <span class="token string">&quot;,&quot;</span> Exp <span class="token string">&quot;]&quot;</span>   <span class="token punctuation">[</span>group<span class="token punctuation">(</span>exp<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Exp2 <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Exp
               <span class="token operator">|</span> <span class="token string">&quot;add[&quot;</span> Exp2 <span class="token string">&quot;,&quot;</span> Exp2 <span class="token string">&quot;]&quot;</span> <span class="token punctuation">[</span>group<span class="token punctuation">(</span>exp2<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>This grammar is a little ambiguous and contrived, but it serves to demonstrate<br>
how a semantic cast might be insufficient to disambiguate a term. If we were<br>
to write the term <code>add[ I1:Int , I2:Int ]:Exp2</code>, the term would be ambiguous,<br>
because the cast is not sufficiently strict to determine whether you mean<br>
to derive the &quot;add&quot; production defined in group <code>exp</code> or the one in group <code>exp2</code>.</p>
<p>In this situation, there is a solution: the <strong>strict cast</strong>. For every sort<br>
<code>S</code> in your grammar, K also defines the following production:</p>
<pre data-role="codeBlock" data-info class="language-"><code>  syntax S ::= S &quot;::S&quot;
</code></pre><p>This may at first glance seem the same as the previous cast. And indeed,<br>
from the perspective of the grammar and from the perspective of rewriting,<br>
they are in fact identical. However, the second variant has a unique meaning<br>
in the <strong>type system</strong> of K: namely, the term inside the cast cannot be a<br>
<strong>subsort</strong>, i.e., a term of another sort <code>S2</code> such that the production<br>
<code>syntax S ::= S2</code> exists.</p>
<p>As a result, if we were to write in the above grammar the term<br>
<code>add[ I1:Int , I2:Int ]::Exp2</code>, then we would know that the second derivation above<br>
should be chosen, whereas if we want the first derivation, we could write<br>
<code>add[ I1:Int , I2:Int ]::Exp</code>.</p>
<p>Care must be taken when using a strict cast with brackets. For example, consider a<br>
similar grammar but using an infix &quot;+&quot;:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">11</span><span class="token operator">-</span>D
  <span class="token keyword keyword-imports">imports</span> INT

  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;+&quot;</span> Exp   <span class="token punctuation">[</span>group<span class="token punctuation">(</span>exp<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Exp2 <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Exp
               <span class="token operator">|</span> Exp2 <span class="token string">&quot;+&quot;</span> Exp2 <span class="token punctuation">[</span>group<span class="token punctuation">(</span>exp2<span class="token punctuation">)</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;(&quot;</span> Exp2 <span class="token string">&quot;)&quot;</span>  <span class="token punctuation">[</span><span class="token class-name">bracket</span><span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>The term <code>I1:Int + I2:Int</code> is ambiguous and could refer to either the production<br>
in group <code>exp</code> or the one in group <code>exp2</code>. To differentiate, you might try to write<br>
<code>(I1:Int + I2:Int)::Exp2</code> similarly to the previous example.</p>
<p>Unfortunately though, this is still ambiguous. Here, the strict cast <code>::Exp2</code> applies<br>
directly to the brackets themselves rather than the underlying term within those brackets.<br>
As a result, it enforces that <code>(I1:Int + I2:Int)</code> cannot be a strict subsort of <code>Exp2</code>, but<br>
it has no effect on the sort of the subterm <code>I1:Int + I2:Int</code>.</p>
<p>For cases like this, K provides an alternative syntax for strict casts:</p>
<pre data-role="codeBlock" data-info class="language-"><code>  syntax S ::= &quot;{&quot; S &quot;}::S&quot;
</code></pre><p>The ambiguity can then be resolved with <code>{I1:Int + I2:Int}::Exp</code> or <code>{I1:Int + I2:Int}::Exp2</code>.</p>
<h3 class="mume-header" id="projection-casts">Projection casts</h3>

<p>Thus far we have focused entirely on casts which exist solely to inform the<br>
compiler about the sort of terms. However, sometimes when dealing with grammars<br>
containing subsorts, it can be desirable to reason with the subsort production<br>
itself, which <strong>injects</strong> one sort into another. Remember from above that such<br>
a production looks like <code>syntax S ::= S2</code>. This type of production, called a<br>
<strong>subsort production</strong>, can be thought of as a type of inheritance involving<br>
constructors. If we have the above production in our grammar, we say that <code>S2</code><br>
is a subsort of <code>S</code>, or that any <code>S2</code> is also an <code>S</code>. K implicitly maintains a<br>
symbol at runtime which keeps track of where such subsortings occur; this<br>
symbol is called an <strong>injection</strong>.</p>
<p>Sometimes, when one sort is a subsort of another, it can be the case that<br>
a function returns one sort, but you actually want to cast the result of<br>
calling that function to another sort which is a subsort of the first sort.<br>
This is similar to what happens with inheritance in an object-oriented<br>
language, where you might cast a superclass to a subclass if you know for<br>
sure the object at runtime is in fact an instance of that class.</p>
<p>K provides something similar for subsorts: the <strong>projection cast</strong>.</p>
<p>For each pair of sorts <code>S</code> and <code>S2</code>, K provides the following production:</p>
<pre data-role="codeBlock" data-info class="language-"><code>  syntax S ::= &quot;{&quot; S2 &quot;}&quot; &quot;:&gt;S&quot;
</code></pre><p>What this means is that you take any term of sort <code>S2</code> and <strong>cast</strong> it to sort<br>
<code>S</code>. If the term of sort S2 consists of an injection containing a term of sort<br>
<code>S</code>, then this will return that term. Otherwise, an error occurs and rewriting<br>
fails, returning the projection function which failed to apply. The sort is<br>
not actually checked at compilation time; rather, it is a runtime check<br>
inserted into the code that runs when the rule applies.</p>
<p>For example, here is a module that makes use of projection casts:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">11</span><span class="token operator">-</span>E
  <span class="token keyword keyword-imports">imports</span> INT
  <span class="token keyword keyword-imports">imports</span> BOOL

  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span> <span class="token operator">|</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token operator">|</span> Exp <span class="token string">&quot;+&quot;</span> Exp <span class="token operator">|</span> Exp <span class="token string">&quot;&amp;&amp;&quot;</span> Exp

  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> eval<span class="token punctuation">(</span>Exp<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> eval<span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> I
  <span class="token keyword keyword-rule">rule</span> eval<span class="token punctuation">(</span>B<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> B
  <span class="token keyword keyword-rule">rule</span> eval<span class="token punctuation">(</span>E1 <span class="token operator">+</span> E2<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>eval<span class="token punctuation">(</span>E1<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">:</span>&gt;<span class="token keyword keyword-Int">Int</span> <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">{</span>eval<span class="token punctuation">(</span>E2<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">:</span>&gt;<span class="token keyword keyword-Int">Int</span>
  <span class="token keyword keyword-rule">rule</span> eval<span class="token punctuation">(</span>E1 <span class="token operator">&amp;&amp;</span> E2<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>eval<span class="token punctuation">(</span>E1<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">:</span>&gt;<span class="token keyword keyword-Bool">Bool</span> andBool <span class="token punctuation">{</span>eval<span class="token punctuation">(</span>E2<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">:</span>&gt;<span class="token keyword keyword-Bool">Bool</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>Here we have defined constructors for a simple expression language over<br>
Booleans and integers, as well as a function <code>eval</code> that evaluates these<br>
expressions to a value. Because that value could be an integer or a Boolean,<br>
we need the casts in the last two rules in order to meet the type signature of<br>
<code>+Int</code> and <code>andBool</code>. Of course, the user can write ill-formed expressions like<br>
<code>1 &amp;&amp; true</code> or <code>false + true</code>, but these will cause errors at runtime, because<br>
the projection cast will fail.</p>
<h2 class="mume-header" id="exercises">Exercises</h2>

<ol>
<li>
<p>Extend the <code>eval</code> function in <code>LESSON-11-E</code> to include Strings and add a <code>.</code><br>
operator which concatenates them.</p>
</li>
<li>
<p>Modify your solution from Lesson 1.9, Exercise 2 by using an <code>Exp</code> sort to<br>
express the integer and Boolean expressions that it supports, in the same style<br>
as <code>LESSON-11-E</code>. Then write an <code>eval</code> function that evaluates all terms of<br>
sort <code>Exp</code> to either a <code>Bool</code> or an <code>Int</code>.</p>
</li>
</ol>
<h2 class="mume-header" id="next-lesson">Next lesson</h2>

<p>Once you have completed the above exercises, you can continue to<br>
<a href="#ebook-heading-lesson-112-syntactic-lists">Lesson 1.12: Syntactic Lists</a>.</p>
</div></div><div id="ebook-heading-lesson-112-syntactic-lists" ebook-toc-level-3 heading="Lesson 1.12: Syntactic Lists"><div><h1 class="mume-header" id="lesson-112-syntactic-lists">Lesson 1.12: Syntactic Lists</h1>

<p>The purpose of this lesson is to explain how K provides support for syntactic<br>
repetition through the use of the <code>List{}</code> and <code>NeList{}</code> constructs,<br>
generally called <strong>syntactic lists</strong>.</p>
<h2 class="mume-header" id="the-list-construct">The <code>List{}</code> construct</h2>

<p>Sometimes, when defining a grammar in K, it is useful to define a syntactic<br>
construct consisting of an arbitrary-length sequence of items. For example,<br>
you might wish to define a function call construct, and need to express a way<br>
of passing arguments to the function. You can in theory simply define these<br>
productions using ordinary constructors, but it can be tricky to get the syntax<br>
exactly right in K without a lot of tedious glue code.</p>
<p>For this reason, K provides a way of specifying that a non-terminal represents<br>
a syntactic list (<code>lesson-12-a.k</code>):</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span>A<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> INT<span class="token operator">-</span>SYNTAX

  <span class="token keyword keyword-syntax">syntax</span> Ints <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span>A
  <span class="token keyword keyword-imports">imports</span> LESSON<span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span>A<span class="token operator">-</span>SYNTAX
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>Note that instead of a sequence of terminals and non-terminals, the right hand<br>
side of the <code>Ints</code> production contains the symbol <code>List</code> followed by two items<br>
in curly braces. The first item is the non-terminal which is the element type<br>
of the list, and the second item is a terminal representing the separator of<br>
the list. As a special case, lists which are separated only by whitespace can<br>
be specified with a separator of <code>&quot;&quot;</code>.</p>
<p>This <code>List{}</code> construct is roughly equivalent to the following definition<br>
(<code>lesson-12-b.k</code>):</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span>B<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> INT<span class="token operator">-</span>SYNTAX

  <span class="token keyword keyword-syntax">syntax</span> Ints <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;,&quot;</span> Ints <span class="token operator">|</span> <span class="token string">&quot;.Ints&quot;</span>
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span>B
  <span class="token keyword keyword-imports">imports</span> LESSON<span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span>B<span class="token operator">-</span>SYNTAX
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>As you can see, the <code>List{}</code> construct represents a cons-list with an element<br>
at the head and another list at the tail. The empty list is represented by<br>
a <code>.</code> followed by the sort of the list.</p>
<p>However, the <code>List{}</code> construct provides several key syntactic conveniences<br>
over the above definition. First of all, when writing a list in a rule,<br>
explicitly writing the terminator is not always required. For example, consider<br>
the following additional module (<code>lesson-12-c.k</code>):</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span>C
  <span class="token keyword keyword-imports">imports</span> LESSON<span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span>A
  <span class="token keyword keyword-imports">imports</span> INT

  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> sum<span class="token punctuation">(</span>Ints<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> sum<span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> I
  <span class="token keyword keyword-rule">rule</span> sum<span class="token punctuation">(</span>I1<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> I2<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> Is<span class="token punctuation">:</span>Ints<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> sum<span class="token punctuation">(</span>I1 <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> I2<span class="token punctuation">,</span> Is<span class="token punctuation">)</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>Here we see a function that sums together a non-empty list of integers. Note in<br>
particular the first rule. We do not explicitly mention <code>.Ints</code>, but in fact,<br>
the rule in question is equivalent to the following rule:</p>
<pre data-role="codeBlock" data-info class="language-"><code>  rule sum(I:Int, .Ints) =&gt; I
</code></pre><p>The reason for this is that K will automatically insert a list terminator<br>
anywhere a syntactic list is expected, but an element of that list appears<br>
instead. This works even with lists of more than one element:</p>
<pre data-role="codeBlock" data-info class="language-"><code>  rule sum(I1:Int, I2:Int) =&gt; I1 +Int I2
</code></pre><p>This rule is redundant, but here we explicitly match a list of exactly two<br>
elements, because the <code>.Ints</code> is implicitly added after <code>I2</code>.</p>
<h2 class="mume-header" id="parsing-syntactic-lists-in-programs">Parsing Syntactic Lists in Programs</h2>

<p>An additional syntactic convenience takes place when you want to express a<br>
syntactic list in the input to <code>krun</code>. In this case, K will automatically<br>
transform the grammar in <code>LESSON-12-B-SYNTAX</code> into the following<br>
(<code>lesson-12-d.k</code>):</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span>D
  <span class="token keyword keyword-imports">imports</span> INT<span class="token operator">-</span>SYNTAX

  <span class="token keyword keyword-syntax">syntax</span> Ints <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> #NonEmptyInts <span class="token operator">|</span> #IntsTerminator
  <span class="token keyword keyword-syntax">syntax</span> #NonEmptyInts <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;,&quot;</span> #NonEmptyInts
                         <span class="token operator">|</span> <span class="token keyword keyword-Int">Int</span> #IntsTerminator
  <span class="token keyword keyword-syntax">syntax</span> #IntsTerminator <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;&quot;</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>This allows you to express the usual comma-separated list of arguments where<br>
an empty list is represented by the empty string, and you don&apos;t have to<br>
explicitly terminate the list. Because of this, we can write the syntax<br>
of function calls in C very easily (<code>lesson-12-e.k</code>):</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span>E
  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Id">Id</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> r<span class="token string">&quot;[a-zA-Z_][a-zA-Z0-9_]*&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Id">Id</span> <span class="token operator">|</span> Exp <span class="token string">&quot;(&quot;</span> Exps <span class="token string">&quot;)&quot;</span>
  <span class="token keyword keyword-syntax">syntax</span> Exps <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Exp<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><h3 class="mume-header" id="exercise">Exercise</h3>

<p>Write a function <code>concat</code> which takes a list of <code>String</code> and concatenates them<br>
all together. Do not worry if the function is O(n^2).<br>
Test your implementation using the syntactic sugar for lists added by the parser.</p>
<p>Then write some function call expressions using identifiers in C and verify with<br>
<code>kast</code> that the above grammar captures the intended syntax. Make sure to test<br>
with function calls with zero, one, and two or more arguments.</p>
<h2 class="mume-header" id="the-nelist-construct">The <code>NeList{}</code> construct</h2>

<p>One limitation of the <code>List{}</code> construct is that it is always possible to<br>
write a list of zero elements where a <code>List{}</code> is expected. While this is<br>
desirable in a number of cases, it is sometimes not what the grammar expects.</p>
<p>For example, in C, it is not allowable for an <code>enum</code> definition to have zero<br>
members. In other words, if we were to write the grammar for enumerations like<br>
so (<code>lesson-12-f.k</code>):</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span>F
  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Id">Id</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> r<span class="token string">&quot;[a-zA-Z_][a-zA-Z0-9_]*&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Id">Id</span>

  <span class="token keyword keyword-syntax">syntax</span> EnumSpecifier <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;enum&quot;</span> <span class="token keyword keyword-Id">Id</span> <span class="token string">&quot;{&quot;</span> Ids <span class="token string">&quot;}&quot;</span>
  <span class="token keyword keyword-syntax">syntax</span> Ids <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>Then we would be syntactically allowed to write <code>enum X {}</code>, which instead,<br>
ought to be a syntax error.</p>
<p>For this reason, we introduce the additional <code>NeList{}</code> construct. The syntax<br>
is identical to <code>List{}</code>, except with <code>NeList</code> instead of <code>List</code> before the<br>
curly braces. When parsing rules, it behaves identically to the <code>List{}</code><br>
construct. However, when parsing inputs to <code>krun</code>, the above grammar, if we<br>
replaced <code>syntax Ids ::= List{Id,&quot;,&quot;}</code> with <code>syntax Ids ::= NeList{Id,&quot;,&quot;}</code>,<br>
would become equivalent to the following (<code>lesson-12-g.k</code>):</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span>G
  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Id">Id</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> r<span class="token string">&quot;[a-zA-Z_][a-zA-Z0-9_]*&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Id">Id</span>

  <span class="token keyword keyword-syntax">syntax</span> EnumSpecifier <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;enum&quot;</span> <span class="token keyword keyword-Id">Id</span> <span class="token string">&quot;{&quot;</span> Ids <span class="token string">&quot;}&quot;</span>
  <span class="token keyword keyword-syntax">syntax</span> Ids <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Id">Id</span> <span class="token operator">|</span> <span class="token keyword keyword-Id">Id</span> <span class="token string">&quot;,&quot;</span> Ids
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>In other words, only non-empty lists of <code>Id</code> would be allowed.</p>
<h2 class="mume-header" id="exercises">Exercises</h2>

<ol>
<li>
<p>Modify the <code>sum</code> function in <code>LESSON-12-C</code> so that the <code>Ints</code> sort is an<br>
<code>NeList{}</code>. Verify that calling <code>sum()</code> with no arguments is now a syntax<br>
error.</p>
</li>
<li>
<p>Write a modified <code>sum</code> function with the <code>List</code> construct that can also sum<br>
up an empty list of arguments. In such a case, the sum ought to be 0.</p>
</li>
</ol>
<h2 class="mume-header" id="next-lesson">Next lesson</h2>

<p>Once you have completed the above exercises, you can continue to<br>
<a href="#ebook-heading-lesson-113-basics-of-k-rewriting">Lesson 1.13: Basics of K Rewriting</a>.</p>
</div></div><div id="ebook-heading-lesson-113-basics-of-k-rewriting" ebook-toc-level-3 heading="Lesson 1.13: Basics of K Rewriting"><div><h1 class="mume-header" id="lesson-113-basics-of-k-rewriting">Lesson 1.13: Basics of K Rewriting</h1>

<p>The purpose of this lesson is to explain how rewrite rules that are not the<br>
definition of a function behave, and how, using these rules, you can construct<br>
a semantics of programs in a programming language in K.</p>
<h2 class="mume-header" id="recap-function-rules-in-k">Recap: Function rules in K</h2>

<p>Recall from <a href="#ebook-heading-lesson-12-basics-of-functional-k">Lesson 1.2</a> that we have, thus far,<br>
introduced two types of productions in K: <strong>constructors</strong> and <strong>functions</strong>.<br>
A function is identified by the <strong>function</strong> attribute placed on the<br>
production. As you may recall, when we write a rule with a function on the<br>
left-hand side of the <code>=&gt;</code> operator, we are defining the meaning of that<br>
function for inputs which match the patterns on the left-hand side of the rule.<br>
If the argument to the function match the patterns, then the function is<br>
evaluated to the value constructed by substituting the bindings for the<br>
variables into the right-hand side of the rule.</p>
<h2 class="mume-header" id="top-level-rules">Top-level rules</h2>

<p>However, function rules are not the only type of rule permissible in K, nor<br>
even the most frequently used. K also has a concept of a<br>
<strong>top-level rewrite rule</strong>. The simplest way to ensure that a rule is treated<br>
as a top-level rule is for the left-hand side of the rule to mention one or<br>
more <strong>cells</strong>. We will cover how cells work and are declared in more detail<br>
in a later lesson, but for now, what you should know is that when we ran <code>krun</code><br>
in our very first example in Lesson 1.2 and got the following output:</p>
<pre data-role="codeBlock" data-info class="language-"><code>&lt;k&gt;
  Yellow ( ) ~&gt; .
&lt;/k&gt;
</code></pre><p><code>&lt;k&gt;</code> is a cell, known by convention as the <strong>K cell</strong>. This cell is available<br>
by default in any definition without needing to be explicitly declared.</p>
<p>The K cell contains a single term of sort <code>K</code>. <code>K</code> is a predefined sort in K<br>
with two constructors, that can be roughly represented by the following<br>
grammar:</p>
<pre data-role="codeBlock" data-info class="language-"><code>  syntax K ::= KItem &quot;~&gt;&quot; K
             | &quot;.&quot;
</code></pre><p>As a syntactic convenience, K allows you to treat <code>~&gt;</code> like it is an<br>
associative list (i.e., as if it were defined as <code>syntax K ::= K &quot;~&gt;&quot; K</code>).<br>
When a definition is compiled, it will automatically transform the rules you<br>
write so that they treat the <code>K</code> sort as a cons-list. Another syntactic<br>
convenience is that, for disambiguation purposes, you can write <code>.K</code> anywhere<br>
you would otherwise write <code>.</code> and the meaning is identical.</p>
<p>Now, you may notice that the above grammar mentions the sort <code>KItem</code>. This is<br>
another built-in sort in K. For every sort <code>S</code> declared in a definition (with<br>
the exception of <code>K</code> and <code>KItem</code>), K will implicitly insert the following<br>
production:</p>
<pre data-role="codeBlock" data-info class="language-"><code>  syntax KItem ::= S
</code></pre><p>In other words, every sort is a subsort of the sort <code>KItem</code>, and thus a term<br>
of any sort can be injected as an element of a term of sort <code>K</code>, also called<br>
a <strong>K sequence</strong>.</p>
<p>By default, when you <code>krun</code> a program, the AST of the program is inserted as<br>
the sole element of a K sequence into the <code>&lt;k&gt;</code> cell. This explains why we<br>
saw the output we did in Lesson 1.2.</p>
<p>With these preliminaries in mind, we can now explain how top-level rewrite<br>
rules work in K. Put simply, any rule where there is a cell (such as the K<br>
cell) at the top on the left-hand side will be a top-level rewrite rule. Once<br>
the initial program has been inserted into the K cell, the resulting term,<br>
called the <strong>configuration</strong>, will be matched against all the top-level<br>
rewrite rules in the definition. If only one rule matches, the substitution<br>
generated by the matching will be applied to the right-hand side of the rule<br>
and the resulting term is <strong>rewritten</strong> to be the new configuration. Rewriting<br>
proceeds by iteratively applying rules, also called <strong>taking steps</strong>, until<br>
no top-level rewrite rule can be applied. At this point the configuration<br>
becomes the <strong>final configuration</strong> and is output by <code>krun</code>.</p>
<p>If more than one top-level rule applies, by default, <code>K</code> will pick just one<br>
of those rules, apply it, and continue rewriting. However, it is<br>
<strong>non-deterministic</strong> which rule applies. In theory, it could be any of them.<br>
By passing the <code>--search</code> flag to <code>krun</code>, you are able to tell <code>krun</code> to<br>
explore all possible non-deterministic choices, and generate a complete list of<br>
all possible final configurations reachable by each nondeterminstic choice that<br>
can be made. Note that the <code>--search</code> flag to krun only works if you pass<br>
<code>--enable-search</code> to kompile first.</p>
<p>Unlike top-level rewrite rules, function rules are not associated with any<br>
particular set of cells in the configuration (although they can contain cells<br>
in their function arguments and return value). While top-level rewrite rules<br>
apply to the entire term being rewritten, function rules apply anywhere a<br>
function application for that function appears, and are immediately rewritten<br>
to their return value in that position.</p>
<p>Another key distinction between top-level rules and function rules is that<br>
function <em>symbols</em>, i.e., productions with the <code>function</code> attribute, are<br>
mathematical functions rather than constructors. While a constructor is<br>
logically distinct from any other constructor of the same sort, and can be<br>
matched against unconditionally, a function does not necessaraily have the<br>
same restriction unless it happens to be an injective function. Thus, two<br>
function symbols with different arguments may still ultimately produce the<br>
same value and thus compare equal to one another. Due to this, concrete<br>
execution (i.e., all K definitions introduced thus far; see Lesson 1.21)<br>
introduces the restriction that you cannot match on a function symbol on the<br>
left-hand side of a rule, except as the top symbol on the left-hand side of<br>
a function rule. This restriction will be later lifted when we introduce the<br>
Haskell Backend which performs <strong>symbolic execution</strong>.</p>
<h3 class="mume-header" id="exercise">Exercise</h3>

<p>Pass a program containing no functions to <code>krun</code>. You can use a term of sort<br>
<code>Exp</code> from <code>LESSON-11-E</code>. Observe the output and try to understand why you get<br>
the output you do. Then write two rules that rewrite that program to another.<br>
Run <code>krun --search</code> on that program and observe both results. Then add a third<br>
rule that rewrites one of those results again. Test that that rule applies as<br>
well.</p>
<h2 class="mume-header" id="using-top-level-rules-to-evaluate-expressions">Using top-level rules to evaluate expressions</h2>

<p>Thus far, we have focused primarily on defining functions over constructors<br>
in K. However, now that we have a basic understanding of top-level rules,<br>
it is possible to introduce a <strong>rewrite system</strong> to our definitions. A rewrite<br>
system is a collection of top-level rewrite rules which performs an organized<br>
transformation of a particular program into a result which expresses the<br>
meaning of that program. For example, we might rewrite an expression in a<br>
programming language into a value representing the result of evaluating that<br>
expression.</p>
<p>Recall in Lesson 1.11, we wrote a simple grammar of Boolean and integer<br>
expressions that looked roughly like this (<code>lesson-13-a.k</code>):</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">13</span><span class="token operator">-</span>A
  <span class="token keyword keyword-imports">imports</span> INT

  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span>
               <span class="token operator">|</span> <span class="token keyword keyword-Bool">Bool</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;+&quot;</span> Exp
               <span class="token operator">|</span> Exp <span class="token string">&quot;&amp;&amp;&quot;</span> Exp
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>In that lesson, we defined a function <code>eval</code> which evaluated such expressions<br>
to either an integer or Boolean.</p>
<p>However, it is more idiomatic to evaluate such expressions using top-level<br>
rewrite rules. Here is how one might do so in K (<code>lesson-13-b.k</code>):</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">13</span><span class="token operator">-</span>B<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> UNSIGNED<span class="token operator">-</span>INT<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> BOOL<span class="token operator">-</span>SYNTAX

  <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span> <span class="token operator">|</span> <span class="token keyword keyword-Bool">Bool</span>
  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Val
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span> Exp <span class="token string">&quot;+&quot;</span> Exp
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span> Exp <span class="token string">&quot;&amp;&amp;&quot;</span> Exp
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">13</span><span class="token operator">-</span>B
  <span class="token keyword keyword-imports">imports</span> LESSON<span class="token operator">-</span><span class="token number">13</span><span class="token operator">-</span>B<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> INT
  <span class="token keyword keyword-imports">imports</span> BOOL

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> I1<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">+</span> I2<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">~&gt;</span> K<span class="token punctuation">:</span>K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> I1 <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> I2 <span class="token operator">~&gt;</span> K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> B1<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span> <span class="token operator">&amp;&amp;</span> B2<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span> <span class="token operator">~&gt;</span> K<span class="token punctuation">:</span>K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> B1 andBool B2 <span class="token operator">~&gt;</span> K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> freezer1<span class="token punctuation">(</span>Val<span class="token punctuation">)</span> <span class="token operator">|</span> freezer2<span class="token punctuation">(</span>Exp<span class="token punctuation">)</span>
                 <span class="token operator">|</span> freezer3<span class="token punctuation">(</span>Val<span class="token punctuation">)</span> <span class="token operator">|</span> freezer4<span class="token punctuation">(</span>Exp<span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> E1<span class="token punctuation">:</span>Val <span class="token operator">+</span> E2<span class="token punctuation">:</span>Exp <span class="token operator">~&gt;</span> K<span class="token punctuation">:</span>K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> E2 <span class="token operator">~&gt;</span> freezer1<span class="token punctuation">(</span>E1<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">[</span>priority<span class="token punctuation">(</span><span class="token number">51</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> E1<span class="token punctuation">:</span>Exp <span class="token operator">+</span> E2<span class="token punctuation">:</span>Exp <span class="token operator">~&gt;</span> K<span class="token punctuation">:</span>K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> E1 <span class="token operator">~&gt;</span> freezer2<span class="token punctuation">(</span>E2<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">[</span>priority<span class="token punctuation">(</span><span class="token number">52</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> E1<span class="token punctuation">:</span>Val <span class="token operator">&amp;&amp;</span> E2<span class="token punctuation">:</span>Exp <span class="token operator">~&gt;</span> K<span class="token punctuation">:</span>K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> E2 <span class="token operator">~&gt;</span> freezer3<span class="token punctuation">(</span>E1<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">[</span>priority<span class="token punctuation">(</span><span class="token number">51</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> E1<span class="token punctuation">:</span>Exp <span class="token operator">&amp;&amp;</span> E2<span class="token punctuation">:</span>Exp <span class="token operator">~&gt;</span> K<span class="token punctuation">:</span>K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> E1 <span class="token operator">~&gt;</span> freezer4<span class="token punctuation">(</span>E2<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">[</span>priority<span class="token punctuation">(</span><span class="token number">52</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> E2<span class="token punctuation">:</span>Val <span class="token operator">~&gt;</span> freezer1<span class="token punctuation">(</span>E1<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> K<span class="token punctuation">:</span>K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> E1 <span class="token operator">+</span> E2 <span class="token operator">~&gt;</span> K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> E1<span class="token punctuation">:</span>Val <span class="token operator">~&gt;</span> freezer2<span class="token punctuation">(</span>E2<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> K<span class="token punctuation">:</span>K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> E1 <span class="token operator">+</span> E2 <span class="token operator">~&gt;</span> K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> E2<span class="token punctuation">:</span>Val <span class="token operator">~&gt;</span> freezer3<span class="token punctuation">(</span>E1<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> K<span class="token punctuation">:</span>K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> E1 <span class="token operator">&amp;&amp;</span> E2 <span class="token operator">~&gt;</span> K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> E1<span class="token punctuation">:</span>Val <span class="token operator">~&gt;</span> freezer4<span class="token punctuation">(</span>E2<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> K<span class="token punctuation">:</span>K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> E1 <span class="token operator">&amp;&amp;</span> E2 <span class="token operator">~&gt;</span> K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>This is of course rather cumbersome currently, but we will soon introduce<br>
syntactic convenience which makes writing definitions of this type considerably<br>
easier. For now, notice that there are roughly 3 types of rules here: the first<br>
matches a K cell in which the first element of the K sequence is an <code>Exp</code> whose<br>
arguments are values, and rewrites the first element of the sequence to the<br>
result of that expression. The second also matches a K cell with an <code>Exp</code> in<br>
the first element of its K sequence, but it matches when one or both arguments<br>
of the <code>Exp</code> are not values, and replaces the first element of the K sequence<br>
with two new elements: one being an argument to evaluate, and the other being<br>
a special constructor called a <strong>freezer</strong>. Finally, the third matches a K<br>
sequence where a <code>Val</code> is first, and a freezer is second, and replaces them<br>
with a partially evaluated expression.</p>
<p>This general pattern is what is known as <strong>heating</strong> an expression,<br>
<strong>evaluating</strong> its arguments, <strong>cooling</strong> the arguments into the expression<br>
again, and <strong>evaluating</strong> the expression itself. By repeatedly performing<br>
this sequence of actions, we can evaluate an entire AST containing a complex<br>
expression down into its resulting value.</p>
<h3 class="mume-header" id="exercise-1">Exercise</h3>

<p>Write an addition expression with integers. Use <code>krun --depth 1</code> to see the<br>
result of rewriting after applying a single top-level rule. Gradually increase<br>
the value of <code>--depth</code> to see successive states. Observe how this combination<br>
of rules is eventually able to evaluate the entire expression.</p>
<h2 class="mume-header" id="simplifying-the-evaluator-local-rewrites-and-cell-ellipses">Simplifying the evaluator: Local rewrites and cell ellipses</h2>

<p>As you saw above, the definition we wrote is rather cumbersome. Over the<br>
remainder of Lessons 1.13 and 1.14, we will greatly simplify it. The first step<br>
in doing so is to teach a bit more about the rewrite operator, <code>=&gt;</code>. Thus far,<br>
all the rules we have written look like <code>rule LHS =&gt; RHS</code>. However, this is not<br>
the only way the rewrite operator can be used. It is actually possible to place<br>
a constructor or function at the very top of the rule, and place rewrite<br>
operators inside that term. While a rewrite operator cannot appear nested<br>
inside another rewrite operator, by doing this, we can express that some parts<br>
of what we are matching are not <strong>changed</strong> by the rewrite operator. For<br>
example, consider the following rule from above:</p>
<pre data-role="codeBlock" data-info class="language-"><code>  rule &lt;k&gt; I1:Int + I2:Int ~&gt; K:K &lt;/k&gt; =&gt; &lt;k&gt; I1 +Int I2 ~&gt; K &lt;/k&gt;
</code></pre><p>We can equivalently write it like following:</p>
<pre data-role="codeBlock" data-info class="language-"><code>  rule &lt;k&gt; (I1:Int + I2:Int =&gt; I1 +Int I2) ~&gt; _:K &lt;/k&gt;
</code></pre><p>When you put a rewrite inside a term like this, in essence, you are telling<br>
the rule to only rewrite <strong>part</strong> of the left-hand side to the right-hand side.<br>
In practice, this is implemented by lifting the rewrite operator to the top of<br>
the rule by means of duplicating the surrounding context.</p>
<p>There is a way that the above rule can be simplified further, however. K<br>
provides a special syntax for each cell containing a term of sort K, indicating<br>
that we want to match only on some prefix of the K sequence. For example, the<br>
above rule can be simplified further like so:</p>
<pre data-role="codeBlock" data-info class="language-"><code>  rule &lt;k&gt; I1:Int + I2:Int =&gt; I1 +Int I2 ...&lt;/k&gt;
</code></pre><p>Here we have placed the symbol <code>...</code> immediately prior to the <code>&lt;/k&gt;</code> which ends<br>
the cell. What this tells the compiler is to take the contents of the cell,<br>
treat it as the prefix of a K sequence, and insert an anonymous variable of<br>
sort <code>K</code> at the end. Thus we can think of <code>...</code> as a way of saying we<br>
<strong>don&apos;t care</strong> about the part of the K sequence after the beginning, leaving<br>
it unchanged.</p>
<p>Putting all this together, we can rewrite <code>LESSON-13-B</code> like so<br>
(<code>lesson-13-c.k</code>):</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">13</span><span class="token operator">-</span>C<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> UNSIGNED<span class="token operator">-</span>INT<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> BOOL<span class="token operator">-</span>SYNTAX

  <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span> <span class="token operator">|</span> <span class="token keyword keyword-Bool">Bool</span>
  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Val
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span> Exp <span class="token string">&quot;+&quot;</span> Exp
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span> Exp <span class="token string">&quot;&amp;&amp;&quot;</span> Exp
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">13</span><span class="token operator">-</span>C
  <span class="token keyword keyword-imports">imports</span> LESSON<span class="token operator">-</span><span class="token number">13</span><span class="token operator">-</span>C<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> INT
  <span class="token keyword keyword-imports">imports</span> BOOL

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> I1<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">+</span> I2<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">=&gt;</span> I1 <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> I2 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> B1<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span> <span class="token operator">&amp;&amp;</span> B2<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span> <span class="token operator">=&gt;</span> B1 andBool B2 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> freezer1<span class="token punctuation">(</span>Val<span class="token punctuation">)</span> <span class="token operator">|</span> freezer2<span class="token punctuation">(</span>Exp<span class="token punctuation">)</span>
                 <span class="token operator">|</span> freezer3<span class="token punctuation">(</span>Val<span class="token punctuation">)</span> <span class="token operator">|</span> freezer4<span class="token punctuation">(</span>Exp<span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> E1<span class="token punctuation">:</span>Val <span class="token operator">+</span> E2<span class="token punctuation">:</span>Exp <span class="token operator">=&gt;</span> E2 <span class="token operator">~&gt;</span> freezer1<span class="token punctuation">(</span>E1<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">[</span>priority<span class="token punctuation">(</span><span class="token number">51</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> E1<span class="token punctuation">:</span>Exp <span class="token operator">+</span> E2<span class="token punctuation">:</span>Exp <span class="token operator">=&gt;</span> E1 <span class="token operator">~&gt;</span> freezer2<span class="token punctuation">(</span>E2<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">[</span>priority<span class="token punctuation">(</span><span class="token number">52</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> E1<span class="token punctuation">:</span>Val <span class="token operator">&amp;&amp;</span> E2<span class="token punctuation">:</span>Exp <span class="token operator">=&gt;</span> E2 <span class="token operator">~&gt;</span> freezer3<span class="token punctuation">(</span>E1<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">[</span>priority<span class="token punctuation">(</span><span class="token number">51</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> E1<span class="token punctuation">:</span>Exp <span class="token operator">&amp;&amp;</span> E2<span class="token punctuation">:</span>Exp <span class="token operator">=&gt;</span> E1 <span class="token operator">~&gt;</span> freezer4<span class="token punctuation">(</span>E2<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">[</span>priority<span class="token punctuation">(</span><span class="token number">52</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> E2<span class="token punctuation">:</span>Val <span class="token operator">~&gt;</span> freezer1<span class="token punctuation">(</span>E1<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> E1 <span class="token operator">+</span> E2 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> E1<span class="token punctuation">:</span>Val <span class="token operator">~&gt;</span> freezer2<span class="token punctuation">(</span>E2<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> E1 <span class="token operator">+</span> E2 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> E2<span class="token punctuation">:</span>Val <span class="token operator">~&gt;</span> freezer3<span class="token punctuation">(</span>E1<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> E1 <span class="token operator">&amp;&amp;</span> E2 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> E1<span class="token punctuation">:</span>Val <span class="token operator">~&gt;</span> freezer4<span class="token punctuation">(</span>E2<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> E1 <span class="token operator">&amp;&amp;</span> E2 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>This is still rather cumbersome, but it is already greatly simplified. In the<br>
next lesson, we will see how additional features of K can be used to specify<br>
heating and cooling rules much more compactly.</p>
<h2 class="mume-header" id="exercises">Exercises</h2>

<ol>
<li>Modify <code>LESSON-13-C</code> to add rules to evaluate integer subtraction.</li>
</ol>
<h2 class="mume-header" id="next-lesson">Next lesson</h2>

<p>Once you have completed the above exercises, you can continue to<br>
<a href="#ebook-heading-lesson-114-defining-evaluation-order">Lesson 1.14: Defining Evaluation Order</a>.</p>
</div></div><div id="ebook-heading-lesson-114-defining-evaluation-order" ebook-toc-level-3 heading="Lesson 1.14: Defining Evaluation Order"><div><h1 class="mume-header" id="lesson-114-defining-evaluation-order">Lesson 1.14: Defining Evaluation Order</h1>

<p>The purpose of this lesson is to explain how to use the <code>heat</code> and <code>cool</code><br>
attributes, <code>context</code> and <code>context alias</code> sentences, and the <code>strict</code> and<br>
<code>seqstrict</code> attributes to more compactly express heating and cooling in K,<br>
and to express more advanced evaluation strategies in K.</p>
<h2 class="mume-header" id="the-heat-and-cool-attributes">The <code>heat</code> and <code>cool</code> attributes</h2>

<p>Thus far, we have been using rule priority and casts to express when to heat<br>
an expression and when to cool it. For example, the rules for heating have<br>
lower priority, so they do not apply if the term could be evaluated instead,<br>
and the rules for heating are expressly written only to apply if the argument<br>
of the expression is a value.</p>
<p>However, K has built-in support for deciding when to heat and when to cool.<br>
This support comes in the form of the rule attributes <code>heat</code> and <code>cool</code> as<br>
well as the specially named function <code>isKResult</code>.</p>
<p>Consider the following definition, which is equivalent to <code>LESSON-13-C</code><br>
(<code>lesson-14-a.k</code>):</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">14</span><span class="token operator">-</span>A<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> UNSIGNED<span class="token operator">-</span>INT<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> BOOL<span class="token operator">-</span>SYNTAX

  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span>
               <span class="token operator">|</span> <span class="token keyword keyword-Bool">Bool</span>
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span> Exp <span class="token string">&quot;+&quot;</span> Exp
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span> Exp <span class="token string">&quot;&amp;&amp;&quot;</span> Exp
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">14</span><span class="token operator">-</span>A
  <span class="token keyword keyword-imports">imports</span> LESSON<span class="token operator">-</span><span class="token number">14</span><span class="token operator">-</span>A<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> INT
  <span class="token keyword keyword-imports">imports</span> BOOL

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> I1<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">+</span> I2<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">=&gt;</span> I1 <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> I2 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> B1<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span> <span class="token operator">&amp;&amp;</span> B2<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span> <span class="token operator">=&gt;</span> B1 andBool B2 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> freezer1<span class="token punctuation">(</span>Exp<span class="token punctuation">)</span> <span class="token operator">|</span> freezer2<span class="token punctuation">(</span>Exp<span class="token punctuation">)</span>
                 <span class="token operator">|</span> freezer3<span class="token punctuation">(</span>Exp<span class="token punctuation">)</span> <span class="token operator">|</span> freezer4<span class="token punctuation">(</span>Exp<span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> E<span class="token punctuation">:</span>Exp <span class="token operator">+</span> HOLE<span class="token punctuation">:</span>Exp <span class="token operator">=&gt;</span> HOLE <span class="token operator">~&gt;</span> freezer1<span class="token punctuation">(</span>E<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> isKResult<span class="token punctuation">(</span>E<span class="token punctuation">)</span> <span class="token punctuation">[</span>heat<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> HOLE<span class="token punctuation">:</span>Exp <span class="token operator">+</span> E<span class="token punctuation">:</span>Exp <span class="token operator">=&gt;</span> HOLE <span class="token operator">~&gt;</span> freezer2<span class="token punctuation">(</span>E<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">[</span>heat<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> E<span class="token punctuation">:</span>Exp <span class="token operator">&amp;&amp;</span> HOLE<span class="token punctuation">:</span>Exp <span class="token operator">=&gt;</span> HOLE <span class="token operator">~&gt;</span> freezer3<span class="token punctuation">(</span>E<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> isKResult<span class="token punctuation">(</span>E<span class="token punctuation">)</span> <span class="token punctuation">[</span>heat<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> HOLE<span class="token punctuation">:</span>Exp <span class="token operator">&amp;&amp;</span> E<span class="token punctuation">:</span>Exp <span class="token operator">=&gt;</span> HOLE <span class="token operator">~&gt;</span> freezer4<span class="token punctuation">(</span>E<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">[</span>heat<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> HOLE<span class="token punctuation">:</span>Exp <span class="token operator">~&gt;</span> freezer1<span class="token punctuation">(</span>E<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> E <span class="token operator">+</span> HOLE <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">[</span>cool<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> HOLE<span class="token punctuation">:</span>Exp <span class="token operator">~&gt;</span> freezer2<span class="token punctuation">(</span>E<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> HOLE <span class="token operator">+</span> E <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">[</span>cool<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> HOLE<span class="token punctuation">:</span>Exp <span class="token operator">~&gt;</span> freezer3<span class="token punctuation">(</span>E<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> E <span class="token operator">&amp;&amp;</span> HOLE <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">[</span>cool<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> HOLE<span class="token punctuation">:</span>Exp <span class="token operator">~&gt;</span> freezer4<span class="token punctuation">(</span>E<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> HOLE <span class="token operator">&amp;&amp;</span> E <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">[</span>cool<span class="token punctuation">]</span>

  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> isKResult<span class="token punctuation">(</span>K<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> isKResult<span class="token punctuation">(</span>_<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
  <span class="token keyword keyword-rule">rule</span> isKResult<span class="token punctuation">(</span>_<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
  <span class="token keyword keyword-rule">rule</span> isKResult<span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">false</span> <span class="token punctuation">[</span>owise<span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>We have introduced three major changes to this definition. First, we have<br>
removed the <code>Val</code> sort. We replace it instead with a function <code>isKResult</code>.<br>
The function in question must have the same signature and attributes as seen in<br>
this example. It ought to return <code>true</code> whenever a term should not be heated<br>
(because it is a value) and <code>false</code> when it should be heated (because it is not<br>
a value). We thus also insert <code>isKResult</code> calls in the side condition of two<br>
of the heating rules, where the <code>Val</code> sort was previously used.</p>
<p>Second, we have removed the rule priorities on the heating rules and the use of<br>
the <code>Val</code> sort on the cooling rules, and replaced them with the <code>heat</code> and<br>
<code>cool</code> attributes. These attributes instruct the compiler that these rules are<br>
heating and cooling rules, and thus should implicitly apply only when certain<br>
terms on the LHS either are or are not a <code>KResult</code> (i.e., <code>isKResult</code> returns<br>
<code>true</code> versus <code>false</code>).</p>
<p>Third, we have renamed some of the variables in the heating and cooling rules<br>
to the special variable <code>HOLE</code>. Syntactically, <code>HOLE</code> is just a special name<br>
for a variable, but it is treated specially by the compiler. By naming a<br>
variable <code>HOLE</code>, we have informed the compiler which term is being heated<br>
or cooled. The compiler will automatically insert the side condition<br>
<code>requires isKResult(HOLE)</code> to cooling rules and the side condition<br>
<code>requires notBool isKResult(HOLE)</code> to heating rules.</p>
<h3 class="mume-header" id="exercise">Exercise</h3>

<p>Modify <code>LESSON-14-A</code> to add rules to evaluate integer subtraction.</p>
<h2 class="mume-header" id="simplifying-further-with-contexts">Simplifying further with Contexts</h2>

<p>The above example is still rather cumbersome to write. We must explicitly write<br>
both the heating and the cooling rule separately, even though they are<br>
essentially inverses of one another. It would be nice to instead simply<br>
indicate which terms should be heated and cooled, and what part of them to<br>
operate on.</p>
<p>To do this, K introduces a new type of sentence, the <strong>context</strong>. Contexts<br>
begin with the <code>context</code> keyword instead of the <code>rule</code> keyword, and usually<br>
do not contain a rewrite operator.</p>
<p>Consider the following definition which is equivalent to <code>LESSON-14-A</code><br>
(<code>lesson-14-b.k</code>):</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">14</span><span class="token operator">-</span>B<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> UNSIGNED<span class="token operator">-</span>INT<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> BOOL<span class="token operator">-</span>SYNTAX

  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span>
               <span class="token operator">|</span> <span class="token keyword keyword-Bool">Bool</span>
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span> Exp <span class="token string">&quot;+&quot;</span> Exp
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span> Exp <span class="token string">&quot;&amp;&amp;&quot;</span> Exp
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">14</span><span class="token operator">-</span>B
  <span class="token keyword keyword-imports">imports</span> LESSON<span class="token operator">-</span><span class="token number">14</span><span class="token operator">-</span>B<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> INT
  <span class="token keyword keyword-imports">imports</span> BOOL

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> I1<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">+</span> I2<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">=&gt;</span> I1 <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> I2 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> B1<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span> <span class="token operator">&amp;&amp;</span> B2<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span> <span class="token operator">=&gt;</span> B1 andBool B2 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-context">context</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> E<span class="token punctuation">:</span>Exp <span class="token operator">+</span> HOLE<span class="token punctuation">:</span>Exp <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> isKResult<span class="token punctuation">(</span>E<span class="token punctuation">)</span>
  <span class="token keyword keyword-context">context</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> HOLE<span class="token punctuation">:</span>Exp <span class="token operator">+</span> _<span class="token punctuation">:</span>Exp <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-context">context</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> E<span class="token punctuation">:</span>Exp <span class="token operator">&amp;&amp;</span> HOLE<span class="token punctuation">:</span>Exp <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> isKResult<span class="token punctuation">(</span>E<span class="token punctuation">)</span>
  <span class="token keyword keyword-context">context</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> HOLE<span class="token punctuation">:</span>Exp <span class="token operator">&amp;&amp;</span> _<span class="token punctuation">:</span>Exp <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> isKResult<span class="token punctuation">(</span>K<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> isKResult<span class="token punctuation">(</span>_<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
  <span class="token keyword keyword-rule">rule</span> isKResult<span class="token punctuation">(</span>_<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
  <span class="token keyword keyword-rule">rule</span> isKResult<span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">false</span> <span class="token punctuation">[</span>owise<span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>In this example, the <code>heat</code> and <code>cool</code> rules have been removed entirely, as<br>
have been the productions defining the freezers. Don&apos;t worry, they still exist<br>
under the hood; the compiler is just generating them automatically. For each<br>
context sentence like above, the compiler generates a <code>#freezer</code> production,<br>
a <code>heat</code> rule, and a <code>cool</code> rule. The generated form is equivalent to the<br>
rules we wrote manually in <code>LESSON-14-A</code>. However, we are now starting to<br>
considerably simplify the definition. Instead of 3 sentences, we just have one.</p>
<h2 class="mume-header" id="context-alias-sentences-and-the-strict-and-seqstrict-attributes"><code>context alias</code> sentences and the <code>strict</code> and <code>seqstrict</code> attributes</h2>

<p>Notice that the contexts we included in <code>LESSON-14-B</code> still seem rather<br>
similar in form. For each expression we want to evaluate, we are declaring<br>
one context for each operand of that expression, and they are each rather<br>
similar to one another. We would like to be able to simplify further by<br>
simply annotating each expression production with information about how<br>
it is to be evaluated instead. We can do this with the <code>seqstrict</code> attribute.</p>
<p>Consider the following definition, once again equivalent to those above<br>
(<code>lesson-14-c.k</code>):</p>
<pre data-role="codeBlock" data-info="{.k .alias}" class="language- k alias"><code>module LESSON-14-C-SYNTAX
  imports UNSIGNED-INT-SYNTAX
  imports BOOL-SYNTAX

  syntax Exp ::= Int
               | Bool
               &gt; left: Exp &quot;+&quot; Exp [seqstrict(exp; 1, 2)]
               &gt; left: Exp &quot;&amp;&amp;&quot; Exp [seqstrict(exp; 1, 2)]
endmodule

module LESSON-14-C
  imports LESSON-14-C-SYNTAX
  imports INT
  imports BOOL

  rule &lt;k&gt; I1:Int + I2:Int =&gt; I1 +Int I2 ...&lt;/k&gt;
  rule &lt;k&gt; B1:Bool &amp;&amp; B2:Bool =&gt; B1 andBool B2 ...&lt;/k&gt;

  context alias [exp]: &lt;k&gt; HERE ...&lt;/k&gt;

  syntax Bool ::= isKResult(K) [function, symbol]
  rule isKResult(_:Int) =&gt; true
  rule isKResult(_:Bool) =&gt; true
  rule isKResult(_) =&gt; false [owise]
endmodule
</code></pre><p>This definition has two important changes from the one above. The first is<br>
that the individual <code>context</code> sentences have been removed and have been<br>
replaced with a single <code>context alias</code> sentence. You may notice that this<br>
sentence begins with an identifier in square brackets followed by a colon. This<br>
syntax is a way of naming individual sentences in K for reference by the tool<br>
or by other sentences. The context alias sentence also has a special variable<br>
<code>HERE</code>.</p>
<p>The second is that the productions in <code>LESSON-14-C-SYNTAX</code> have been given a<br>
<code>seqstrict</code> attribute. The value of this attribute has two parts. The first<br>
is the name of a context alias sentence. The second is a comma-separated list<br>
of integers. Each integer represents an index of a non-terminal in the<br>
production, counting from 1. For each integer present, the compiler implicitly<br>
generates a new <code>context</code> sentence according to the following rules:</p>
<ol>
<li>The compiler starts by looking for the <code>context alias</code> sentence named. If<br>
there is more than one, then one <code>context</code> sentence is created per<br>
<code>context alias</code> sentence with that name.</li>
<li>For each <code>context</code> created, the variable <code>HERE</code> in the context alias is<br>
substituted with an instance of the production the <code>seqstrict</code> attribute is<br>
attached to. Each child of that production is a variable. The non-terminal<br>
indicated by the integer offset of the <code>seqstrict</code> attribute is given the name<br>
<code>HOLE</code>.</li>
<li>For each integer offset prior in the list to the one currently being<br>
processed, the predicate <code>isKResult(E)</code> is conjuncted together and included<br>
as a side condition, where <code>E</code> is the child of the production term with that<br>
offset, starting from 1. For example, if the attribute lists <code>1, 2</code>, then<br>
the rule generated for the <code>2</code> will include <code>isKResult(E1)</code> where <code>E1</code> is the<br>
first child of the production.</li>
</ol>
<p>As you can see if you work through the process, the above code will ultimately<br>
generate the same contexts present in <code>LESSON-14-B</code>.</p>
<p>Finally, note that there are a few minor syntactic conveniences provided by the<br>
<code>seqstrict</code> attribute. First, in the special case of the <code>context alias</code> sentence<br>
being <code>&lt;k&gt; HERE ...&lt;/k&gt;</code>, you can omit both the <code>context alias</code> sentence<br>
and the name from the <code>seqstrict</code> attribute.</p>
<p>Second, if the numbered list of offsets contains every non-terminal in the<br>
production, it can be omitted from the attribute value.</p>
<p>Thus, we can finally produce the idiomatic K definition for this example<br>
(<code>lesson-14-d.k</code>):</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">14</span><span class="token operator">-</span>D<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> UNSIGNED<span class="token operator">-</span>INT<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> BOOL<span class="token operator">-</span>SYNTAX

  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span>
               <span class="token operator">|</span> <span class="token keyword keyword-Bool">Bool</span>
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span> Exp <span class="token string">&quot;+&quot;</span> Exp <span class="token punctuation">[</span><span class="token class-name">seqstrict</span><span class="token punctuation">]</span>
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span> Exp <span class="token string">&quot;&amp;&amp;&quot;</span> Exp <span class="token punctuation">[</span><span class="token class-name">seqstrict</span><span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">14</span><span class="token operator">-</span>D
  <span class="token keyword keyword-imports">imports</span> LESSON<span class="token operator">-</span><span class="token number">14</span><span class="token operator">-</span>D<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> INT
  <span class="token keyword keyword-imports">imports</span> BOOL

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> I1<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">+</span> I2<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">=&gt;</span> I1 <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> I2 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> B1<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span> <span class="token operator">&amp;&amp;</span> B2<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span> <span class="token operator">=&gt;</span> B1 andBool B2 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> isKResult<span class="token punctuation">(</span>K<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> isKResult<span class="token punctuation">(</span>_<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
  <span class="token keyword keyword-rule">rule</span> isKResult<span class="token punctuation">(</span>_<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
  <span class="token keyword keyword-rule">rule</span> isKResult<span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">false</span> <span class="token punctuation">[</span>owise<span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><h3 class="mume-header" id="exercise-1">Exercise</h3>

<p>Modify <code>LESSON-14-D</code> to add a production and rule to evaluate integer<br>
subtraction.</p>
<h2 class="mume-header" id="nondeterministic-evaluation-order-with-the-strict-attribute">Nondeterministic evaluation order with the <code>strict</code> attribute</h2>

<p>Thus far, we have focused entirely on deterministic evaluation order. However,<br>
not all languages are deterministic in the order they evaluate expressions.<br>
For example, in C, the expression <code>a() + b() + c()</code> is guaranteed to parse<br>
to <code>(a() + b()) + c()</code>, but it is not guaranteed that <code>a</code> will be called before<br>
<code>b</code> before <code>c</code>. In fact, this evaluation order is non-deterministic.</p>
<p>We can express non-deterministic evaluation orders with the <code>strict</code> attribute.<br>
Its behavior is identical to the <code>seqstrict</code> attribute, except that step 3 in<br>
the above list (with the side condition automatically added) does not take<br>
place. In other words, if we wrote <code>syntax Exp ::= Exp &quot;+&quot; Exp [strict]</code><br>
instead of <code>syntax Exp ::= Exp &quot;+&quot; Exp [seqstrict]</code>, it would generate the<br>
following two contexts instead of the ones found in <code>LESSON-14-B</code>:</p>
<pre data-role="codeBlock" data-info class="language-"><code>  context &lt;k&gt; _:Exp + HOLE:Exp ...&lt;/k&gt;
  context &lt;k&gt; HOLE:Exp + _:Exp ...&lt;/k&gt;
</code></pre><p>As you can see, these contexts will generate heating rules that can both<br>
apply to the same term. As a result, the choice of which heating rule<br>
applies first is non-deterministic, and as we saw in Lesson 1.13, we can<br>
get all possible behaviors by passing <code>--search</code> to krun.</p>
<h2 class="mume-header" id="exercises">Exercises</h2>

<ol>
<li>
<p>Add integer division to <code>LESSON-14-D</code>. Make division and addition <code>strict</code><br>
instead of <code>seqstrict</code>, and write a rule evaluating integer division with a<br>
side condition that the denominator is non-zero. Run <code>krun --search</code> on the<br>
program <code>1 / 0 + 2 / 1</code> and observe all possible outputs of the program. How<br>
many are there total, and why?</p>
</li>
<li>
<p>Rework your solution from Lesson 1.9, Exercise 2 to evaluate expressions from left to right using the <code>seqstrict</code> attribute.</p>
</li>
</ol>
<h2 class="mume-header" id="next-lesson">Next lesson</h2>

<p>Once you have completed the above exercises, you can continue to<br>
<a href="#ebook-heading-lesson-115-configuration-declarations-and-cell-nesting">Lesson 1.15: Configuration Declarations and Cell Nesting</a>.</p>
</div></div><div id="ebook-heading-lesson-115-configuration-declarations-and-cell-nesting" ebook-toc-level-3 heading="Lesson 1.15: Configuration Declarations and Cell Nesting"><div><h1 class="mume-header" id="lesson-115-configuration-declarations-and-cell-nesting">Lesson 1.15: Configuration Declarations and Cell Nesting</h1>

<p>The purpose of this lesson is to explain how to store additional information<br>
about the state of your interpreter by declaring <strong>cells</strong> using the<br>
<code>configuration</code> sentence, as well as how to add additional inputs to your<br>
definition.</p>
<h2 class="mume-header" id="cells-and-configuration-declarations">Cells and Configuration Declarations</h2>

<p>We have already covered the absolute basics of cells in K by looking at the<br>
<code>&lt;k&gt;</code> cell. As explained in <a href="#ebook-heading-lesson-113-basics-of-k-rewriting">Lesson 1.13</a>, the<br>
<code>&lt;k&gt;</code> cell is available without being explicitly declared. It turns out this is<br>
because, if the user does not explicitly specify a <code>configuration</code> sentence<br>
anywhere in the main module of their definition, the <code>configuration</code> sentence<br>
from the <code>DEFAULT-CONFIGURATION</code> module of<br>
<a href="#ebook-heading-kast">kast.md</a> is imported<br>
automatically. Here is what that sentence looks like:</p>
<pre data-role="codeBlock" data-info class="language-"><code>  configuration &lt;k&gt; $PGM:K &lt;/k&gt;
</code></pre><p>This configuration declaration declares a single cell, the <code>&lt;k&gt;</code> cell. It also<br>
declares that at the start of rewriting, the contents of that cell should be<br>
initialized with the value of the <code>$PGM</code> <strong>configuration variable</strong>.<br>
Configuration variables function as inputs to <code>krun</code>. These terms are supplied<br>
to <code>krun</code> in the form of ASTs parsed using a particular module. By default, the<br>
<code>$PGM</code> configuration variable uses the main syntax module of the definition.</p>
<p>The cast on the configuration variable also specifies the sort that is used as<br>
the entry point to the parser, in this case the <code>K</code> sort. It is often<br>
useful to cast to other sorts there as well for better control over the accepted<br>
language. The sort used for the <code>$PGM</code> variable is referred to as the start<br>
symbol. During parsing, the default start symbol <code>K</code> subsumes all user-defined<br>
sorts except for syntactic lists. These are excluded because they will always<br>
produce an ambiguity error when parsing a single element.</p>
<p>Note that we did not explicitly specify the <code>$PGM</code> configuration variable when<br>
we invoked <code>krun</code> on a file. This is because <code>krun</code> handles the <code>$PGM</code> variable<br>
specially, and allows you to pass the term for that variable via a file passed<br>
as a positional argument to <code>krun</code>. We did, however, specify the <code>PGM</code> name<br>
explicitly when we called <code>krun</code> with the <code>-cPGM</code> command line argument in<br>
<a href="#ebook-heading-lesson-12-basics-of-functional-k">Lesson 1.2</a>. This is the other, explicit, way of<br>
specifying an input to krun.</p>
<p>This explains the most basic use of configuration declarations in K. We can,<br>
however, declare multiple cells and multiple configuration variables. We can<br>
also specify the initial values of cells statically, rather than dynamically<br>
via krun.</p>
<p>For example, consider the following definition (<code>lesson-15-a.k</code>):</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">15</span><span class="token operator">-</span>A<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> INT<span class="token operator">-</span>SYNTAX

  <span class="token keyword keyword-syntax">syntax</span> Ints <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">15</span><span class="token operator">-</span>A
  <span class="token keyword keyword-imports">imports</span> LESSON<span class="token operator">-</span><span class="token number">15</span><span class="token operator">-</span>A<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> INT

  <span class="token keyword keyword-configuration">configuration</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> $PGM<span class="token punctuation">:</span>Ints <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sum</span><span class="token punctuation">&gt;</span></span> <span class="token number">0</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sum</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> Is<span class="token punctuation">:</span>Ints <span class="token operator">=&gt;</span> Is <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sum</span><span class="token punctuation">&gt;</span></span> SUM<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">=&gt;</span> SUM <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> I <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sum</span><span class="token punctuation">&gt;</span></span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>This simple definition takes a list of integers as input and sums them<br>
together. Here we have declared two cells: <code>&lt;k&gt;</code> and <code>&lt;sum&gt;</code>. Unlike <code>&lt;k&gt;</code>,<br>
<code>&lt;sum&gt;</code> does not get initialized via a configuration variable, but instead<br>
is initialized statically with the value <code>0</code>.</p>
<p>Note the rule in the second module: we have explicitly specified multiple<br>
cells in a single rule. K will expect each of these cells to match in order for<br>
the rule to apply.</p>
<p>Here is a second example (<code>lesson-15-b.k</code>):</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">15</span><span class="token operator">-</span>B<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> INT<span class="token operator">-</span>SYNTAX
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">15</span><span class="token operator">-</span>B
  <span class="token keyword keyword-imports">imports</span> LESSON<span class="token operator">-</span><span class="token number">15</span><span class="token operator">-</span>B<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> INT
  <span class="token keyword keyword-imports">imports</span> BOOL

  <span class="token keyword keyword-configuration">configuration</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>first</span><span class="token punctuation">&gt;</span></span> $FIRST<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>first</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>second</span><span class="token punctuation">&gt;</span></span> $SECOND<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>second</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span> <span class="token operator">=&gt;</span> FIRST &gt;<span class="token keyword keyword-Int">Int</span> SECOND <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>first</span><span class="token punctuation">&gt;</span></span> FIRST <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>first</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>second</span><span class="token punctuation">&gt;</span></span> SECOND <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>second</span><span class="token punctuation">&gt;</span></span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>This definition takes two integers as command-line arguments and populates the<br>
<code>&lt;k&gt;</code> cell with a Boolean indicating whether the first integer is greater than<br>
the second. Notice that we have specified no <code>$PGM</code> configuration variable<br>
here. As a result, we cannot invoke <code>krun</code> via the syntax <code>krun $file</code>.<br>
Instead, we must explicitly pass values for each configuration variable via the<br>
<code>-cFIRST</code> and <code>-cSECOND</code> command line flags. For example, if we invoke<br>
<code>krun -cFIRST=0 -cSECOND=1</code>, we will get the value <code>false</code> in the K cell.</p>
<p>You can also specify both a <code>$PGM</code> configuration variable and other<br>
configuration variables in a single configuration declaration, in which case<br>
you would be able to initialize <code>$PGM</code> with either a positional argument or the<br>
<code>-cPGM</code> command line flag, but the other configuration variables would need<br>
to be explicitly initialized with <code>-c</code>.</p>
<h3 class="mume-header" id="exercise">Exercise</h3>

<p>Modify your solution to Lesson 1.14, Exercise 2 to add a new cell with a<br>
configuration variable of sort <code>Bool</code>. This variable should determine whether<br>
the <code>/</code> operator is evaluated using <code>/Int</code> or <code>divInt</code>. Test that by specifying<br>
different values for this variable, you can change the behavior of rounding on<br>
division of negative numbers.</p>
<h2 class="mume-header" id="cell-nesting">Cell Nesting</h2>

<p>It is possible to nest cells inside one another. A cell that contains other<br>
cells must contain <strong>only</strong> other cells, but in doing this, you are able to<br>
create a hierarchical structure to the configuration. Consider the following<br>
definition (<code>lesson-15-c.k</code>), which is equivalent to the one in <code>LESSON-15-B</code>:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">15</span><span class="token operator">-</span>C<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> INT<span class="token operator">-</span>SYNTAX
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">15</span><span class="token operator">-</span>C
  <span class="token keyword keyword-imports">imports</span> LESSON<span class="token operator">-</span><span class="token number">15</span><span class="token operator">-</span>C<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> INT
  <span class="token keyword keyword-imports">imports</span> BOOL

  <span class="token keyword keyword-configuration">configuration</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>T</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>state</span><span class="token punctuation">&gt;</span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>first</span><span class="token punctuation">&gt;</span></span> $FIRST<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>first</span><span class="token punctuation">&gt;</span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>second</span><span class="token punctuation">&gt;</span></span> $SECOND<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>second</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>state</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>T</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span> <span class="token operator">=&gt;</span> FIRST &gt;<span class="token keyword keyword-Int">Int</span> SECOND <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>first</span><span class="token punctuation">&gt;</span></span> FIRST <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>first</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>second</span><span class="token punctuation">&gt;</span></span> SECOND <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>second</span><span class="token punctuation">&gt;</span></span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>Note that we have added some new cells to the configuration declaration:<br>
the <code>&lt;T&gt;</code> cell wraps the entire configuration, and the <code>&lt;state&gt;</code> cell is<br>
introduced around the <code>&lt;first&gt;</code> and <code>&lt;second&gt;</code> cells.</p>
<p>However, we have not changed the rule in this definition. This is because of<br>
a concept in K called <strong>configuration abstraction</strong>. K allows you to specify<br>
any number of cells in a rule (except zero) in any order you want, and K will<br>
compile the rules into a form that matches the structure of the configuration<br>
specified by the configuration declaration.</p>
<p>Here then, is how this rule would look after the configuration abstraction<br>
has been resolved:</p>
<pre data-role="codeBlock" data-info class="language-"><code>  rule &lt;T&gt;
         &lt;k&gt; . =&gt; FIRST &gt;Int SECOND &lt;/k&gt;
         &lt;state&gt;
           &lt;first&gt; FIRST &lt;/first&gt;
           &lt;second&gt; SECOND &lt;/second&gt;
         &lt;/state&gt;
       &lt;/T&gt;
</code></pre><p>In other words, K will complete cells to the top of the configuration by<br>
inserting parent cells where appropriate based on the declared structure of<br>
the configuration. This is useful because as a definition evolves, the<br>
configuration may change, but you don&apos;t want to have to modify every single<br>
rule each time. Thus, K follows the principle that you should only mention the<br>
cells in a rule that are actually needed in order to accomplish its specific<br>
goal. By following this best practice, you can significantly increase the<br>
modularity of the definition and make it easier to maintain and modify.</p>
<p>Note that unlike top-level rewrite rules, cells that appear inside function<br>
rules are not necessarily completed to the top of the configuration. They still<br>
participate in cell ccompletion in the sense that you can mention cell<br>
structure loosely inside a function rule and it will be completed into the<br>
correct cell structure specified by the configuration declaration. However,<br>
they do not complete all the way to the top, instead completing only up to<br>
the top-most cell mentioned in the rule.</p>
<p>For example, if I write the following function rule in the above definition:</p>
<pre data-role="codeBlock" data-info class="language-"><code>  rule doStuff(&lt;first&gt; FIRST &lt;/first&gt;) =&gt; FIRST
</code></pre><p>The function will only match on the <code>first</code> cell, rather than the entire<br>
configuration. However, if we had mentioned a parent cell in the rule, it still<br>
would have completed the children of that parent cell as needed to ensure that<br>
the resulting term is well formed.</p>
<h3 class="mume-header" id="exercise-1">Exercise</h3>

<p>Modify your definition from the previous exercise in this lesson to wrap the<br>
two cells you have declared in a top cell <code>&lt;T&gt;</code>. You should not have to change<br>
any other rules in the definition.</p>
<h2 class="mume-header" id="cell-variables">Cell Variables</h2>

<p>Sometimes it is desirable to explicitly match a variable against certain<br>
fragments of the configuration. Because K&apos;s configuration is hierarchical,<br>
we can grab subsets of the configuration as if they were just another term.<br>
However, configuration abstraction applies here as well.<br>
In particular, for each cell you specify in a configuration declaration, a<br>
unique sort is assigned for that cell with a single constructor (the cell<br>
itself). The sort name is taken by removing all special characters,<br>
capitalizing the first letter and each letter after a hyphen, and adding the<br>
word <code>Cell</code> at the end. For example, in the above example, the cell sorts are<br>
<code>TCell</code>, <code>KCell</code>, <code>StateCell</code>, <code>FirstCell</code>, and <code>SecondCell</code>. If we had declared<br>
a cell as <code>&lt;first-number&gt;</code>, then the cell sort name would be <code>FirstNumberCell</code>.</p>
<p>You can explicitly reference a variable of one of these sorts anywhere you<br>
might instead write that cell. For example, consider the following rule:</p>
<pre data-role="codeBlock" data-info class="language-"><code>  rule &lt;k&gt; true =&gt; S &lt;/k&gt;
       (S:StateCell =&gt; &lt;state&gt;... .Bag ...&lt;/state&gt;)
</code></pre><p>Here we have introduced two new concepts. The first is the variable of sort<br>
<code>StateCell</code>, which matches the entire <code>&lt;state&gt;</code> part of the configuration. The<br>
second is that we have introduced the concept of <code>...</code> once again. When a cell<br>
contains other cells, it is also possible to specify <code>...</code> on either the left,<br>
right or both sides of the cell term. Each of these three syntaxes are<br>
equivalent in this case. When they appear on the left-hand side of a rule, they<br>
indicate that we don&apos;t care what value any cells not explicitly named might<br>
have. For example, we might write <code>&lt;state&gt;... &lt;first&gt; 0 &lt;/first&gt; ...&lt;/state&gt;</code> on<br>
the left-hand side of a rule in order to indicate that we want to match the<br>
rule when the <code>&lt;first&gt;</code> cell contains a zero, regardless of what the <code>&lt;second&gt;</code><br>
cell contains. If we had not included this ellipsis, it would have been a<br>
syntax error, because K would have expected you to provide a value for each of<br>
the child cells.</p>
<p>However, if, as in the example above, the <code>...</code> appeared on the right-hand side<br>
of a rule, this instead indicates that the cells not explicitly mentioned under<br>
the cell should be initialized with their default value from the configuration<br>
declaration. In other words, that rule will set the value of <code>&lt;first&gt;</code> and<br>
<code>&lt;second&gt;</code> to zero.</p>
<p>You may note the presence of the phrase <code>.Bag</code> here. You can think of this as<br>
the empty set of cells. It is used as the child of a cell when you want to<br>
indicate that no cells should be explicitly named. We will cover other uses<br>
of this term in later lessons.</p>
<h2 class="mume-header" id="exercises">Exercises</h2>

<ol>
<li>Modify the definition from the previous exercise in this lesson so that the<br>
Boolean cell you created is initialized to false. Then add a production<br>
<code>syntax Stmt ::= Bool &quot;;&quot; Exp</code>, and a rule that uses this <code>Stmt</code> to set the<br>
value of the Boolean flag. Then add another production<br>
<code>syntax Stmt ::= &quot;reset&quot; &quot;;&quot; Exp</code> which sets the value of the Boolean flag back<br>
to its default value via a <code>...</code> on the right-hand side. You will need to add<br>
an additional cell around the Boolean cell to make this work.</li>
</ol>
<h2 class="mume-header" id="next-lesson">Next lesson</h2>

<p>Once you have completed the above exercises, you can continue to<br>
<a href="#ebook-heading-lesson-116-maps-semantic-lists-and-sets">Lesson 1.16: Maps, Semantic Lists, and Sets</a>.</p>
</div></div><div id="ebook-heading-lesson-116-maps-semantic-lists-and-sets" ebook-toc-level-3 heading="Lesson 1.16: Maps, Semantic Lists, and Sets"><div><h1 class="mume-header" id="lesson-116-maps-semantic-lists-and-sets">Lesson 1.16: Maps, Semantic Lists, and Sets</h1>

<p>The purpose of this lesson is to explain how to use the data structure sorts<br>
provided by K: maps, lists, and sets.</p>
<h2 class="mume-header" id="maps">Maps</h2>

<p>The most frequently used type of data structure in K is the map. The sort<br>
provided by K for this purpose is the <code>Map</code> sort, and it is provided in<br>
<a href="#ebook-heading-domains">domains.md</a> in the <code>MAP</code><br>
module. This type is not (currently) polymorphic. All <code>Map</code> terms are maps that<br>
map terms of sort <code>KItem</code> to other terms of sort <code>KItem</code>. A <code>KItem</code> can contain<br>
any sort except a <code>K</code> sequence. If you need to store such a term in a<br>
map, you can always use a wrapper such as <code>syntax KItem ::= kseq(K)</code>.</p>
<p>A <code>Map</code> pattern consists of zero or more map elements (as represented by the<br>
symbol <code>syntax Map ::= KItem &quot;|-&gt;&quot; KItem</code>), mixed in any order, separated by<br>
whitespace, with zero or one variables of sort <code>Map</code>. The empty map is<br>
represented by <code>.Map</code>. If all of the bindings for the variables in the keys<br>
of the map can be deterministically chosen, these patterns can be matched in<br>
<code>O(1)</code> time. If they cannot, then each map element that cannot be<br>
deterministically constructed contributes a single dimension of polynomial<br>
time to the cost of the matching. In other words, a single such element is<br>
linear, two are quadratic, three are cubic, etc.</p>
<p>Patterns like the above are the only type of <code>Map</code> pattern that can appear<br>
on the left-hand-side of a rule. In other words, you are not allowed to write<br>
a <code>Map</code> pattern on the left-hand-side with more than one variable of sort <code>Map</code><br>
in it. You are, however, allowed to write such patterns on the right-hand-side<br>
of a rule. You can also write a function pattern in the key of a map element<br>
so long as all the variables in the function pattern can be deterministically<br>
chosen.</p>
<p>Note the meaning of matching on a <code>Map</code> pattern: a map pattern with no<br>
variables of sort <code>Map</code> will match if the map being matched has exactly as<br>
many bindings as <code>|-&gt;</code> symbols in the pattern. It will then match if each<br>
binding in the map pattern matches exactly one distinct binding in the map<br>
being matched. A map pattern with one <code>Map</code> variable will also match any map<br>
that contains such a map as a subset. The variable of sort <code>Map</code> will be bound<br>
to whatever bindings are left over (<code>.Map</code> if there are no bindings left over).</p>
<p>Here is an example of a simple definition that implements a very basic<br>
variable declaration semantics using a <code>Map</code> to store the value of variables<br>
(<code>lesson-16-a.k</code>):</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">16</span><span class="token operator">-</span>A<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> INT<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> ID<span class="token operator">-</span>SYNTAX

  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Id">Id</span> <span class="token operator">|</span> <span class="token keyword keyword-Int">Int</span>
  <span class="token keyword keyword-syntax">syntax</span> Decl <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;int&quot;</span> <span class="token keyword keyword-Id">Id</span> <span class="token string">&quot;=&quot;</span> Exp <span class="token string">&quot;;&quot;</span> <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Pgm <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Decl<span class="token punctuation">,</span><span class="token string">&quot;&quot;</span><span class="token punctuation">}</span>
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">16</span><span class="token operator">-</span>A
  <span class="token keyword keyword-imports">imports</span> LESSON<span class="token operator">-</span><span class="token number">16</span><span class="token operator">-</span>A<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> BOOL

  <span class="token keyword keyword-configuration">configuration</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>T</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> $PGM<span class="token punctuation">:</span>Pgm <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>state</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>state</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>T</span><span class="token punctuation">&gt;</span></span>

  <span class="token comment">// declaration sequence</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> D<span class="token punctuation">:</span>Decl P<span class="token punctuation">:</span>Pgm <span class="token operator">=&gt;</span> D <span class="token operator">~&gt;</span> P <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Pgm <span class="token operator">=&gt;</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>

  <span class="token comment">// variable declaration</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> int X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=</span> I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>state</span><span class="token punctuation">&gt;</span></span> STATE <span class="token operator">=&gt;</span> STATE <span class="token punctuation">[</span> X &lt;<span class="token operator">-</span> I <span class="token punctuation">]</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>state</span><span class="token punctuation">&gt;</span></span>

  <span class="token comment">// variable lookup</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=&gt;</span> I <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>state</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> X <span class="token operator">|</span><span class="token operator">-</span>&gt; I <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>state</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> isKResult<span class="token punctuation">(</span>K<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">,</span> function<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> isKResult<span class="token punctuation">(</span>_<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
  <span class="token keyword keyword-rule">rule</span> isKResult<span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">false</span> <span class="token punctuation">[</span>owise<span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>There are several new features in this definition. First, note we import<br>
the module <code>ID-SYNTAX</code>. This module is defined in <code>domains.md</code> and provides a<br>
basic syntax for identifiers. We are using the <code>Id</code> sort provided by this<br>
module in this definition to implement the names of program variables. This<br>
syntax is only imported when parsing programs, not when parsing rules. Later in<br>
this lesson we will see how to reference specific concrete identifiers in a<br>
rule.</p>
<p>Second, we introduce a single new function over the <code>Map</code> sort. This function,<br>
which is represented by the symbol<br>
<code>syntax Map ::= Map &quot;[&quot; KItem &quot;&lt;-&quot; KItem &quot;]&quot;</code>, represents the map update<br>
operation. Other functions over the <code>Map</code> sort can be found in <code>domains.md</code>.</p>
<p>Finally, we have used the <code>...</code> syntax on a cell containing a Map. In this<br>
case, the meaning of <code>&lt;state&gt;... Pattern ...&lt;/state&gt;</code>,<br>
<code>&lt;state&gt;... Pattern &lt;/state&gt;</code>, and <code>&lt;state&gt; Pattern ...&lt;/state&gt;</code> are the same:<br>
it is equivalent to writing <code>&lt;state&gt; (Pattern) _:Map &lt;/state&gt;</code>.</p>
<p>Consider the following program (<code>a.decl</code>):</p>
<pre data-role="codeBlock" data-info class="language-"><code>int x = 0;
int y = 1;
int a = x;
</code></pre><p>If we run this program with <code>krun</code>, we will get the following result:</p>
<pre data-role="codeBlock" data-info class="language-"><code>&lt;T&gt;
  &lt;k&gt;
    .
  &lt;/k&gt;
  &lt;state&gt;
    a |-&gt; 0
    x |-&gt; 0
    y |-&gt; 1
  &lt;/state&gt;
&lt;/T&gt;
</code></pre><p>Note that <code>krun</code> has automatically sorted the collection for you. This doesn&apos;t<br>
happen at runtime, so you still get the performance of a hash map, but it will<br>
help make the output more readable.</p>
<h3 class="mume-header" id="exercise">Exercise</h3>

<p>Create a sort <code>Stmt</code> that is a subsort of <code>Decl</code>. Create a production of sort<br>
<code>Stmt</code> for variable assignment in addition to the variable declaration<br>
production. Feel free to use the syntax <code>syntax Stmt ::= Id &quot;=&quot; Exp &quot;;&quot;</code>. Write<br>
a rule that implements variable assignment using a map update function. Then<br>
write the same rule using a map pattern. Test your implementations with some<br>
programs to ensure they behave as expected.</p>
<h2 class="mume-header" id="semantic-lists">Semantic Lists</h2>

<p>In a previous lesson, we explained how to represent lists in the AST of a<br>
program. However, this is not the only context where lists can be used. We also<br>
frequently use lists in the configuration of an interpreter in order to<br>
represent certain types of program state. For this purpose, it is generally<br>
useful to have an associative-list sort, rather than the cons-list sorts<br>
provided in <a href="#ebook-heading-lesson-112-syntactic-lists">Lesson 1.12</a>.</p>
<p>The type provided by K for this purpose is the <code>List</code> sort, and it is also<br>
provided in <code>domains.md</code>, in the <code>LIST</code> module. This type is also not<br>
(currently) polymorphic. Like <code>Map</code>, all <code>List</code> terms are lists of terms of the<br>
<code>KItem</code> sort.</p>
<p>A <code>List</code> pattern in K consists of zero or more list elements (as represented by<br>
the <code>ListItem</code> symbol), followed by zero or one variables of sort <code>List</code>,<br>
followed by zero or more list elements. An empty list is represented by<br>
<code>.List</code>. These patterns can be matched in <code>O(log(N))</code> time. This is the only<br>
type of <code>List</code> pattern that can appear on the left-hand-side of a rule. In<br>
other words, you are not allowed to write a <code>List</code> pattern on the<br>
left-hand-side with more than one variable of sort <code>List</code> in it. You are,<br>
however, allowed to write such patterns on the right-hand-side of a rule.</p>
<p>Note the meaning of matching on a <code>List</code> pattern: a list pattern with no<br>
variables of sort <code>List</code> will match if the list being matched has exactly as<br>
many elements as <code>ListItem</code> symbols in the pattern. It will then match if each<br>
element in sequence matches the pattern contained in the <code>ListItem</code> symbol. A<br>
list pattern with one variable of sort <code>List</code> operates the same way, except<br>
that it can match any list with at least as many elements as <code>ListItem</code><br>
symbols, so long as the prefix and suffix of the list match the patterns inside<br>
the <code>ListItem</code> symbols. The variable of sort <code>List</code> will be bound to whatever<br>
elements are left over (<code>.List</code> if there are no elements left over).</p>
<p>The <code>...</code> syntax is allowed on cells containing lists as well. In this case,<br>
the meaning of <code>&lt;cell&gt;... Pattern &lt;/cell&gt;</code> is the same as<br>
<code>&lt;cell&gt; _:List (Pattern) &lt;/cell&gt;</code>, the meaning of <code>&lt;cell&gt; Pattern ...&lt;/cell&gt;</code><br>
is the same as <code>&lt;cell&gt; (Pattern) _:List&lt;/cell&gt;</code>. Because list patterns with<br>
multiple variables of sort <code>List</code> are not allowed, it is an error to write<br>
<code>&lt;cell&gt;... Pattern ...&lt;/cell&gt;</code>.</p>
<p>Here is an example of a simple definition that implements a very basic<br>
function-call semantics using a <code>List</code> as a function stack (<code>lesson-16-b.k</code>):</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">16</span><span class="token operator">-</span>B<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> INT<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> ID<span class="token operator">-</span>SYNTAX

  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Id">Id</span> <span class="token string">&quot;(&quot;</span> <span class="token string">&quot;)&quot;</span> <span class="token operator">|</span> <span class="token keyword keyword-Int">Int</span>
  <span class="token keyword keyword-syntax">syntax</span> Stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;return&quot;</span> Exp <span class="token string">&quot;;&quot;</span> <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Decl <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;fun&quot;</span> <span class="token keyword keyword-Id">Id</span> <span class="token string">&quot;(&quot;</span> <span class="token string">&quot;)&quot;</span> <span class="token string">&quot;{&quot;</span> Stmt <span class="token string">&quot;}&quot;</span>
  <span class="token keyword keyword-syntax">syntax</span> Pgm <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Decl<span class="token punctuation">,</span><span class="token string">&quot;&quot;</span><span class="token punctuation">}</span>
  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Id">Id</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;main&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">16</span><span class="token operator">-</span>B
  <span class="token keyword keyword-imports">imports</span> LESSON<span class="token operator">-</span><span class="token number">16</span><span class="token operator">-</span>B<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> BOOL
  <span class="token keyword keyword-imports">imports</span> LIST

  <span class="token keyword keyword-configuration">configuration</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>T</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> $PGM<span class="token punctuation">:</span>Pgm <span class="token operator">~&gt;</span> main <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>functions</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>functions</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fstack</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fstack</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>T</span><span class="token punctuation">&gt;</span></span>

  <span class="token comment">// declaration sequence</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> D<span class="token punctuation">:</span>Decl P<span class="token punctuation">:</span>Pgm <span class="token operator">=&gt;</span> D <span class="token operator">~&gt;</span> P <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Pgm <span class="token operator">=&gt;</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>

  <span class="token comment">// function definitions</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> fun X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> S <span class="token punctuation">}</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>functions</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Map <span class="token operator">=&gt;</span> X <span class="token operator">|</span><span class="token operator">-</span>&gt; S <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>functions</span><span class="token punctuation">&gt;</span></span>

  <span class="token comment">// function call</span>
  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> stackFrame<span class="token punctuation">(</span>K<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">~&gt;</span> K <span class="token operator">=&gt;</span> S <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>functions</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> X <span class="token operator">|</span><span class="token operator">-</span>&gt; S <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>functions</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fstack</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token operator">=&gt;</span> ListItem<span class="token punctuation">(</span>stackFrame<span class="token punctuation">(</span>K<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fstack</span><span class="token punctuation">&gt;</span></span>

  <span class="token comment">// return statement</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> return I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">;</span> <span class="token operator">~&gt;</span> _ <span class="token operator">=&gt;</span> I <span class="token operator">~&gt;</span> K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fstack</span><span class="token punctuation">&gt;</span></span> ListItem<span class="token punctuation">(</span>stackFrame<span class="token punctuation">(</span>K<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>List <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fstack</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> isKResult<span class="token punctuation">(</span>K<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> isKResult<span class="token punctuation">(</span>_<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
  <span class="token keyword keyword-rule">rule</span> isKResult<span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">false</span> <span class="token punctuation">[</span>owise<span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>Notice that we have declared the production <code>syntax Id ::= &quot;main&quot; [token]</code>.<br>
Since we use the <code>ID-SYNTAX</code> module, this declaration is necessary in order to<br>
be able to refer to the <code>main</code> identifier directly in the configuration<br>
declaration. Our <code>&lt;k&gt;</code> cell now contains a <code>K</code> sequence initially: first we<br>
process all the declarations in the program, then we call the <code>main</code> function.</p>
<p>Consider the following program (<code>foo.func</code>):</p>
<pre data-role="codeBlock" data-info class="language-"><code>fun foo() { return 5; }
fun main() { return foo(); }
</code></pre><p>When we <code>krun</code> this program, we should get the following output:</p>
<pre data-role="codeBlock" data-info class="language-"><code>&lt;T&gt;
  &lt;k&gt;
    5 ~&gt; .
  &lt;/k&gt;
  &lt;functions&gt;
    foo |-&gt; return 5 ;
    main |-&gt; return foo ( ) ;
  &lt;/functions&gt;
  &lt;fstack&gt;
    .List
  &lt;/fstack&gt;
&lt;/T&gt;
</code></pre><p>Note that we have successfully put on the <code>&lt;k&gt;</code> cell the value returned by the<br>
<code>main</code> function.</p>
<h3 class="mume-header" id="exercise-1">Exercise</h3>

<p>Add a term of sort <code>Id</code> to the <code>stackFrame</code> operator to keep track of the<br>
name of the function in that stack frame. Then write a function<br>
<code>syntax String ::= printStackTrace(List)</code> that takes the contents of the<br>
<code>&lt;fstack&gt;</code> cell and pretty prints the current stack trace. You can concatenate<br>
strings with <code>+String</code> in the <code>STRING</code> module in <code>domains.md</code>, and you can<br>
convert an <code>Id</code> to a <code>String</code> with the <code>Id2String</code> function in the <code>ID</code> module.<br>
Test this function by creating a new expression that returns the current stack<br>
trace as a string. Make sure to update <code>isKResult</code> and the <code>Exp</code> sort as<br>
appropriate to allow strings as values.</p>
<h2 class="mume-header" id="sets">Sets</h2>

<p>The final primary data structure sort in K is a set, i.e., an idempotent<br>
unordered collection where elements are deduplicated. The sort provided by K<br>
for this purpose is the <code>Set</code> sort and it is provided in <code>domains.md</code> in the<br>
<code>SET</code> module. Like maps and lists, this type is not (currently) polymorphic.<br>
Like <code>Map</code> and <code>List</code>, all <code>Set</code> terms are sets of terms of the <code>KItem</code> sort.</p>
<p>A <code>Set</code> pattern has the exact same restrictions as a <code>Map</code> pattern, except that<br>
its elements are treated like keys, and there are no values. It has the same<br>
performance characteristics as well. However, syntactically it is more similar<br>
to the <code>List</code> sort: An empty <code>Set</code> is represented by <code>.Set</code>, but a set element<br>
is represented by the <code>SetItem</code> symbol.</p>
<p>Matching behaves similarly to the <code>Map</code> sort: a set pattern with no variables<br>
of sort <code>Set</code> will match if the set has exactly as many bindings as <code>SetItem</code><br>
symbols, and if each element pattern matches one distinct element in the set.<br>
A set with a variable of sort <code>Set</code> also matches any superset of such a set.<br>
As with map, the elements left over will be bound to the <code>Set</code> variable (or<br>
<code>.Set</code> if no elements are left over).</p>
<p>Like <code>Map</code>, the <code>...</code> syntax on a set is syntactic sugar for an anonymous<br>
variable of sort <code>Set</code>.</p>
<p>Here is an example of a simple modification to <code>LESSON-16-A</code> which uses a <code>Set</code><br>
to ensure that variables are never declared more than once. In practice, you<br>
would likely just use the <code>in_keys</code> symbol over maps to test for this, but<br>
it&apos;s still useful as an example of sets in practice:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">16</span><span class="token operator">-</span>C<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> LESSON<span class="token operator">-</span><span class="token number">16</span><span class="token operator">-</span>A<span class="token operator">-</span>SYNTAX
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">16</span><span class="token operator">-</span>C
  <span class="token keyword keyword-imports">imports</span> LESSON<span class="token operator">-</span><span class="token number">16</span><span class="token operator">-</span>C<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> BOOL
  <span class="token keyword keyword-imports">imports</span> SET

  <span class="token keyword keyword-configuration">configuration</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>T</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> $PGM<span class="token punctuation">:</span>Pgm <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>state</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>state</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>declared</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Set <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>declared</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>T</span><span class="token punctuation">&gt;</span></span>

  <span class="token comment">// declaration sequence</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> D<span class="token punctuation">:</span>Decl P<span class="token punctuation">:</span>Pgm <span class="token operator">=&gt;</span> D <span class="token operator">~&gt;</span> P <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Pgm <span class="token operator">=&gt;</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>

  <span class="token comment">// variable declaration</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> int X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=</span> I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>state</span><span class="token punctuation">&gt;</span></span> STATE <span class="token operator">=&gt;</span> STATE <span class="token punctuation">[</span> X &lt;<span class="token operator">-</span> I <span class="token punctuation">]</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>state</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>declared</span><span class="token punctuation">&gt;</span></span> D <span class="token operator">=&gt;</span> D SetItem<span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>declared</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> notBool X in D

  <span class="token comment">// variable lookup</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=&gt;</span> I <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>state</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> X <span class="token operator">|</span><span class="token operator">-</span>&gt; I <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>state</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>declared</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> SetItem<span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>declared</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> isKResult<span class="token punctuation">(</span>K<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">,</span> function<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> isKResult<span class="token punctuation">(</span>_<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
  <span class="token keyword keyword-rule">rule</span> isKResult<span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">false</span> <span class="token punctuation">[</span>owise<span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>Now if we <code>krun</code> a program containing duplicate declarations, it will get<br>
stuck on the declaration.</p>
<h2 class="mume-header" id="exercises">Exercises</h2>

<ol>
<li>Modify your solution to Lesson 1.14, Exercise 2 and introduce the sorts<br>
<code>Decls</code>, <code>Decl</code>, and <code>Stmt</code> which include variable and function declaration<br>
(without function parameters), and return and assignment statements, as well<br>
as call expressions. Use <code>List</code> and <code>Map</code> to implement these operators, making<br>
sure to consider the interactions between components, such as saving and<br>
restoring the environment of variables at each call site. Don&apos;t worry about<br>
local function definitions or global variables for now. Make sure to test the<br>
resulting interpreter.</li>
</ol>
<h2 class="mume-header" id="next-lesson">Next lesson</h2>

<p>Once you have completed the above exercises, you can continue to<br>
<a href="#ebook-heading-lesson-117-cell-multiplicity-and-cell-collections">Lesson 1.17: Cell Multiplicity and Cell Collections</a>.</p>
</div></div><div id="ebook-heading-lesson-117-cell-multiplicity-and-cell-collections" ebook-toc-level-3 heading="Lesson 1.17: Cell Multiplicity and Cell Collections"><div><h1 class="mume-header" id="lesson-117-cell-multiplicity-and-cell-collections">Lesson 1.17: Cell Multiplicity and Cell Collections</h1>

<p>The purpose of this lesson is to explain how you can create optional cells<br>
and cells that repeat multiple times in a configuration using a feature called<br>
<strong>cell multiplicity</strong>.</p>
<h2 class="mume-header" id="cell-multiplicity">Cell Multiplicity</h2>

<p>K allows you to specify attributes for cell productions as part of the syntax<br>
of configuration declarations. Unlike regular productions, which use the <code>[]</code><br>
syntax for attributes, configuration cells use an XML-like attribute syntax:</p>
<pre data-role="codeBlock" data-info class="language-"><code>configuration &lt;k color=&quot;red&quot;&gt; $PGM:K &lt;/k&gt;
</code></pre><p>This configuration declaration gives the <code>&lt;k&gt;</code> cell the color red during<br>
unparsing using the <code>color</code> attribute as discussed in<br>
<a href="#ebook-heading-lesson-19-unparsing-and-the-format-and-color-attributes">Lesson 1.9</a>.</p>
<p>However, in addition to the usual attributes for productions, there are some<br>
other attributes that can be applied to cells with special meaning. One such<br>
attribute is the <code>multiplicity</code> attribute. By default, each cell that is<br>
declared occurs exactly once in every configuration term. However, using the<br>
<code>multiplicity</code> attribute, this default behavior can be changed. There are two<br>
values that this attribute can have: <code>?</code> and <code>*</code>.</p>
<h2 class="mume-header" id="optional-cells">Optional cells</h2>

<p>The first cell multiplicity we will discuss is <code>?</code>. Similar to a regular<br>
expression language, this attribute tells the compiler that this cell can<br>
appear 0 or 1 times in the configuration. In other words, it is an<br>
<strong>optional cell</strong>. By default, K does not create optional cells in the initial<br>
configuration, unless that optional cell has a configuration variable inside<br>
it. However, it is possible to override the default behavior and create that<br>
cell initially by adding the additional cell attribute <code>initial=&quot;&quot;</code>.</p>
<p>K uses the <code>.Bag</code> symbol to represent the absence of any cells in a particular<br>
rule. Consider the following module:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">17</span><span class="token operator">-</span>A
  <span class="token keyword keyword-imports">imports</span> INT

  <span class="token keyword keyword-configuration">configuration</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> $PGM<span class="token punctuation">:</span>K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>optional</span> <span class="token attr-name">multiplicity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>?<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token number">0</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>optional</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;init&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;destroy&quot;</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> init <span class="token operator">=&gt;</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token punctuation">(</span><span class="token punctuation">.</span>Bag <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>optional</span><span class="token punctuation">&gt;</span></span> <span class="token number">0</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>optional</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> destroy <span class="token operator">=&gt;</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>optional</span><span class="token punctuation">&gt;</span></span> _ <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>optional</span><span class="token punctuation">&gt;</span></span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Bag<span class="token punctuation">)</span>

<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>In this definition, when the <code>init</code> symbol is executed, the <code>&lt;optional&gt;</code> cell<br>
is added to the configuration, and when the <code>destroy</code> symbol is executed, it<br>
is removed. Any rule that matches on that cell will only match if that cell is<br>
present in the configuration.</p>
<h3 class="mume-header" id="exercise">Exercise</h3>

<p>Create a simple definition with a <code>Stmts</code> sort that is a <code>List{Stmt,&quot;&quot;}</code> and<br>
a <code>Stmt</code> sort with the constructors<br>
<code>syntax Stmt ::= &quot;enable&quot; | &quot;increment&quot; | &quot;decrement&quot; | &quot;disable&quot;</code>. The<br>
configuration should have an optional cell that contains an integer that<br>
is created with the <code>enable</code> command, destroyed with the <code>disable</code> command,<br>
and its value is incremented or decremented by the <code>increment</code> and <code>decrement</code><br>
command.</p>
<h2 class="mume-header" id="cell-collections">Cell collections</h2>

<p>The second type of cell multiplicity we will discuss is <code>*</code>. Simlar to a<br>
regular expression language, this attribute tells the compiler that this cell<br>
can appear 0 or more times in the configuration. In other words, it is a<br>
<strong>cell collection</strong>. Cells with multiplicity <code>*</code> must be the only child of<br>
their parent cell. As a convention, the inner cell is usually named with the<br>
singular form of what it contains, and the outer cell with the plural form, for<br>
example, &quot;thread&quot; and &quot;threads&quot;.</p>
<p>All cell collections are required to have the <code>type</code> attribute set to either<br>
<code>Set</code> or <code>Map</code>. A <code>Set</code> cell collection is represented as a set and behaves<br>
internally the same as the <code>Set</code> sort, although it actually declares a new<br>
sort. A <code>Map</code> cell collection is represented as a <code>Map</code> in which the first<br>
subcell of the cell collection is the key and the remaining cells are the<br>
value.</p>
<p>For example, consider the following module:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">17</span><span class="token operator">-</span>B
  <span class="token keyword keyword-imports">imports</span> INT
  <span class="token keyword keyword-imports">imports</span> BOOL
  <span class="token keyword keyword-imports">imports</span> ID<span class="token operator">-</span>SYNTAX

  <span class="token keyword keyword-syntax">syntax</span> Stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Id">Id</span> <span class="token string">&quot;=&quot;</span> Exp <span class="token string">&quot;;&quot;</span> <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;return&quot;</span> Exp <span class="token string">&quot;;&quot;</span> <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Stmts <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Stmt<span class="token punctuation">,</span><span class="token string">&quot;&quot;</span><span class="token punctuation">}</span>
  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Id">Id</span>
               <span class="token operator">|</span> <span class="token keyword keyword-Int">Int</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;+&quot;</span> Exp <span class="token punctuation">[</span><span class="token class-name">seqstrict</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;spawn&quot;</span> <span class="token string">&quot;{&quot;</span> Stmts <span class="token string">&quot;}&quot;</span>
               <span class="token operator">|</span> <span class="token string">&quot;join&quot;</span> Exp <span class="token string">&quot;;&quot;</span> <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-configuration">configuration</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>threads</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>thread</span> <span class="token attr-name">multiplicity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>*<span class="token punctuation">&quot;</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Map<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">&gt;</span></span> <span class="token number">0</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">&gt;</span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> $PGM<span class="token punctuation">:</span>K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>thread</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>threads</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>state</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>state</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>next-id</span><span class="token punctuation">&gt;</span></span> <span class="token number">1</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>next-id</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=&gt;</span> I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>state</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> X <span class="token operator">|</span><span class="token operator">-</span>&gt; I <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>state</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=</span> I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>state</span><span class="token punctuation">&gt;</span></span> STATE <span class="token operator">=&gt;</span> STATE <span class="token punctuation">[</span> X &lt;<span class="token operator">-</span> I <span class="token punctuation">]</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>state</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> S<span class="token punctuation">:</span>Stmt Ss<span class="token punctuation">:</span>Stmts <span class="token operator">=&gt;</span> S <span class="token operator">~&gt;</span> Ss <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> I1<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">+</span> I2<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">=&gt;</span> I1 <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> I2 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>thread</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> spawn <span class="token punctuation">{</span> Ss <span class="token punctuation">}</span> <span class="token operator">=&gt;</span> NEXTID <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>thread</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>next-id</span><span class="token punctuation">&gt;</span></span> NEXTID <span class="token operator">=&gt;</span> NEXTID <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>next-id</span><span class="token punctuation">&gt;</span></span>
       <span class="token punctuation">(</span><span class="token punctuation">.</span>Bag <span class="token operator">=&gt;</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>thread</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">&gt;</span></span> NEXTID <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> Ss <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>thread</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>thread</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> join ID<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">;</span> <span class="token operator">=&gt;</span> I <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>thread</span><span class="token punctuation">&gt;</span></span>
       <span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>thread</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">&gt;</span></span> ID <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> return I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>thread</span><span class="token punctuation">&gt;</span></span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Bag<span class="token punctuation">)</span>

  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> isKResult<span class="token punctuation">(</span>K<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> isKResult<span class="token punctuation">(</span>_<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
  <span class="token keyword keyword-rule">rule</span> isKResult<span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">false</span> <span class="token punctuation">[</span>owise<span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>This module implements a very basic fork/join semantics. The <code>spawn</code> expression<br>
spawns a new thread to execute a sequence of statements and returns a thread<br>
id, and the <code>join</code> statement waits until a thread executes <code>return</code> and then<br>
returns the return value of the thread.</p>
<p>Note something quite novel here: the <code>&lt;k&gt;</code> cell is inside a cell of<br>
multiplicity <code>*</code>. Since the <code>&lt;k&gt;</code> cell is just a regular cell (mostly), this<br>
is perfectly allowable. Rules that don&apos;t mention a specific thread are<br>
automatically completed to match any thread.</p>
<p>When you execute programs in this language, the cells in the cell collection<br>
get sorted and printed like any other collection, but they still display like<br>
cells. Rules in this language also benefit from all the structural power of<br>
cells, allowing you to omit cells you don&apos;t care about or complete the<br>
configuration automatically. This allows you to have the power of cells while<br>
still being a collection under the hood.</p>
<h2 class="mume-header" id="exercises">Exercises</h2>

<ol>
<li>Modify the solution from Lesson 1.16, Exercise 1 so that the cell you use to<br>
keep track of functions in a <code>Map</code> is now a cell collection. Run some programs<br>
and compare how they get unparsed before and after this change.</li>
</ol>
<h2 class="mume-header" id="next-lesson">Next lesson</h2>

<p>Once you have completed the above exercises, you can continue to<br>
<a href="#ebook-heading-lesson-118-term-equality-and-the-ternary-operator">Lesson 1.18: Term Equality and the Ternary Operator</a>.</p>
</div></div><div id="ebook-heading-lesson-118-term-equality-and-the-ternary-operator" ebook-toc-level-3 heading="Lesson 1.18: Term Equality and the Ternary Operator"><div><h1 class="mume-header" id="lesson-118-term-equality-and-the-ternary-operator">Lesson 1.18: Term Equality and the Ternary Operator</h1>

<p>The purpose of this lesson is to introduce how to compare equality of terms in<br>
K, and how to put conditional expressions directly into the right-hand side of<br>
rules.</p>
<h2 class="mume-header" id="term-equality">Term Equality</h2>

<p>One major way you can compare whether two terms are equal in K is to simply<br>
match both terms with a variable with the same name. This will only succeed<br>
in matching if the two terms are equal structurally. However, sometimes this<br>
is impractical, and it is useful to have access to a way to actually compare<br>
whether two terms in K are equal. The operator for this is found in<br>
<a href="#ebook-heading-domains">domains.md</a> in the <code>K-EQUAL</code><br>
module. The operator is <code>==K</code> and takes two terms of sort <code>K</code> and returns a<br>
<code>Bool</code>. It returns true if they are equal. This includes equality over builtin<br>
types such as <code>Map</code> and <code>Set</code> where equality is not purely structural in<br>
nature. However, it does not include any notion of semantic equality over<br>
user-defined syntax. The inverse symbol for inequality is <code>=/=K</code>.</p>
<h2 class="mume-header" id="ternary-operator">Ternary Operator</h2>

<p>One way to introduce conditional logic in K is to have two separate rules,<br>
each with a side condition (or one rule with a side condition and another with<br>
the <code>owise</code> attribute). However, sometimes it is useful to explicitly write<br>
a conditional expression directly in the right-hand side of a rule. For this<br>
purpose, K defines one more operator in the <code>K-EQUAL</code> module, which corresponds<br>
to the usual ternary operator found in many languages. Here is an example of its<br>
usage (<code>lesson-18.k</code>):</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">18</span>
  <span class="token keyword keyword-imports">imports</span> INT
  <span class="token keyword keyword-imports">imports</span> BOOL
  <span class="token keyword keyword-imports">imports</span> K<span class="token operator">-</span>EQUAL

  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span> <span class="token operator">|</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token operator">|</span> <span class="token string">&quot;if&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Exp <span class="token string">&quot;else&quot;</span> Exp <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> isKResult<span class="token punctuation">(</span>K<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> isKResult<span class="token punctuation">(</span>_<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
  <span class="token keyword keyword-rule">rule</span> isKResult<span class="token punctuation">(</span>_<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">true</span>

  <span class="token keyword keyword-rule">rule</span> if <span class="token punctuation">(</span>B<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span><span class="token punctuation">)</span> E1<span class="token punctuation">:</span>Exp else E2<span class="token punctuation">:</span>Exp <span class="token operator">=&gt;</span> #if B #then E1 #else E2 #fi
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>Note the symbol on the right-hand side of the final rule. This symbol is<br>
polymorphic: <code>B</code> must be of sort <code>Bool</code>, but <code>E1</code> and <code>E2</code> could have been<br>
any sort so long as both were of the same sort, and the sort of the entire<br>
expression becomes equal to that sort. K supports polymorphic built-in<br>
operators, but does not yet allow users to write their own polymorphic<br>
productions.</p>
<p>The behavior of this function is to evaluate the Boolean expression to a<br>
Boolean, then pick one of the two children and return it based on whether the<br>
Boolean is true or false. Please note that it is not a good idea to use this<br>
symbol in cases where one or both of the children is potentially undefined<br>
(for example, an integer expression that divides by zero). While the default<br>
implementation is smart enough to only evaluate the branch that happens to be<br>
picked, this will not be true when we begin to do program verification. If<br>
you need short circuiting behavior, it is better to use a side condition.</p>
<h2 class="mume-header" id="exercises">Exercises</h2>

<ol>
<li>
<p>Write a function in K that takes two terms of sort <code>K</code> and returns an<br>
<code>Int</code>: the <code>Int</code> should be 0 if the terms are equal and 1 if the terms are<br>
unequal.</p>
</li>
<li>
<p>Modify your solution to <a href="#ebook-heading-lesson-116-maps-semantic-lists-and-sets">Lesson 1.16</a>, Exercise 1 and introduce an <code>if</code><br>
<code>Stmt</code> to the syntax of the language, then implement it using the <code>#if</code> symbol.<br>
Make sure to write tests for the resulting interpreter.</p>
</li>
</ol>
<h2 class="mume-header" id="next-lesson">Next lesson</h2>

<p>Once you have completed the above exercises, you can continue to<br>
<a href="#ebook-heading-lesson-119-debugging-with-gdb-or-lldb">Lesson 1.19: Debugging with GDB</a>.</p>
</div></div><div id="ebook-heading-lesson-119-debugging-with-gdb-or-lldb" ebook-toc-level-3 heading="Lesson 1.19: Debugging with GDB or LLDB"><div><h1 class="mume-header" id="lesson-119-debugging-with-gdb-or-lldb">Lesson 1.19: Debugging with GDB or LLDB</h1>

<p>The purpose of this lesson is to teach how to debug your K interpreter using<br>
the K-language support provided in <a href="https://www.gnu.org/software/gdb/">GDB</a> or<br>
<a href="https://lldb.llvm.org/index.html">LLDB</a>.</p>
<h2 class="mume-header" id="caveats">Caveats</h2>

<p>This lesson has been written with GDB support on Linux in mind. Unfortunately,<br>
on macOS, GDB has limited support. To address this, we have introduced early<br>
experimental support for debugging with LLDB on macOS. In some cases, the<br>
features supported by LLDB are slightly different to those supported by GDB; the<br>
tutorial text will make this clear where necessary. If you use a macOS with an<br>
LLVM version older than 15, you may need to upgrade it to use the LLDB<br>
correctly. If you encounter an issue on either operating system, please open an<br>
issue against the <a href="https://github.com/runtimeverification/k">K repository</a>.</p>
<h2 class="mume-header" id="getting-started">Getting started</h2>

<p>On Linux, you will need GDB in order to complete this lesson. If you do not<br>
already have GDB installed, then do so. Steps to install GDB are outlined in<br>
this <a href="http://www.gdbtutorial.com/tutorial/how-install-gdb">GDB Tutorial</a>.</p>
<p>On macOS, LLDB should already have been installed with K&apos;s build dependencies<br>
(whether you have built K from source, or installed it using <code>kup</code> or Homebrew).</p>
<p>The first thing neccessary in order to debug a K interpreter is to build the<br>
interpreter with full debugging support enabled. This can be done relatively<br>
simply. First, run <code>kompile</code> with the command line flag <code>--enable-llvm-debug</code>.<br>
The resulting compiled K definition will be ready to support debugging.</p>
<p>Once you have a compiled K definition and a program you wish to debug, you can<br>
start the debugger by passing the <code>--debugger</code> flag to <code>krun</code>. This will<br>
automatically load the program you are executing into GDB and drop you into a<br>
GDB shell ready to start executing the program.</p>
<p>As an example, consider the following K definition (<code>lesson-19-a.k</code>):</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">19</span><span class="token operator">-</span>A
  <span class="token keyword keyword-imports">imports</span> INT

  <span class="token keyword keyword-rule">rule</span> I <span class="token operator">=&gt;</span> I <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span>
    <span class="token keyword keyword-requires">requires</span> I &lt;<span class="token keyword keyword-Int">Int</span> <span class="token number">100</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>If we compile this definition with <code>kompile lesson-19-a.k --enable-llvm-debug</code>,<br>
and run the program <code>0</code> in the debugger with <code>krun -cPGM=0 --debugger</code>, we will<br>
see the following output (roughly, and depending on which platform you are<br>
using):</p>
<h3 class="mume-header" id="gdb-linux">GDB / Linux</h3>

<pre data-role="codeBlock" data-info class="language-"><code>GNU gdb (Ubuntu 9.2-0ubuntu1~20.04) 9.2
Copyright (C) 2020 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type &quot;show copying&quot; and &quot;show warranty&quot; for details.
This GDB was configured as &quot;x86_64-linux-gnu&quot;.
Type &quot;show configuration&quot; for configuration details.
For bug reporting instructions, please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;.
Find the GDB manual and other documentation resources online at:
    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.

For help, type &quot;help&quot;.
Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...
Reading symbols from ./lesson-19-a-kompiled/interpreter...
warning: File &quot;/home/dwightguth/kframework-5.0.0/k-distribution/k-tutorial/1_basic/19_debugging/lesson-19-a-kompiled/interpreter&quot; auto-loading has been declined by your `auto-load safe-path&apos; set to &quot;$debugdir:$datadir/auto-load&quot;.
To enable execution of this file add
        add-auto-load-safe-path /home/dwightguth/kframework-5.0.0/k-distribution/k-tutorial/1_basic/19_debugging/lesson-19-a-kompiled/interpreter
line to your configuration file &quot;/home/dwightguth/.gdbinit&quot;.
To completely disable this security protection add
        set auto-load safe-path /
line to your configuration file &quot;/home/dwightguth/.gdbinit&quot;.
For more information about this security protection see the
&quot;Auto-loading safe path&quot; section in the GDB manual.  E.g., run from the shell:
        info &quot;(gdb)Auto-loading safe path&quot;
(gdb)
</code></pre><p>To make full advantage of the GDB features of K, you should follow the first<br>
command listed in this output message and add the corresponding<br>
<code>add-auto-load-safe-path</code> command to your <code>~/.gdbinit</code> file as prompted.<br>
Please note that the path will be different on your machine than the one<br>
listed above. Adding directories to the &quot;load safe path&quot; effectively tells GDB<br>
to trust those directories. All content under a given directory will be recursively<br>
trusted, so if you want to avoid having to add paths to the &quot;load safe path&quot; every<br>
time you kompile a different <code>K</code> definition, then you can just trust a minimal<br>
directory containing all your kompiled files; however, do not choose a top-level directory containing arbitrary files as this amounts to trusting arbitrary files and is a security risk. More info on the load safe path<br>
can be found <a href="https://sourceware.org/gdb/onlinedocs/gdb/Auto_002dloading-safe-path.html">here</a>.</p>
<h3 class="mume-header" id="lldb-macos">LLDB / macOS</h3>

<pre data-role="codeBlock" data-info class="language-"><code>(lldb) target create &quot;./lesson-19-a-kompiled/interpreter&quot;
warning: &apos;interpreter&apos; contains a debug script. To run this script in this debug session:

    command script import &quot;/Users/brucecollie/code/scratch/lesson-19-a-kompiled/interpreter.dSYM/Contents/Resources/Python/interpreter.py&quot;

To run all discovered debug scripts in this session:

    settings set target.load-script-from-symbol-file true

Current executable set to &apos;/Users/brucecollie/code/scratch/lesson-19-a-kompiled/interpreter&apos; (x86_64).
(lldb) settings set -- target.run-args  &quot;.krun-2023-03-20-11-22-46-TcYt9ffhb2/tmp.in.RupiLwHNfn&quot; &quot;-1&quot; &quot;.krun-2023-03-20-11-22-46-TcYt9ffhb2/result.kore&quot;
(lldb) 
</code></pre><p>LLDB applies slightly different security policies to GDB. To load K&apos;s debugging<br>
scripts for this session only, you can run the <code>command script import</code> line at<br>
the LLDB prompt. The loaded scripts will not persist across debugging sessions<br>
if you do this. It is also possible to configure LLDB to automatically load the<br>
K scripts when an interpreter is started in LLDB; doing so requires a slightly<br>
less broad permission than GDB.</p>
<p>On macOS, the <code>.dSYM</code> directory that contains debugging symbols for an<br>
executable can also contain Python scripts in <code>Contents/Resources/Python</code>. If<br>
there is a Python script with a name matching the name of the current executable<br>
(here, <code>interpreter</code> and <code>interpreter.py</code>), it will be automatically loaded if<br>
the <code>target.load-script-from-symbol-file</code> setting is set). You can therefore add<br>
the <code>settings set</code> command to your <code>~/.lldbinit</code> without enabling full arbitrary<br>
code execution, but you should be aware of the paths from which code <em>can</em> be<br>
executed if you do so.</p>
<h2 class="mume-header" id="basic-commands">Basic commands</h2>

<blockquote>
<p><strong>LLDB Note:</strong> the <code>k start</code> and <code>k step</code> commands are currently not<br>
implemented in the K LLDB scripts. To work around this limitation temporarily,<br>
you can run <code>process launch --stop-at-entry</code> instead of <code>k start</code>. To emulate<br>
<code>k step</code>, first run <code>rbreak k_step</code> once, then <code>continue</code> instead of each <code>k step</code>. We hope to address these limitations soon.</p>
</blockquote>
<p>The most basic commands you can execute in the K GDB session are to run your<br>
program or to step through it. The first can be accomplished using GDB&apos;s<br>
built-in <code>run</code> command. This will automatically start the program and begin<br>
executing it. It will continue until the program aborts or finishes, or the<br>
debugger is interrupted with Ctrl-C.</p>
<p>Sometimes you want finer-grained control over how you proceed through the<br>
program you are debugging. To step through the rule applications in your<br>
program, you can use the <code>k start</code> and <code>k step</code> GDB commands.</p>
<p><code>k start</code> is similar to the built-in <code>start</code> command in that it starts the<br>
program and then immediately breaks before doing any work. However, unlike<br>
the <code>start</code> command which will break immediately after the <code>main</code> method of<br>
a program is executed, the <code>K start</code> program will initialize the rewriter,<br>
evaluate the initial configuration, and break immediately prior to applying<br>
any rewrite steps.</p>
<p>In the example above, here is what we see when we run the <code>k start</code> command:</p>
<pre data-role="codeBlock" data-info class="language-"><code>Temporary breakpoint 1 at 0x239210
Starting program: /home/dwightguth/kframework-5.0.0/k-distribution/k-tutorial/1_basic/19_debugging/lesson-19-a-kompiled/interpreter .krun-2021-08-13-14-10-50-sMwBkbRicw/tmp.in.01aQt85TaA -1 .krun-2021-08-13-14-10-50-sMwBkbRicw/result.kore
[Thread debugging using libthread_db enabled]
Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.

Temporary breakpoint 1, 0x0000000000239210 in main ()
0x0000000000231890 in step (subject=&lt;k&gt;
  0 ~&gt; .
&lt;/k&gt;)
(gdb)
</code></pre><p>As you can see, we are stopped at the <code>step</code> function in the interpreter.<br>
This function is responsible for taking top-level rewrite steps. The <code>subject</code><br>
parameter to this function is the current K configuration.</p>
<p>We can step through K rewrite steps one at a time by running the <code>k step</code><br>
command. By default, this takes a single rewrite step (including any function<br>
rule applications that are part of that step).</p>
<p>Here is what we see when we run that command:</p>
<pre data-role="codeBlock" data-info class="language-"><code>Continuing.

Temporary breakpoint -22, 0x0000000000231890 in step (subject=&lt;k&gt;
  1 ~&gt; .
&lt;/k&gt;)
(gdb)
</code></pre><p>As we can see, we have taken a single rewrite step. We can also pass a number<br>
to the <code>k step</code> command which indicates the number of rewrite steps to take.</p>
<p>Here is what we see if we run <code>k step 10</code>:</p>
<pre data-role="codeBlock" data-info class="language-"><code>Continuing.

Temporary breakpoint -23, 0x0000000000231890 in step (subject=&lt;k&gt;
  11 ~&gt; .
&lt;/k&gt;)
(gdb)
</code></pre><p>As we can see, ten rewrite steps were taken.</p>
<h2 class="mume-header" id="breakpoints">Breakpoints</h2>

<p>The next important step in debugging an application in GDB is to be able to<br>
set breakpoints. Generally speaking, there are three types of breakpoints we<br>
are interested in a K semantics: Setting a breakpoint when a particular<br>
function is called, setting a breakpoint when a particular rule is applied,<br>
and setting a breakpoint when a side condition of a rule is evaluated.</p>
<p>The easiest way to do the first two things is to set a breakpoint on the<br>
line of code containing the function or rule.</p>
<p>For example, consider the following K definition (<code>lesson-19-b.k</code>):</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">19</span><span class="token operator">-</span>B
  <span class="token keyword keyword-imports">imports</span> BOOL

  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> isBlue<span class="token punctuation">(</span>Fruit<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Fruit <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Blueberry<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">|</span> Banana<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> isBlue<span class="token punctuation">(</span>Blueberry<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
  <span class="token keyword keyword-rule">rule</span> isBlue<span class="token punctuation">(</span>Banana<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">false</span>

  <span class="token keyword keyword-rule">rule</span> F<span class="token punctuation">:</span>Fruit <span class="token operator">=&gt;</span> isBlue<span class="token punctuation">(</span>F<span class="token punctuation">)</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>Once this program has been compiled for debugging, we can run the program<br>
<code>Blueberry()</code>. We can then set a breakpoint that stops when the <code>isBlue</code><br>
function is called with the following command in GDB:</p>
<pre data-role="codeBlock" data-info class="language-"><code>break lesson-19-b.k:4
</code></pre><p>Similarly, in LLDB, run:</p>
<pre data-role="codeBlock" data-info class="language-"><code>breakpoint set --file lesson-19-b.k --line 4
</code></pre><p>Here is what we see if we set this breakpoint and then run the interpreter:</p>
<pre data-role="codeBlock" data-info class="language-"><code>(gdb) break lesson-19-b.k:4
Breakpoint 1 at 0x231040: file /home/dwightguth/kframework-5.0.0/k-distribution/k-tutorial/1_basic/19_debugging/lesson-19-b.k, line 4.
(gdb) run
Starting program: /home/dwightguth/kframework-5.0.0/k-distribution/k-tutorial/1_basic/19_debugging/lesson-19-b-kompiled/interpreter .krun-2021-08-13-14-20-27-vXOQmV6lwS/tmp.in.fga98yqXlc -1 .krun-2021-08-13-14-20-27-vXOQmV6lwS/result.kore
[Thread debugging using libthread_db enabled]
Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.

Breakpoint 1, LblisBlue&apos;LParUndsRParUnds&apos;LESSON-19-B&apos;Unds&apos;Bool&apos;Unds&apos;Fruit (_1=Blueberry ( )) at /home/dwightguth/kframework-5.0.0/k-distribution/k-tutorial/1_basic/19_debugging/lesson-19-b.k:4
4         syntax Bool ::= isBlue(Fruit) [function]
(gdb)
</code></pre><pre data-role="codeBlock" data-info class="language-"><code>(lldb) breakpoint set --file lesson-19-b.k --line 4
Breakpoint 1: where = interpreter`LblisBlue&apos;LParUndsRParUnds&apos;LESSON-19-B&apos;Unds&apos;Bool&apos;Unds&apos;Fruit + 20 at lesson-19-b.k:4:19, address = 0x0000000100003ff4
(lldb) run
Process 50546 launched: &apos;/Users/brucecollie/code/scratch/lesson-19-b-kompiled/interpreter&apos; (x86_64)
Process 50546 stopped
* thread #1, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 1.1
    frame #0: 0x0000000100003ff4 interpreter`LblisBlue&apos;LParUndsRParUnds&apos;LESSON-19-B&apos;Unds&apos;Bool&apos;Unds&apos;Fruit(_1=Blueberry ( )) at lesson-19-b.k:4:19
   1   	module LESSON-19-B
   2   	  imports BOOL
   3   	
-&gt; 4   	  syntax Bool ::= isBlue(Fruit) [function]
   5   	  syntax Fruit ::= Blueberry() | Banana()
   6   	  rule isBlue(Blueberry()) =&gt; true
   7   	  rule isBlue(Banana()) =&gt; false
(lldb)
</code></pre><p>As we can see, we have stopped at the point where we are evaluating that<br>
function. The value <code>_1</code> that is a parameter to that function shows the<br>
value passed to the function by the caller.</p>
<p>We can also break when the <code>isBlue(Blueberry()) =&gt; true</code> rule applies by simply<br>
changing the line number to the line number of that rule:</p>
<pre data-role="codeBlock" data-info class="language-"><code>(gdb) break lesson-19-b.k:6
Breakpoint 1 at 0x2af710: file /home/dwightguth/kframework-5.0.0/k-distribution/k-tutorial/1_basic/19_debugging/lesson-19-b.k, line 6.
(gdb) run
Starting program: /home/dwightguth/kframework-5.0.0/k-distribution/k-tutorial/1_basic/19_debugging/lesson-19-b-kompiled/interpreter .krun-2021-08-13-14-32-36-7kD0ic7XwD/tmp.in.8JNH5Qtmow -1 .krun-2021-08-13-14-32-36-7kD0ic7XwD/result.kore
[Thread debugging using libthread_db enabled]
Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.

Breakpoint 1, apply_rule_138 () at /home/dwightguth/kframework-5.0.0/k-distribution/k-tutorial/1_basic/19_debugging/lesson-19-b.k:6
6         rule isBlue(Blueberry()) =&gt; true
(gdb)
</code></pre><pre data-role="codeBlock" data-info class="language-"><code>(lldb) breakpoint set --file lesson-19-b.k --line 6
Breakpoint 1: where = interpreter`apply_rule_140 at lesson-19-b.k:6:8, address = 0x0000000100004620
(lldb) run
Process 50681 launched: &apos;/Users/brucecollie/code/scratch/lesson-19-b-kompiled/interpreter&apos; (x86_64)
Process 50681 stopped
* thread #1, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 1.1
    frame #0: 0x0000000100004620 interpreter`apply_rule_140 at lesson-19-b.k:6:8
   3   	
   4   	  syntax Bool ::= isBlue(Fruit) [function]
   5   	  syntax Fruit ::= Blueberry() | Banana()
-&gt; 6   	  rule isBlue(Blueberry()) =&gt; true
   7   	  rule isBlue(Banana()) =&gt; false
   8   	
   9   	  rule F:Fruit =&gt; isBlue(F)
(lldb) 
</code></pre><p>We can also do the same with a top-level rule:</p>
<pre data-role="codeBlock" data-info class="language-"><code>(gdb) break lesson-19-b.k:9
Breakpoint 1 at 0x2aefa0: lesson-19-b.k:9. (2 locations)
(gdb) run
Starting program: /home/dwightguth/kframework-5.0.0/k-distribution/k-tutorial/1_basic/19_debugging/lesson-19-b-kompiled/interpreter .krun-2021-08-13-14-33-13-9fC8Sz4aO3/tmp.in.jih1vtxSiQ -1 .krun-2021-08-13-14-33-13-9fC8Sz4aO3/result.kore
[Thread debugging using libthread_db enabled]
Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.

Breakpoint 1, apply_rule_107 (Var&apos;Unds&apos;DotVar0=&lt;generatedCounter&gt;
  0
&lt;/generatedCounter&gt;, Var&apos;Unds&apos;DotVar1=., VarF=Blueberry ( )) at /home/dwightguth/kframework-5.0.0/k-distribution/k-tutorial/1_basic/19_debugging/lesson-19-b.k:9
9         rule F:Fruit =&gt; isBlue(F)
(gdb)
</code></pre><pre data-role="codeBlock" data-info class="language-"><code>(lldb) breakpoint set --file lesson-19-b.k --line 9
Breakpoint 1: 2 locations.
(lldb) run
Process 50798 launched: &apos;/Users/brucecollie/code/scratch/lesson-19-b-kompiled/interpreter&apos; (x86_64)
Process 50798 stopped
* thread #1, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 1.1
    frame #0: 0x0000000100003f2e interpreter`apply_rule_109(Var&apos;Unds&apos;DotVar0=&lt;generatedCounter&gt;
  0
&lt;/generatedCounter&gt;, Var&apos;Unds&apos;DotVar1=., VarF=Blueberry ( )) at lesson-19-b.k:9:8
   6   	  rule isBlue(Blueberry()) =&gt; true
   7   	  rule isBlue(Banana()) =&gt; false
   8   	
-&gt; 9   	  rule F:Fruit =&gt; isBlue(F)
   10  	endmodule
(lldb)  
</code></pre><p>Unlike the function rule above, we see several parameters to this function.<br>
These are the substitution that was matched for the function. Variables only<br>
appear in this substitution if they are actually used on the right-hand side<br>
of the rule.</p>
<h2 class="mume-header" id="advanced-breakpoints">Advanced breakpoints</h2>

<p>Sometimes it is inconvenient to set the breakpoint based on a line number.</p>
<p>It is also possible to set a breakpoint based on the rule label of a particular<br>
rule. Consider the following definition (<code>lesson-19-c.k</code>):</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">19</span><span class="token operator">-</span>C
  <span class="token keyword keyword-imports">imports</span> INT
  <span class="token keyword keyword-imports">imports</span> BOOL

  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> isEven<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">[</span>isEven<span class="token punctuation">]</span><span class="token punctuation">:</span> isEven<span class="token punctuation">(</span>I<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">true</span> <span class="token keyword keyword-requires">requires</span> I <span class="token operator">%</span><span class="token keyword keyword-Int">Int</span> <span class="token number">2</span> <span class="token operator">==</span><span class="token keyword keyword-Int">Int</span> <span class="token number">0</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">[</span>isOdd<span class="token punctuation">]</span><span class="token punctuation">:</span> isEven<span class="token punctuation">(</span>I<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">false</span> <span class="token keyword keyword-requires">requires</span> I <span class="token operator">%</span><span class="token keyword keyword-Int">Int</span> <span class="token number">2</span> <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span><span class="token keyword keyword-Int">Int</span> <span class="token number">0</span>

<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>We will run the program <code>isEven(4)</code>. We can set a breakpoint for when a rule<br>
applies by means of the <code>MODULE-NAME.label.rhs</code> syntax:</p>
<pre data-role="codeBlock" data-info class="language-"><code>(gdb) break LESSON-19-C.isEven.rhs
Breakpoint 1 at 0x2afda0: file /home/dwightguth/kframework-5.0.0/k-distribution/k-tutorial/1_basic/19_debugging/lesson-19-c.k, line 6.
(gdb) run
Starting program: /home/dwightguth/kframework-5.0.0/k-distribution/k-tutorial/1_basic/19_debugging/lesson-19-c-kompiled/interpreter .krun-2021-08-13-14-40-29-LNNT8YEZ61/tmp.in.ZG93vWCGGC -1 .krun-2021-08-13-14-40-29-LNNT8YEZ61/result.kore
[Thread debugging using libthread_db enabled]
Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.

Breakpoint 1, LESSON-19-C.isEven.rhs () at /home/dwightguth/kframework-5.0.0/k-distribution/k-tutorial/1_basic/19_debugging/lesson-19-c.k:6
6         rule [isEven]: isEven(I) =&gt; true requires I %Int 2 ==Int 0
(gdb)
</code></pre><pre data-role="codeBlock" data-info class="language-"><code>(lldb) breakpoint set --name LESSON-19-C.isEven.rhs
Breakpoint 1: where = interpreter`LESSON-19-C.isEven.rhs at lesson-19-c.k:6:18, address = 0x00000001000038e0
(lldb) run
Process 51205 launched: &apos;/Users/brucecollie/code/scratch/lesson-19-c-kompiled/interpreter&apos; (x86_64)
Process 51205 stopped
* thread #1, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 1.1
    frame #0: 0x00000001000038e0 interpreter`LESSON-19-C.isEven.rhs at lesson-19-c.k:6:18
   3   	  imports BOOL
   4   	
   5   	  syntax Bool ::= isEven(Int) [function]
-&gt; 6   	  rule [isEven]: isEven(I) =&gt; true requires I %Int 2 ==Int 0
   7   	  rule [isOdd]: isEven(I) =&gt; false requires I %Int 2 =/=Int 0
   8   	
   9   	endmodule
(lldb) 
</code></pre><p>We can also set a breakpoint for when a rule&apos;s side condition is evaluated<br>
by means of the <code>MODULE-NAME.label.sc</code> syntax:</p>
<pre data-role="codeBlock" data-info class="language-"><code>(gdb) break LESSON-19-C.isEven.sc
Breakpoint 1 at 0x2afd70: file /home/dwightguth/kframework-5.0.0/k-distribution/k-tutorial/1_basic/19_debugging/lesson-19-c.k, line 6.
(gdb) run
Starting program: /home/dwightguth/kframework-5.0.0/k-distribution/k-tutorial/1_basic/19_debugging/lesson-19-c-kompiled/interpreter .krun-2021-08-13-14-41-48-1BoGfJRbYc/tmp.in.kg4F8cwfCe -1 .krun-2021-08-13-14-41-48-1BoGfJRbYc/result.kore
[Thread debugging using libthread_db enabled]
Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.

Breakpoint 1, LESSON-19-C.isEven.sc (VarI=4) at /home/dwightguth/kframework-5.0.0/k-distribution/k-tutorial/1_basic/19_debugging/lesson-19-c.k:6
6         rule [isEven]: isEven(I) =&gt; true requires I %Int 2 ==Int 0
(gdb) finish
Run till exit from #0  LESSON-19-C.isEven.sc (VarI=4) at /home/dwightguth/kframework-5.0.0/k-distribution/k-tutorial/1_basic/19_debugging/lesson-19-c.k:6
0x00000000002b2662 in LblisEven&apos;LParUndsRParUnds&apos;LESSON-19-C&apos;Unds&apos;Bool&apos;Unds&apos;Int (_1=4) at /home/dwightguth/kframework-5.0.0/k-distribution/k-tutorial/1_basic/19_debugging/lesson-19-c.k:5
5         syntax Bool ::= isEven(Int) [function]
Value returned is $1 = true
(gdb)
</code></pre><pre data-role="codeBlock" data-info class="language-"><code>(lldb) breakpoint set --name LESSON-19-C.isEven.sc
Breakpoint 1: where = interpreter`LESSON-19-C.isEven.sc + 1 at lesson-19-c.k:6:18, address = 0x00000001000038c1
(lldb) run
Process 52530 launched: &apos;/Users/brucecollie/code/scratch/lesson-19-c-kompiled/interpreter&apos; (x86_64)
Process 52530 stopped
* thread #1, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 1.1
    frame #0: 0x00000001000038c1 interpreter`LESSON-19-C.isEven.sc(VarI=0x0000000101800088) at lesson-19-c.k:6:18
   3   	  imports BOOL
   4   	
   5   	  syntax Bool ::= isEven(Int) [function]
-&gt; 6   	  rule [isEven]: isEven(I) =&gt; true requires I %Int 2 ==Int 0
   7   	  rule [isOdd]: isEven(I) =&gt; false requires I %Int 2 =/=Int 0
   8   	
   9   	endmodule
(lldb) finish
Process 52649 stopped
* thread #1, queue = &apos;com.apple.main-thread&apos;, stop reason = step out
Return value: (bool) $0 = true

    frame #0: 0x00000001000069e5 interpreter`LblisEven&apos;LParUndsRParUnds&apos;LESSON-19-C&apos;Unds&apos;Bool&apos;Unds&apos;Int(_1=0x0000000101800088) at lesson-19-c.k:5:19
   2   	  imports INT
   3   	  imports BOOL
   4   	
-&gt; 5   	  syntax Bool ::= isEven(Int) [function]
   6   	  rule [isEven]: isEven(I) =&gt; true requires I %Int 2 ==Int 0
   7   	  rule [isOdd]: isEven(I) =&gt; false requires I %Int 2 =/=Int 0
   8
(lldb)
</code></pre><p>Here we have used the built-in command <code>finish</code> to tell us whether the side<br>
condition returned true or not. Note that once again, we see the substitution<br>
that was matched from the left-hand side. Like before, a variable will only<br>
appear here if it is used in the side condition.</p>
<h2 class="mume-header" id="debugging-rule-matching">Debugging rule matching</h2>

<p>Sometimes it is useful to try to determine why a particular rule did or did<br>
not apply. K provides some basic debugging commands which make it easier<br>
to determine this.</p>
<p>Consider the following K definition (<code>lesson-19-d.k</code>):</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">19</span><span class="token operator">-</span>D

  <span class="token keyword keyword-syntax">syntax</span> Foo <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> foo<span class="token punctuation">(</span>Bar<span class="token punctuation">)</span>
  <span class="token keyword keyword-syntax">syntax</span> Bar <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> bar<span class="token punctuation">(</span>Baz<span class="token punctuation">)</span> <span class="token operator">|</span> bar2<span class="token punctuation">(</span>Baz<span class="token punctuation">)</span>
  <span class="token keyword keyword-syntax">syntax</span> Baz <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> baz<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">|</span> baz2<span class="token punctuation">(</span><span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">[</span>baz<span class="token punctuation">]</span><span class="token punctuation">:</span> foo<span class="token punctuation">(</span>bar<span class="token punctuation">(</span>baz<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K

<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>Suppose we try to run the program <code>foo(bar(baz2()))</code>. It is obvious from this<br>
example why the rule in this definition will not apply. However, in practice,<br>
such cases are not always obvious. You might look at a rule and not immediately<br>
spot why it didn&apos;t apply on a particular term. For this reason, it can be<br>
useful to get the debugger to provide a log about how it tried to match that<br>
term. You can do this with the <code>k match</code> command. If you are stopped after<br>
having run <code>k start</code> or <code>k step</code>, you can obtain this log for any rule after<br>
any step by running the command <code>k match MODULE.label subject</code> for a particular<br>
top-level rule label.</p>
<p>For example, with the <code>baz</code> rule above, we get the following output:</p>
<pre data-role="codeBlock" data-info class="language-"><code>(gdb) k match LESSON-19-D.baz subject
Subject:
baz2 ( )
does not match pattern:
baz ( )
</code></pre><pre data-role="codeBlock" data-info class="language-"><code>(lldb) k match LESSON-19-D.baz subject
Subject:
baz2 ( )
does not match pattern:
baz ( )
</code></pre><p>As we can see, it provided the exact subterm which did not match against the<br>
rule, as well as the particular subpattern it ought to have matched against.</p>
<p>This command does not actually take any rewrite steps. In the event that<br>
matching actually succeeds, you will still need to run the <code>k step</code> command<br>
to advance to the next step.</p>
<h2 class="mume-header" id="final-notes">Final notes</h2>

<p>In addition to the functionality provided above, you have the full power of<br>
GDB or LLDB at your disposal when debugging. Some features are not particularly<br>
well-adapted to K code and may require more advanced knowledge of the<br>
term representation or implementation to use effectively, but anything that<br>
can be done in GDB or LLDB can in theory be done using this debugging functionality.<br>
We suggest you refer to the<br>
<a href="https://www.gnu.org/software/gdb/documentation/">GDB Documentation</a> or<br>
<a href="https://lldb.llvm.org/use/tutorial.html">LLDB Tutorial</a> if you<br>
want to try to do something and are unsure as to how.</p>
<h2 class="mume-header" id="exercises">Exercises</h2>

<ol>
<li>Compile your solution to Lesson 1.18, Exercise 2 with debugging support<br>
enabled and step through several programs you have previously used to test.<br>
Then set a breakpoint on the <code>isKResult</code> function and observe the state of the<br>
interpreter when stopped at that breakpoint. Set a breakpoint on the rule for<br>
addition and run a program that causes it to be stopped at that breakpoint.<br>
Finally, step through the program until the addition symbol is at the top<br>
of the K cell, and then use the <code>k match</code> command to report the reason why<br>
the subtraction rule does not apply. You may need to modify the definition<br>
to insert some rule labels.</li>
</ol>
<h2 class="mume-header" id="next-lesson">Next lesson</h2>

<p>Once you have completed the above exercises, you can continue to<br>
<a href="#ebook-heading-lesson-120-k-backends-and-the-haskell-backend">Lesson 1.20: K Backends and the Haskell Backend</a>.</p>
</div></div><div id="ebook-heading-lesson-120-k-backends-and-the-haskell-backend" ebook-toc-level-3 heading="Lesson 1.20: K Backends and the Haskell Backend"><div><h1 class="mume-header" id="lesson-120-k-backends-and-the-haskell-backend">Lesson 1.20: K Backends and the Haskell Backend</h1>

<p>The purpose of this lesson is to teach about the multiple backends of K,<br>
in particular the Haskell Backend which is the complement of the backend we<br>
have been using so far.</p>
<h2 class="mume-header" id="k-backends">K Backends</h2>

<p>Thus far, we have not discussed the distinction between the K frontend and<br>
the K backends at all. We have simply assumed that if you run <code>kompile</code> on a<br>
K definition, there will be a compiler backend that will allow you to execute<br>
the K definition you have compiled.</p>
<p>K actually has multiple different backends. The one we have been using so far<br>
implicitly, the default backend, is called the <strong>LLVM Backend</strong>. It is<br>
designed to support efficient, optimized concrete execution and search. It<br>
does this by compiling your K definition to LLVM bitcode and then using LLVM<br>
to generate machine code for it that is compiled and linked and executed.<br>
However, K is a formal methods toolkit at the end of the day, and the primary<br>
goal many people have when defining a programming language in K is to<br>
ultimately be able to perform more advanced verification on programs in their<br>
programming language.</p>
<p>It is for this purpose that K also provides the <strong>Haskell Backend</strong>, so called<br>
because it is implemented in Haskell. While we will cover the features of the<br>
Haskell Backend in more detail in the next two lessons, the important thing to<br>
understand is that it is a separate backend which is optimized for more formal<br>
reasoning about programming languages. While it is capable of performing<br>
concrete execution, it does not do so as efficiently as the LLVM Backend.<br>
In exchange, it provides more advanced features.</p>
<h2 class="mume-header" id="choosing-a-backend">Choosing a backend</h2>

<p>You can choose which backend to use to compile a K definition by means of the<br>
<code>--backend</code> flag to <code>kompile</code>. By default, if you do not specify this flag, it<br>
is equivalent to if you had specified <code>--backend llvm</code>. However, to use the<br>
Haskell Backend instead, you can simply say <code>kompile --backend haskell</code> on a<br>
particular K definition.</p>
<p>As an example, here is a simple K definition that we have seen before in the<br>
previous lesson (<code>lesson-20.k</code>):</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">20</span>
  <span class="token keyword keyword-imports">imports</span> INT

  <span class="token keyword keyword-rule">rule</span> I <span class="token operator">=&gt;</span> I <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span>
    <span class="token keyword keyword-requires">requires</span> I &lt;<span class="token keyword keyword-Int">Int</span> <span class="token number">100</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>Previously we compiled this definition using the LLVM Backend, but if we<br>
instead execute the command <code>kompile lesson-20.k --backend haskell</code>, we<br>
will get an interpreter for this K definition that is implemented in Haskell<br>
instead. Unlike the default LLVM Backend, the Haskell Backend is not a<br>
compiler per se. It does not generate new Haskell code corresponding to your<br>
programming language and then compile and execute it. Instead, it is an<br>
interpreter which reads the generated IR from <code>kompile</code> and implements in<br>
Haskell an interpreter that is capable of interpreting any K definition.</p>
<p>Note that on arm64 macOS (Apple Silicon), there is a known issue with the <code>Compact</code><br>
library that causes crashes in the Haskell backend. Pass the additional flag<br>
<code>--no-haskell-binary</code> to <code>kompile</code> to resolve this.<br>
This flag is also needed when using <code>krun</code>.</p>
<h3 class="mume-header" id="exercise">Exercise</h3>

<p>Try running the program <code>0</code> in this K definition on the Haskell Backend and<br>
compare the final configuration to what you would get compiling the same<br>
definition with the LLVM Backend.</p>
<h2 class="mume-header" id="legacy-backends">Legacy backends</h2>

<p>As a quick note, K does provide one other backend, which exists primarily as<br>
legacy code which should be considered deprecated. This is the<br>
<strong>Java Backend</strong>. The Java Backend is essentially a precursor to the Haskell<br>
Backend. We will not cover this backend in any detail since it is deprecated,<br>
but we still mention it here for the purposes of understanding.</p>
<h2 class="mume-header" id="exercises">Exercises</h2>

<ol>
<li>Compile your solution to Lesson 1.18, Exercise 2 with the Haskell Backend<br>
and execute some programs. Compare the resulting configurations with the<br>
output of the same program on the LLVM Backend. Note that if you are getting<br>
different behaviors on the Haskell backend, you might have some luck debugging<br>
by passing <code>--search</code> to <code>krun</code> when using the LLVM backend.</li>
</ol>
<h2 class="mume-header" id="next-lesson">Next lesson</h2>

<p>Once you have completed the above exercises, you can continue to<br>
<a href="#ebook-heading-lesson-121-unification-and-symbolic-execution">Lesson 1.21: Unification and Symbolic Execution</a>.</p>
</div></div><div id="ebook-heading-lesson-121-unification-and-symbolic-execution" ebook-toc-level-3 heading="Lesson 1.21: Unification and Symbolic Execution"><div><h1 class="mume-header" id="lesson-121-unification-and-symbolic-execution">Lesson 1.21: Unification and Symbolic Execution</h1>

<p>The purpose of this lesson is to teach the basic concepts of symbolic execution<br>
in order to introduce the unique capabilities of the Haskell Backend at a<br>
conceptual level.</p>
<h2 class="mume-header" id="symbolic-execution">Symbolic Execution</h2>

<p>Thus far, all of the programs we have run using K have been <strong>concrete</strong><br>
configurations. What this means is that the configuration we use to initialize<br>
the K rewrite engine is concrete; in other words, contains no logical<br>
variables. The LLVM Backend is a <strong>concrete execution</strong> engine, meaning that<br>
it is only capable of rewriting concrete configurations.</p>
<p>By contrast, the Haskell Backend performs <strong>symbolic execution</strong>, which is<br>
capable of rewriting any configuration, including those where parts of the<br>
configuration are <strong>symbolic</strong>, ie, contain variables or uninterpreted<br>
functions.</p>
<h2 class="mume-header" id="unification">Unification</h2>

<p>Previously, we have introduced the concept that K rewrite rules operate by<br>
means of pattern matching: the current configuration being rewritten is pattern<br>
matched against the left-hand side of the rewrite rule, and the substitution<br>
is used in order to construct a new term from the right-hand side. In symbolic<br>
execution, we use<br>
<a href="https://en.wikipedia.org/wiki/Unification_%28computer_science%29">unification</a><br>
instead of pattern matching. To summarize, unification behaves akin to a<br>
two-way pattern matching where both the configuration and the left-hand side<br>
of the rule can contain variables, and the algorithm generates a<br>
<strong>most general unifier</strong> containing substitutions for the variables in both<br>
which will make both terms equal.</p>
<h2 class="mume-header" id="feasibility">Feasibility</h2>

<p>Unification by itself cannot completely solve the problem of symbolic<br>
execution. One task symbolic execution must perform is to identify whether<br>
a particular symbolic term is <strong>feasible</strong>, that is to say, that there actually<br>
exists a concrete instantiation of that term such that all the logical<br>
constraints on that term can actually be satisfied. The Haskell Backend<br>
delegates this task to <a href="https://github.com/Z3Prover/z3">Z3</a>, an<br>
<a href="https://en.wikipedia.org/wiki/Satisfiability_modulo_theories">SMT solver</a>.<br>
This solver is used to periodically trim configurations that are determined<br>
to be mathematically infeasible.</p>
<h2 class="mume-header" id="symbolic-terms">Symbolic terms</h2>

<p>The final component of symbolic execution consists of the task of introducing<br>
symbolic terms into the configuration. This can be done one of two different<br>
ways. First, the term being passed to <code>krun</code> can actually be symbolic. This<br>
is less frequently used because it requires the user to construct an AST<br>
that contains variables, something which our current parsing capabilities are<br>
not well-equipped to do. The second, more common, way of introducing symbolic<br>
terms into a configuration consists of writing rules where there exists an<br>
existentially qualified variable on the right-hand side of the rule that does<br>
not exist on the left-hand side of the rule.</p>
<p>In order to prevent users from writing such rules by accident, K requires<br>
that such variables begin with the <code>?</code> prefix. For example, here is a rule<br>
that rewrites a constructor <code>foo</code> to a symbolic integer:</p>
<pre data-role="codeBlock" data-info class="language-"><code>rule &lt;k&gt; foo =&gt; ?X:Int ...&lt;/k&gt;
</code></pre><p>When this rule applies, a fresh variable is introduced to the configuration, which<br>
then is unified against the rules that might apply in order to symbolically<br>
execute that configuration.</p>
<h3 class="mume-header" id="ensures-clauses"><code>ensures</code> clauses</h3>

<p>We also introduce here a new feature of K rules that applies when a rule<br>
has this type of variable on the right-hand side: the <code>ensures</code> clause.<br>
An <code>ensures</code> clause is similar to a <code>requires</code> clause and can appear after<br>
a rule body, or after a <code>requires</code> clause. The <code>ensures</code> clause is used to<br>
introduce constraints that might apply to the variable that was introduced by<br>
that rule. For example, we could write the rule above with the additional<br>
constraint that the symbolic integer that was introduced must be less than<br>
five, by means of the following rule:</p>
<pre data-role="codeBlock" data-info class="language-"><code>rule &lt;k&gt; foo =&gt; ?X:Int ...&lt;/k&gt; ensures ?X &lt;Int 5
</code></pre><h2 class="mume-header" id="putting-it-all-together">Putting it all together</h2>

<p>Putting all these pieces together, it is possible to use the Haskell Backend<br>
to perform symbolic reasoning about a particular K module, determining all the<br>
possible states that can be reached by a symbolic configuration.</p>
<p>For example, consider the following K definition (<code>lesson-21.k</code>):</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">21</span>
    <span class="token keyword keyword-imports">imports</span> INT

    <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token number">0</span> <span class="token operator">=&gt;</span> <span class="token operator">?</span>X<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> ensures <span class="token operator">?</span>X <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span><span class="token keyword keyword-Int">Int</span> <span class="token number">0</span>
    <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> X<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">=&gt;</span> <span class="token number">5</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token keyword keyword-requires">requires</span> X <span class="token operator">&gt;=</span><span class="token keyword keyword-Int">Int</span> <span class="token number">10</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>When we symbolically execute the program <code>0</code>, we get the following output<br>
from the Haskell Backend:</p>
<pre data-role="codeBlock" data-info class="language-"><code>    &lt;k&gt;
      5 ~&gt; .
    &lt;/k&gt;
  #And
    {
      true
    #Equals
      ?X:Int &gt;=Int 10
    }
  #And
    #Not ( {
      ?X:Int
    #Equals
      0
    } )
#Or
    &lt;k&gt;
      ?X:Int ~&gt; .
    &lt;/k&gt;
  #And
    #Not ( {
      true
    #Equals
      ?X:Int &gt;=Int 10
    } )
  #And
    #Not ( {
      ?X:Int
    #Equals
      0
    } )
</code></pre><p>Note some new symbols introduced by this configuration: <code>#And</code>, <code>#Or</code>, and<br>
<code>#Equals</code>. While <code>andBool</code>, <code>orBool</code>, and <code>==K</code> represent functions of sort<br>
<code>Bool</code>, <code>#And</code>, <code>#Or</code>, and <code>#Equals</code> are <strong>matching logic connectives</strong>. We<br>
will discuss matching logic in more detail later in the tutorial, but the basic<br>
idea is that these symbols represent Boolean operators over the domain of<br>
configurations and constraints, as opposed to over the <code>Bool</code> sort.</p>
<p>Notice that the configuration listed above is a disjunction of conjunctions.<br>
This is the most common form of output that can be produced by the Haskell<br>
Backend. In this case, each conjunction consists of a configuration and a set<br>
of constraints. What this conjunction describes, essentially, is a<br>
configuration and a set of information that was derived to be true while<br>
rewriting that configuration.</p>
<p>Similar to how we saw <code>--search</code> in a previous lesson, the reason we have<br>
multiple disjuncts is because there are multiple possible output states<br>
for this program, depending on whether or not the second rule applied. In the<br>
first case, we see that <code>?X</code> is greater than or equal to 10, so the second rule<br>
applied, rewriting the symbolic integer to the concrete integer 5. In the<br>
second case, we see that the second rule did not apply because <code>?X</code> is less<br>
than 10. Moreover, because of the <code>ensures</code> clause on the first rule, we know<br>
that <code>?X</code> is not zero, therefore the first rule will not apply a second time.<br>
If we had omitted this constraint, we would have ended up infinitely applying<br>
the first rule, leading to <code>krun</code> not terminating.</p>
<p>In the next lesson, we will cover how symbolic execution forms the backbone<br>
of deductive program verification in K and how we can use K to prove programs<br>
correct against a specification.</p>
<h2 class="mume-header" id="exercises">Exercises</h2>

<ol>
<li>Create another rule in <code>LESSON-21</code> that rewrites odd integers greater than<br>
ten to a symbolic even integer less than 10 and greater than 0. This rule will<br>
now apply nondeterministically along with the existing rules. Predict what the<br>
resulting output configuration will be from rewriting <code>0</code> after adding this<br>
rule. Then run the program and see whether your prediction is correct.</li>
</ol>
<p>Once you have completed the above exercises, you can continue to<br>
<a href="#ebook-heading-lesson-122-k-deductive-verification">Lesson 1.22: Basics of Deductive Program Verification using K</a>.</p>
</div></div><div id="ebook-heading-lesson-122-k-deductive-verification" ebook-toc-level-3 heading="Lesson 1.22: K Deductive Verification"><div><h1 class="mume-header" id="lesson-122-basics-of-deductive-program-verification-using-k">Lesson 1.22: Basics of Deductive Program Verification using K</h1>

<p>In this lesson, you will familiarize yourself with the basics of using K for<br>
deductive program verification.</p>
<h2 class="mume-header" id="1-setup-simple-programming-language-with-function-calls">1. Setup: Simple Programming Language with Function Calls</h2>

<p>We base this lesson on a simple programming language with functions,<br>
assignment, if conditionals, and while loops. Take your time to study its<br>
formalization below (<code>lesson-22.k</code>):</p>
<pre data-role="codeBlock" data-info class="language-"><code>module LESSON-22-SYNTAX
    imports INT-SYNTAX
    imports BOOL-SYNTAX
    imports ID-SYNTAX

    syntax Exp ::= IExp | BExp

    syntax IExp ::= Id | Int

    syntax KResult ::= Int | Bool | Ints

    // Take this sort structure:
    //
    //     IExp
    //    /    \
    // Int      Id
    //
    // Through the List{_, &quot;,&quot;} functor.
    // Must add a `Bot`, for a common subsort for the empty list.

    syntax Bot
    syntax Bots ::= List{Bot, &quot;,&quot;} [klabel(exps)]
    syntax Ints ::= List{Int, &quot;,&quot;} [klabel(exps)]
                  | Bots
    syntax Ids  ::= List{Id, &quot;,&quot;}  [klabel(exps)]
                  | Bots
    syntax Exps ::= List{Exp, &quot;,&quot;} [klabel(exps), seqstrict]
                  | Ids | Ints

    syntax IExp ::= &quot;(&quot; IExp &quot;)&quot; [bracket]
                  | IExp &quot;+&quot; IExp [seqstrict]
                  | IExp &quot;-&quot; IExp [seqstrict]
                  &gt; IExp &quot;*&quot; IExp [seqstrict]
                  | IExp &quot;/&quot; IExp [seqstrict]
                  &gt; IExp &quot;^&quot; IExp [seqstrict]
                  | Id &quot;(&quot; Exps &quot;)&quot; [strict(2)]

    syntax BExp ::= Bool

    syntax BExp ::= &quot;(&quot; BExp &quot;)&quot; [bracket]
                  | IExp &quot;&lt;=&quot; IExp [seqstrict]
                  | IExp &quot;&lt;&quot;  IExp [seqstrict]
                  | IExp &quot;&gt;=&quot; IExp [seqstrict]
                  | IExp &quot;&gt;&quot;  IExp [seqstrict]
                  | IExp &quot;==&quot; IExp [seqstrict]
                  | IExp &quot;!=&quot; IExp [seqstrict]

    syntax BExp ::= BExp &quot;&amp;&amp;&quot; BExp
                  | BExp &quot;||&quot; BExp

    syntax Stmt ::=
         Id &quot;=&quot; IExp &quot;;&quot; [strict(2)]                        // Assignment
       | Stmt Stmt [left]                                   // Sequence
       | Block                                              // Block
       | &quot;if&quot; &quot;(&quot; BExp &quot;)&quot; Block &quot;else&quot; Block [strict(1)]   // If conditional
       | &quot;while&quot; &quot;(&quot; BExp &quot;)&quot; Block                         // While loop
       | &quot;return&quot; IExp &quot;;&quot;                    [seqstrict]   // Return statement
       | &quot;def&quot; Id &quot;(&quot; Ids &quot;)&quot; Block                         // Function definition

    syntax Block ::=
         &quot;{&quot; Stmt &quot;}&quot;    // Block with statement
       | &quot;{&quot; &quot;}&quot;         // Empty block
endmodule

module LESSON-22
    imports INT
    imports BOOL
    imports LIST
    imports MAP
    imports LESSON-22-SYNTAX

    configuration
      &lt;k&gt; $PGM:Stmt &lt;/k&gt;
      &lt;store&gt; .Map &lt;/store&gt;
      &lt;funcs&gt; .Map &lt;/funcs&gt;
      &lt;stack&gt; .List &lt;/stack&gt;

 // -----------------------------------------------
    rule &lt;k&gt; I1 + I2 =&gt; I1 +Int I2 ... &lt;/k&gt;
    rule &lt;k&gt; I1 - I2 =&gt; I1 -Int I2 ... &lt;/k&gt;
    rule &lt;k&gt; I1 * I2 =&gt; I1 *Int I2 ... &lt;/k&gt;
    rule &lt;k&gt; I1 / I2 =&gt; I1 /Int I2 ... &lt;/k&gt;
    rule &lt;k&gt; I1 ^ I2 =&gt; I1 ^Int I2 ... &lt;/k&gt;

    rule &lt;k&gt; I:Id =&gt; STORE[I] ... &lt;/k&gt;
         &lt;store&gt; STORE &lt;/store&gt;

 // ------------------------------------------------
    rule &lt;k&gt; I1 &lt;= I2 =&gt; I1  &lt;=Int I2 ... &lt;/k&gt;
    rule &lt;k&gt; I1  &lt; I2 =&gt; I1   &lt;Int I2 ... &lt;/k&gt;
    rule &lt;k&gt; I1 &gt;= I2 =&gt; I1  &gt;=Int I2 ... &lt;/k&gt;
    rule &lt;k&gt; I1  &gt; I2 =&gt; I1   &gt;Int I2 ... &lt;/k&gt;
    rule &lt;k&gt; I1 == I2 =&gt; I1  ==Int I2 ... &lt;/k&gt;
    rule &lt;k&gt; I1 != I2 =&gt; I1 =/=Int I2 ... &lt;/k&gt;

    rule &lt;k&gt; B1 &amp;&amp; B2 =&gt; B1 andBool B2 ... &lt;/k&gt;
    rule &lt;k&gt; B1 || B2 =&gt; B1  orBool B2 ... &lt;/k&gt;

    rule &lt;k&gt; S1:Stmt S2:Stmt =&gt; S1 ~&gt; S2 ... &lt;/k&gt;

    rule &lt;k&gt; ID = I:Int ; =&gt; . ... &lt;/k&gt;
         &lt;store&gt; STORE =&gt; STORE [ ID &lt;- I ] &lt;/store&gt;

    rule &lt;k&gt; { S } =&gt; S ... &lt;/k&gt;
    rule &lt;k&gt; {   } =&gt; . ... &lt;/k&gt;

    rule &lt;k&gt; if (true)   THEN else _ELSE =&gt; THEN ... &lt;/k&gt;
    rule &lt;k&gt; if (false) _THEN else  ELSE =&gt; ELSE ... &lt;/k&gt;

    rule &lt;k&gt; while ( BE ) BODY =&gt; if ( BE ) { BODY while ( BE ) BODY } else { } ... &lt;/k&gt;

    rule &lt;k&gt; def FNAME ( ARGS ) BODY =&gt; . ... &lt;/k&gt;
         &lt;funcs&gt; FS =&gt; FS [ FNAME &lt;- def FNAME ( ARGS ) BODY ] &lt;/funcs&gt;

    rule &lt;k&gt; FNAME ( IS:Ints ) ~&gt; CONT =&gt; #makeBindings(ARGS, IS) ~&gt; BODY &lt;/k&gt;
         &lt;funcs&gt; ... FNAME |-&gt; def FNAME ( ARGS ) BODY ... &lt;/funcs&gt;
         &lt;store&gt; STORE =&gt; .Map &lt;/store&gt;
         &lt;stack&gt; .List =&gt; ListItem(state(CONT, STORE)) ... &lt;/stack&gt;

    rule &lt;k&gt; return I:Int ; ~&gt; _ =&gt; I ~&gt; CONT &lt;/k&gt;
         &lt;stack&gt; ListItem(state(CONT, STORE)) =&gt; .List ... &lt;/stack&gt;
         &lt;store&gt; _ =&gt; STORE &lt;/store&gt;

    rule &lt;k&gt; return I:Int ; ~&gt; . =&gt; I &lt;/k&gt;
         &lt;stack&gt; .List &lt;/stack&gt;

    syntax KItem ::= #makeBindings(Ids, Ints)
                   | state(continuation: K, store: Map)
 // ----------------------------------------------------
    rule &lt;k&gt; #makeBindings(.Ids, .Ints) =&gt; . ... &lt;/k&gt;
    rule &lt;k&gt; #makeBindings((I:Id, IDS =&gt; IDS), (IN:Int, INTS =&gt; INTS)) ... &lt;/k&gt;
         &lt;store&gt; STORE =&gt; STORE [ I &lt;- IN ] &lt;/store&gt;
endmodule
</code></pre><p>Next, compile this example using <code>kompile lesson-22.k --backend haskell</code>. If<br>
your processor is an Apple Silicon processor, add the <code>--no-haskell-binary</code><br>
flag if the compilation fails.</p>
<h2 class="mume-header" id="2-setup-proof-environment">2. Setup: Proof Environment</h2>

<p>Next, take the following snippet of K code and save it in <code>lesson-22-spec.k</code>.<br>
This is a skeleton of the proof environment, and we will complete it as the<br>
lesson progresses.</p>
<pre data-role="codeBlock" data-info class="language-"><code>requires &quot;lesson-22.k&quot;
requires &quot;domains.md&quot;

module LESSON-22-SPEC-SYNTAX
    imports LESSON-22-SYNTAX

endmodule

module VERIFICATION
    imports K-EQUAL
    imports LESSON-22-SPEC-SYNTAX
    imports LESSON-22
    imports MAP-SYMBOLIC

endmodule

module LESSON-22-SPEC
    imports VERIFICATION

endmodule
</code></pre><h2 class="mume-header" id="3-claims">3. Claims</h2>

<ol>
<li>The first claim we will ask K to prove is that 3 + 4, in fact, equals 7.<br>
Claims are stated using the <code>claim</code> keyword, followed by the claim<br>
statement:</li>
</ol>
<pre data-role="codeBlock" data-info class="language-"><code>claim &lt;k&gt; 3 + 4 =&gt; 7 ... &lt;/k&gt;
</code></pre><p>Add this claim to the <code>LESSON-22-SPEC</code> module and run the K prover using the<br>
command <code>kprove lesson-22-spec.k</code>. You should get back the output <code>#Top</code>,<br>
which denotes the Matching Logic equivalent of <code>true</code> and means, in this<br>
context, that all claims have been proven correctly.</p>
<ol start="2">
<li>The second claim reasons about the <code>if</code> statement that has a concrete condition:</li>
</ol>
<pre data-role="codeBlock" data-info class="language-"><code>claim &lt;k&gt; if ( 3 + 4 == 7 ) {
            $a = 1 ;
            } else {
            $a = 2 ;
            }
        =&gt; . ... &lt;/k&gt;
        &lt;store&gt; STORE =&gt; STORE [ $a &lt;- 1 ] &lt;/store&gt;
</code></pre><p>stating that the given program terminates (<code>=&gt; .</code>), and when it does, the value<br>
of the variable <code>$a</code> is set to <code>1</code>, meaning that the execution will have taken<br>
the <code>then</code> branch. Add this claim to the <code>LESSON-22-SPEC</code> module, but also add</p>
<pre data-role="codeBlock" data-info class="language-"><code>syntax Id ::= &quot;$a&quot; [token]
</code></pre><p>to the <code>LESSON-22-SPEC-SYNTAX</code> module in order to declare <code>$a</code> as a token so<br>
that it can be used as a program variable. Re-run the K prover, which should<br>
again return <code>#Top</code>.</p>
<ol start="3">
<li>Our third claim demonstrates how to reason about both branches of an <code>if</code><br>
statement at the same time:</li>
</ol>
<pre data-role="codeBlock" data-info class="language-"><code>claim &lt;k&gt; $a = A:Int ; $b = B:Int ;
          if ($a &lt; $b) {
            $c = $b ;
          } else {
            $c = $a ;
          }
        =&gt; . ... &lt;/k&gt;
        &lt;store&gt; STORE =&gt; STORE [ $a &lt;- A ] [ $b &lt;- B ] [ $c &lt;- ?C:Int ] &lt;/store&gt;
    ensures (?C ==Int A) orBool (?C ==Int B)
</code></pre><p>The program in question first assigns symbolic integers <code>A</code> and <code>B</code> to program<br>
variables <code>$a</code> and <code>$b</code>, respectively, and then executes the given <code>if</code><br>
statement, which has a symbolic condition (<code>A &lt; B</code>), updating the value of the<br>
program variable <code>$c</code> in both branches. The specification we give states that<br>
the <code>if</code> statement terminates, with <code>$a</code> and <code>$b</code> updated, respectively, to <code>A</code><br>
and <code>B</code>, and <code>$c</code> updated to <em>some</em> symbolic integer value <code>?C</code>. Via the<br>
<code>ensures</code> clause, which is used to specify additional constraints that hold<br>
after execution, we also state that this existentially quantified <code>?C</code> equals<br>
either <code>A</code> or <code>B</code>.</p>
<p>Add the productions declaring <code>$b</code> and <code>$c</code> as tokens to the<br>
<code>LESSON-22-SPEC-SYNTAX</code> module, the claim to the <code>LESSON-22-SPEC</code> module, run<br>
the K prover again, and observe the output, which should not be <code>#Top</code> this<br>
time. This means that K was not able to prove the claim, and we now need to<br>
understand why. We do so by examining the output, which should look as follows:</p>
<pre data-role="codeBlock" data-info class="language-"><code>    (InfoReachability) while checking the implication:
    The configuration&apos;s term unifies with the destination&apos;s term,
    but the implication check between the conditions has failed.

  #Not (
    #Exists ?C . {
        STORE [ $a &lt;- A:Int ] [ $b &lt;- B:Int ] [ $c &lt;- ?C:Int ]
      #Equals
        STORE [ $a &lt;- A:Int ] [ $b &lt;- B:Int ] [ $c &lt;- B:Int ]
    }
  #And
    {
      true
    #Equals
      ?C ==Int A orBool ?C ==Int B
    }
  )
#And
  &lt;generatedTop&gt;
    &lt;k&gt;
      _DotVar1
    &lt;/k&gt;
    &lt;store&gt;
      STORE [ $a &lt;- A:Int ] [ $b &lt;- B:Int ] [ $c &lt;- B:Int ]
    &lt;/store&gt;
    &lt;funcs&gt;
      _Gen3
    &lt;/funcs&gt;
    &lt;stack&gt;
      _Gen5
    &lt;/stack&gt;
  &lt;/generatedTop&gt;
#And
  {
    true
  #Equals
    A &lt;Int B
  }
</code></pre><p>This output starts with a message telling us at which point the proof failed,<br>
followed by the final state, which consists of three parts: some negative<br>
Matching Logic (ML) constraints, the final configuration (<code>&lt;generatedTop&gt; ... &lt;/generatedTop&gt;</code>), and some positive ML constraints. Generally speaking,<br>
these positive and the negative constraints could arise from various sources,<br>
such as (but not limited to) branches taken by the execution<br>
(e.g. <code>{ true #Equals A &lt;Int B }</code> or <code>#Not ( { true #Equals A &lt;Int B } )</code>),<br>
or <code>ensures</code> constraints.</p>
<p>First, we examine the message:</p>
<pre data-role="codeBlock" data-info class="language-"><code>(InfoReachability) while checking the implication:
The configuration&apos;s term unifies with the destination&apos;s term,
but the implication check between the conditions has failed.
</code></pre><p>which tells us that the <em>structure</em> of the final configuration is as expected,<br>
but that some of the associated constraints cannot be proven. We next look at<br>
the final configuration, in which the relevant item is the <code>&lt;store&gt; ... &lt;/store&gt;</code> cell, because it is the only one that we are reasoning about. By<br>
inspecting its contents:</p>
<pre data-role="codeBlock" data-info class="language-"><code>STORE [ $a &lt;- A:Int ] [ $b &lt;- B:Int ] [ $c &lt;- B:Int ]
</code></pre><p>we see that we should be within the constraints of the <code>ensures</code>, since the<br>
value of <code>$c</code> in the store equals <code>B</code> in this branch. We next examine the<br>
negative and positive constraints of the output and, more often than not, the<br>
goal is to instruct K how to use the information from the final configuration<br>
and the positive constraints to falsify one of the negative constraints. This<br>
is done through <em>simplifications</em>.</p>
<p>So, the positive constraint that we have is</p>
<pre data-role="codeBlock" data-info class="language-"><code>{ true #Equals A &lt;Int B }
</code></pre><p>meaning that <code>A &lt;Int B</code> holds. Given the analysed program, this tells us that<br>
we are in the <code>then</code> branch of the <code>if</code>. The negative constraint is</p>
<pre data-role="codeBlock" data-info class="language-"><code>  #Not (
    #Exists ?C . {
        STORE [ $a &lt;- A:Int ] [ $b &lt;- B:Int ] [ $c &lt;- ?C:Int ]
      #Equals
        STORE [ $a &lt;- A:Int ] [ $b &lt;- B:Int ] [ $c &lt;- B:Int ]
    }
  #And
    { true #Equals ?C ==Int A orBool ?C ==Int B }
  )
</code></pre><p>and we observe, from the first equality, that the existential <code>?C</code> should be<br>
instantiated with <code>B</code>. This would make both branches of the <code>#And</code> true,<br>
falsifying the outside <code>#Not</code>. We just need to show <code>K</code> how to conclude that<br>
<code>?C ==Int B</code>. We do so by introducing the following simplification into the<br>
<code>VERIFICATION</code> module:</p>
<pre data-role="codeBlock" data-info class="language-"><code>rule { M:Map [ K &lt;- V ] #Equals M [ K &lt;- V&apos; ] } =&gt; { V #Equals V&apos; } [simplification]
</code></pre><p>which formalizes our internal understanding of <code>?C ==Int B</code>. The rule states<br>
that when we update the same key in the same map with two values, and the<br>
resulting maps are equal, then the two values must be equal as well. The<br>
<code>[simplification]</code> attribute indicates to K to use this rule to simplify the<br>
state when trying to prove claims. Like function rules, simplification rules<br>
do not complete to the top of the configuration, but instead apply anywhere<br>
their left-hand-side matches. Re-run the K prover, which should now return<br>
<code>#Top</code>, indicating that K was able to use the simplification and prove the<br>
required claims.</p>
<ol start="4">
<li>Next, we show how to state and prove properties of <code>while</code> loops. In<br>
particular, we consider the following loop</li>
</ol>
<pre data-role="codeBlock" data-info class="language-"><code>claim
    &lt;k&gt;
        while ( 0 &lt; $n ) {
            $s = $s + $n;
            $n = $n - 1;
            } =&gt; . ...
    &lt;/k&gt;
    &lt;store&gt;
        $s |-&gt; (S:Int =&gt; S +Int ((N +Int 1) *Int N /Int 2))
        $n |-&gt; (N:Int =&gt; 0)
    &lt;/store&gt;
    requires N &gt;=Int 0
</code></pre><p>which adds the sum of the first <code>$n</code> integers to <code>$s</code>, assuming the value of <code>$n</code><br>
is non-negative to begin with. This is reflected in the store by stating that,<br>
after the execution of the loop, the original value of <code>$s</code> (which is set to<br>
equal some symbolic integer <code>S</code>) is incremented by <code>((N +Int 1) *Int N /Int 2)</code>, and the value of <code>$n</code> always equals <code>0</code>. Add <code>$n</code> and <code>$s</code> as tokens in<br>
the <code>LESSON-22-SPEC-SYNTAX</code> module, the above claim to the <code>LESSON-22-SPEC</code><br>
module, and run the K prover, which should return <code>#Top</code>.</p>
<ol start="5">
<li>Finally, our last claim is about a program that uses function calls:</li>
</ol>
<pre data-role="codeBlock" data-info class="language-"><code>claim
    &lt;k&gt;
        def $sum($n, .Ids) {
            $s = 0 ;
            while (0 &lt; $n) {
                $s = $s + $n;
                $n = $n - 1;
            }
            return $s;
        }

        $s = $sum(N:Int, .Ints);
    =&gt; . ... &lt;/k&gt;
    &lt;funcs&gt; .Map =&gt; ?_ &lt;/funcs&gt;
    &lt;store&gt; $s |-&gt; (_ =&gt; ((N +Int 1) *Int N /Int 2)) &lt;/store&gt;
    &lt;stack&gt; .List &lt;/stack&gt;
    requires N &gt;=Int 0
</code></pre><p>Essentially, we have wrapped the <code>while</code> loop from claim 3.4 into a function<br>
<code>$sum</code>, and then called that function with a symbolic integer <code>N</code>, storing the<br>
return value in the variable <code>$s</code>. The specification states that this program<br>
ends up storing the sum of the first <code>N</code> integers in the variable <code>$n</code>. Add <code>$sum</code><br>
to the <code>LESSON-22-SPEC-SYNTAX</code> module, the above claim to the<br>
<code>LESSON-22-SPEC</code> module, and run the K prover, which should again return<br>
<code>#Top</code>.</p>
<h2 class="mume-header" id="exercises">Exercises</h2>

<ol>
<li>
<p>Change the condition of the if statement in part 3.2 to take the <code>else</code><br>
branch and adjust the claim so that the proof passes.</p>
</li>
<li>
<p>The post-condition of the specification in part 3.3 loses some information.<br>
In particular, the value of <code>?C</code> is in fact the maximum of <code>A</code> and <code>B</code>.<br>
Prove the same claim as in 3.2, but with the post-condition <code>ensures (?C ==Int maxInt(A, B))</code>.  For this, you will need to extend the <code>VERIFICATION</code><br>
module with two simplifications that capture the meaning of <code>maxInt(A:Int, B:Int)</code>. Keep in mind that any rewriting rule can be used as a<br>
simplification; in particular, that simplifications can have <code>requires</code><br>
clauses.</p>
</li>
<li>
<p>Following the pattern shown in part 3.4, assuming a non-negative initial<br>
value of <code>$b</code>, specify and verify the following <code>while</code> loop:</p>
</li>
</ol>
<pre data-role="codeBlock" data-info class="language-"><code>while ( 0 &lt; $b ) {
    $a = $a + $c;
    $b = $b - 1;
    $c = $c - 1;
}
</code></pre><p><strong>Hint</strong>: You will not need additional simplifications---once you&apos;ve got the<br>
specification right, the proof will go through.</p>
<ol start="4">
<li>Write an arbitrary yet not-too-complex function (or several functions<br>
interacting with each other), and try to specify and verify it (them) in K.</li>
</ol>
</div></div><div id="ebook-heading-section-2-intermediate-k-concepts" ebook-toc-level-2 heading="Section 2: Intermediate K Concepts"><div><h1 class="mume-header" id="section-2-intermediate-k-concepts">Section 2: Intermediate K Concepts</h1>

<p>The goal of this second section is to supplement a beginning developer&apos;s<br>
knowledge of K after they have gained a basic understanding of K. Each lesson<br>
in this section can be completed independently in order to learn about a<br>
particular facet of the K language. The lessons are written to provide basic<br>
understanding of less commonly-used features of K to someone who is still<br>
learning K. For more complete references of these features, the reader ought to<br>
consult the <a href="file:///home/runner/work/k/k/gh-pages/USER_MANUAL.md">User Manual</a>.</p>
<p>The reader ought to be able to complete lessons in this section as needed in<br>
order to learn about specific features of interest, but if desired, can also<br>
complete the entire section in one go. Someone who has completed this entire<br>
section ought to be able to read and understand most K specifications, as well<br>
as write their own specifications of some complexity, and use them to perform<br>
most common K-related tasks. They can then read about specific lessons in<br>
<a href="file:///home/runner/work/k/k/gh-pages/k-distribution/k-tutorial/3_advanced/README.md">Section 3: Advanced K Concepts</a> if they want to<br>
learn more.</p>
<h2 class="mume-header" id="table-of-contents">Table of Contents</h2>

<ol>
<li><a href="#ebook-heading-lesson-21-macros-aliases-and-anywhere-rules">Macros, Aliases, and Anywhere Rules</a></li>
<li><a href="#ebook-heading-lesson-22-fresh-constants">Fresh Constants</a></li>
<li><a href="#ebook-heading-lesson-23-klabels-and-abstract-syntax">KLabels and Abstract Syntax</a></li>
<li><a href="#ebook-heading-lesson-24-overloaded-symbols">Overloaded Symbols</a></li>
<li><a href="#ebook-heading-lesson-25-matching-logic-connectives-and-or-patterns">Matching Logic Connectives and <code>#Or</code> Patterns</a></li>
<li><a href="#ebook-heading-lesson-26-function-context">Function Context</a></li>
<li><a href="#ebook-heading-lesson-27-record-productions-and-named-nonterminals">Record Productions and Named Nonterminals</a></li>
<li><a href="#ebook-heading-lesson-28-fun-and-let"><code>#fun</code> and <code>#let</code></a></li>
<li><a href="#ebook-heading-lesson-29-as-patterns"><code>#as</code> patterns</a></li>
<li><a href="#ebook-heading-lesson-210-the-matching-operators-k-and-k">The Matching Operators, <code>:=K</code> and <code>:/=K</code></a></li>
<li><a href="#ebook-heading-lesson-211-uncommon-evaluation-order-concepts">Uncommon Evaluation Order Concepts</a></li>
<li><a href="#ebook-heading-lesson-212-ieee-754-floating-point-and-fixed-width-integers">IEEE 754 Floating Point and Fixed Width Integers</a></li>
<li><a href="#ebook-heading-lesson-213-alpha-renaming-aware-substitution">Alpha-renaming-aware Substitution</a></li>
<li><a href="#ebook-heading-lesson-214-file-io">File I/O</a></li>
<li><a href="#ebook-heading-lesson-215-string-buffers-and-byte-sequences">String Buffers and Byte Sequences</a></li>
<li><a href="#ebook-heading-lesson-216-the-intermediate-language-of-k-kore">The Intermediate Language of K, KORE</a></li>
<li><a href="#ebook-heading-lesson-217-debugging-proofs-using-the-haskell-backend-repl">Debugging Proofs using the Haskell Backend REPL</a></li>
</ol>
</div></div><div id="ebook-heading-lesson-21-macros-aliases-and-anywhere-rules" ebook-toc-level-3 heading="Lesson 2.1: Macros, Aliases, and Anywhere Rules"><div><h1 class="mume-header" id="lesson-21-macros-aliases-and-anywhere-rules">Lesson 2.1: Macros, Aliases, and Anywhere Rules</h1>

<p>The purpose of this lesson is to explain the behavior of the <code>macro</code>,<br>
<code>macro-rec</code>, <code>alias</code>, and <code>alias-rec</code> production attributes, as well as the<br>
<code>anywhere</code> rule attribute. These attributes control the meaning of how rules<br>
associated with them are applied.</p>
<h2 class="mume-header" id="macros">Macros</h2>

<p>Thus far in the K tutorial, we have described three different types of rules:</p>
<ol>
<li>Top-level rewrite rules, which rewrite a configuration composed of cells to<br>
another configuration;</li>
<li>Function rules, which define the behavior of a function written over<br>
arbitrary input and output types; and</li>
<li>Simplification rules, which describe ways in which the symbolic execution<br>
engine ought to simplify terms containing symbolic values.</li>
</ol>
<p>This lesson introduces three more types of rules, the first of which are<br>
<strong>macros</strong>. A production is a macro if it has the <code>macro</code> attribute, and all<br>
rules whose top symbol on the left hand side is a macro are <strong>macro rules</strong><br>
which define the behavior of the macro. Like function rules and simplification<br>
rules, macro rules do not participate in cell completion. However, unlike<br>
function rules and simplification rules, macro rules are applied <strong>statically</strong><br>
before rewriting begins, and the macro symbol is expected to no longer appear<br>
in the initial configuration for rewriting once all macros in that<br>
configuration are rewritten.</p>
<p>The rationale behind macros is they allow you to define one piece of syntax<br>
in terms of another piece of syntax without any runtime overhead associated<br>
with the cost of rewriting one to the other. This process is a common one in<br>
programming language design and specification and is referred to as<br>
<strong>desugaring</strong>; The syntax that is transformed is typically also referred to as<br>
<strong>syntactic sugar</strong> for another type of syntax. For example, in a language with<br>
<code>if</code> statements and curly braces, you could write the following fragment<br>
(<code>lesson-01.k</code>):</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LESSON<span class="token operator">-</span><span class="token number">01</span>
  <span class="token keyword keyword-imports">imports</span> BOOL

  <span class="token keyword keyword-syntax">syntax</span> Stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;if&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Stmt             <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;if&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Stmt <span class="token string">&quot;else&quot;</span> Stmt
                <span class="token operator">|</span> <span class="token string">&quot;{&quot;</span> Stmts <span class="token string">&quot;}&quot;</span>
  <span class="token keyword keyword-syntax">syntax</span> Stmts <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Stmt<span class="token punctuation">,</span><span class="token string">&quot;&quot;</span><span class="token punctuation">}</span>
  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Bool">Bool</span>

  <span class="token keyword keyword-rule">rule</span> if <span class="token punctuation">(</span> E <span class="token punctuation">)</span> S <span class="token operator">=&gt;</span> if <span class="token punctuation">(</span> E <span class="token punctuation">)</span> S else <span class="token punctuation">{</span> <span class="token punctuation">.</span>Stmts <span class="token punctuation">}</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>In this example, we see that an if statement without an <code>else</code> clause is<br>
defined in terms of one with an <code>else</code> clause. As a result, we would only<br>
need to give a single rule for how to rewrite <code>if</code> statements, rather than<br>
two separate rules for two types of <code>if</code> statements. This is a common pattern<br>
for dealing with program syntax that contains an optional component to it.</p>
<p>It is worth noting that by default, macros are not applied recursively. To be<br>
more precise, by default a macro that arises as a result of the expansion of<br>
the same macro is not rewritten further. This is primarily to simplify the<br>
macro expansion process and reduce the risk that improperly defined macros will<br>
lead to non-terminating behavior.</p>
<p>It is possible, however, to tell K to expand a macro recursively. To do this,<br>
simply replace the <code>macro</code> attribute with the <code>macro-rec</code> attribute. Note that<br>
K does not do any kind of checking to ensure termination here, so it is<br>
important that rules be defined correctly to always terminate, otherwise the<br>
macro expansion phase will run forever. Fortunately, in practice it is very<br>
simple to ensure this property for most of the types of macros that are<br>
typically used in real-world semantics.</p>
<h3 class="mume-header" id="exercise">Exercise</h3>

<p>Using a <code>Nat</code> sort containing the constructors <code>0</code> and <code>S</code> (i.e., a<br>
<a href="https://en.wikipedia.org/wiki/Peano_axioms">Peano-style</a> axiomatization of the<br>
natural numbers where <code>S(N) = N + 1</code>, <code>S(S(N)) = N + 2</code>, etc), write a macro<br>
that will compute the sum of two numbers.</p>
<h2 class="mume-header" id="aliases">Aliases</h2>

<p><strong>NOTE</strong>: This lesson introduces the concept of &quot;aliases&quot;, which are a variant<br>
of macros. While similar, this is different from the concept of &quot;aliases&quot; in<br>
matching logic, which is introduced in Lesson 2.16.</p>
<p>Macros can be very useful in helping you define a programming language.<br>
However, they can be disruptive while pretty printing a configuration. For<br>
example, you might write a set of macros that transforms the code the user<br>
wrote into equivalent code that is slightly harder to read. This can make it<br>
more difficult to understand the code when it is pretty printed as part of the<br>
output of rewriting.</p>
<p>K defines a relatively straightforward but novel solution to this problem,<br>
which is known as a K <strong>alias</strong>. An alias in K is very similar to a macro,<br>
with the exception that the rewrite rule will also be applied <strong>backwards</strong><br>
during the pretty-printing process.</p>
<p>It is very simple to make a production be an alias instead of a macro: simply<br>
use the <code>alias</code> or <code>alias-rec</code> attributes instead of the <code>macro</code> or <code>macro-rec</code><br>
attributes. For example, if the example involving <code>if</code> statements above was<br>
declared using an alias instead of a macro, the <code>Stmt</code> term <code>if (E) {} else {}</code><br>
would be pretty-printed as <code>if (E) {}</code>. This is because during pretty-printing,<br>
the term participates in another macro-expansion pass. However, this macro<br>
expansion step will only apply rules with the <code>alias</code> or <code>alias-rec</code> attribute,<br>
and, critically, it will reverse the rule by treating the left-hand side as if<br>
it were the right-hand side, and vice versa.</p>
<p>This can be very useful to allow you to define one construct in terms of<br>
another while still being able to pretty-print the result as if it were<br>
the original term in question. This can be especially useful for applications<br>
of K where we are taking the output of rewriting and attempting to use it as<br>
a code fragment that we then execute, such as with test generation.</p>
<h3 class="mume-header" id="exercise-1">Exercise</h3>

<p>Modify <code>LESSON-01</code> above to use an alias instead of a macro and experiment<br>
with how various terms are pretty-printed by invoking <code>krun</code> on them.</p>
<h2 class="mume-header" id="anywhere-rules"><code>anywhere</code> rules</h2>

<p>The last type of rule introduced in this lesson is the <strong>anywhere rule</strong>. An<br>
anywhere rule is specified by adding the <code>anywhere</code> attribute to a rule. Such a<br>
rule is similar to a function rule in that it does not participate in cell<br>
completion, and will apply anywhere that the left-hand-side matches in the<br>
configuration, but distinct in that the symbol in question can still be matched<br>
against in the left-hand side of other rules, even during concrete rewriting.<br>
The reasoning behind this is that instead of the symbol in question being a<br>
constructor, it is a constructor <em>modulo</em> the axioms defined with the<br>
<code>anywhere</code> attribute. Essentially, the rules with the <code>anywhere</code> attribute will<br>
apply as soon as they appear in the right-hand side of a rule being applied,<br>
but the symbol in question will still be treated as a symbol that can be<br>
matched on if it is not completely removed by those rules.</p>
<p>This can be useful in certain cases to allow you to define transformations over<br>
particular pieces of syntax while still generally giving those pieces of syntax<br>
another meaning when the anywhere rule does not apply. For example, the ISO C<br>
standard defines the semantics of <code>*&amp;x</code> as exactly equal to <code>x</code>, with no<br>
reading or writing of memory taking place, and the K semantics of C implements<br>
this functionality using an anywhere rule that is applied at compilation time.</p>
<p><strong>NOTE</strong>: the <code>anywhere</code> attribute is only implemented on the LLVM backend<br>
currently. Attempting to use it in a semantics that is compiled with the<br>
Haskell backend will result in an error being reported by the compiler. This<br>
should be remembered when using this attribute, as it may not be suitable for<br>
a segment of a semantics which is intended to be symbolically executed.</p>
<h2 class="mume-header" id="exercises">Exercises</h2>

<ol>
<li>Write a version of the calculator from Lesson 1.14 Exercise 1, which uses<br>
the same syntax for evaluating expressions, but defines its arithmetic logic<br>
using <code>anywhere</code> rules rather than top-level rewrite rules.</li>
</ol>
<h2 class="mume-header" id="return-to-top">Return to Top</h2>

<p><a href="#ebook-heading-section-2-intermediate-k-concepts">Click here</a> to return to the Table of Contents for Section 2.</p>
</div></div><div id="ebook-heading-lesson-22-fresh-constants" ebook-toc-level-3 heading="Lesson 2.2: Fresh Constants"><div><h1 class="mume-header" id="lesson-22-fresh-constants">Lesson 2.2: Fresh Constants</h1>

<h2 class="mume-header" id="return-to-top">Return to Top</h2>

<p><a href="#ebook-heading-section-2-intermediate-k-concepts">Click here</a> to return to the Table of Contents for Section 2.</p>
</div></div><div id="ebook-heading-lesson-23-klabels-and-abstract-syntax" ebook-toc-level-3 heading="Lesson 2.3: KLabels and Abstract Syntax"><div><h1 class="mume-header" id="lesson-23-klabels-and-abstract-syntax">Lesson 2.3: KLabels and Abstract Syntax</h1>

<h2 class="mume-header" id="return-to-top">Return to Top</h2>

<p><a href="#ebook-heading-section-2-intermediate-k-concepts">Click here</a> to return to the Table of Contents for Section 2.</p>
</div></div><div id="ebook-heading-lesson-24-overloaded-symbols" ebook-toc-level-3 heading="Lesson 2.4: Overloaded Symbols"><div><h1 class="mume-header" id="lesson-24-overloaded-symbols">Lesson 2.4: Overloaded Symbols</h1>

<h2 class="mume-header" id="return-to-top">Return to Top</h2>

<p><a href="#ebook-heading-section-2-intermediate-k-concepts">Click here</a> to return to the Table of Contents for Section 2.</p>
</div></div><div id="ebook-heading-lesson-25-matching-logic-connectives-and-or-patterns" ebook-toc-level-3 heading="Lesson 2.5: Matching Logic Connectives and #Or Patterns"><div><h1 class="mume-header" id="lesson-25-matching-logic-connectives-and-or-patterns">Lesson 2.5: Matching Logic Connectives and <code>#Or</code> Patterns</h1>

<h2 class="mume-header" id="return-to-top">Return to Top</h2>

<p><a href="#ebook-heading-section-2-intermediate-k-concepts">Click here</a> to return to the Table of Contents for Section 2.</p>
</div></div><div id="ebook-heading-lesson-26-function-context" ebook-toc-level-3 heading="Lesson 2.6: Function Context"><div><h1 class="mume-header" id="lesson-26-function-context">Lesson 2.6: Function Context</h1>

<h2 class="mume-header" id="return-to-top">Return to Top</h2>

<p><a href="#ebook-heading-section-2-intermediate-k-concepts">Click here</a> to return to the Table of Contents for Section 2.</p>
</div></div><div id="ebook-heading-lesson-27-record-productions-and-named-nonterminals" ebook-toc-level-3 heading="Lesson 2.7: Record Productions and Named Nonterminals"><div><h1 class="mume-header" id="lesson-27-record-productions-and-named-nonterminals">Lesson 2.7: Record Productions and Named Nonterminals</h1>

<h2 class="mume-header" id="return-to-top">Return to Top</h2>

<p><a href="#ebook-heading-section-2-intermediate-k-concepts">Click here</a> to return to the Table of Contents for Section 2.</p>
</div></div><div id="ebook-heading-lesson-28-fun-and-let" ebook-toc-level-3 heading="Lesson 2.8: #fun and #let"><div><h1 class="mume-header" id="lesson-28-fun-and-let">Lesson 2.8: <code>#fun</code> and <code>#let</code></h1>

<h2 class="mume-header" id="return-to-top">Return to Top</h2>

<p><a href="#ebook-heading-section-2-intermediate-k-concepts">Click here</a> to return to the Table of Contents for Section 2.</p>
</div></div><div id="ebook-heading-lesson-29-as-patterns" ebook-toc-level-3 heading="Lesson 2.9: #as Patterns"><div><h1 class="mume-header" id="lesson-29-as-patterns">Lesson 2.9: <code>#as</code> Patterns</h1>

<h2 class="mume-header" id="return-to-top">Return to Top</h2>

<p><a href="#ebook-heading-section-2-intermediate-k-concepts">Click here</a> to return to the Table of Contents for Section 2.</p>
</div></div><div id="ebook-heading-lesson-210-the-matching-operators-k-and-k" ebook-toc-level-3 heading="Lesson 2.10: The Matching Operators, :=K and :/=K"><div><h1 class="mume-header" id="lesson-210-the-matching-operators-k-and-k">Lesson 2.10: The Matching Operators, <code>:=K</code> and <code>:/=K</code></h1>

<h2 class="mume-header" id="return-to-top">Return to Top</h2>

<p><a href="#ebook-heading-section-2-intermediate-k-concepts">Click here</a> to return to the Table of Contents for Section 2.</p>
</div></div><div id="ebook-heading-lesson-211-uncommon-evaluation-order-concepts" ebook-toc-level-3 heading="Lesson 2.11: Uncommon Evaluation Order Concepts"><div><h1 class="mume-header" id="lesson-211-uncommon-evaluation-order-concepts">Lesson 2.11: Uncommon Evaluation Order Concepts</h1>

<h2 class="mume-header" id="return-to-top">Return to Top</h2>

<p><a href="#ebook-heading-section-2-intermediate-k-concepts">Click here</a> to return to the Table of Contents for Section 2.</p>
</div></div><div id="ebook-heading-lesson-212-ieee-754-floating-point-and-fixed-width-integers" ebook-toc-level-3 heading="Lesson 2.12: IEEE 754 Floating Point and Fixed Width Integers"><div><h1 class="mume-header" id="lesson-212-ieee-754-floating-point-and-fixed-width-integers">Lesson 2.12: IEEE 754 Floating Point and Fixed Width Integers</h1>

<h2 class="mume-header" id="return-to-top">Return to Top</h2>

<p><a href="#ebook-heading-section-2-intermediate-k-concepts">Click here</a> to return to the Table of Contents for Section 2.</p>
</div></div><div id="ebook-heading-lesson-213-alpha-renaming-aware-substitution" ebook-toc-level-3 heading="Lesson 2.13: Alpha-renaming-aware Substitution"><div><h1 class="mume-header" id="lesson-213-alpha-renaming-aware-substitution">Lesson 2.13: Alpha-renaming-aware Substitution</h1>

<h2 class="mume-header" id="return-to-top">Return to Top</h2>

<p><a href="#ebook-heading-section-2-intermediate-k-concepts">Click here</a> to return to the Table of Contents for Section 2.</p>
</div></div><div id="ebook-heading-lesson-214-file-io" ebook-toc-level-3 heading="Lesson 2.14: File I/O"><div><h1 class="mume-header" id="lesson-214-file-io">Lesson 2.14: File I/O</h1>

<h2 class="mume-header" id="return-to-top">Return to Top</h2>

<p><a href="#ebook-heading-section-2-intermediate-k-concepts">Click here</a> to return to the Table of Contents for Section 2.</p>
</div></div><div id="ebook-heading-lesson-215-string-buffers-and-byte-sequences" ebook-toc-level-3 heading="Lesson 2.15: String Buffers and Byte Sequences"><div><h1 class="mume-header" id="lesson-215-string-buffers-and-byte-sequences">Lesson 2.15: String Buffers and Byte Sequences</h1>

<h2 class="mume-header" id="return-to-top">Return to Top</h2>

<p><a href="#ebook-heading-section-2-intermediate-k-concepts">Click here</a> to return to the Table of Contents for Section 2.</p>
</div></div><div id="ebook-heading-lesson-216-the-intermediate-language-of-k-kore" ebook-toc-level-3 heading="Lesson 2.16: The Intermediate Language of K, KORE"><div><h1 class="mume-header" id="lesson-216-the-intermediate-language-of-k-kore">Lesson 2.16: The Intermediate Language of K, KORE</h1>

<h2 class="mume-header" id="return-to-top">Return to Top</h2>

<p><a href="#ebook-heading-section-2-intermediate-k-concepts">Click here</a> to return to the Table of Contents for Section 2.</p>
</div></div><div id="ebook-heading-lesson-217-debugging-proofs-using-the-haskell-backend-repl" ebook-toc-level-3 heading="Lesson 2.17: Debugging Proofs using the Haskell Backend REPL"><div><h1 class="mume-header" id="lesson-217-debugging-proofs-using-the-haskell-backend-repl">Lesson 2.17: Debugging Proofs using the Haskell Backend REPL</h1>

<h2 class="mume-header" id="return-to-top">Return to Top</h2>

<p><a href="#ebook-heading-section-2-intermediate-k-concepts">Click here</a> to return to the Table of Contents for Section 2.</p>
</div></div><div id="ebook-heading-k-user-manual" ebook-toc-level-1 heading="K User Manual"><div><h1>K User Manual</h1>
<p><strong>NOTE:</strong> The K User Manual is still <strong>under construction</strong>; some features of K<br>
may have partial or missing documentation.</p>
<h2>Introduction</h2>
<h3 class="mume-header" id="why-k">Why K?</h3>

<p>The K Framework is a programming language and system design toolkit made for<br>
practioners and researchers alike.</p>
<p><strong>K For Practioners:</strong><br>
<em>K is a framework for deriving programming languages tools from their semantic<br>
specifications.</em></p>
<p>Typically, programming language tool development follows a similar pattern.<br>
After a new programming language is designed, separate teams will develop<br>
separate language tools (e.g. a compiler, interpreter, parser, symbolic<br>
execution engine, etc). Code reuse is uncommon. The end result is that for each<br>
new language, the same basic tools and patterns are re-implemented again and<br>
again.</p>
<p>K approaches the problem differently -- it generates each of these tools from a single language specification.<br>
The work of programming language design and tool implementation are made separate concerns.<br>
The end result is that the exercise of<br>
designing new languages and their associated tooling is now reduced to<br>
developing a single language specification from which we derive our tooling <em>for<br>
free</em>.</p>
<p><strong>K For Researchers:</strong><br>
<em>K is a configuration- and rewrite-based executable semantic framework.</em></p>
<p>In more detail, K specifications are:</p>
<ol>
<li><strong>Executable:</strong> compile into runnable and testable programs;</li>
<li><strong>Semantic:</strong> correspond to a logical theory with a sound and relatively<br>
complete proof system;</li>
<li><strong>Configuration-based:</strong> organize system states into compositional,<br>
hierarchical, labelled units called cells;</li>
<li><strong>Rewrite-based:</strong> define system transitions using rewrite rules.</li>
</ol>
<p>K specifications are compiled into particular <em>matching logic</em> theories, giving<br>
them a simple and expressive semantics. K semantic rules are implicitly defined<br>
over the entire configuration structure, but omit unused cells, enabling a<br>
highly modular definitional style. Furthermore, K has been used to develop<br>
programming languages, type systems, and formal analysis tools.</p>
<h3 class="mume-header" id="manual-objectives">Manual Objectives</h3>

<p>As mentioned in the <em>Why K?</em> section above, the K Framework is designed as a<br>
collection of language-generic command-line interface (CLI) tools which revolve<br>
around K specifications. These tools cover a broad range of uses, but they<br>
typically fall into one of the following categories:</p>
<ol>
<li>Transforming K Specs (e.g. compilation)</li>
<li>Running K Specs (e.g. concrete and symbolic execution)</li>
<li>Analyzing K Specs (e.g. theorem proving)</li>
</ol>
<p>The main <em>user-facing</em> K tools include:</p>
<ul>
<li><code>kompile</code> - the K compiler driver</li>
<li><code>kparse</code> - the stanadlone K parser and abstract syntax tree (AST)<br>
transformation tool</li>
<li><code>krun</code> - the K interpreter and symbolic execution engine driver</li>
<li><code>kprove</code> - the K theorem prover</li>
</ul>
<p>This user manual is designed to be a tool reference.<br>
In particular, it is not desgined to be a tutorial on how to write K<br>
specifications or to teach the logical foundations of K. New K users should<br>
consult our dedicated<br>
<a href="https://kframework.org/k-distribution/k-tutorial/">K tutorial</a>,<br>
or the more language-design oriented<br>
<a href="https://kframework.org/k-distribution/pl-tutorial/">PL tutorial</a>.<br>
Researchers seeking to learn more about the logic underlying K are encouraged<br>
to peruse the<br>
<a href="https://fsl.cs.illinois.edu/projects/pl/index.html">growing literature on K and matching logic</a>.<br>
We will consider the manual complete when it provides a complete description of<br>
all user-facing K tools and features.</p>
<h2>Introduction to K</h2>
<p>Since K specifications are the primary input into the entire system, let us<br>
take a moment to describe them. At the highest level, K specifications describe<br>
a programming language or system using three different pieces:</p>
<ol>
<li>the <em>system primitives</em>, the base datatypes used during system operation,<br>
e.g., numbers, lists, maps, etc;</li>
<li>the <em>system state</em>, a tuple or record over system primitives which gives a<br>
complete snapshot of the system at any given moment;</li>
<li>the <em>system behavior</em>, a set of rules which defines possible system<br>
evolutions.</li>
</ol>
<p>K specifications are then defined by a collection of <em>sentences</em> which<br>
correspond to the three concepts above:</p>
<ol>
<li><code>syntax</code> declarations encode the <em>system primitives</em>;</li>
<li><code>configuration</code> declarations encode the <em>system state</em>;</li>
<li><code>context</code> and <code>rule</code> declarations encode the <em>system behavior</em>.</li>
</ol>
<p>K sentences are then organized into one or <em>modules</em> which are stored in one or<br>
more <em>files</em>. In this scheme, files may <em>require</em> other files and modules may<br>
<em>import</em> other modules, giving rise to a hierarchy of files and modules. We<br>
give an intuitive sketch of the two levels of grouping in the diagram below:</p>
<pre data-role="codeBlock" data-info class="language-"><code>   example.k file
  +=======================+
  | requires &quot;..&quot; --------|--&gt; File_1
  | ...                   |
  | requires &quot;..&quot; --------|--&gt; File_N
  |                       |
  |  +-----------------+  |
  |  | module ..       |  |
  |  |   imports .. ---|--|--&gt; Module_1
  |  |   ...           |  |
  |  |   imports .. ---|--|--&gt; Module_M
  |  |                 |  |
  |  |   sentence_1    |  |
  |  |   ...           |  |
  |  |   sentence_K    |  |
  |  | endmodule       |  |
  |  +-----------------+  |
  |                       |
  +=======================+
</code></pre><p>where:</p>
<ul>
<li>files and modules are denoted by double-bordered and single-borded boxes<br>
respectively;</li>
<li>file or module identifiers are denoted by double dots (<code>..</code>);</li>
<li>potential repititions are denoted by triple dots (<code>...</code>).</li>
</ul>
<p>In the end, we require that the file and module hierarchies both form a<br>
directed acyclic graph (DAG). This is, no file may recursively require itself,<br>
and likewise, no module may recursively import itself.</p>
<p>We now zoom in further to discuss the various kinds of sentences contained in K<br>
specifications:</p>
<ol>
<li>
<p>sentences that define our <em>system&apos;s primitives</em>, including:</p>
<ul>
<li><strong>sort declarations:</strong> define new categories of primitive datatypes</li>
<li><strong>Backus-Naur Form (BNF) grammar declarations:</strong> define the<br>
operators that inhabit our primitive datatypes</li>
<li><strong>lexical syntax declarations:</strong> define lexemes/tokens for the<br>
lexer/tokenizer</li>
<li><strong>syntax associativity declarations:</strong> specify the<br>
associativity/grouping of our declared operators</li>
<li><strong>syntax priority declarations:</strong> specify the priority of<br>
potential ambiguous operators</li>
</ul>
</li>
<li>
<p>sentences that define our <em>system&apos;s state</em>, including:</p>
<ul>
<li><strong>configuration declarations:</strong> define labelled, hierarchical records<br>
using an nested XML-like syntax</li>
</ul>
</li>
<li>
<p>sentences that define our <em>system&apos;s behavior</em>, including:</p>
<ul>
<li><strong>context declarations:</strong> describe how primitives and configurations<br>
can simplify</li>
<li><strong>context alias declarations:</strong> define templates that can generate new<br>
contexts</li>
<li><strong>rule declarations:</strong> define how the system transitions from one state<br>
to the next</li>
</ul>
</li>
</ol>
<h3 class="mume-header" id="k-process-overview">K Process Overview</h3>

<p>We now examine how the K tools are generally used. The main input to all of the<br>
K tools is a K specification. For effieciency reasons, this specification is<br>
first compiled into an intermediate representation called Kore. Once we have<br>
obtained this intermediate representation, we can use it to do:</p>
<ol>
<li>parsing/pretty-printing, i.e., converting a K term, whose syntax is defined<br>
by a K specification, into a alternate representation</li>
<li>concrete and abstract execution of a K specification</li>
<li>theorem proving, i.e., verifying whether a set of claims about a K<br>
specification hold</li>
</ol>
<p>We represent the overall process using the graphic below:</p>
<pre data-role="codeBlock" data-info class="language-"><code> K Compilation Process
+============================================================+
|                     +---------+                            |
|  K Specification ---| kompile |--&gt; Kore Specification --+  |
|                     +---------+                         |  |
+=========================================================|==+
                                                          |
 K Execution Process                                      |
+=========================================================|==+
|                                                         |  |
|             +-------------------------------------------+  |
|             |                                              |
|             |       +---------+                            |
|  K Term ----+-------| kparse  |--&gt; K Term                  |
|             |       +---------+                            |
|             |                                              |
|             |       +---------+                            |
|  K Term ----+-------|  krun   |--&gt; K Term                  |
|             |       +---------+                            |
|             |                                              |
|             |       +---------+                            |
|  K Claims --+-------| kprove  |--&gt; K Claims                |
|                     +---------+                            |
|                                                            |
+============================================================+
</code></pre><p>where:</p>
<ul>
<li>process outlines are denoted by boxes with double-lined borders</li>
<li>executables are denoted by boxes with single-lined borders</li>
<li>inputs and outputs are denoted by words attached to lines</li>
<li>K terms typically correspond to <em>programs</em> defined in a particular<br>
language&apos;s syntax (which are either parsed using <code>kparse</code> or executed using<br>
<code>krun</code>)</li>
<li>K claims are a notation for describing <em>how</em> certain K programs <em>should</em><br>
execute (which are checked by our theorem prover <code>kprove</code>)</li>
</ul>
<p><strong>K Compilation Process:</strong><br>
Let us start with a description of the compilation process. According to the<br>
above diagram, the compiler driver is called <code>kompile</code>. For our purposes, it is<br>
enough to view the K compilation process as a black box that transforms a K<br>
specification into a lower-level Kore specification that encodes the same<br>
information, but that is easier to work with programmatically.</p>
<p><strong>K Execution Process:</strong><br>
We now turn our attention to the K execution process. Abstractly, we can divide<br>
the K execution process into the following stages:</p>
<ol>
<li>the kore specification is loaded (which defines a lexer, parser, and<br>
unparser among other things)</li>
<li>the input string is lexed into a token stream</li>
<li>the token stream is parsed into K terms/claims</li>
<li>the K term/claims are transformed according the K tool being used (e.g.<br>
<code>kparse</code>, <code>krun</code>, or <code>kprove</code>)</li>
<li>the K term/claims are unparsed into a string form and printed</li>
</ol>
<p>Note that all of the above steps performed in K execution process are fully<br>
prescribed by the input K specification. Of course, there are entire languages<br>
devoted to encoding these various stages proces individually, e.g., <code>flex</code> for<br>
lexers, <code>bison</code> for parsers, etc. What K offers is a <em>consistent</em> language to<br>
package the above concepts in a way that we believe is convenient and practical<br>
for a wide range of uses.</p>
<h2>Module Declaration</h2>
<p>K modules are declared at the top level of a K file. They begin with the<br>
<code>module</code> keyword and are followed by a <strong>module ID</strong> and an optional set of<br>
attributes. They continue with zero or more imports and zero or more sentences<br>
until the <code>endmodule</code> keyword is reached.</p>
<p>A module ID consists of an optional <code>#</code> at the beginning, followed by one or<br>
more components separated by hyphens. Each component can contain letters,<br>
numbers, or underscores.</p>
<p>After the module ID, attributes can be specified in square brackets. See below<br>
for an (incomplete) list of allowed module attributes.</p>
<p>Following the attributes, a module can contain zero or more <strong>imports</strong>. An<br>
import consists of the <code>import</code> or <code>imports</code> keywords followed by a module ID.<br>
An import tells the compiler that this module should contain all the sentences<br>
(recursively) contained by the module being imported.</p>
<p>Imports can be <strong>public</strong> or <strong>private</strong>. By default, they are public, which<br>
means that all the imported syntax can be used by any module that imports the<br>
module doing the import. However, you can explicitly override the visibility<br>
of the import with the <code>public</code> or <code>private</code> keyword immediately prior to the<br>
module name. A module imported privately does not export its syntax to modules<br>
that import the module doing the import.</p>
<p>Following imports, a module can contain zero or more sentences. A sentence can<br>
be a syntax declaration, a rule, a configuration declaration, a context, a<br>
claim, or a context alias. Details on each of these can be found in subsequent<br>
sections.</p>
<h3 class="mume-header" id="private-attribute"><code>private</code> attribute</h3>

<p>If the module is given the <code>private</code> attribute, all of its imports and syntax<br>
are private by default. Individual pieces of syntax can be made public with<br>
the <code>public</code> attribute, and individual imports can be made public with the<br>
<code>public</code> keyword. See relevant sections on syntax and modules for more details<br>
on what it means for syntax and imports to be public or private.</p>
<h3 class="mume-header" id="symbolic-and-concrete-attribute"><code>symbolic</code> and <code>concrete</code> attribute</h3>

<p>These attributes may be placed on modules to indicate that they should only<br>
be used by the Haskell and LLVM backends respectively. If the definition is<br>
compiled on the opposite backend, they are implicitly removed from the<br>
definition prior to parsing anywhere they are imported. This can be useful when<br>
used in limited capacity in order to provide alternate semantics for certain<br>
features on different backends. It should be used sparingly as it makes it more<br>
difficult to trust the correctness of your semantics, even in the presence of<br>
testing.</p>
<h2>Syntax Declaration</h2>
<h3 class="mume-header" id="named-non-terminals">Named Non-Terminals</h3>

<p>We have added a syntax to Productions which allows non-terminals to be given a<br>
name in productions. This significantly improves the ability to document K, by<br>
providing a way to explicitly explain what a field in a production corresponds<br>
to instead of having to infer it from a comment or from the rule body.</p>
<p>The syntax is:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">name<span class="token punctuation">:</span> Sort
</pre><p>This syntax can be used anywhere in a K definition that expects a non-terminal.</p>
<h3 class="mume-header" id="symbol_-attribute"><code>symbol(_)</code> attribute</h3>

<p>By default, when compiling a definition, K generates a unique &quot;mangled&quot; label<br>
identifier for each syntactic production. These identifiers can be used to<br>
reference productions externally, for example when constructing terms by hand<br>
or programmatically via Pyk.</p>
<p>The <code>symbol(_)</code> attribute can be applied to a production to control the precise<br>
identifier for a production that appears in a compiled definition. For example:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> SYMBOLS
    <span class="token keyword keyword-syntax">syntax</span> Foo <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> foo<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">]</span>
                 <span class="token operator">|</span> bar<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>Here, the compiled definition will contain the following symbol declarations:</p>
<pre data-role="codeBlock" data-info class="language-"><code>  symbol Lblfoo{}() ...
  symbol Lblbar&apos;LParRParUnds&apos;SYMBOLS&apos;Unds&apos;Foo{}() ...
</code></pre><p>The compiler enforces uniqueness<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> of symbol names specified in<br>
this way; it would be an error to apply <code>symbol(foo)</code> to another production in<br>
the module above. Additionally, <code>symbol(_)</code> with an argument may not co-occur<br>
with the <code>klabel(_)</code> attribute (see below).</p>
<h3 class="mume-header" id="overload-attribute"><code>overload</code> attribute</h3>

<p>K supports <em>subsort overloading</em><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup> on symbols, whereby a<br>
constructor can have a more specific sort for certain arguments. For example,<br>
consider the following productions derived from a C-like language semantics:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> Exp  <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> LVal
              <span class="token operator">|</span> Exp  <span class="token string">&quot;.&quot;</span> <span class="token keyword keyword-Id">Id</span>
<span class="token keyword keyword-syntax">syntax</span> LVal <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> LVal <span class="token string">&quot;.&quot;</span> <span class="token keyword keyword-Id">Id</span>
</pre><p>Here, it is useful for the result of the dot operator to be an <code>LVal</code> if the<br>
left-hand side is itself an <code>LVal</code>. However, there is an issue with the code<br>
as written: if <code>L()</code> is a term of sort <code>LVal</code>, then the program <code>L() . x</code> has a<br>
parsing ambiguity between the two productions for the dot operator. To resolve<br>
this, we can mark the productions as <em>overloads</em>:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> Exp  <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> LVal
              <span class="token operator">|</span> Exp  <span class="token string">&quot;.&quot;</span> <span class="token keyword keyword-Id">Id</span> <span class="token punctuation">[</span>overload<span class="token punctuation">(</span>_<span class="token punctuation">.</span>_<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword keyword-syntax">syntax</span> LVal <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> LVal <span class="token string">&quot;.&quot;</span> <span class="token keyword keyword-Id">Id</span> <span class="token punctuation">[</span>overload<span class="token punctuation">(</span>_<span class="token punctuation">.</span>_<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><p>Now, the parser will select the <em>most specific</em> overloaded production when it<br>
resolves ambiguities in <code>L() . x</code> (that is, <code>L() . x</code> parses to a term of sort<br>
<code>LVal</code>.</p>
<p>Formally, the compiler organises productions into a partial order that defines<br>
the overload relation as follows. We say that <code>P</code> is a more specific overload<br>
of <code>Q</code> if:</p>
<ul>
<li><code>P</code> and <code>Q</code> have the same <code>overload(_)</code> attribute. Note that the argument<br>
supplied has no semantic meaning other than as a key grouping productions<br>
together.</li>
<li>Let <code>S_P</code> be the sort of <code>P</code>, and <code>S_p1</code> etc. be the sorts of its arguments<br>
(c.f. for <code>Q</code>). The tuple <code>(S_P, S_p1, ..., S_pN)</code> must be elementwise<br>
<em>strictly less than</em> <code>(S_Q, S_q1, ..., S_qN)</code> according to the definition&apos;s<br>
subsorting relationship. That is, a term from production <code>P</code> is a restriction<br>
of one from production <code>Q</code>; when its arguments are more precise, we can give<br>
the result a more precise sort.</li>
</ul>
<h3 class="mume-header" id="klabel_-and-symbol-attributes"><code>klabel(_)</code> and <code>symbol</code> attributes</h3>

<p><strong>Note: the <code>klabel(_), symbol</code> approach described in this section is a legacy<br>
feature that will be removed in the future. New code should use the <code>symbol(_)</code><br>
and <code>overload(_)</code> attributes to opt into explicit naming and overloading<br>
respectively.</strong></p>
<p><em>References here to &quot;overloading&quot; are explained in the section above; the use<br>
of the <code>klabel(_)</code> attribute without <code>symbol</code> is equivalent to the new<br>
<code>overload(_)</code> syntax.</em></p>
<p>By default K generates for each syntax definition a long and obfuscated klabel<br>
string, which serves as a unique internal identifier and also is used in kast<br>
format of that syntax. If we need to reference a certain syntax production<br>
externally, we have to manually define the klabels using the <code>klabel</code> attribute.<br>
One example of where you would want to do this is to be able to refer to a given<br>
symbol via the <code>syntax priority</code> attribute, or to enable overloading of a<br>
given symbol.</p>
<p>If you only provide the <code>klabel</code> attribute, you can use the provided <code>klabel</code> to<br>
refer to that symbol anywhere in the frontend K code. However, the internal<br>
identifier seen by the backend for that symbol will still be the long obfuscated<br>
generated string. Sometimes you want control over the internal identifier used as<br>
well, in which case you use the <code>symbol</code> attribute. This tells the frontend to<br>
use whatever the declared <code>klabel</code> is directly as the internal identifier.</p>
<p>For example:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> MYMODULE
    <span class="token keyword keyword-syntax">syntax</span> FooBarBaz <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> #Foo<span class="token punctuation">(</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token class-name">klabel</span><span class="token punctuation">(</span>#Foo<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">]</span> <span class="token comment">// symbol1</span>
                       <span class="token operator">|</span> #Bar<span class="token punctuation">(</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token class-name">klabel</span><span class="token punctuation">(</span>#Bar<span class="token punctuation">)</span><span class="token punctuation">]</span>         <span class="token comment">// symbol2</span>
                       <span class="token operator">|</span> #Baz<span class="token punctuation">(</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">)</span>                        <span class="token comment">// symbol3</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>Here, we have that:</p>
<ul>
<li>In frontend K, you can refer to &quot;symbol1&quot; as <code>#Foo</code> (from <code>klabel(#Foo)</code>),<br>
and the backend will see <code>&apos;Hash&apos;Foo</code> as the symbol name.</li>
<li>In frontend K, you can refer to &quot;symbol2&quot; as <code>#Bar</code> (from <code>klabel(#Bar)</code>),<br>
and the backend will see<br>
<code>&apos;Hash&apos;Bar&apos;LParUndsCommUndsRParUnds&apos;MYMODULE&apos;Unds&apos;FooBarBaz&apos;Unds&apos;Int&apos;Unds&apos;Int</code><br>
as the symbol name.</li>
<li>In frontend K, you can refer to &quot;symbol3&quot; as<br>
<code>#Baz(_,_)_MYMODULE_FooBarBaz_Int_Int</code> (from auto-generated klabel), and<br>
the backend will see<br>
<code>&apos;Hash&apos;Baz&apos;LParUndsCommUndsRParUnds&apos;MYMODULE&apos;Unds&apos;FooBarBaz&apos;Unds&apos;Int&apos;Unds&apos;Int</code><br>
as the symbol name.</li>
</ul>
<p>The <code>symbol</code> provided <em>must</em> be unique to this definition. This is enforced by<br>
K. In general, it&apos;s recommended to use the <code>symbol</code> attribute whenever you use<br>
<code>klabel</code> unless you explicitly have a reason not to (e.g. you want to <em>overload</em><br>
symbols, or you&apos;re using a deprecated backend). It can be very helpful use the<br>
<code>symbol</code> attribute for debugging, as many debugging messages are printed in<br>
Kast format which will be more readable with the <code>symbol</code> names you explicitly<br>
declare. In addition, if you are programatically manipulating definitions via<br>
the JSON Kast format, building terms using the user-provided pretty<br>
<code>symbol, klabel(...)</code> is easier and less error-prone if the auto-generation<br>
process for klabels changes.</p>
<h4 class="mume-header" id="syntactic-lists">Syntactic Lists</h4>

<p>When using K&apos;s support for syntactic lists, a production like:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> Ints <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> <span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>ints<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><p>will desugar into two productions:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> Ints <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;,&quot;</span> Ints <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>ints<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword keyword-syntax">syntax</span> Ints <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;.Ints&quot;</span>      <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>List<span class="token punctuation">{</span><span class="token string">&quot;ints&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><p>Note that the symbol for the <em>terminator</em> of the list has been generated<br>
automatically from the label on the original production. It is possible to<br>
control what the terminator&apos;s label is using the <code>terminator-symbol(_)</code><br>
attribute. For example:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> Ints <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> <span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>ints<span class="token punctuation">)</span><span class="token punctuation">,</span> terminator<span class="token operator">-</span><span class="token class-name">symbol</span><span class="token punctuation">(</span><span class="token punctuation">.</span>ints<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><p>will desugar into two productions:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> Ints <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;,&quot;</span> Ints <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>ints<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword keyword-syntax">syntax</span> Ints <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;.Ints&quot;</span>      <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span><span class="token punctuation">.</span>ints<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><p>It is an error to apply <code>terminator-symbol(_)</code> to a non-production sentence, or<br>
to a production that does not declare a syntactic list.</p>
<h3 class="mume-header" id="parametric-productions-and-bracket-attributes">Parametric productions and <code>bracket</code> attributes</h3>

<p>Some syntax productions, like the rewrite operator, the bracket operator, and<br>
the #if #then #else #fi operator, cannot have their precise type system<br>
expressed using only concrete sorts.</p>
<p>Prior versions of K solved this issue by using the K sort in this case, but<br>
this introduces inexactness in which poorly typed terms can be created even<br>
without having a cast operator present in the syntax, which is a design<br>
consideration we would prefer to avoid.</p>
<p>It also introduces cases where terms cannot be placed in positions where they<br>
ought to be well sorted unless their return sort is made to be KBott, which in<br>
turn vastly complicates the grammar and makes parsing much slower.</p>
<p>In order to introduce this, we provide a new syntax for parametric productions<br>
in K. This allows you to express syntax that has a sort signature based on<br>
parametric polymorphism. We do this by means of an optional curly-brace-<br>
enclosed list of parameters prior to the return sort of a production.</p>
<p>Some examples:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>Sort<span class="token punctuation">}</span> Sort <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;(&quot;</span> Sort <span class="token string">&quot;)&quot;</span> <span class="token punctuation">[</span><span class="token class-name">bracket</span><span class="token punctuation">]</span>
<span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>Sort<span class="token punctuation">}</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Sort
<span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>Sort<span class="token punctuation">}</span> Sort <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> KBott
<span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>Sort<span class="token punctuation">}</span> Sort <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Sort <span class="token string">&quot;=&gt;&quot;</span> Sort
<span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>Sort<span class="token punctuation">}</span> Sort <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;#if&quot;</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token string">&quot;#then&quot;</span> Sort <span class="token string">&quot;#else&quot;</span> Sort <span class="token string">&quot;#fi&quot;</span>
<span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>Sort1<span class="token punctuation">,</span> Sort2<span class="token punctuation">}</span> Sort1 <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;#fun&quot;</span> <span class="token string">&quot;(&quot;</span> Sort2 <span class="token string">&quot;=&gt;&quot;</span> Sort1 <span class="token string">&quot;)&quot;</span> <span class="token string">&quot;(&quot;</span> Sort2 <span class="token string">&quot;)&quot;</span>
</pre><p>Here we have:</p>
<ol>
<li>Brackets, which can enclose any sort but should be of the same sort that was<br>
enclosed.</li>
<li>Every sort is a KItem.</li>
<li>A KBott term can appear inside any sort.</li>
<li>Rewrites, which can rewrite a value of any sort to a value of the same sort.<br>
Note that this allows the lhs or rhs to be a subsort of the other.</li>
<li>If then else, which can return any sort but which must contain that sort on<br>
both the true and false branches.</li>
<li>lambda applications, in which the argument and parameter must be the same<br>
sort, and the return value of the application must be the same sort as the<br>
return value of the function.</li>
</ol>
<p>Note the last case, in which two different parameters are specified separated<br>
by a comma. This indicates that we have multiple independent parameters which<br>
must be the same each place they occur, but not the same as the other<br>
parameters.</p>
<p>In practice, because every sort is a subsort of K, the <code>Sort2</code><br>
parameter in #6 above does nothing during parsing. It cannot<br>
actually reject any parse, because it can always infer that the sort of the<br>
argument and parameter are K, and it has no effect on the resulting sort of<br>
the term. However, it will nevertheless affect the kore generated from the term<br>
by introducing an additional parameter to the symbol generated for the term.</p>
<h3 class="mume-header" id="function-and-total-attributes"><code>function</code> and <code>total</code> attributes</h3>

<p>Many times it becomes easier to write a semantics if you have &quot;helper&quot;<br>
functions written which can be used in the RHS of rules. The <code>function</code><br>
attribute tells K that a given symbol should be simplified immediately when it<br>
appears anywhere in the configuration. Semantically, it means that evaluation<br>
of that symbol will result in at most one return value (that is, the symbol is<br>
a <em>partial function</em>).</p>
<p>The <code>total</code> attribute indicates that a symbol cannot be equal to matching logic<br>
bottom; in other words, it has <em>at least</em> one value for every possible set of<br>
arguments. It can be added to a production with the <code>function</code> attribute to<br>
indicate to the symbolic reasoning engine that a given symbol is a<br>
<em>total function</em>, that is it has <em>exactly</em> one return value for every possible<br>
input. Other uses of the <code>total</code> attribute (i.e., on multi-valued symbols to<br>
indicate they always have at least one value) are not yet implemented.</p>
<p>For example, here we define the <code>_+Word_</code> total function and the <code>_/Word_</code><br>
partial function, which can be used to do addition/division modulo<br>
<code>2 ^Int 256</code>. These functions can be used anywhere in the semantics where<br>
integers should not grow larger than <code>2 ^Int 256</code>. Notice how <code>_/Word_</code> is<br>
<em>not</em> defined when the denominator is <code>0</code>.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;+Word&quot;</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">]</span>
             <span class="token operator">|</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;/Word&quot;</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>

<span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">+</span>Word I2 <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>I1 <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> I2<span class="token punctuation">)</span> modInt <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">^</span><span class="token keyword keyword-Int">Int</span> <span class="token number">256</span><span class="token punctuation">)</span>
<span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">/</span>Word I2 <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>I1 <span class="token operator">/</span><span class="token keyword keyword-Int">Int</span> I2<span class="token punctuation">)</span> modInt <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">^</span><span class="token keyword keyword-Int">Int</span> <span class="token number">256</span><span class="token punctuation">)</span> <span class="token keyword keyword-requires">requires</span> I2 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span><span class="token keyword keyword-Int">Int</span> <span class="token number">0</span>
</pre><h3 class="mume-header" id="freshgenerator-attribute"><code>freshGenerator</code> attribute</h3>

<p>In K, you can access &quot;fresh&quot; values in a given domain using the syntax<br>
<code>!VARNAME:VarSort</code> (with the <code>!</code>-prefixed variable name). This is supported for<br>
builtin sorts <code>Int</code> and <code>Id</code> already. For example, you can generate fresh<br>
memory locations for declared identifiers as such:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> new var x <span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> ENV <span class="token operator">=&gt;</span> ENV <span class="token punctuation">[</span> x &lt;<span class="token operator">-</span> <span class="token operator">!</span>I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">]</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mem</span><span class="token punctuation">&gt;</span></span> MEM <span class="token operator">=&gt;</span> MEM <span class="token punctuation">[</span> <span class="token operator">!</span>I &lt;<span class="token operator">-</span> <span class="token number">0</span>     <span class="token punctuation">]</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mem</span><span class="token punctuation">&gt;</span></span>
</pre><p>Each time a <code>!</code>-prefixed variable is encountered, a new integer will be used,<br>
so each variable declared with <code>new var _ ;</code> will get a unique position in the<br>
<code>&lt;mem&gt;</code>.</p>
<p>Sometimes you want to have generation of fresh constants in a user-defined<br>
sort. For this, K will still generate a fresh <code>Int</code>, but can use a converter<br>
function you supply to turn it into the correct sort. For example, here we can<br>
generate fresh <code>Foo</code>s using the <code>freshFoo(_)</code> function annotated with<br>
<code>freshGenerator</code>.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> Foo <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;a&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;b&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;c&quot;</span> <span class="token operator">|</span> d <span class="token punctuation">(</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">)</span>

<span class="token keyword keyword-syntax">syntax</span> Foo <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> freshFoo <span class="token punctuation">(</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">)</span> <span class="token punctuation">[</span>freshGenerator<span class="token punctuation">,</span> function<span class="token punctuation">,</span> total<span class="token punctuation">]</span>

<span class="token keyword keyword-rule">rule</span> freshFoo<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a
<span class="token keyword keyword-rule">rule</span> freshFoo<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> b
<span class="token keyword keyword-rule">rule</span> freshFoo<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> c
<span class="token keyword keyword-rule">rule</span> freshFoo<span class="token punctuation">(</span>I<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> d<span class="token punctuation">(</span>I<span class="token punctuation">)</span> <span class="token punctuation">[</span>owise<span class="token punctuation">]</span>

<span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> new var x <span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> ENV <span class="token operator">=&gt;</span> ENV <span class="token punctuation">[</span> x &lt;<span class="token operator">-</span> <span class="token operator">!</span>I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span>  <span class="token punctuation">]</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mem</span><span class="token punctuation">&gt;</span></span> MEM <span class="token operator">=&gt;</span> MEM <span class="token punctuation">[</span> <span class="token operator">!</span>I &lt;<span class="token operator">-</span> <span class="token operator">!</span>F<span class="token punctuation">:</span>Foo <span class="token punctuation">]</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mem</span><span class="token punctuation">&gt;</span></span>
</pre><p>Now each newly allocated memory slot will have a fresh <code>Foo</code> placed in it.</p>
<h3 class="mume-header" id="token-attribute"><code>token</code> attribute</h3>

<p>The <code>token</code> attribute signals to the Kore generator that the associated sort<br>
will be inhabited by domain values. Sorts inhabited by domain values must not<br>
have any constructors declared.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> Bytes <span class="token punctuation">[</span>hook<span class="token punctuation">(</span>BYTES<span class="token punctuation">.</span>Bytes<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">token</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="converting-between-token-sorts">Converting between <code>[token]</code> sorts</h3>

<p>You can convert between tokens of one sort via <code>String</code>s by defining functions<br>
implemented by builtin hooks.<br>
The hook <code>STRING.token2string</code> allows conversion of any token to a string:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> FooToString<span class="token punctuation">(</span>Foo<span class="token punctuation">)</span>  <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>STRING<span class="token punctuation">.</span>token2string<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><p>Similarly, the hook <code>STRING.string2Token</code> allows the inverse:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> Bar <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> StringToBar<span class="token punctuation">(</span><span class="token keyword keyword-String">String</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>STRING<span class="token punctuation">.</span>string2token<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><p>WARNING: This sort of conversion does <em>NOT</em> do any sort of parsing or validation.<br>
Thus, we can create arbitary tokens of any sort:</p>
<pre data-role="codeBlock" data-info class="language-"><code>StringToBar(&quot;The sun rises in the west.&quot;)
</code></pre><p>Composing these two functions lets us convert from <code>Foo</code> to <code>Bar</code></p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> Bar <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> FooToBar<span class="token punctuation">(</span>Foo<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
<span class="token keyword keyword-rule">rule</span> FooToBar<span class="token punctuation">(</span>F<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> StringToBar<span class="token punctuation">(</span>FooToString<span class="token punctuation">(</span>F<span class="token punctuation">)</span><span class="token punctuation">)</span>
</pre><h3 class="mume-header" id="parsing-comments-and-the-layout-sort">Parsing comments, and the <code>#Layout</code> sort</h3>

<p>Productions for the <code>#Layout</code> sort are used to describe tokens that are<br>
considered &quot;whitespace&quot;. The scanner removes tokens matching these productions<br>
so they are not even seen by the parser. Below, we use it to define<br>
lines begining with <code>;</code> (semicolon) as comments.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> #Layout <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> r<span class="token string">&quot;(;[^\\n\\r]*)&quot;</span>    <span class="token comment">// Semi-colon comments</span>
                 <span class="token operator">|</span> r<span class="token string">&quot;([\\ \\n\\r\\t])&quot;</span> <span class="token comment">// Whitespace</span>
</pre><h3 class="mume-header" id="prec-attribute"><code>prec</code> attribute</h3>

<p>Consider the following naive attempt at creating a language what syntax that<br>
allows two types of variables: names that contain underbars, and names that<br>
contain sharps/hashes/pound-signs:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> NameWithUnderbar <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> r<span class="token string">&quot;[a-zA-Z][A-Za-z0-9_]*&quot;</span>  <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
<span class="token keyword keyword-syntax">syntax</span> NameWithSharp    <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> r<span class="token string">&quot;[a-zA-Z][A-Za-z0-9_#]*&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
<span class="token keyword keyword-syntax">syntax</span> Pgm <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> underbar<span class="token punctuation">(</span>NameWithUnderbar<span class="token punctuation">)</span>
             <span class="token operator">|</span> sharp<span class="token punctuation">(</span>NameWithSharp<span class="token punctuation">)</span>
</pre><p>Although, it seems that K has enough information to parse the programs<br>
<code>underbar(foo)</code> and <code>sharp(foo)</code> with, the lexer does not take into account<br>
whether a token is being parsed for the <code>sharp</code> or for the <code>underbar</code><br>
production. It chooses an arbitary sort for the token <code>foo</code> (perhaps<br>
<code>NameWithUnderbar</code>). Thus, during paring it is unable to construct a valid term<br>
for one of those programs (<code>sharp(foo)</code>) and produces the error message:<br>
<code>Inner Parser: Parse error: unexpected token &apos;foo&apos;.</code></p>
<p>Since calculating inclusions and intersections between regular expressions is<br>
tricky, we must provide this information to K. We do this via the <code>prec(N)</code><br>
attribute. The lexer will always prefer longer tokens to shorter tokens.<br>
However, when it has to choose between two different tokens of equal length,<br>
token productions with higher precedence are tried first. Note that the default<br>
precedence value is zero when the <code>prec</code> attribute is not specified.</p>
<p>For example, the <code>BUILTIN-ID-TOKENS</code> module defines <code>#UpperId</code> and <code>#LowerId</code> with<br>
the <code>prec(2)</code> attribute.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> #LowerId <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> r<span class="token string">&quot;[a-z][a-zA-Z0-9]*&quot;</span>                    <span class="token punctuation">[</span>prec<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">token</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> #UpperId <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> r<span class="token string">&quot;[A-Z][a-zA-Z0-9]*&quot;</span>                    <span class="token punctuation">[</span>prec<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">token</span><span class="token punctuation">]</span>
</pre><p>Furthermore, we also need to make sorts with more specific tokens subsorts of ones with more<br>
general tokens. We add the token attribute to this production so that all<br>
tokens of a particular sort are marked with the sort they are parsed as and not a<br>
subsort thereof. e.g. we get <code>underbar(#token(&quot;foo&quot;, &quot;NameWithUnderbar&quot;))</code><br>
instead of <code>underbar(#token(&quot;foo&quot;, &quot;#LowerId&quot;))</code></p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-imports">imports</span> BUILTIN<span class="token operator">-</span>ID<span class="token operator">-</span>TOKENS
<span class="token keyword keyword-syntax">syntax</span> NameWithUnderbar <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> r<span class="token string">&quot;[a-zA-Z][A-Za-z0-9_]*&quot;</span> <span class="token punctuation">[</span>prec<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">token</span><span class="token punctuation">]</span>
                          <span class="token operator">|</span> #UpperId                <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
                          <span class="token operator">|</span> #LowerId                <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
<span class="token keyword keyword-syntax">syntax</span> NameWithSharp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> r<span class="token string">&quot;[a-zA-Z][A-Za-z0-9_#]*&quot;</span> <span class="token punctuation">[</span>prec<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">token</span><span class="token punctuation">]</span>
                       <span class="token operator">|</span> #UpperId                 <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
                       <span class="token operator">|</span> #LowerId                 <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
<span class="token keyword keyword-syntax">syntax</span> Pgm <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> underbar<span class="token punctuation">(</span>NameWithUnderbar<span class="token punctuation">)</span>
             <span class="token operator">|</span> sharp<span class="token punctuation">(</span>NameWithSharp<span class="token punctuation">)</span>
</pre><h3 class="mume-header" id="unused-attribute"><code>unused</code> attribute</h3>

<p>K will warn you if you declare a symbol that is not used in any of the rules of<br>
your definition. Sometimes this is intentional, however; in this case, you can<br>
suppress the warning by adding the <code>unused</code> attribute to the production or<br>
cell.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> Foo <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> foo<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>unused<span class="token punctuation">]</span>

<span class="token keyword keyword-configuration">configuration</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>foo</span> <span class="token attr-name">unused</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>foo</span><span class="token punctuation">&gt;</span></span>
</pre><h3 class="mume-header" id="deprecated-attribute"><code>deprecated</code> attribute</h3>

<p>Symbols can be marked as deprecated by adding the <code>deprecated</code> attribute to<br>
their declaration. If that symbol subsequently appears in the definition (in a<br>
rule, context, context alias or configuration), the compiler will issue a<br>
warning.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> Foo <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> foo<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>deprecated<span class="token punctuation">]</span>
<span class="token keyword keyword-rule">rule</span> foo<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span> <span class="token comment">// warning on this line</span>
</pre><h3 class="mume-header" id="symbol-priority-and-associativity">Symbol priority and associativity</h3>

<p>Unlike most other parser generators, K combines the task of parsing with AST<br>
generation. A production declared with the <code>syntax</code> keyword in K is both a<br>
piece of syntax used when parsing, and a symbol that is used when rewriting.<br>
As a result, it is generally convenient to describe expression grammars using<br>
priority and associativity declarations rather than explicitly transforming<br>
your grammar into a series of nonterminals, one for each level of operator<br>
precedence. Thus, for example, a simple grammar for addition and multiplication<br>
will look like this:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Exp <span class="token string">&quot;*&quot;</span> Exp
             <span class="token operator">|</span> Exp <span class="token string">&quot;+&quot;</span> Exp
</pre><p>However, this grammar is ambiguous. The term <code>x+y*z</code> might refer to <code>x+(y*z)</code><br>
or to <code>(x+y)*z</code>. In order to differentiate this, we introduce a partial<br>
ordering between productions known as priority. A symbol &quot;has tighter priority&quot;<br>
than another symbol if the first symbol can appear under the second, but the<br>
second cannot appear under the first without a bracket. For example, in<br>
traditional arithmetic, multiplication has tighter priority than addition,<br>
which means that <code>x+y*z</code> cannot parse as <code>(x+y)*z</code> because the addition<br>
operator would appear directly beneath the multiplication, which is forbidden<br>
by the priority filter.</p>
<p>Priority is applied individually to each possible ambiguous parse of a term. It<br>
then either accepts or rejects that parse. If there is only a single remaining<br>
parse (after all the other disambiguation steps have happened), this is the<br>
parse that is chosen. If all the parses were rejected, it is a parse error. If<br>
multiple parses remain, they might be resolved by further disambiguation such<br>
as via the <code>prefer</code> and <code>avoid</code> attributes, but if multiple parses remain after<br>
disambiguation finishes, this is an ambiguous parse error, indicating there is<br>
not a unique parse for that term. In the vast majority of cases, this is<br>
an error and indicates that you ought to either change your grammar or add<br>
brackets to the term in question.</p>
<p>Priority is specified in K grammars by means of one of two different<br>
mechanisms. The first, and simplest, simply replaces the <code>|</code> operator in a<br>
sequence of K productions with the <code>&gt;</code> operator. This operator indicates that<br>
everything prior to the <code>&gt;</code> operator (including transitively) binds tighter<br>
than what comes after. For example, a more complete grammar for simple<br>
arithmetic might be:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Exp <span class="token string">&quot;*&quot;</span> Exp
             <span class="token operator">|</span> Exp <span class="token string">&quot;/&quot;</span> Exp
             &gt; Exp <span class="token string">&quot;+&quot;</span> Exp
             <span class="token operator">|</span> Exp <span class="token string">&quot;-&quot;</span> Exp
</pre><p>This indicates that multiplication and division bind tigher than addition<br>
and subtraction, but that there is no relationship in priority between<br>
multiplication and division.</p>
<p>As you may have noticed, this grammar is also ambiguous. <code>x*y/z</code> might refer to<br>
<code>x*(y/z)</code> or to <code>(x*y)/z</code>. Indeed, if we removed division and subtraction<br>
entirely, the grammar would still be ambiguous: <code>x*y*z</code> might parse as<br>
<code>x*(y*z)</code>, or as <code>(x*y)*z</code>. To resolve this, we introduce another feature:<br>
associativity. Roughly, asssociativity tells us how symbols are allowed to nest<br>
within other symbols with the same priority. If a set of symbols is left<br>
associative, then symbols in that set cannot appear as the rightmost child<br>
of other symbols in that set. If a set of symbols is right associative, then<br>
symbols in that set cannot appear as the leftmost child of other symbols in<br>
that set. Finally, if a set of symbols is non-associative, then symbols<br>
in that set cannot appear as the rightmost or leftmost child of other symbols<br>
in that set. For example, in the above example, if addition and subtraction<br>
are left associative, then <code>x+y+z</code> will parse as <code>(x+y)+</code>z and <code>x+y-z</code> will<br>
parse as <code>(x+y)-z</code> (because the other parse will have been rejected).</p>
<p>You might notice that this seems to apply only to binary infix operators. In<br>
fact, the real behavior is slightly more complicated. Priority and<br>
associativity (for technical reasons that go beyond the scope of this document)<br>
really only apply when the rightmost or leftmost item in a production is a<br>
nonterminal. If the rightmost nonterminal is followed by a terminal (or<br>
respectively the leftmost preceded), priority and associativity do not apply.<br>
Thus we can generalize these concepts to arbitrary context-free grammars.</p>
<p>Note that in some cases, this is not the behavior you want. You may actually<br>
want to reject parses even though the leftmost and rightmost item in a<br>
production are terminals. You can accomplish this by means of the<br>
<code>applyPriority</code> attribute. When placed on a production, it tells the parser<br>
which nonterminals of a production the priority filter ought to reject children<br>
under, overriding the default behavior. For example, I might have a production<br>
like <code>syntax Exp ::= foo(Exp, Exp) [applyPriority(1)]</code>. This tells the parser<br>
to reject terms with looser priority binding under the first <code>Exp</code>, but not<br>
the second. By default, with this production, neither position would apply<br>
to the priority filter, because the first and last items of the production<br>
are both terminals.</p>
<p>Associativity is specified in K grammars by means of one of two different<br>
mechanisms. The first, and simplest, adds the associativity of a priority block<br>
of symbols prior to that block. For example, we can remove the remaining<br>
ambiguities in the above grammar like so:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token class-name">left</span><span class="token punctuation">:</span>
               Exp <span class="token string">&quot;*&quot;</span> Exp
             <span class="token operator">|</span> Exp <span class="token string">&quot;/&quot;</span> Exp
             &gt; <span class="token class-name">right</span><span class="token punctuation">:</span>
               Exp <span class="token string">&quot;+&quot;</span> Exp
             <span class="token operator">|</span> Exp <span class="token string">&quot;-&quot;</span> Exp
</pre><p>This indicates that multiplication and division are left-associative, ie, after<br>
symbols with higher priority are parsed as innermost, symbols are nested with<br>
the rightmost on top. Addition and subtraction are right associative, which<br>
is the opposite and indicates that symbols are nested with the leftmost on top.<br>
Note that this is similar but different from evaluation order, which also<br>
concerns itself with the ordering of symbols, which is described in the next<br>
section.</p>
<p>You may note we have not yet introduced the second syntax for priority<br>
and associativity. In some cases, syntax for a grammar might be spread across<br>
multiple modules, sometimes for very good reasons with respect to code<br>
modularity. As a result, it becomes infeasible to declare priority and<br>
associativity inline within a set of productions, because the productions<br>
are not contiguous within a single file.</p>
<p>For this purpose, we introduce the equivalent <code>syntax priority</code>,<br>
<code>syntax left</code>, <code>syntax right</code>, and <code>syntax non-assoc</code> declarations. For<br>
example, the above grammar can be written equivalently as:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Exp <span class="token string">&quot;*&quot;</span> Exp <span class="token punctuation">[</span>group<span class="token punctuation">(</span>mult<span class="token punctuation">)</span><span class="token punctuation">]</span>
             <span class="token operator">|</span> Exp <span class="token string">&quot;/&quot;</span> Exp <span class="token punctuation">[</span>group<span class="token punctuation">(</span>div<span class="token punctuation">)</span><span class="token punctuation">]</span>
             <span class="token operator">|</span> Exp <span class="token string">&quot;+&quot;</span> Exp <span class="token punctuation">[</span>group<span class="token punctuation">(</span>add<span class="token punctuation">)</span><span class="token punctuation">]</span>
             <span class="token operator">|</span> Exp <span class="token string">&quot;-&quot;</span> Exp <span class="token punctuation">[</span>group<span class="token punctuation">(</span>sub<span class="token punctuation">)</span><span class="token punctuation">]</span>

<span class="token keyword keyword-syntax priority">syntax priority</span> mult div &gt; add sub
<span class="token keyword keyword-syntax left">syntax left</span> mult div
<span class="token keyword keyword-syntax right">syntax right</span> add sub
</pre><p>Here, the <code>group(_)</code> attribute is used to create user-defined groups of<br>
sentences. A particular group name collectively refers to the whole set of<br>
sentences within that group. The sets are flattened together, so we could<br>
equivalently have written:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Exp <span class="token string">&quot;*&quot;</span> Exp <span class="token punctuation">[</span>group<span class="token punctuation">(</span>mult<span class="token punctuation">)</span><span class="token punctuation">]</span>
             <span class="token operator">|</span> Exp <span class="token string">&quot;/&quot;</span> Exp <span class="token punctuation">[</span>group<span class="token punctuation">(</span>mult<span class="token punctuation">)</span><span class="token punctuation">]</span>
             <span class="token operator">|</span> Exp <span class="token string">&quot;+&quot;</span> Exp <span class="token punctuation">[</span>group<span class="token punctuation">(</span>add<span class="token punctuation">)</span><span class="token punctuation">]</span>
             <span class="token operator">|</span> Exp <span class="token string">&quot;-&quot;</span> Exp <span class="token punctuation">[</span>group<span class="token punctuation">(</span>add<span class="token punctuation">)</span><span class="token punctuation">]</span>

<span class="token keyword keyword-syntax priority">syntax priority</span> mult &gt; add
<span class="token keyword keyword-syntax left">syntax left</span> mult
<span class="token keyword keyword-syntax right">syntax right</span> add
</pre><p>Note that <code>syntax [left|right|non-assoc]</code> should not be used to group together<br>
productions with different priorities. For example, this code would be invalid:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax priority">syntax priority</span> mult &gt; add
<span class="token keyword keyword-syntax left">syntax left</span> mult add
</pre><p>Note that there is one other way to describe associativity, but it is<br>
prone to a very common mistake. You can apply the attribute <code>left</code>, <code>right</code>,<br>
or <code>non-assoc</code> directly to a production to indicate that it is, by itself,<br>
left-, right-, or non-associative.</p>
<p>However, this often does not mean what users think it means. In particular:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Exp <span class="token string">&quot;+&quot;</span> Exp <span class="token punctuation">[</span><span class="token class-name">left</span><span class="token punctuation">]</span>
             <span class="token operator">|</span> Exp <span class="token string">&quot;-&quot;</span> Exp <span class="token punctuation">[</span><span class="token class-name">left</span><span class="token punctuation">]</span>
</pre><p>is not equivalent to:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token class-name">left</span><span class="token punctuation">:</span>
               Exp <span class="token string">&quot;+&quot;</span> Exp
             <span class="token operator">|</span> Exp <span class="token string">&quot;-&quot;</span> Exp
</pre><p>Under the first, each production is associative with itself, but not each<br>
other. Thus, <code>x+y+z</code> will parse unambiguously as <code>(x+y)+z</code>, but <code>x+y-z</code> will<br>
be ambiguous. However, in the second, <code>x+y-z</code> will parse unambiguously as<br>
<code>(x+y)-z</code>.</p>
<p>Think carefully about how you want your grammar to parse. In general, if you&apos;re<br>
not sure, it&apos;s probably best to group associativity together into the same<br>
blocks you use for priority, rather than using <code>left</code>, <code>right</code>, or <code>non-assoc</code><br>
attributes on the productions.</p>
<h3 class="mume-header" id="lexical-identifiers">Lexical identifiers</h3>

<p>Sometimes it is convenient to be able to give a certain regular expression a<br>
name and then refer to it in one or more regular expression terminals. This<br>
can be done with a <code>syntax lexical</code> sentence in K:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax lexical">syntax lexical</span> Alphanum <span class="token operator">=</span> r<span class="token string">&quot;[0-9a-zA-Z]&quot;</span>
</pre><p>This defines a lexical identifier <code>Alphanum</code> which can be expanded in any<br>
regular expression terminal to the above regular expression. For  example, I<br>
might choose to then implement the syntax of identifiers as follows:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Id">Id</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> r<span class="token string">&quot;[a-zA-Z]{Alphanum}*&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
</pre><p>Here <code>{Alphanum}</code> expands to the above regular expression, making the sentence<br>
equivalent to the following:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Id">Id</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> r<span class="token string">&quot;[a-zA-Z]([0-9a-zA-Z])*&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
</pre><p>This feature can be used to more modularly construct the lexical syntax of your<br>
language. Note that K does not currently check that lexical identifiers used<br>
in regular expressions have been defined; this will generate an error when<br>
creating the scanner, however, and the user ought to be able to debug what<br>
happened.</p>
<h3 class="mume-header" id="assoc-comm-idem-and-unit-attributes"><code>assoc</code>, <code>comm</code>, <code>idem</code>, and <code>unit</code> attributes</h3>

<p>These attributes are used to indicate whether a collection or a production<br>
is associative, commutative, idempotent, and/or has a unit.<br>
In general, you should not need to apply these attributes to productions<br>
yourself, however, they do have certain special meaning to K. K will generate<br>
axioms related to each of these concepts into your definition for you<br>
automatically. It will also automatically sort associative-commutative<br>
collections, and flatten the indentation of associative collections, when<br>
unparsing.</p>
<h3 class="mume-header" id="public-and-private-attribute"><code>public</code> and <code>private</code> attribute</h3>

<p>K allows users to declare certain pieces of syntax as either public or private.<br>
All syntax is public by default. Public syntax can be used from any module that<br>
imports that piece of syntax. A piece of syntax can be declared private with<br>
the <code>private</code> attribute. This means that that syntax can only be used in the<br>
module in which it is declared; it is not visible from modules that import<br>
that module.</p>
<p>You can also change the default visibility of a module with the <code>private</code><br>
attribute, when it is placed directly on a module. A module with the <code>private</code><br>
attribute has all syntax <code>private</code> by default; this can be overridden on<br>
specific sentences with the <code>public</code> attribute.</p>
<p>Note that the <code>private</code> module attribute also changes the default visiblity<br>
of imports; please refer to the appropriate section elsewhere in the manual<br>
for more details.</p>
<p>Here is an example usage:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> WIDGET<span class="token operator">-</span>SYNTAX

  <span class="token keyword keyword-syntax">syntax</span> Widget <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> foo<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-syntax">syntax</span> WidgetHelper <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> bar<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>private<span class="token punctuation">]</span> <span class="token comment">// this production is not visible</span>
                                          <span class="token comment">// outside this module</span>
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> WIDGET <span class="token punctuation">[</span>private<span class="token punctuation">]</span>
  <span class="token keyword keyword-imports">imports</span> WIDGET<span class="token operator">-</span>SYNTAX

  <span class="token keyword keyword-syntax">syntax</span> Widget <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> fooImpl<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// this production is not visible outside this</span>
                              <span class="token comment">// module</span>

  <span class="token comment">// this production is visible outside this module</span>
  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> adjustWidget<span class="token punctuation">(</span>Widget<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> public<span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><h2>Configuration Declaration</h2>
<h3 class="mume-header" id="exit-attribute"><code>exit</code> attribute</h3>

<p>A single configuration cell containing an integer may have the &quot;exit&quot;<br>
attribute. This integer will then be used as the return value on the console<br>
when executing the program.</p>
<p>For example:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-configuration">configuration</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> $PGM<span class="token punctuation">:</span>Pgm <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>status-code</span> <span class="token attr-name">exit</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token number">1</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>status-code</span><span class="token punctuation">&gt;</span></span>
</pre><p>declares that the cell <code>status-code</code> should be used as the exit-code for<br>
invocations of <code>krun</code>. Additionally, we state that the default exit-code is <code>1</code><br>
(an error state). One use of this is for writing testing harnesses which assume<br>
that the test fails until proven otherwise and only set the <code>&lt;status-code&gt;</code> cell<br>
to <code>0</code> if the test succeeds.</p>
<h3 class="mume-header" id="collection-cells-multiplicity-and-type-attributes">Collection Cells: <code>multiplicity</code> and <code>type</code> attributes</h3>

<p>Sometimes a semantics needs to allow multiple copies of the same cell, for<br>
example if you are making a concurrent multi-threading programming language.<br>
For this purpose, K supports the <code>multiplicity</code> and <code>type</code> attributes on cells<br>
declared in the configuration.</p>
<p><code>multiplicity</code> can take on values <code>*</code> and <code>?</code>. Declaring <code>multiplicity=&quot;*&quot;</code><br>
indicates that the cell may appear any number of times in a runtime<br>
configuration. Setting <code>multiplicity=&quot;?&quot;</code> indicates that the cell may only<br>
appear exactly 0 or 1 times in a runtime configuration. If there are no<br>
configuration variables present in the cell collection, the initial<br>
configuration will start with exactly 0 instances of the cell collection. If<br>
there are configuration variables present in the cell collection, the initial<br>
configuration will start with exactly 1 instance of the cell collection.</p>
<p><code>type</code> can take on values <code>Set</code>, <code>List</code>, and <code>Map</code>. For example, here we declare<br>
several collecion cells:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-configuration">configuration</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> $PGM<span class="token punctuation">:</span>Pgm <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sets</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>set</span>  <span class="token attr-name">multiplicity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>?<span class="token punctuation">&quot;</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Set<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>  <span class="token number">0</span><span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>set</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sets</span><span class="token punctuation">&gt;</span></span>
              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>lists</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>list</span> <span class="token attr-name">multiplicity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>*<span class="token punctuation">&quot;</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>List<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token number">0</span><span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>list</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>lists</span><span class="token punctuation">&gt;</span></span>
              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maps</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>map</span> <span class="token attr-name">multiplicity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>*<span class="token punctuation">&quot;</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Map<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>map-key</span><span class="token punctuation">&gt;</span></span> <span class="token number">0</span><span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>map-key</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>map-value-1</span><span class="token punctuation">&gt;</span></span> <span class="token string">&quot;&quot;</span><span class="token punctuation">:</span><span class="token keyword keyword-String">String</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>map-value-1</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>map-value-2</span><span class="token punctuation">&gt;</span></span> <span class="token number">0</span><span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>map-value-2</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>map</span><span class="token punctuation">&gt;</span></span>
              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maps</span><span class="token punctuation">&gt;</span></span>
</pre><p>Declaring <code>type=&quot;Set&quot;</code> indicates that duplicate occurrences of the cell should<br>
be de-duplicated, and accesses to instances of the cell will be nondeterministic<br>
choices (constrained by any other parts of the match and side-conditions).<br>
Similarly, declaring <code>type=&quot;List&quot;</code> means that new instances of the cell can be<br>
added at the front or back, and elements can be accessed from the front or back,<br>
and the order of the cells will be maintained. The following are examples of<br>
introduction and elimination rules for these collections:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> introduce<span class="token operator">-</span>set<span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sets</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Bag <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>set</span><span class="token punctuation">&gt;</span></span> I <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>set</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sets</span><span class="token punctuation">&gt;</span></span>

<span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> eliminate<span class="token operator">-</span>set <span class="token operator">=&gt;</span> I <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sets</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>set</span><span class="token punctuation">&gt;</span></span> I <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>set</span><span class="token punctuation">&gt;</span></span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Bag <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sets</span><span class="token punctuation">&gt;</span></span>

<span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> introduce<span class="token operator">-</span>list<span class="token operator">-</span>start<span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>lists</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span><span class="token punctuation">.</span>Bag <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>list</span><span class="token punctuation">&gt;</span></span> I <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>list</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>lists</span><span class="token punctuation">&gt;</span></span>

<span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> introduce<span class="token operator">-</span>list<span class="token operator">-</span>end<span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>lists</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">(</span><span class="token punctuation">.</span>Bag <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>list</span><span class="token punctuation">&gt;</span></span> I <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>list</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>lists</span><span class="token punctuation">&gt;</span></span>

<span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> eliminate<span class="token operator">-</span>list<span class="token operator">-</span>start <span class="token operator">=&gt;</span> I <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>lists</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>list</span><span class="token punctuation">&gt;</span></span> I <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>list</span><span class="token punctuation">&gt;</span></span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Bag<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>lists</span><span class="token punctuation">&gt;</span></span>

<span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> eliminate<span class="token operator">-</span>list<span class="token operator">-</span>end <span class="token operator">=&gt;</span> I <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>lists</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>list</span><span class="token punctuation">&gt;</span></span> I <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>list</span><span class="token punctuation">&gt;</span></span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Bag<span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>lists</span><span class="token punctuation">&gt;</span></span>
</pre><p>Notice that for <code>multiplicity=&quot;?&quot;</code>, we only admit a single <code>&lt;set&gt;</code> instance at<br>
a time. For the <code>type=List</code> cell, we can add/eliminate cells from the from or<br>
back of the <code>&lt;lists&gt;</code> cell. Also note that we use <code>.Bag</code> to indicate the empty<br>
cell collection in all cases.</p>
<p>Declaring <code>type=&quot;Map&quot;</code> indicates that the first sub-cell will be used as a<br>
cell-key. This means that matching on those cells will be done as a map-lookup<br>
operation if the cell-key is mentioned in the rule (for performance). If the<br>
cell-key is not mentioned, it will fallback to normal nondeterministic<br>
constrained by other parts of the match and any side-conditions. Note that there<br>
is no special meaning to the name of the cells (in this case <code>&lt;map&gt;</code>,<br>
<code>&lt;map-key&gt;</code>, <code>&lt;map-value-1&gt;</code>, and <code>&lt;map-value-2&gt;</code>). Additionally, any number of<br>
sub-cells are allowed, and the <em>entire</em> instance of the cell collection is<br>
considered part of the cell-value, including the cell-key (<code>&lt;map-key&gt;</code> in this<br>
case) and the surrounding collection cell (<code>&lt;map&gt;</code> in this case).</p>
<p>For example, the following rules introduce, set, retrieve from, and eliminate<br>
<code>type=&quot;Map&quot;</code> cells:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> introduce<span class="token operator">-</span>map<span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maps</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">(</span><span class="token punctuation">.</span>Bag <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>map</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>map-key</span><span class="token punctuation">&gt;</span></span> I <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>map-key</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>map</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maps</span><span class="token punctuation">&gt;</span></span>

<span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> set<span class="token operator">-</span>map<span class="token operator">-</span>value<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> S<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>map</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>map-key</span><span class="token punctuation">&gt;</span></span> I <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>map-key</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>map-value-1</span><span class="token punctuation">&gt;</span></span> _ <span class="token operator">=&gt;</span> S <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>map-value-1</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>map</span><span class="token punctuation">&gt;</span></span>

<span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> set<span class="token operator">-</span>map<span class="token operator">-</span>value<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> V<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>map</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>map-key</span><span class="token punctuation">&gt;</span></span> I <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>map-key</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>map-value-2</span><span class="token punctuation">&gt;</span></span> _ <span class="token operator">=&gt;</span> V <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>map-value-2</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>map</span><span class="token punctuation">&gt;</span></span>

<span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> retrieve<span class="token operator">-</span>map<span class="token operator">-</span>value<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> S <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>map</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>map-key</span><span class="token punctuation">&gt;</span></span> I <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>map-key</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>map-value-1</span><span class="token punctuation">&gt;</span></span> S <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>map-value-1</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>map</span><span class="token punctuation">&gt;</span></span>

<span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> retrieve<span class="token operator">-</span>map<span class="token operator">-</span>value<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> V <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>map</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>map-key</span><span class="token punctuation">&gt;</span></span> I <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>map-key</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>map-value-2</span><span class="token punctuation">&gt;</span></span> V <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>map-value-2</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>map</span><span class="token punctuation">&gt;</span></span>

<span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> eliminate<span class="token operator">-</span>map<span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maps</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>map</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>map-key</span><span class="token punctuation">&gt;</span></span> I <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>map-key</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>map</span><span class="token punctuation">&gt;</span></span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Bag<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maps</span><span class="token punctuation">&gt;</span></span>
</pre><p>Note how each rule makes sure that <code>&lt;map-key&gt;</code> cell is mentioned, and we<br>
continue to use <code>.Bag</code> to indicate the empty collection. Also note that<br>
when introducing new map elements, you may omit any of the sub-cells which are<br>
not the cell-key. In case you do omit sub-cells, you must use structural<br>
framing <code>...</code> to indicate the missing cells, they will receive the default<br>
value given in the <code>configuration ...</code> declaration.</p>
<h2>Rule Declaration</h2>
<h3 class="mume-header" id="rule-structure">Rule Structure</h3>

<p>Each K rule follows the same basic structure (given as an example here):</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-rule">rule</span> LHS <span class="token operator">=&gt;</span> RHS <span class="token keyword keyword-requires">requires</span> REQ ensures ENS <span class="token punctuation">[</span>ATTRS<span class="token punctuation">]</span>
</pre><p>The portion between <code>rule</code> and <code>requires</code> is referred to as the <em>rule body</em>,<br>
and may contain one or more rewrites (though not nested). Here, the rule body is<br>
<code>LHS =&gt; RHS</code>, where <code>LHS</code> and <code>RHS</code> are used as placeholders for the pre- and<br>
post- states. Note that we lose no generality referring to <em>the</em> <code>LHS</code> or <em>the</em><br>
<code>RHS</code>, even in the presence of multiple rewrites, as the rewrites are pulled to<br>
the top-level anyway.</p>
<p>Next is the <em>requires clause</em>, represented here as <code>REQ</code>. The requires clause is<br>
an additional predicate (function-like term of sort <code>Bool</code>), which is to be<br>
evaluated before applying the rule. If the requires clause does not evaluate to<br>
<code>true</code>, then the rule does not apply.</p>
<p>Finally is the <em>ensures clause</em>, represented here as <code>ENS</code>. The ensures clause<br>
is to be interpreted as a post-condition, and will be automatically added to the<br>
path condition if the rule applies. It <em>may</em> cause the entire term to become<br>
undefined, but the backend will not stop itself from applying the rule in this<br>
case. Note that concrete backends (eg. the LLVM backend) are free to ignore the<br>
ensures clause.</p>
<p>Overall, the transition represented by such a rule is from a state<br>
<code>LHS #And REQ</code> ending in a state <code>RHS #And ENS</code>. When backends apply this rule<br>
as a transition/rewrite, they should:</p>
<ul>
<li>Check if pattern <code>LHS</code> matches (or unifies) with the current term, giving<br>
substitution <code>alpha</code>.</li>
<li>Check if the instantiation <code>alpha(REQ)</code> is valid (or satisfiable).</li>
<li>Build the new term <code>alpha(RHS #And ENS)</code>, and check if it&apos;s satisfiable.</li>
</ul>
<h3 class="mume-header" id="pattern-matching-operator">Pattern Matching operator</h3>

<p>Sometimes when you want to express a side condition, you want to say that a<br>
rule matches if a particular term matches a particular pattern, or if it<br>
instead does /not/ match a particular pattern.</p>
<p>The syntax in K for this is :=K and :/=K. It has similar meaning to ==K and<br>
=/=K, except that where ==K and =/=K express equality, :=K and =/=K express<br>
model membership. That is to say, whether or not the rhs is a member of the set<br>
of terms expressed by the lhs pattern. Because the lhs of these operators is a<br>
pattern, the user can use variables in the lhs of the operator. However, due to<br>
current limitations, these variables are <em>NOT</em> bound in the rest of the term.<br>
The user is thus encouraged to use anonymous variables only, although this is<br>
not required.</p>
<p>This is compiled by the K frontend down to an efficient pattern matching on a<br>
fresh function symbol.</p>
<h3 class="mume-header" id="anonymous-function-applications">Anonymous function applications</h3>

<p>There are a number of cases in K where you would prefer to be able to take some<br>
term on the RHS, bind it to a variable, and refer to it in multiple different<br>
places in a rule.</p>
<p>You might also prefer to take a variable for which you know some of its<br>
structure, and modify some of its internal structure without requiring you to<br>
match on every single field contained inside that structure.</p>
<p>In order to do this, we introduce syntax to K that allows you to construct<br>
anonymous functions in the RHS of a rule and apply them to a term.</p>
<p>The syntax for this is:</p>
<pre data-role="codeBlock" data-info class="language-"><code>#fun(RuleBody)(Argument)
</code></pre><p>Note the limitations currently imposed by the implementation. These functions<br>
are not first-order: you cannot bind them to a variable and inject them like<br>
you can with a regular klabel for a function. You also cannot express multiple<br>
rules or multiple parameters, or side conditions. All of these are extensions<br>
we would like to support in the future, however.</p>
<p>In the following, we use three examples to illustrate the behavior of <code>#fun</code>.<br>
We point out that the support for <code>#fun</code> is provided by the frontend, not the<br>
backends.</p>
<p>The three examples are real examples borrowed or modified from existing language<br>
semantics.</p>
<p><em>Example 1 (A Simple Self-Explained Example).</em></p>
<pre data-role="codeBlock" data-info class="language-"><code>#fun(V:Val =&gt; isFoo(V) andBool isBar(V))(someFunctionReturningVal())
</code></pre><p><em>Example 2 (Nested #fun).</em></p>
<pre data-role="codeBlock" data-info class="language-"><code>   #fun(C
=&gt; #fun(R
=&gt; #fun(E
=&gt; foo1(E, R, C)
  )(foo2(C))
  )(foo3(0))
  )(foo4(1))
</code></pre><p>This example is from the <code>beacon</code><br>
semantics:<a href="https://github.com/runtimeverification/beacon-chain-spec/blob/master/b">https://github.com/runtimeverification/beacon-chain-spec/blob/master/b</a><br>
eacon-chain.k at line 302, with some modification for simplicity. Note how<br>
variables <code>C, R, E</code> are bound in the nested <code>#fun</code>.</p>
<p><em>Example 3 (Matching a structure).</em></p>
<pre data-role="codeBlock" data-info class="language-"><code>rule foo(K, RECORD) =&gt;
  #fun(record(... field: _ =&gt; K))(RECORD)
</code></pre><p>Unlike previous examples, the LHS of <code>#fun</code> in this example is no longer a<br>
variable, but a structure. It has the same spirit as the first two examples,<br>
but we match the <code>RECORD</code> with a structure <code>record( DotVar, field: X)</code>, instead<br>
of a standalone variable. We also use K&apos;s local rewrite syntax (i.e., the<br>
rewriting symbol <code>=&gt;</code> does not occur at the top-level) to prevent writing<br>
duplicate expressions on the LHS and RHS of the rewriting.</p>
<h3 class="mume-header" id="macros-and-aliases">Macros and Aliases</h3>

<p>A production can be tagged with the <code>macro</code>, <code>alias</code>, <code>macro-rec</code>, or <code>alias-rec</code><br>
attributes. In all cases, what this signifies is that this is a macro production.<br>
Macro rules are rules where the top symbol of the left-hand-side are macro<br>
labels. Macro rules are applied statically during compilation on all terms that<br>
they match, and statically before program execution on the initial configuration.<br>
Currently, macro rules are required to not have side conditions, although they<br>
can contain sort checks.</p>
<p><code>alias</code> rules are also applied statically in reverse prior to unparsing on the<br>
final configuration. Note that a macro rule can have unbound variables in the<br>
right hand side. When such a macro exists, it should be used only on the left<br>
hand side of rules, unless the user is performing symbolic execution and expects<br>
to introduce symbolic terms into the subject being rewritten.</p>
<p>However, when used on the left hand side of a rule, it functions similarly to a<br>
pattern alias, and allows the user to concisely express a reusable pattern that<br>
they wish to match on in multiple places.</p>
<p>For example, consider the following semantics:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;foo&quot;</span> <span class="token punctuation">[</span>alias<span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token string">&quot;foobar&quot;</span>
<span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> bar<span class="token punctuation">(</span>KItem<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span> <span class="token operator">|</span> baz<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> KItem<span class="token punctuation">)</span>
<span class="token keyword keyword-rule">rule</span> foo <span class="token operator">=&gt;</span> foobar
<span class="token keyword keyword-rule">rule</span> bar<span class="token punctuation">(</span>I<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> baz<span class="token punctuation">(</span><span class="token operator">?</span>_<span class="token punctuation">,</span> I<span class="token punctuation">)</span>
<span class="token keyword keyword-rule">rule</span> bar<span class="token punctuation">(</span>I<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> I
</pre><p>This will rewrite <code>baz(0, foo)</code> to <code>foo</code>. First <code>baz(0, foo)</code> will be rewritten<br>
statically to <code>baz(0, foobar)</code>. Then the non-<code>macro</code> rule will apply (because<br>
the rule will have been rewritten to <code>rule baz(_, I) =&gt; I</code>). Then <code>foobar</code> will<br>
be rewritten statically after rewriting finishes to <code>foo</code> via the reverse form<br>
of the alias.</p>
<p>Note that macros do not apply recursively within their own expansion. This is<br>
done so as to ensure that macro expansion will always terminate. If the user<br>
genuinely desires a recursive macro, the <code>macro-rec</code> and <code>alias-rec</code> attributes<br>
can be used to provide this behavior.</p>
<p>For example, consider the following semantics:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;int&quot;</span> Exp <span class="token string">&quot;;&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;int&quot;</span> Exps <span class="token string">&quot;;&quot;</span> <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span> <span class="token operator">|</span> Exp Exp <span class="token operator">|</span> <span class="token keyword keyword-Id">Id</span>
<span class="token keyword keyword-syntax">syntax</span> Exps <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Exp<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>

<span class="token keyword keyword-rule">rule</span> int X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span> X<span class="token string">&apos;:Id, Xs:Exps ; =&gt; int X ; int X&apos;</span><span class="token punctuation">,</span> Xs <span class="token punctuation">;</span>
</pre><p>This will expand <code>int x, y, z;</code> to <code>int x; int y, z;</code> because the macro does<br>
not apply the second time after applying the substitution of the first<br>
application. However, if the <code>macro</code> attribute were changed to the <code>macro-rec</code><br>
attribute, it would instead expand (as the user likely intended) to<br>
<code>int x; int y; int z;</code>.</p>
<p>The <code>alias-rec</code> attribute behaves with respect to the <code>alias</code> attribute the<br>
same way the <code>macro-rec</code> attribute behaves with respect to <code>macro</code>.</p>
<h3 class="mume-header" id="anywhere-rules"><code>anywhere</code> rules</h3>

<p>Some rules are not functional, but you want them to apply anywhere in the<br>
configuration (similar to functional rules). You can use the <code>anywhere</code><br>
attribute on a rule to instruct the backends to make sure they apply anywhere<br>
they match in the entire configuration.</p>
<p>For example, if you want to make sure that some associative operator is always<br>
right-associated anywhere in the configuration, you can do:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> Stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Stmt <span class="token string">&quot;;&quot;</span> Stmt

<span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>S1 <span class="token punctuation">;</span> S2<span class="token punctuation">)</span> <span class="token punctuation">;</span> S3 <span class="token operator">=&gt;</span> S1 <span class="token punctuation">;</span> <span class="token punctuation">(</span>S2 <span class="token punctuation">;</span> S3<span class="token punctuation">)</span> <span class="token punctuation">[</span>anywhere<span class="token punctuation">]</span>
</pre><p>Then after every step, all occurrences of <code>_;_</code> will be re-associated. Note that<br>
this allows the symbol <code>_;_</code> to still be a constructor, even though it is<br>
simplified similarly to a <code>function</code>.</p>
<h3 class="mume-header" id="trusted-claims"><code>trusted</code> claims</h3>

<p>You may add the <code>trusted</code> attribute to a given claim for the K prover to<br>
automatically add it to the list of proven circularities, instead of trying to<br>
discharge it separately.</p>
<h3 class="mume-header" id="projection-and-predicate-functions">Projection and Predicate functions</h3>

<p>K automatically generates certain predicate and projection functions from the<br>
syntax you declare. For example, if you write:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> Foo <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> foo<span class="token punctuation">(</span>bar<span class="token punctuation">:</span> Bar<span class="token punctuation">)</span>
</pre><p>It will automatically generate the following K code:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> isFoo<span class="token punctuation">(</span>K<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
<span class="token keyword keyword-syntax">syntax</span> Foo <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;{&quot;</span> K <span class="token string">&quot;}&quot;</span> <span class="token string">&quot;:&gt;Foo&quot;</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
<span class="token keyword keyword-syntax">syntax</span> Bar <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> bar<span class="token punctuation">(</span>Foo<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>

<span class="token keyword keyword-rule">rule</span> isFoo<span class="token punctuation">(</span>F<span class="token punctuation">:</span>Foo<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
<span class="token keyword keyword-rule">rule</span> isFoo<span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">false</span> <span class="token punctuation">[</span>owise<span class="token punctuation">]</span>

<span class="token keyword keyword-rule">rule</span> <span class="token punctuation">{</span> F<span class="token punctuation">:</span>Foo <span class="token punctuation">}</span><span class="token punctuation">:</span>&gt;Foo <span class="token operator">=&gt;</span> F
<span class="token keyword keyword-rule">rule</span> bar<span class="token punctuation">(</span>foo<span class="token punctuation">(</span>B<span class="token punctuation">:</span>Bar<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> B
</pre><p>The first two types of functions are generated automatically for every sort in<br>
your K definition, and the third type of function is generated automatically<br>
for each named nonterminal in your definition. Essentially, <code>isFoo</code> for some<br>
sort <code>Foo</code> will tell you whether a particular term of sort <code>K</code> is a <code>Foo</code>,<br>
<code>{F}:&gt;Foo</code> will cast <code>F</code> to sort <code>Foo</code> if <code>F</code> is of sort <code>Foo</code> and will be<br>
undefined (i.e., theoretically defined as <code>#Bottom</code>, the bottom symbol in<br>
matching logic) otherwise. Finally, <code>bar</code> will project out the child of a <code>foo</code><br>
named <code>bar</code> in its production declaration.</p>
<p>Note that if another term of equal or smaller sort to <code>Foo</code> exists and has a<br>
child named <code>bar</code> of equal or smaller sort to <code>Bar</code>, this will generate an<br>
ambiguity during parsing, so care should be taken to ensure that named<br>
nonterminals are sufficiently unique from one another to prevent such<br>
ambiguities. Of course, the compiler will generate a warning in this case.</p>
<h3 class="mume-header" id="simplification-attribute"><code>simplification</code> attribute</h3>

<p>The simplification attribute identifies rules outside the main semantics that<br>
are used to simplify function patterns.</p>
<p><strong>Conditions</strong>: A simplification rule is applied by <em>matching</em> the function<br>
arguments, instead of unification as when applying function definition<br>
rules. This allows function symbols to appear nested as arguments to other<br>
functions on the left-hand side of a simplification rule, which is forbidden in<br>
function definition rules. For example, this rule would not be accepted as a<br>
function definition rule:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>X <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> Y<span class="token punctuation">)</span> <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> Z <span class="token operator">=&gt;</span> X <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">(</span>Y <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> Z<span class="token punctuation">)</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
</pre><p>A simplification rule is only applied when the current side condition <em>implies</em><br>
the <code>requires</code> clause of the rule, like function definition rules.</p>
<p><strong>Order</strong>: The <code>simplification</code> attribute accepts an optional integer argument<br>
which is the rule&apos;s <em>simplification priority</em>; if the optional argument is not<br>
specified, it is equivalent to a simplification priority of 50. Backends<br>
<em>should</em> attempt simplification rules in order of their <em>simplification<br>
priority</em>, but are not required to do so; in fact, the backend is free to apply<br>
<code>simplification</code> rules at <em>any time</em>. Because of this, users must ensure that<br>
simplification rules are sound regardless of their order of application. This<br>
differs from the <code>priority</code> attribute in that rules with the <code>priority</code><br>
attribute <em>must</em> be applied in their priority order by the backend. It is an<br>
error to have the <code>priority</code> attribute on a <code>simplification</code> rule.</p>
<p>For example, for the following definition:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">    <span class="token keyword keyword-syntax">syntax</span> WordStack <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;:&quot;</span> WordStack <span class="token operator">|</span> <span class="token string">&quot;.WordStack&quot;</span>
    <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> sizeWordStack    <span class="token punctuation">(</span> WordStack       <span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
                 <span class="token operator">|</span> sizeWordStackAux <span class="token punctuation">(</span> WordStack <span class="token punctuation">,</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
 <span class="token comment">// --------------------------------------------------------------</span>
    <span class="token keyword keyword-rule">rule</span> sizeWordStack<span class="token punctuation">(</span>WS<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> sizeWordStackAux<span class="token punctuation">(</span>WS<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>

    <span class="token keyword keyword-rule">rule</span> sizeWordStackAux<span class="token punctuation">(</span><span class="token punctuation">.</span>WordStack<span class="token punctuation">,</span> N<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> N
    <span class="token keyword keyword-rule">rule</span> sizeWordStackAux<span class="token punctuation">(</span>W <span class="token punctuation">:</span> WS    <span class="token punctuation">,</span> N<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> sizeWordStackAux<span class="token punctuation">(</span>WS<span class="token punctuation">,</span> N <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">)</span>
</pre><p>We might add the following simplification lemma:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">    <span class="token keyword keyword-rule">rule</span> sizeWordStackAux<span class="token punctuation">(</span>WS<span class="token punctuation">,</span> N<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> N <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> sizeWordStackAux<span class="token punctuation">(</span>WS<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
      <span class="token keyword keyword-requires">requires</span> N <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span><span class="token keyword keyword-Int">Int</span> <span class="token number">0</span>
      <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
</pre><p>Then this simplification rule will only apply if the Haskell backend can prove<br>
that <code>notBool N =/=Int 0</code> is unsatisfiable. This avoids an infinite cycle of<br>
applying this simplification lemma.</p>
<p><strong>NOTE</strong>: The frontend and Haskell backend <strong>do not check</strong> that supplied<br>
simplification rules are sound, this is the developer&apos;s responsibility. In<br>
particular, rules with the simplification attribute must preserve definedness;<br>
that is, if the left-hand side refers to any partial function then:</p>
<ul>
<li>the right-hand side must be <code>#Bottom</code> when the left-hand side is <code>#Bottom</code>, or</li>
<li>the rule must have an <code>ensures</code> clause that is <code>false</code> when the left-hand<br>
side is <code>#Bottom</code>, or</li>
<li>the rule must have a <code>requires</code> clause that is <code>false</code> when the left-hand<br>
side is <code>#Bottom</code>.</li>
</ul>
<p>These conditions are in order of decreasing preference: the best option is to<br>
preserve <code>#Bottom</code> on the right-hand side, the next best option is to have an<br>
<code>ensures</code> clause, and the least-preferred option is to have a <code>requires</code> clause.<br>
The most preferred option is to write total functions and avoid the entire issue.</p>
<p><strong>NOTE</strong>: The Haskell backend does not attempt to prove claims which right-hand<br>
side is <code>#Bottom</code>. The reason for this is that the general case is undecidable,<br>
and the backend might enter an infinite loop. Therefore, the backend emits a<br>
warning if it encounters such a claim.</p>
<h3 class="mume-header" id="concrete-and-symbolic-attributes-haskell-backend"><code>concrete</code> and <code>symbolic</code> attributes (Haskell backend)</h3>

<p>Users can control the application of <code>simplification</code> rules using the <code>concrete</code><br>
and the <code>symbolic</code> attributes by specifying the type of patterns the rule&apos;s<br>
arguments are to match.</p>
<p>A concrete pattern is a pattern which does not contain variables or unevaluated<br>
functions, otherwise the pattern is symbolic.</p>
<p>The semantics of the two attributes is defined as follows:</p>
<ul>
<li>If a simplification rule is marked <code>concrete</code>, then <em>all</em> arguments must be<br>
concrete for the rule to match.</li>
<li>If a simplification rule is marked <code>symbolic</code>, then <em>all</em> arguments must be<br>
symbolic for the rule to match.</li>
<li>The following syntax <code>concrete(&lt;variables&gt;)</code> (resp. <code>symbolic(&lt;variables&gt;)</code>),<br>
where <code>&lt;variables&gt;</code> is a list of variable names separated by commas, can be used<br>
to specify the exact arguments the user expects to match concrete (resp. symbolic)<br>
patterns.</li>
</ul>
<p>For example, the following will only match when all arguments<br>
are concrete:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-rule">rule</span> X <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">(</span>Y <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> Z<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>X <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> Y<span class="token punctuation">)</span> <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> Z <span class="token punctuation">[</span>simplification<span class="token punctuation">,</span> concrete<span class="token punctuation">]</span>
</pre><p>Conversely, the following will only match when all arguments<br>
are symbolic:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-rule">rule</span> X <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">(</span>Y <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> Z<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>X <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> Y<span class="token punctuation">)</span> <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> Z <span class="token punctuation">[</span>simplification<span class="token punctuation">,</span> symbolic<span class="token punctuation">]</span>
</pre><p>In practice, the following rules will re-associate and commute terms to combine<br>
concrete arguments:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>A <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> Y<span class="token punctuation">)</span> <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> Z <span class="token operator">=&gt;</span> A <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">(</span>Y <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> Z<span class="token punctuation">)</span>
  <span class="token punctuation">[</span>concrete<span class="token punctuation">(</span>Y<span class="token punctuation">,</span> Z<span class="token punctuation">)</span><span class="token punctuation">,</span> symbolic<span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">,</span> simplification<span class="token punctuation">]</span>

<span class="token keyword keyword-rule">rule</span> X <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">(</span>B <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> Z<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> B <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">(</span>X <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> Z<span class="token punctuation">)</span>
  <span class="token punctuation">[</span>concrete<span class="token punctuation">(</span>X<span class="token punctuation">,</span> Z<span class="token punctuation">)</span><span class="token punctuation">,</span> symbolic<span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">,</span> simplification<span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="the-unboundvariables-attribute">The <code>unboundVariables</code> attribute</h3>

<p>Normally, K rules are not allowed to contain regular (i.e., not fresh, not<br>
existential) variables in the RHS / <code>requires</code> / <code>ensures</code> clauses which are not<br>
bound in the LHS.</p>
<p>However, in certain cases this behavior might be desired, like, for example,<br>
when specifying a macro rule which is to be used in the LHS of other rules.<br>
To allow for such cases, but still be useful and perform the unboundness checks<br>
in regular cases, the <code>unboundVariables</code> attributes allows the user to specify<br>
a comma-separated list of names of variables which can be unbound in the rule.</p>
<p>For example, in the macro declaration</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> cppEnumType <span class="token operator">=&gt;</span> bar<span class="token punctuation">(</span>_<span class="token punctuation">,</span> scopedEnum<span class="token punctuation">(</span><span class="token punctuation">)</span> #Or unscopedEnum<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">[</span>unboundVariables<span class="token punctuation">(</span>_<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><p>the declaration <code>unboundVariables(_)</code> allows the rule to pass the unbound<br>
variable checks, and this in turn allows for <code>cppEnumType</code> to be used in<br>
the LHS of a rule to mean the pattern above:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> inverseConvertType<span class="token punctuation">(</span>cppEnumType<span class="token punctuation">,</span> foo<span class="token punctuation">(</span><span class="token punctuation">(</span>cppEnumType #as T<span class="token punctuation">:</span><span class="token punctuation">:</span>CPPType <span class="token operator">=&gt;</span> underlyingType<span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</pre><h3 class="mume-header" id="the-memo-attribute">The <code>memo</code> attribute</h3>

<p>The <code>memo</code> attribute is a hint from the user to the backend to memoize a<br>
function. Not all backends support memoization, but when the attribute is used<br>
and the definition is compiled for a <code>memo</code>-supporting backend, then calls to<br>
the function may be cached. At the time of writing, only the Haskell<br>
backend supports memoization.</p>
<h4 class="mume-header" id="limitations-of-memoization-with-the-haskell-backend">Limitations of memoization with the Haskell backend</h4>

<p>The Haskell backend will only cache a function call if all arguments are concrete.</p>
<p>It is recommended not to memoize recursive functions, as each recursive call<br>
will be stored in the cache, but only the first iteration will be retrieved from<br>
the cache; that is, the cache will be filled with many unreachable<br>
entries. Instead, we recommend to perform a worker-wrapper transformation on<br>
recursive functions, and apply the <code>memo</code> attribute to the wrapper.</p>
<p><strong>Warning:</strong> A function declared with the <code>memo</code> attribute must not use<br>
uninterpreted functions in the side-condition of any rule. Memoizing such an<br>
impure function is unsound. To see why, consider the following rules:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> impure<span class="token punctuation">(</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>

<span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> unsound<span class="token punctuation">(</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> memo<span class="token punctuation">]</span>
<span class="token keyword keyword-rule">rule</span> unsound<span class="token punctuation">(</span>X<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> X <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span> <span class="token keyword keyword-requires">requires</span> impure<span class="token punctuation">(</span>X<span class="token punctuation">)</span>
<span class="token keyword keyword-rule">rule</span> unsound<span class="token punctuation">(</span>X<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> X        <span class="token keyword keyword-requires">requires</span> notBool impure<span class="token punctuation">(</span>X<span class="token punctuation">)</span>
</pre><p>Because the function <code>impure</code> is not given rules to cover all inputs, <code>unsound</code><br>
can be memoized incoherently. For example,</p>
<pre data-role="codeBlock" data-info class="language-"><code>{unsound(0) #And {impure(0) #Equals true}} #Equals 1
</code></pre><p>but</p>
<pre data-role="codeBlock" data-info class="language-"><code>{unsound(0) #And {impure(0) #Equals false}} #Equals 0
</code></pre><p>The memoized value of <code>unsound(0)</code> would be incoherently determined by which<br>
pattern the backend encounters first.</p>
<h3 class="mume-header" id="variable-sort-inference">Variable Sort Inference</h3>

<p>In K, it is not required that users declare the sorts of variables in rules or<br>
in the initial configuration. If the user does not explicitly declare the sort<br>
of a variable somewhere via a cast (see below), the sort of the variable is<br>
inferred from context based on the sort signature of every place the variable<br>
appears in the rule.</p>
<p>As an example, consider the rule for addition in IMP:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">    <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Exp <span class="token string">&quot;+&quot;</span> Exp <span class="token operator">|</span> <span class="token keyword keyword-Int">Int</span>

    <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">+</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> I2
</pre><p>Here <code>+Int</code> is defined in the INT module with the following signature:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">    <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;+Int&quot;</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
</pre><p>In the rule above, the sort of both <code>I1</code> and <code>I2</code> is inferred as <code>Int</code>. This is because<br>
a variable must have the same sort every place it appears within the same rule.<br>
While a variable appearing only on the left-hand-side of the rule could have<br>
sort <code>Exp</code> instead, the same variable appears as a child of <code>+Int</code>, which<br>
constriants the sorts of <code>I1</code> and <code>I2</code> more tightly. Since the sort must be a<br>
subsort of <code>Int</code> or equal to <code>Int</code>, and <code>Int</code> has no subsorts, we infer <code>Int</code><br>
as the sorts of <code>I1</code> and <code>I2</code>. This means that the above rule will not match<br>
until <code>I1</code> and <code>I2</code> become integers (i.e., have already been evaluated).</p>
<p>More complex examples are possible, however:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">    <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Exp <span class="token string">&quot;+&quot;</span> <span class="token keyword keyword-Int">Int</span> <span class="token operator">|</span> <span class="token keyword keyword-Int">Int</span>
    <span class="token keyword keyword-rule">rule</span> _ <span class="token operator">+</span> _ <span class="token operator">=&gt;</span> <span class="token number">0</span>
</pre><p>Here we have two anonymous variables. They do not refer to the same variable<br>
as one another, so they can have different sorts. The right side is constrained<br>
by <code>+</code> to be of sort <code>Int</code>, but the left side could be either <code>Exp</code> or <code>Int</code>.<br>
When this occurs, we have multiple solutions to the sorts of the variables in<br>
the rule. K will only choose solutions which are <strong>maximal</strong>, however. To be<br>
precise, if two different solutions exist, but the sorts of one solution are<br>
all greater than or equal to the sorts of the other solution, K will discard<br>
the smaller solution. Thus, in the case above, the variable on the left side<br>
of the <code>+</code> is inferred of sort <code>Exp</code>, because the solution (<code>Exp</code>, <code>Int</code>) is<br>
strictly greater than the solution (<code>Int</code>, <code>Int</code>).</p>
<p>It is possible, however, for terms to have multiple maximal solutions:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">    <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Exp <span class="token string">&quot;+&quot;</span> <span class="token keyword keyword-Int">Int</span> <span class="token operator">|</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;+&quot;</span> Exp <span class="token operator">|</span> <span class="token keyword keyword-Int">Int</span>
    <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">+</span> I2 <span class="token operator">=&gt;</span> <span class="token number">0</span>
</pre><p>In this example, there is an ambiguous parse. This could parse as either<br>
the first <code>+</code> or the second. In the first case, the maximal solution chosen is<br>
(<code>Exp</code>, <code>Int</code>). In the second, it is (<code>Int</code>, <code>Exp</code>). Neither of these solutions is<br>
greater than the other, so both are allowed by K. As a result, this program<br>
will emit an error because the parse is ambiguous. To pick one solution over<br>
the other, a cast or a <code>prefer</code> or <code>avoid</code> attribute can be used.</p>
<h3 class="mume-header" id="casting">Casting</h3>

<p>There are three main types of casts in K: the semantic cast, the strict cast,<br>
and the projection cast.</p>
<h3 class="mume-header" id="semantic-casts">Semantic casts</h3>

<p>For every sort <code>S</code> declared in your grammar, K will define the following<br>
production for you for use in rules:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">    <span class="token keyword keyword-syntax">syntax</span> S <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> S <span class="token string">&quot;:S&quot;</span>
</pre><p>The meaning of this cast is that the term inside the cast must be less than<br>
or equal to <code>Sort</code>. This can be used to resolve ambiguities, but its principle<br>
purpose is to guide execution by telling K what sort variables must match in<br>
order for the rule to apply. When compiled, it will generate a pattern that<br>
matches on an injection into <code>Sort</code>.</p>
<h3 class="mume-header" id="strict-casts">Strict casts</h3>

<p>K also introduces the strict cast:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">    <span class="token keyword keyword-syntax">syntax</span> S <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> S <span class="token string">&quot;::S&quot;</span>
</pre><p>The meaning at runtime is exactly the same as the semantic cast; however, it<br>
restricts the sort of the term inside the cast to <strong>exactly</strong> <code>Sort</code>. That is<br>
to say, if you use it on something that is a strictly smaller sort, it will<br>
generate a type error. This is useful in certain circumstances to help<br>
disambiguate terms, when a semantic cast would not have resolved the ambiguity.<br>
As such, it is primarily used to solve ambiguities rather than to guide<br>
execution.</p>
<h3 class="mume-header" id="projection-casts">Projection casts</h3>

<p>K also introduces the projection cast:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">    <span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>S2<span class="token punctuation">}</span> S <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;{&quot;</span> S2 <span class="token string">&quot;}&quot;</span> <span class="token string">&quot;:&gt;S&quot;</span>
</pre><p>The meaning of this cast at runtime is that if the term inside is of sort<br>
<code>Sort</code>, it should have it injection stripped away and the value inside is<br>
returned as a term of static sort <code>Sort</code>. However, if the term is of a<br>
different sort, it is an error and execution will get stuck. Thus the primary<br>
usefulness of this cast is to cast the return value of a function with a<br>
greater sort down to a strictly smaller sort that you expect the return value<br>
of the function to have. For example:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">    <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> foo<span class="token punctuation">(</span>Exp<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span> <span class="token operator">|</span> bar<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token keyword keyword-Int">Int</span>
    <span class="token keyword keyword-rule">rule</span> foo<span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> I
    <span class="token keyword keyword-rule">rule</span> bar<span class="token punctuation">(</span>I<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> bar<span class="token punctuation">(</span><span class="token punctuation">{</span>foo<span class="token punctuation">(</span>I <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">:</span>&gt;<span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span>
</pre><p>Here we know that <code>foo(I +Int 1)</code> will return an Int, but the return sort of<br>
<code>foo</code> is <code>Exp</code>. So we project the result into the <code>Int</code> sort so that it can<br>
be placed as the child of a <code>bar</code>.</p>
<h3 class="mume-header" id="owise-and-priority-attributes"><code>owise</code> and <code>priority</code> attributes.</h3>

<p>Sometimes, it is simply not convenient to explicitly describe every<br>
single negative case under which a rule should <strong>not</strong> apply. Instead,<br>
we simply wish to say that a rule should only apply after some other set of<br>
rules have been tried. K introduces two different attributes that can be<br>
added to rules which will automatically generate the necessary matching<br>
conditions in a manner which is performant for concrete execution (indeed,<br>
it generally outperforms during concrete execution code where the conditions<br>
are written explicitly).</p>
<p>The first is the <code>owise</code> attribute. Very roughly, rules without an attribute<br>
indicating their priority apply first, followed by rules with the <code>owise</code><br>
attribute only if all the other rules have been tried and failed. For example,<br>
consider the following function:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> foo<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
<span class="token keyword keyword-rule">rule</span> foo<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token number">0</span>
<span class="token keyword keyword-rule">rule</span> foo<span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token number">1</span> <span class="token punctuation">[</span>owise<span class="token punctuation">]</span>
</pre><p>Here <code>foo(0)</code> is defined explicitly as <code>0</code>. Any other integer yields the<br>
integer <code>1</code>. In particular, the second rule above will only be tried after the<br>
first rule has been shown not to apply.</p>
<p>This is because the first rule has a lower number assigned for its priority<br>
than the second rule. In practice, each rule in your semantics is implicitly<br>
or explicitly assigned a numerical priority. Rules are tried in increasing<br>
order of priority, starting at zero and trying each increasing numerical value<br>
successively.</p>
<p>You can specify the priority of a rule with the <code>priority</code> attribute. For<br>
example, I could equivalently write the second rule above as:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-rule">rule</span> foo<span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token number">1</span> <span class="token punctuation">[</span>priority<span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><p>The number <code>200</code> is not chosen at random. In fact, when you use the <code>owise</code><br>
attribute, what you are doing is implicitly setting the priority of the rule<br>
to <code>200</code>. This has a couple of implications:</p>
<ol>
<li>Multiple rules with the owise attribute all have the same priority and thus<br>
can apply in any order.</li>
<li>Rules with priority higher than <code>200</code> apply <strong>after</strong> all rules with the<br>
<code>owise</code> attribute have been tried.</li>
</ol>
<p>There is one more rule by which priorities are assigned: a rule with no<br>
attributes indicating its priority is assigned the priority 50. Thus,<br>
with each priority explicitly declared, the above example looks like:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> foo<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
<span class="token keyword keyword-rule">rule</span> foo<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token number">0</span> <span class="token punctuation">[</span>priority<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword keyword-rule">rule</span> foo<span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token number">1</span> <span class="token punctuation">[</span>owise<span class="token punctuation">]</span>
</pre><p>One final note: the llvm backend reserves priorities between 50 and 150<br>
inclusive for certain specific purposes. Because of this, explicit<br>
priorities which are given within this region may not behave precisely as<br>
described above. This is primarily in order that it be possible where necessary<br>
to provide guidance to the pattern matching algorithm when it would otherwise<br>
make bad choices about which rules to try first. You generally should not<br>
give any rule a priority within this region unless you know exactly what the<br>
implications are with respect to how the llvm backend orders matches.</p>
<h2>Evaluation Strategy</h2>
<h3 class="mume-header" id="strict-and-seqstrict-attributes"><code>strict</code> and <code>seqstrict</code> attributes</h3>

<p>The strictness attributes allow defining evaluation strategies without having<br>
to explicitly make rules which implement them. This is done by injecting<br>
<em>heating</em> and <em>cooling</em> rules for the subterms. For this to work, you need to<br>
define what a <em>result</em> is for K, by extending the  <code>KResult</code> sort.</p>
<p>For example:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> AExp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span>
              <span class="token operator">|</span> AExp <span class="token string">&quot;+&quot;</span> AExp <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">klabel</span><span class="token punctuation">(</span>addExp<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><p>This generates two heating rules (where the hole syntaxes <code>&quot;[]&quot; &quot;+&quot; AExp</code> and<br>
<code>AExp &quot;+&quot; &quot;[]&quot;</code> is automatically added to create an evaluation context):</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-rule">rule</span> <span class="token punctuation">[</span>addExp1<span class="token operator">-</span>heat<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> HOLE<span class="token punctuation">:</span>AExp <span class="token operator">+</span>  AE2<span class="token punctuation">:</span>AExp <span class="token operator">=&gt;</span> HOLE <span class="token operator">~&gt;</span>  <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">+</span> AE2 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">[</span>heat<span class="token punctuation">]</span>
<span class="token keyword keyword-rule">rule</span> <span class="token punctuation">[</span>addExp2<span class="token operator">-</span>heat<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span>  AE1<span class="token punctuation">:</span>AExp <span class="token operator">+</span> HOLE<span class="token punctuation">:</span>AExp <span class="token operator">=&gt;</span> HOLE <span class="token operator">~&gt;</span> AE1 <span class="token operator">+</span>  <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">[</span>heat<span class="token punctuation">]</span>
</pre><p>And two corresponding cooling rules:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-rule">rule</span> <span class="token punctuation">[</span>addExp1<span class="token operator">-</span>cool<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> HOLE<span class="token punctuation">:</span>AExp <span class="token operator">~&gt;</span>  <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">+</span> AE2 <span class="token operator">=&gt;</span> HOLE <span class="token operator">+</span>  AE2 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">[</span>cool<span class="token punctuation">]</span>
<span class="token keyword keyword-rule">rule</span> <span class="token punctuation">[</span>addExp2<span class="token operator">-</span>cool<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> HOLE<span class="token punctuation">:</span>AExp <span class="token operator">~&gt;</span> AE1 <span class="token operator">+</span>  <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=&gt;</span>  AE1 <span class="token operator">+</span> HOLE <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">[</span>cool<span class="token punctuation">]</span>
</pre><p>Note that the rules are given labels based on the klabel of the production, which<br>
nonterminal is the hole, and whether it&apos;s the heating or the cooling rule.</p>
<p>You will note that these rules can apply one after another infinitely. In<br>
practice, the <code>KResult</code> sort is used to break this cycle by ensuring that only<br>
terms that are not part of the <code>KResult</code> sort will be heated. The <code>heat</code> and<br>
<code>cool</code> attributes are used to tell the compiler that these are heating and<br>
cooling rules and should be handled in the manner just described. Nothing stops<br>
the user from writing such heating and cooling rules directly if they wish,<br>
although we describe other more convenient syntax for most of the advanced<br>
cases below.</p>
<p>One other thing to note is that in the above sentences, <code>HOLE</code> is just a<br>
variable, but it has special meaning in the context of sentences with the<br>
<code>heat</code> or <code>cool</code> attribute. In heating or cooling rules, the variable named<br>
<code>HOLE</code> is considered to be the term being heated or cooled and the compiler<br>
will generate <code>isKResult(HOLE)</code> and <code>notBool isKResult(HOLE)</code> side conditions<br>
appropriately to ensure that the backend does not loop infinitely. The module<br>
<code>BOOL</code> will also be automatically and privately included for semantic<br>
purposes. The syntax for parsing programs will not be affected.</p>
<p>In order for this functionality to work, you need to define the <code>KResult</code> sort.<br>
For instance, we tell K that a term is fully evaluated once it becomes an <code>Int</code><br>
here:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> KResult <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span>
</pre><p>Note that you can also say that a given expression is only strict only in<br>
specific argument positions. Here we use this to define &quot;short-circuiting&quot;<br>
boolean operators.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> KResult <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Bool">Bool</span>

<span class="token keyword keyword-syntax">syntax</span> BExp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Bool">Bool</span>
              <span class="token operator">|</span> BExp <span class="token string">&quot;||&quot;</span> BExp <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
              <span class="token operator">|</span> BExp <span class="token string">&quot;&amp;&amp;&quot;</span> BExp <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

<span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token boolean">true</span>  <span class="token operator">||</span> _    <span class="token operator">=&gt;</span> <span class="token boolean">true</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
<span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token boolean">false</span> <span class="token operator">||</span> REST <span class="token operator">=&gt;</span> REST <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>

<span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token boolean">true</span>  <span class="token operator">&amp;&amp;</span> REST <span class="token operator">=&gt;</span> REST  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
<span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token boolean">false</span> <span class="token operator">&amp;&amp;</span> _    <span class="token operator">=&gt;</span> <span class="token boolean">false</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
</pre><p>If you want to force a specific evaluation order of the arguments, you can use<br>
the variant <code>seqstrict</code> to do so. For example, this would make the boolean<br>
operators short-circuit in their <em>second</em> argument first:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> KResult <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Bool">Bool</span>

<span class="token keyword keyword-syntax">syntax</span> BExp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Bool">Bool</span>
              <span class="token operator">|</span> BExp <span class="token string">&quot;||&quot;</span> BExp <span class="token punctuation">[</span><span class="token class-name">seqstrict</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
              <span class="token operator">|</span> BExp <span class="token string">&quot;&amp;&amp;&quot;</span> BExp <span class="token punctuation">[</span><span class="token class-name">seqstrict</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

<span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> _    <span class="token operator">||</span> <span class="token boolean">true</span>  <span class="token operator">=&gt;</span> <span class="token boolean">true</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
<span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> REST <span class="token operator">||</span> <span class="token boolean">false</span> <span class="token operator">=&gt;</span> REST <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>

<span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> REST <span class="token operator">&amp;&amp;</span> <span class="token boolean">true</span>  <span class="token operator">=&gt;</span> REST  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
<span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> _    <span class="token operator">&amp;&amp;</span> <span class="token boolean">false</span> <span class="token operator">=&gt;</span> <span class="token boolean">false</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
</pre><p>This will generate rules like this in the case of <code>_||_</code> (note that <code>BE1</code> will<br>
not be heated unless <code>isKResult(BE2)</code> is true, meaning that <code>BE2</code> must be<br>
evaluated first):</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span>  BE1<span class="token punctuation">:</span>BExp <span class="token operator">||</span> HOLE<span class="token punctuation">:</span>BExp <span class="token operator">=&gt;</span> HOLE <span class="token operator">~&gt;</span> BE1 <span class="token operator">||</span>  <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">[</span>heat<span class="token punctuation">]</span>
<span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> HOLE<span class="token punctuation">:</span>BExp <span class="token operator">||</span>  BE2<span class="token punctuation">:</span>BExp <span class="token operator">=&gt;</span> HOLE <span class="token operator">~&gt;</span>  <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">||</span> BE2 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token keyword keyword-requires">requires</span> isKResult<span class="token punctuation">(</span>BE2<span class="token punctuation">)</span> <span class="token punctuation">[</span>heat<span class="token punctuation">]</span>

<span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> HOLE<span class="token punctuation">:</span>BExp <span class="token operator">~&gt;</span>  <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">||</span> BE2 <span class="token operator">=&gt;</span> HOLE <span class="token operator">||</span>  BE2 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">[</span>cool<span class="token punctuation">]</span>
<span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> HOLE<span class="token punctuation">:</span>BExp <span class="token operator">~&gt;</span> BE1 <span class="token operator">||</span>  <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=&gt;</span>  BE1 <span class="token operator">||</span> HOLE <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">[</span>cool<span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="context-declaration">Context Declaration</h3>

<p>Sometimes more advanced evaluation strategies are needed. By default, the<br>
<code>strict</code> and <code>seqstrict</code> attributes are limited in that they cannot describe<br>
the <em>context</em> in which heating or cooling should occur. When this type of<br>
control over the evaluation strategy is required, <code>context</code> sentences can be<br>
used to simplify the process of declaring heating and cooling when it would be<br>
unnecessarily verbose to write heating and cooling rules directly.</p>
<p>For example, if the user wants to heat a term if it exists under a <code>foo</code><br>
constructor if the term to be heated is of sort <code>bar</code>, one might write the<br>
following context (with the optional label):</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-context">context</span> <span class="token punctuation">[</span>foo<span class="token punctuation">]</span><span class="token punctuation">:</span> foo<span class="token punctuation">(</span>HOLE<span class="token punctuation">:</span>Bar<span class="token punctuation">)</span>
</pre><p>Once again, note that <code>HOLE</code> is just a variable, but one that has special<br>
meaning to the compiler indicating the position in the context that should<br>
be heated or cooled.</p>
<p>This will automatically generate the following sentences:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-rule">rule</span> <span class="token punctuation">[</span>foo<span class="token operator">-</span>heat<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> foo<span class="token punctuation">(</span>HOLE<span class="token punctuation">:</span>Bar<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> HOLE <span class="token operator">~&gt;</span> foo<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">[</span>heat<span class="token punctuation">]</span>
<span class="token keyword keyword-rule">rule</span> <span class="token punctuation">[</span>foo<span class="token operator">-</span>cool<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> HOLE<span class="token punctuation">:</span>Bar <span class="token operator">~&gt;</span> foo<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> foo<span class="token punctuation">(</span>HOLE<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">[</span>cool<span class="token punctuation">]</span>
</pre><p>The user may also write the K cell explicitly in the context declaration<br>
if they want to match on another cell as well, for example:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-context">context</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> foo<span class="token punctuation">(</span>HOLE<span class="token punctuation">:</span>Bar<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>state</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>state</span><span class="token punctuation">&gt;</span></span>
</pre><p>This context will now only heat or cool if the <code>state</code> cell is empty.</p>
<h3 class="mume-header" id="side-conditions-in-context-declarations">Side conditions in context declarations</h3>

<p>The user is allowed to write a side condition in a context declaration, like<br>
so:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-context">context</span> foo<span class="token punctuation">(</span>HOLE<span class="token punctuation">:</span>Bar<span class="token punctuation">)</span> <span class="token keyword keyword-requires">requires</span> baz<span class="token punctuation">(</span>HOLE<span class="token punctuation">)</span>
</pre><p>This side condition will be appended verbatim to the heating rule that is<br>
generated, however, it will not affect the cooling rule that is generated:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> foo<span class="token punctuation">(</span>HOLE<span class="token punctuation">:</span>Bar<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> HOLE <span class="token operator">~&gt;</span> foo<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token keyword keyword-requires">requires</span> baz<span class="token punctuation">(</span>HOLE<span class="token punctuation">)</span> <span class="token punctuation">[</span>heat<span class="token punctuation">]</span>
<span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> HOLE<span class="token punctuation">:</span>Bar <span class="token operator">~&gt;</span> foo<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> foo<span class="token punctuation">(</span>HOLE<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">[</span>cool<span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="rewrites-in-context-declarations">Rewrites in context declarations</h3>

<p>The user can also include exactly one rewrite operation in a context<br>
declaration if that rule rewrites the variable <code>HOLE</code> on the left hand side<br>
to a term containing <code>HOLE</code> on the right hand side. For exampl;e:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-context">context</span> foo<span class="token punctuation">(</span>HOLE<span class="token punctuation">:</span>Bar <span class="token operator">=&gt;</span> bar<span class="token punctuation">(</span>HOLE<span class="token punctuation">)</span><span class="token punctuation">)</span>
</pre><p>In this case, the code generated will be as follows:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> foo<span class="token punctuation">(</span>HOLE<span class="token punctuation">:</span>Bar<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> bar<span class="token punctuation">(</span>HOLE<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> foo<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">[</span>heat<span class="token punctuation">]</span>
<span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> bar<span class="token punctuation">(</span>HOLE<span class="token punctuation">:</span>Bar<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> foo<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> foo<span class="token punctuation">(</span>HOLE<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">[</span>cool<span class="token punctuation">]</span>
</pre><p>This can be useful if the user wishes to evaluate a term using a different<br>
set of rules than normal.</p>
<h3 class="mume-header" id="result-attribute"><code>result</code> attribute</h3>

<p>Sometimes it is necessary to be able to evaluate a term to a different sort<br>
than <code>KResult</code>. This is done by means of adding the <code>result</code> attribute to<br>
a strict production, a context, or an explicit heating or cooling rule:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> BExp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Bool">Bool</span>
              <span class="token operator">|</span> BExp <span class="token string">&quot;||&quot;</span> BExp <span class="token punctuation">[</span><span class="token class-name">seqstrict</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> result<span class="token punctuation">(</span><span class="token keyword keyword-Bool">Bool</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><p>In this case, the sort check used by <code>seqstrict</code> and by the <code>heat</code> and <code>cool</code><br>
attributes will be <code>isBool</code> instead of <code>isKResult</code>. This particular example<br>
does not really require use of the <code>result</code> attribute, but if the user wishes<br>
to evaluate a term of sort KResult further, the result attribute would be<br>
required.</p>
<h3 class="mume-header" id="hybrid-attribute"><code>hybrid</code> attribute</h3>

<p>In certain situations, it is desirable to treat a particular production which<br>
has the <code>strict</code> attribute as a result if the term has had its arguments fully<br>
evaluated. This can be accomplished by means of the <code>hybrid</code> attribute:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> KResult <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Bool">Bool</span>

<span class="token keyword keyword-syntax">syntax</span> BExp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Bool">Bool</span>
              <span class="token operator">|</span> BExp <span class="token string">&quot;||&quot;</span> BExp <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hybrid<span class="token punctuation">]</span>
</pre><p>This attribute is equivalent in this case to the following additional axiom<br>
being added to the definition of <code>isKResult</code>:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-rule">rule</span> isKResult<span class="token punctuation">(</span>BE1<span class="token punctuation">:</span>BExp <span class="token operator">||</span> BE2<span class="token punctuation">:</span>BExp<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">true</span> <span class="token keyword keyword-requires">requires</span> isKResult<span class="token punctuation">(</span>BE1<span class="token punctuation">)</span>
</pre><p>Sometimes you wish to declare a production hybrid with respect to a predicate<br>
other than <code>isKResult</code>. You can do this by specifying a sort as the body of the<br>
<code>hybrid</code> attribute, e.g.:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> BExp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> BExp <span class="token string">&quot;||&quot;</span> BExp <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hybrid<span class="token punctuation">(</span>Foo<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><p>generates the rule:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-rule">rule</span> isFoo<span class="token punctuation">(</span>BE1<span class="token punctuation">:</span>BExp <span class="token operator">||</span> BE2<span class="token punctuation">:</span>BExp<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">true</span> <span class="token keyword keyword-requires">requires</span> isFoo<span class="token punctuation">(</span>BE1<span class="token punctuation">)</span>
</pre><p>Properly speaking, <code>hybrid</code> takes an optional comma-separated list of sort<br>
names. If the list is empty, the attribute is equivalent to <code>hybrid(KResult)</code>.<br>
Otherwise, it generates hybrid predicates for exactly the sorts named.</p>
<h3 class="mume-header" id="context-aliases">Context aliases</h3>

<p>Sometimes it is necessary to define a fairly complicated evaluation strategy<br>
for a lot of different operators. In this case, the user <em>could</em> simply write<br>
a number of complex <code>context</code> declarations, however, this quickly becomes<br>
tedious. For this purpose, K has a concept called a <em>context alias</em>. A context<br>
alias is a bit like a template for describing contexts. The template can then<br>
be instantiated against particular productions using the <code>strict</code> and<br>
<code>seqstrict</code> attributes.</p>
<p>Here is a (simplified) example taken from the K semantics of C++:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-context alias">context alias</span> <span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> HERE<span class="token punctuation">:</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>evaluate</span><span class="token punctuation">&gt;</span></span> <span class="token boolean">false</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>evaluate</span><span class="token punctuation">&gt;</span></span>
<span class="token keyword keyword-context alias">context alias</span> <span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> HERE<span class="token punctuation">:</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>evaluate</span><span class="token punctuation">&gt;</span></span> <span class="token boolean">true</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>evaluate</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">[</span>result<span class="token punctuation">(</span>ExecResult<span class="token punctuation">)</span><span class="token punctuation">]</span>

<span class="token keyword keyword-syntax">syntax</span> Expr <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Expr <span class="token string">&quot;=&quot;</span> Init <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span>c<span class="token punctuation">;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><p>This defines the evaluation strategy during the translation phase of a C++<br>
program for the assignment operator. It is equivalent to writing the following<br>
context declarations:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-context">context</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> HOLE<span class="token punctuation">:</span>Expr <span class="token operator">=</span> I<span class="token punctuation">:</span>Init <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>evaluate</span><span class="token punctuation">&gt;</span></span> <span class="token boolean">false</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>evaluate</span><span class="token punctuation">&gt;</span></span>
<span class="token keyword keyword-context">context</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> HOLE<span class="token punctuation">:</span>Expr <span class="token operator">=</span> I<span class="token punctuation">:</span>Init <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>evaluate</span><span class="token punctuation">&gt;</span></span> <span class="token boolean">true</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>evaluate</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">[</span>result<span class="token punctuation">(</span>ExecResult<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><p>What this is saying is, if the <code>evaluate</code> cell is false, evaluate the term<br>
like normal to a <code>KResult</code>. But if the <code>evaluate</code> cell is true, instead<br>
evaluate it to the <code>ExecResult</code> sort.</p>
<p>Essentially, we have given a name to this evaluation strategy in the form of<br>
the rule label on the context alias sentences (in this case, <code>c</code>). We can<br>
then say that we want to use this evaluation strategy to evaluate particular<br>
arguments of particular productions by referring to it by name in a <code>strict</code><br>
attribute. For example, <code>strict(c)</code> will instantiate these contexts once for<br>
each argument of the production, whereas <code>strict(c; 1)</code> will instantiate it<br>
only for the first argument. The special variable <code>HERE</code> is used to tell the<br>
compiler where you want to place the production that is to be heated or cooled.</p>
<p>You can also specify multiple context aliases for different parts of a production,<br>
for example:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> foo<span class="token punctuation">(</span>Exp<span class="token punctuation">,</span> Exp<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token class-name">left</span><span class="token punctuation">;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token class-name">right</span><span class="token punctuation">;</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><p>This says that we can evaluate the left and right arguments in either order, but to evaluate<br>
the left using the <code>left</code> context alias and the right using the <code>right</code> context alias.</p>
<p>We can also say <code>seqstrict(left; 1; right; 2)</code>, in which case we additionally must evaluate<br>
the left argument before the right argument. Note, all strict positions are considered collectively<br>
when determining the evaluation order of <code>seqstrict</code> or the <code>hybrid</code> predicates.</p>
<p>A <code>strict</code> attribute with no rule label associated with it is equivalent to<br>
a <code>strict</code> attribute given with the following context alias:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-context alias">context alias</span> <span class="token punctuation">[</span>default<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> HERE<span class="token punctuation">:</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
</pre><p>One syntactic convenience that is provided is that if you wish to declare the following context:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-context">context</span> foo<span class="token punctuation">(</span>HOLE <span class="token operator">=&gt;</span> bar<span class="token punctuation">(</span>HOLE<span class="token punctuation">)</span><span class="token punctuation">)</span>
</pre><p>you can simply write the following:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> Foo <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> foo<span class="token punctuation">(</span>Bar<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span>alias<span class="token punctuation">)</span><span class="token punctuation">]</span>

<span class="token keyword keyword-context alias">context alias</span> <span class="token punctuation">[</span>alias<span class="token punctuation">]</span><span class="token punctuation">:</span> HERE <span class="token punctuation">[</span><span class="token keyword keyword-context">context</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h2>Pattern Matching</h2>
<h3 class="mume-header" id="as-patterns">As Patterns</h3>

<p>New syntax has been added to K for matching a pattern and binding the resulting<br>
match in its entirety to a variable.</p>
<p>The syntax is:</p>
<pre data-role="codeBlock" data-info class="language-"><code>Pattern #as V::Var
</code></pre><p>In this case, Pattern, including any variables, is matched and the resulting<br>
variables are added to the substitution if matching succeeds. Furthermore, the<br>
term matched by Pattern is added to the substitution as V.</p>
<p>This code can also be used outside of any rewrite, in which case matching<br>
occurs as if it appeared on the left hand side, and the right hand side becomes<br>
a variable corresponding to the alias.</p>
<p>It is an error to use an as pattern on the right hand side of a rule.</p>
<h3 class="mume-header" id="record-like-kapply-patterns">Record-like KApply Patterns</h3>

<p>We have added a syntax for matching on KApply terms which mimics the record<br>
syntax in functional languages. This allows us to more easily express patterns<br>
involving a KApply term in which we don&apos;t care about some or most of the<br>
children, without introducing a dependency into the code on the number of<br>
arguments which could be changed by a future refactoring.</p>
<p>The syntax is:</p>
<pre data-role="codeBlock" data-info class="language-"><code>record(... field1: Pattern1, field2: Pattern2)
</code></pre><p>Note that this only applies to productions that are prefix productions.<br>
A prefix production is considered by the implementation to be any production<br>
whose production items match the following regular expression:</p>
<pre data-role="codeBlock" data-info class="language-"><code>(Terminal(_)*) Terminal(&quot;(&quot;)
(NonTerminal (Terminal(&quot;,&quot;) NonTerminal)* )?
Terminal(&quot;)&quot;)
</code></pre><p>In other words, any sequence of terminals followed by an open parenthesis, an<br>
optional comma separated list of non-terminals, and a close parenthesis.</p>
<p>If a prefix production has no named nonterminals, a <code>record(...)</code> syntax is<br>
allowed, but in order to reference specific fields, it is necessary to give one<br>
or more of the non-terminals in the production names.</p>
<p>Note: because the implementation currently creates one production per possible<br>
set of fields to match on, and because all possible permutations of all<br>
possible subsets of a list of n elements is a number that scales factorially<br>
and reaches over 100 thousand productions at n=8, we currently do not allow<br>
fields to be matched in any order like a true record, but only in the same<br>
order as appears in the production itself.</p>
<p>Given that this only reduces the number of productions to the size of the power<br>
set, this will still explode the parsing time if we create large productions of<br>
10 or more fields that all have names. This is something that should probably<br>
be improved, however, productions with that large of an arity are rare, and<br>
thus it has not been viewed as a priority.</p>
<h3 class="mume-header" id="or-patterns">Or Patterns</h3>

<p>Sometimes you wish to express that a rule should match if one out of multiple<br>
patterns should match the same subterm. We can now express this in K by means<br>
of using the <code>#Or</code> ML connective on the left hand side of a rule.</p>
<p>For example:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-rule">rule</span> foo #Or bar #Or baz <span class="token operator">=&gt;</span> qux
</pre><p>Here any of foo, bar, or baz will match this rule. Note that the behavior is<br>
ill-defined if it is not the case that all the clauses of the or have the same<br>
bound variables.</p>
<h3 class="mume-header" id="matching-global-context-in-function-rules">Matching global context in function rules</h3>

<p>On occasion it is highly desirable to be able to look up information from the<br>
global configuration and match against it when evaluating a function. For this<br>
purpose, we introduce a new syntax for function rules.</p>
<p>This syntax allows the user to match on <em>function context</em> from within a<br>
function rule:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> foo<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>

<span class="token keyword keyword-rule">rule</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> foo<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> I <span class="token punctuation">]</span><span class="token punctuation">]</span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bar</span><span class="token punctuation">&gt;</span></span> I <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bar</span><span class="token punctuation">&gt;</span></span>

<span class="token keyword keyword-rule">rule</span> something <span class="token operator">=&gt;</span> foo<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
</pre><p>This is completely desugared by the K frontend and does not require any special<br>
support in the backend. It is an error to have a rewrite inside function<br>
context, as we do not currently support propagating such changes back into the<br>
global configuration. It is also an error if the context is not at the top<br>
level of a rule body.</p>
<p>Desugared code:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> foo<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> GeneratedTopCell<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>

<span class="token keyword keyword-rule">rule</span> foo<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>generatedTop</span><span class="token punctuation">&gt;</span></span>
              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bar</span><span class="token punctuation">&gt;</span></span> I <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bar</span><span class="token punctuation">&gt;</span></span>
              <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>generatedTop</span><span class="token punctuation">&gt;</span></span> #as Configuration<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> I
<span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>generatedTop</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> something <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>generatedTop</span><span class="token punctuation">&gt;</span></span> #as Configuration
  <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>generatedTop</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> foo<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> Configuration&gt; <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>generatedTop</span><span class="token punctuation">&gt;</span></span>
</pre><h3 class="mume-header" id="collection-patterns">Collection patterns</h3>

<p>It is allowed to write patterns on the left hand side of rules which refer to<br>
complex terms of sort Map, List, and Set, despite these patterns ostensibly<br>
breaking the rule that terms which are functions should not appear on the left<br>
hand side of rules. Such terms are destructured into pattern matching<br>
operations.</p>
<p>The following forms are allowed:</p>
<pre data-role="codeBlock" data-info class="language-"><code>// 0 or more elements followed by 0 or 1 variables of sort List followed by
// 0 or more elements
ListItem(E1) ListItem(E2) L:List ListItem(E3) ListItem(E4)

// the empty list
.List

// 1 or more list update operations applied to a variable
L:List [ K1 &lt;- E1 ] [ K2 &lt;- E2 ]

// 0 or more elements in any order plus 0 or 1 variables of sort Set
// in any order
SetItem(K1) SetItem(K2) S::Set SetItem(K3) SetItem(K4)

// the empty set
.Set

// 0 or more elements in any order plus by 0 or 1 variables of sort Map
// in any order
K1 |-&gt; E1 K2 |-&gt; E2 M::Map K3 |-&gt; E3 K4 |-&gt; E4

// the empty map
.Map
</code></pre><p>Here K1, K2, K3, K4 etc can be any pattern except a pattern containing both<br>
function symbols and unbound variables. An unbound variable is a variable whose<br>
binding cannot be determined by means of decomposing non-set-or-map patterns or<br>
map elements whose keys contain no unbound variables.</p>
<p>This is determined recursively, ie, the term <code>K1 |-&gt; E2 E2 |-&gt; E3 E3 |-&gt; E4</code> is<br>
considered to contain no unbound variables.</p>
<p>Note that in the pattern <code>K1 |-&gt; E2 K3 |-&gt; E4 E4 |-&gt; E5</code>, K1 and K3 are<br>
unbound, but E4 is bound because it is bound by deconstructing the key E3, even<br>
though E3 is itself unbound.</p>
<p>In the above examples, E1, E2, E3, and E4 can be any pattern that is normally<br>
allowed on the lhs of a rule.</p>
<p>When a map, set, or list key contains function symbols, we know that the<br>
variables in that key are bound (because of the above restriction), so it is<br>
possible to evaluate the function to a concrete term prior to performing the<br>
lookup.</p>
<p>Indeed, this is the precise semantics which occurs; the function is evaluated<br>
and the result is looked up in the collection.</p>
<p>For example:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> f<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
<span class="token keyword keyword-rule">rule</span> f<span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> I <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span>
<span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>state</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> SetItem<span class="token punctuation">(</span>f<span class="token punctuation">(</span>I<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>state</span><span class="token punctuation">&gt;</span></span>
</pre><p>This will rewrite <code>I</code> to <code>.</code> if and only if the state cell contains<br>
<code>I +Int 1</code>.</p>
<p>Note that in the case of Set and Map, one guarantee is that K1, K2, K3, and K4<br>
represent /distinct/ elements. Pattern matching fails if the correct number of<br>
distinct elements cannot be found.</p>
<h3 class="mume-header" id="matching-on-cell-fragments">Matching on cell fragments</h3>

<p>K allows matching fragments of the configuration and using them to construct<br>
terms and use as function parameters.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-configuration">configuration</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>t</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> #init <span class="token operator">~&gt;</span> #collectOdd <span class="token operator">~&gt;</span> $PGM <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fs</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>f</span> <span class="token attr-name">multiplicity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>*<span class="token punctuation">&quot;</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Set<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token number">1</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>f</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fs</span><span class="token punctuation">&gt;</span></span>
              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>t</span><span class="token punctuation">&gt;</span></span>
</pre><p>The <code>#collectOdd</code> construct grabs the entire content of the <code>&lt;fs&gt;</code> cell.<br>
We may also match on only a portion of its content. Note that the fragment<br>
must be wrapped in a <code>&lt;f&gt;</code> cell at the call site.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;#collectOdd&quot;</span>
<span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> #collectOdd <span class="token operator">=&gt;</span> collectOdd<span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fs</span><span class="token punctuation">&gt;</span></span> Fs <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fs</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fs</span><span class="token punctuation">&gt;</span></span> Fs <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fs</span><span class="token punctuation">&gt;</span></span>
</pre><p>The <code>collectOdd</code> function collects the items it needs</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> Set <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> collectOdd<span class="token punctuation">(</span>FsCell<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
<span class="token keyword keyword-rule">rule</span> collectOdd<span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fs</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>f</span><span class="token punctuation">&gt;</span></span> I <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>f</span><span class="token punctuation">&gt;</span></span> REST <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fs</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> SetItem<span class="token punctuation">(</span>I<span class="token punctuation">)</span> collectOdd<span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fs</span><span class="token punctuation">&gt;</span></span> REST <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fs</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> <span class="token keyword keyword-requires">requires</span> I <span class="token operator">%</span><span class="token keyword keyword-Int">Int</span> <span class="token number">2</span> <span class="token operator">==</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span>
<span class="token keyword keyword-rule">rule</span> collectOdd<span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fs</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>f</span><span class="token punctuation">&gt;</span></span> I <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>f</span><span class="token punctuation">&gt;</span></span> REST <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fs</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>            collectOdd<span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fs</span><span class="token punctuation">&gt;</span></span> REST <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fs</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> <span class="token keyword keyword-requires">requires</span> I <span class="token operator">%</span><span class="token keyword keyword-Int">Int</span> <span class="token number">2</span> <span class="token operator">==</span><span class="token keyword keyword-Int">Int</span> <span class="token number">0</span>
<span class="token keyword keyword-rule">rule</span> collectOdd<span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fs</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Bag <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fs</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Set
</pre><h3 class="mume-header" id="all-path-and-one-path-attributes-to-distinguish-reachability-claims"><code>all-path</code> and <code>one-path</code> attributes to distinguish reachability claims</h3>

<p>As the Haskell backend can handle both one-path and all-path reachability<br>
claims, but both these are encoded as rewrite rules in K, these attributes can<br>
be used to clarify what kind of claim a rule is.</p>
<p>In addition of being able to annotate a rule with one of them<br>
(if annotating with more at the same time, only one of them would be chosen),<br>
one can also annotate whole modules, to give a default claim type for all rules<br>
in that module.</p>
<p>Additionally, the Haskell backend introduces an extra command line option<br>
for the K frontend, <code>--default-claim-type</code>, with possible values<br>
<code>all-path</code> and <code>one-path</code> to allow choosing a default type for all<br>
claims.</p>
<h3 class="mume-header" id="set-variables">Set Variables</h3>

<h4 class="mume-header" id="motivation">Motivation</h4>

<p>Set variables were introduced as part of Matching Mu Logic, the mathematical<br>
foundations for K. In Matching Mu Logic, terms evaluate to sets of values.<br>
This is useful for both capturing partiality (as in <code>3/0</code>) and capturing<br>
non-determinism (as in <code>3 #Or 5</code>). Consequently, symbol interpretation is<br>
extended to have a collective interpretation over sets of input values.</p>
<p>Usually, K rules are given using regular variables, which expect that the term<br>
they match is both defined and has a unique interpretation.</p>
<p>However, it is sometimes useful to have simplification rules which work over<br>
any kind of pattern, be it undefined or non-deterministic. This behavior can be<br>
achieved by using set variables to stand for any kind of pattern.</p>
<h4 class="mume-header" id="syntax">Syntax</h4>

<p>Any variable prefixed by <code>@</code> will be considered a set variable.</p>
<h4 class="mume-header" id="example">Example</h4>

<p>Below is a simplification rule which motivated this extension:</p>
<pre data-role="codeBlock" data-info class="language-"><code>  rule #Ceil(@I1:Int /Int @I2:Int) =&gt;
    {(@I2 =/=Int 0) #Equals true} #And #Ceil(@I1) #And #Ceil(@I2)
    [anywhere]
</code></pre><p>This rule basically says that <code>@I1:Int /Int @I2:Int</code> is defined if <code>@I1</code> and<br>
<code>@I2</code> are defined and <code>@I2</code> is not 0. Using sets variables here is important as<br>
it allows the simplification rule to apply <em>any</em> symbolic patterns, without<br>
caring whether they are defined or not.</p>
<p>This allows simplifying the expression <code>#Ceil((A:Int /Int B:Int) / C:Int)</code> to:</p>
<pre data-role="codeBlock" data-info class="language-"><code>{(C =/=Int 0) #Equals true} #And #Ceil(C) #And ({(B =/=Int 0) #Equals true}
#And #Ceil(B) #And #Ceil(A)`
</code></pre><p>See <a href="https://github.com/kframework/kore/issues/729">kframework/kore#729</a> for<br>
more details.</p>
<h4 class="mume-header" id="smt-translation">SMT Translation</h4>

<p>K makes queries to an SMT solver (Z3) to discharge proof obligations when doing<br>
symbolic execution. You can control how these queries are made using the<br>
attributes <code>smtlib</code>, <code>smt-hook</code>, and <code>smt-lemma</code> on declared productions.<br>
These attributes guide the prover when it tries to apply rules to discharge a<br>
proof obligation.</p>
<ul>
<li><code>smt-hook(...)</code> allows you to specify a term in SMTLIB2 format which should<br>
be used to encode that production, and assumes that all symbols appearing in<br>
the term are already declared by the SMT solver.</li>
<li><code>smtlib(...)</code> allows you to declare a new SMT symbol to be used when that<br>
production is sent to Z3, and gives it <em>uninterpreted function</em> semantics.</li>
<li><code>smt-lemma</code> can be applied to a rule to encode it as a conditional equality<br>
when sending queries to Z3. A rule <code>rule LHS =&gt; RHS requires REQ</code> will be<br>
encoded as the conditional equality <code>(=&gt; REQ (= (LHS RHS))</code>. Every symbol<br>
present in the rule must have an <code>smt-hook(...)</code> or <code>smtlib(...)</code> attribute.</li>
</ul>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;~Int&quot;</span> <span class="token keyword keyword-Int">Int</span>          <span class="token punctuation">[</span>function<span class="token punctuation">,</span> <span class="token class-name">klabel</span><span class="token punctuation">(</span><span class="token operator">~</span>Int_<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">,</span>
                                    smtlib<span class="token punctuation">(</span>notInt<span class="token punctuation">)</span><span class="token punctuation">]</span>
             <span class="token operator">|</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;^%Int&quot;</span> <span class="token keyword keyword-Int">Int</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> <span class="token class-name">klabel</span><span class="token punctuation">(</span>_<span class="token operator">^</span><span class="token operator">%</span>Int__<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">,</span>
                                    smt<span class="token operator">-</span>hook<span class="token punctuation">(</span><span class="token punctuation">(</span>mod <span class="token punctuation">(</span><span class="token operator">^</span> #<span class="token number">1</span> #<span class="token number">2</span><span class="token punctuation">)</span> #<span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><p>In the example above, we declare two productions <code>~Int_</code> and <code>_^%Int__</code>, and<br>
tell the SMT solver to:</p>
<ul>
<li>use uninterpreted function semantics for <code>~Int_</code> via SMTLIB2 symbol<br>
<code>notInt</code>, and</li>
<li>use the SMTLIB2 term <code>(mod (^ #1 #2) #3)</code> (where <code>#N</code> marks the <code>N</code>th<br>
production non-terminal argument positions) for <code>_^%Int__</code>, where <code>mod</code> and<br>
<code>^</code> already are declared by the SMT solver.</li>
</ul>
<h4 class="mume-header" id="caution">Caution</h4>

<p>Set variables are currently only supported by the Haskell backend.<br>
The use of rules with set variables should be sound for all other backends<br>
which just execute by rewriting, however it might not be safe for backends<br>
which want to guarantee coverage.</p>
<h3 class="mume-header" id="variables-occurring-only-in-the-rhs-of-a-rule">Variables occurring only in the RHS of a rule</h3>

<p>This section presents possible scenarios requiring variables to only appear in<br>
the RHS of a rule.</p>
<h4 class="mume-header" id="summary">Summary</h4>

<p>Except for <code>?</code> variables and <code>!</code> (fresh) variables, which are<br>
<strong>required</strong> to only appear in the RHS of a rule, all other variables <strong>must</strong><br>
also appear in the LHS of a rule.  This restriction also applies to anonymous<br>
variables; in particular, for claims, <code>?_</code> (not <code>_</code>) should be used in the RHS<br>
to indicate that something changes but we don&apos;t care to what value.</p>
<p>To support specifying random-like behavior, the above restriction can be relaxed<br>
by annotating a rule with the <code>unboundVariables</code> attribute whenever the rule<br>
intentionally contains regular variables only occurring in the RHS.</p>
<h4 class="mume-header" id="introduction">Introduction</h4>

<p>K uses question mark variables of the form <code>?X</code> to refer to<br>
existential variables, and uses <code>ensures</code> to specify logical constraints on<br>
those variables.<br>
These variables are only allowed to appear in the RHS of a K rule.</p>
<p>If the rules represent rewrite (semantic) steps or verification claims,<br>
then the <code>?</code> variables are existentially quantified at the top of the RHS;<br>
otherwise, if they represent equations, the <code>?</code> variables are quantified at the<br>
top of the entire rule.</p>
<p>Note that when both <code>?</code>-variables and regular variables are present,<br>
regular variables are (implicitly) universally quantified on top of the rule<br>
(already containing the existential quantifications).<br>
This essentially makes all <code>?</code> variables depend on all regular variables.</p>
<p>All examples below are intended more for program verification /<br>
symbolic execution, and thus concrete implementations might choose to ignore<br>
them altogether or to provide ad-hoc implementations for them.</p>
<h4 class="mume-header" id="example-verification-claims">Example: Verification claims</h4>

<p>Consider the following definition of a (transition) system:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> A
  <span class="token keyword keyword-rule">rule</span> foo <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
  <span class="token keyword keyword-rule">rule</span> bar <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
  <span class="token keyword keyword-rule">rule</span> bar <span class="token operator">=&gt;</span> <span class="token boolean">false</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>Consider also, the following specification of claims about the definition above:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> A<span class="token operator">-</span>SPEC
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">[</span>s1<span class="token punctuation">]</span><span class="token punctuation">:</span> foo <span class="token operator">=&gt;</span> <span class="token operator">?</span>X<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">[</span>s2<span class="token punctuation">]</span><span class="token punctuation">:</span> foo <span class="token operator">=&gt;</span>  X<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span>  <span class="token punctuation">[</span>unboundVariables<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">[</span>s3<span class="token punctuation">]</span><span class="token punctuation">:</span> bar <span class="token operator">=&gt;</span> <span class="token operator">?</span>X<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">[</span>s4<span class="token punctuation">]</span><span class="token punctuation">:</span> bar <span class="token operator">=&gt;</span>  X<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span>  <span class="token punctuation">[</span>unboundVariables<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><h5 class="mume-header" id="one-path-interpretation">One-path interpretation</h5>

<ul>
<li>(s1) says that there exists a path from <code>foo</code> to some boolean, which is<br>
satisfied easily using the <code>foo =&gt; true</code> rule</li>
<li>(s3) says the same thing about <code>bar</code> and can be satisfied by either of<br>
<code>bar =&gt; true</code> and <code>bar =&gt; false</code> rules</li>
<li>(s2) and (s4) can be better understood by replacing them with instances for<br>
<strong>each</strong> element of type <code>Bool</code>, which can be interpreted that<br>
both <code>true</code> and <code>false</code> are reachable from <code>foo</code> for (s2), or <code>bar</code> for (s4),<br>
respectively.
<ul>
<li>(s2) cannot be verified as we cannot find a path from <code>foo</code> to <code>false</code>.</li>
<li>(s4) can be verified by using <code>bar =&gt; true</code> to show <code>true</code> is reachable and<br>
<code>bar =&gt; false</code> to achieve the same thing for <code>false</code></li>
</ul>
</li>
</ul>
<h5 class="mume-header" id="all-path-interpretation">All-path interpretation</h5>

<ul>
<li>
<p>(s1) says that all paths from <code>foo</code> will reach some boolean, which is<br>
satisfied by the <code>foo =&gt; true</code> rule and the lack of other rules for <code>foo</code></p>
</li>
<li>
<p>(s3) says the same thing about <code>bar</code> and can be satisfied by checking that<br>
both <code>bar =&gt; true</code> and <code>bar =&gt; false</code> end in a boolean, and there are no<br>
other rules for <code>bar</code></p>
</li>
<li>
<p>(s2) and (s4) can be better understood by replacing them with instances for<br>
<strong>each</strong> element of type <code>Bool</code>, which can be interpreted that<br>
both <code>true</code> and <code>false</code> are reachable <strong>in all paths</strong> originating in<br>
<code>foo</code> for (s2), or <code>bar</code> for (s4), respectively.<br>
This is a very strong claim, requiring that all paths originating in<br>
<code>foo</code> (<code>bar</code>) pass through <strong>both</strong> <code>true</code> and <code>false</code>,<br>
so neither (s2) nor (s4) can be verified.</p>
<p>Interestingly enough, adding a rule like <code>false =&gt; true</code> would make both<br>
(s2) and (s4) hold.</p>
</li>
</ul>
<h4 class="mume-header" id="example-random-number-construct-rand">Example: Random Number Construct <code>rand()</code></h4>

<p>The random number construct <code>rand()</code> is a language construct which could be<br>
easily conceived to be part of the syntax of a programming language:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;rand&quot;</span> <span class="token string">&quot;(&quot;</span> <span class="token string">&quot;)&quot;</span>
</pre><p>The intended semantics of <code>rand()</code> is that it can rewrite to any integer in<br>
a single step. This could be expressed as the following following infinitely<br>
many rules.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-rule">rule</span>  rand<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token number">0</span>
<span class="token keyword keyword-rule">rule</span>  rand<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token number">1</span>
<span class="token keyword keyword-rule">rule</span>  rand<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token number">2</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword keyword-rule">rule</span> rand<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token keyword keyword-rule">rule</span> rand<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</pre><p>Since we need an instance of the rule for <strong>every</strong> integer, one could summarize<br>
the above infinitely many rules with the rule</p>
<pre data-role="codeBlock" data-info class="language-"><code>rule rand() =&gt; I:Int [unboundVariables(I)]
</code></pre><p>Note that <code>I</code> occurs only in the RHS in the rule above, and thus the rule<br>
needs the <code>unboundVariables(I)</code> attribute to signal that this is intentionally.</p>
<p>One can define variants of <code>rand()</code> by further constraining the output variable<br>
as a precondition to the rule.</p>
<h5 class="mume-header" id="rand-like-examples">Rand-like examples</h5>

<ol>
<li>
<p><code>randBounded(M,N)</code> can rewrite to any integer between <code>M</code> and <code>N</code></p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> randBounded<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span>
<span class="token keyword keyword-rule">rule</span> randBounded<span class="token punctuation">(</span>M<span class="token punctuation">,</span> N<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> I
  <span class="token keyword keyword-requires">requires</span> M <span class="token operator">&lt;=</span><span class="token keyword keyword-Int">Int</span> I andBool I <span class="token operator">&lt;=</span><span class="token keyword keyword-Int">Int</span> N
  <span class="token punctuation">[</span>unboundVariables<span class="token punctuation">(</span>I<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre></li>
<li>
<p><code>randInList(Is)</code> takes a list <code>Is</code> of items<br>
and can rewrite in one step to any item in <code>Is</code>.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> randInList <span class="token punctuation">(</span>List<span class="token punctuation">)</span>
<span class="token keyword keyword-rule">rule</span> randInList<span class="token punctuation">(</span>Is<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> I
  <span class="token keyword keyword-requires">requires</span> I inList Is
  <span class="token punctuation">[</span>unboundVariables<span class="token punctuation">(</span>I<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre></li>
<li>
<p><code>randNotInList(Is)</code> takes a list <code>Is</code> of items<br>
and can rewrite in one step to any item <em>not</em> in <code>Is</code>.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> randNotInList <span class="token punctuation">(</span>List<span class="token punctuation">)</span>
<span class="token keyword keyword-rule">rule</span> randNotInList<span class="token punctuation">(</span>Is<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> I
  <span class="token keyword keyword-requires">requires</span> notBool<span class="token punctuation">(</span>I inList Is<span class="token punctuation">)</span>
  <span class="token punctuation">[</span>unboundVariables<span class="token punctuation">(</span>I<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre></li>
<li>
<p><code>randPrime()</code>, can rewrite to any <em>prime number</em>.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> randPrime <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword keyword-rule">rule</span> randPrime<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> X<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span>
  <span class="token keyword keyword-requires">requires</span> isPrime<span class="token punctuation">(</span>X<span class="token punctuation">)</span>
  <span class="token punctuation">[</span>unboundVariables<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><p>where <code>isPrime(_)</code> is a predicate that can be defined in the usual way.</p>
</li>
</ol>
<p>Note 1: all above are not function symbols, but language constructs.</p>
<p>Note 2: Currently the frontend does not allow rules with universally quantified<br>
variables in the RHS which are not bound in the LHS.</p>
<p>Note 3. Allowing these rules in a concrete execution engine would require an<br>
algorithm for generating concrete instances for such variables, satisfying the<br>
given constraints; thus the <code>unboundVariables</code> attribute serves two purposes:</p>
<ul>
<li>to allow such rules to pass the variable checks, and</li>
<li>to signal (concrete execution) backends that specialized algorithm would be<br>
needed to instantiate these variables.</li>
</ul>
<h4 class="mume-header" id="example-fresh-integer-construct-freshis">Example: Fresh Integer Construct <code>fresh(Is)</code></h4>

<p>The fresh integer construct <code>fresh(Is)</code> is a language construct.</p>
<pre data-role="codeBlock" data-info class="language-"><code>Exp ::= ... | &quot;fresh&quot; &quot;(&quot; List{Int} &quot;)&quot;
</code></pre><p>The intended semantics of <code>fresh(Is)</code> is that it can always rewrite to an<br>
integer that in not in <code>Is</code>.</p>
<p>Note that <code>fresh(Is)</code> and <code>randNotInList(Is)</code> are different; the former<br>
does not <em>need</em> to be able to rewrite to every integers not in <code>Is</code>,<br>
while the latter requires so.</p>
<p>For example, it is <em>correct</em> to implement <code>fresh(Is)</code> so it always returns the<br>
smallest positive integer that is not in <code>Is</code>, but same implementation for<br>
<code>randNotInList(Is)</code> might be considered <em>inadequate</em>.<br>
In other words, there exist multiple correct implementations of <code>fresh(Is)</code>,<br>
some of which may be deterministic, but there only exists a unique<br>
implementation of <code>randNotInList(Is)</code>.<br>
Finally, note that <code>randNotInList(Is)</code> is a <em>correct</em> implementation<br>
for <code>fresh(Is)</code>; Hence, concrete execution engines can choose to handle<br>
such rules accordingly.</p>
<p>We use the following K syntax to define <code>fresh(Is)</code></p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> fresh <span class="token punctuation">(</span>List<span class="token punctuation">{</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword keyword-rule">rule</span> fresh<span class="token punctuation">(</span>Is<span class="token punctuation">:</span>List<span class="token punctuation">{</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token operator">?</span>I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span>
  ensures notBool <span class="token punctuation">(</span><span class="token operator">?</span>I inList<span class="token punctuation">{</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">}</span> Is<span class="token punctuation">)</span>
</pre><p>A variant of this would be a <code>choiceInList(Is)</code> language construct which would<br>
choose some number from a list:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> choiceInList <span class="token punctuation">(</span>List<span class="token punctuation">{</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword keyword-rule">rule</span> choiceInList<span class="token punctuation">(</span>Is<span class="token punctuation">:</span>List<span class="token punctuation">{</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token operator">?</span>I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span>
  ensures <span class="token operator">?</span>I inList<span class="token punctuation">{</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">}</span> Is
</pre><p>Note: This definition is different from one using a <code>!</code> variable to indicate<br>
freshness because using <code>!</code> is just syntactic sugar for generating globally<br>
unique instances and relies on a special configuration cell, and cannot be<br>
constrained, while the <code>fresh</code> described here is local and can be constrained.<br>
While the first is more appropriate for concrete execution, this might be<br>
better for symbolic execution / program verification.</p>
<h4 class="mume-header" id="example-arbitrary-number-unspecific-function-arb">Example: Arbitrary Number (Unspecific Function) <code>arb()</code></h4>

<p>The function <code>arb()</code> is not a PL construct, but a mathematical function.<br>
Therefore, its definition should not be interpreted as an execution step, but<br>
rather as an equality.</p>
<p>The intended semantics of <code>arb()</code> is that it is an unspecified nullary function.<br>
The exact return value of <code>arb()</code> is unspecified in the semantics but up to the<br>
implementations.<br>
However, being a mathematical function, <code>arb()</code> must return the same value in<br>
any one implementation.</p>
<p>We do not need special frontend syntax to define <code>arb()</code>.<br>
We only need to define it in the usual way as a function<br>
(instead of a language construct), and provide no axioms for it.<br>
The <code>total</code> attribute ensures that the function is total, i.e.,<br>
that it evaluates to precisely one value for each input.</p>
<h5 class="mume-header" id="variants">Variants</h5>

<p>There are many variants of <code>arb()</code>. For example, <code>arbInList(Is)</code> is<br>
an unspecified function whose return value must be an element from <code>Is</code>.</p>
<p>Note that <code>arbInList(Is)</code> is different from <code>choiceInList(Is)</code>, because<br>
<code>choiceInList(Is)</code> <em>transitions</em> to an integer in <code>Is</code> (could be a different one<br>
each time it is used), while <code>arbInList(Is)</code> <em>is equal to</em> a (fixed)<br>
integer not in <code>Is</code>.</p>
<p>W.r.t. the <code>arb</code> variants, we can use <code>?</code> variables and the <code>function</code><br>
annotation to signal that we&apos;re defining a function and the value of the<br>
function is fixed, but non-determinate.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> arbInList<span class="token punctuation">(</span>List<span class="token punctuation">{</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
<span class="token keyword keyword-rule">rule</span> arbInList<span class="token punctuation">(</span>Is<span class="token punctuation">:</span>List<span class="token punctuation">{</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token operator">?</span>I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span>
  ensures <span class="token operator">?</span>I inList<span class="token punctuation">{</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">}</span> Is
</pre><p>If elimination of existentials in equational rules is needed, one possible<br>
approach would be through <a href="https://en.wikipedia.org/wiki/Skolem_normal_form">Skolemization</a>,<br>
i.e., replacing the <code>?</code> variable with a new uninterpreted function depending<br>
on the regular variables present in the function.</p>
<h4 class="mume-header" id="example-interval-non-function-symbols-interval">Example: Interval (Non-function Symbols) <code>interval()</code></h4>

<p>The symbol <code>interval(M,N)</code> is not a PL construct, nor a function in the<br>
first-order sense, but a proper matching-logic symbol, whose interpretation is<br>
in the powerset of its domain.<br>
Its axioms will not use rewrites but equalities.</p>
<p>The intended semantics of <code>interval(M,N)</code> is that it equals the <em>set</em> of<br>
integers that are larger than or equal to <code>M</code> and smaller than or equal to <code>N</code>.</p>
<p>Since expressing the axiom for <code>interval</code> requires an an existential<br>
quantification on the right-hand-side, thus making it a non-total symbol<br>
defined through an equation, using <code>?</code> variables might be confusing since their<br>
usage would be different from that presented in the previous sections.</p>
<p>Hence, the proposal to support this would be to write this as a proper ML rule.<br>
A possible syntax for this purpose would be:</p>
<pre data-role="codeBlock" data-info class="language-"><code>eq  interval(M,N)
    ==
    #Exists X:Int .
        (X:Int #And { X &gt;=Int M #Equals true } #And { X &lt;=Int N #Equals true })
</code></pre><p>Additionally, the symbol declaration would require a special attribute to<br>
signal the fact that it is not a constructor but a <em>defined</em> symbol.</p>
<p>Since this feature is not clearly needed by K users at the moment, it is only<br>
presented here as an example; its implementation will be postponed for such time<br>
when its usefulness becomes apparent.</p>
<h2>Parser Generation</h2>
<p>In addition to on-the-fly parser generation using <code>kast</code>, K is capable of<br>
ahead-of-time parser generation of LR(1) or GLR parsers using Flex and Bison.<br>
This can be done one of two different ways.</p>
<ol>
<li>You can explicitly request for a particular parser to be generated by<br>
invoking <code>kast --gen-parser &lt;outputFile&gt;</code> or<br>
<code>kast --gen-glr-parser &lt;outputFile&gt;</code> respectively. <code>kast</code> will then create a<br>
parser based on the same command line flags that govern on-the-fly parsing,<br>
like <code>-s</code> to specify the starting sort, and <code>-m</code> to specify the module to<br>
parse under. By default, this generates a parser for the sort of the <code>$PGM</code><br>
configuration variable in the main syntax module of the definition.</li>
<li>You can request that a specific set of parsers be generated for all the<br>
configuration variables of your definition by passing the<br>
<code>--gen-bison-parser</code> or <code>--gen-glr-bison-parser</code> flags to <code>kompile</code>.<br>
<code>kompile</code> will decide the sorts to use as start symbols based on the sorts<br>
in the configuration declaration for the configuration variables. The <code>$PGM</code><br>
configuration variable will be generated based on the main syntax module<br>
of the definition. The user must explicitly annotate the configuration<br>
declaration with the other modules to use to parse the other configuration<br>
variables as attributes. For example, if I have the following cell in the<br>
configuration declaration: <code>&lt;cell&gt; foo($FOO:Foo, $BAR:Bar) &lt;/cell&gt;</code>,<br>
One might annotate it with the attribute pair <code>parser=&quot;FOO, TEST; BAR, TEST2&quot;</code><br>
to indicate that configuration variable <code>$FOO</code> should be parsed in the<br>
<code>TEST</code> module, and configuration variable <code>$BAR</code> should be parsed in the<br>
<code>TEST2</code> module. If the user forgets to annotate the declaration with the<br>
parser attribute, only the <code>$PGM</code> parser will be generated.</li>
</ol>
<p>Bison-generated parsers are extremely fast compared to <code>kast</code>, but they have<br>
some important limitations:</p>
<ul>
<li>Bison parsers will always output Kore. You can then pass the resulting AST<br>
directly to <code>llvm-krun</code> or <code>kore-exec</code> and bypass the <code>krun</code> frontend, making<br>
them very fast, but lower-level.</li>
<li>Bison parsers do not yet support macros. This may change in a future release.<br>
Note that you can use anywhere rules instead of macros in most cases to get<br>
around this limitation, although they will not benefit from unparsing via the<br>
<code>alias</code> attribute.</li>
<li>Obligation falls on the user to ensure that the grammar they write is LR(1)<br>
if they choose to use LR(1) parsing. If this does not happen, the parser<br>
generated will have shift/reduce or reduce/reduce conflicts and the parser<br>
may behave differently than <code>kast</code> would (<code>kast</code> is a GLL parser, ie, it<br>
is based on LL parsers and parses all unambiguous context-free grammars).<br>
K provides an attribute, <code>not-lr1</code>, which can be applied to modules known to<br>
not be LR(1), and will trigger a warning if the user attempts to generate an<br>
LR(1) parser which recursively imports that module.</li>
<li>If you are using LR(1) based parsing, the <code>prefer</code> and <code>avoid</code> attributes are<br>
ignored. It is only possible to implement these attributes by means of<br>
generalized LL or LR parsing and a postprocessing on the AST to remove the<br>
undesirable ambiguity.</li>
<li>Obligation falls on the user to ensure that the grammar they write has as<br>
few conflicts as possible if they are using GLR parsing. Bison&apos;s GLR support<br>
is quite primitive, and in the worst case it can use exponential space and<br>
time to parse a program, which generally leads the generated parser to report<br>
&quot;memory exhausted&quot;, indicating that the parse could not be completed within<br>
the stack space allocated by Bison. It&apos;s best to ensure that the grammar is<br>
as close to LR(1) as possible and only utilizes conflicts where absolutely<br>
necessary. One tool that can be used to facilitate this is to pass<br>
<code>--bison-lists</code> to kompile. This will disable support for the <code>List{Sort}</code><br>
syntax production, and it will make <code>NeList{Sort}</code> left associative, but the<br>
resulting productions generated for <code>NeList{Sort}</code> will be LR(1) and use bounded<br>
stack space.</li>
<li>If the grammar you are parsing is context-sensitive (for example, because<br>
it requires a symbol table to parse), one thing you can do to make this<br>
language parse in K is to implement the language as an ambiguous grammar.<br>
Bison&apos;s GLR parser will generate an <code>amb</code> production that is parametric in<br>
the sort of the ambiguity. You can then import the <code>K-AMBIGUITIES</code> module<br>
and use rewriting to resolve the ambiguities using whatever preprocessing<br>
mechanisms you prefer.</li>
</ul>
<h2>Location Information</h2>
<p>K is able to insert file, line, and column metadata into the parse tree on a<br>
per-sort basis when parsing using a bison-generated parser. To enable this,<br>
mark the sort with the <code>locations</code> attribute.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">[</span>locations<span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Exp <span class="token string">&quot;/&quot;</span> Exp <span class="token operator">|</span> <span class="token keyword keyword-Int">Int</span>
</pre><p>K implicitly wraps productions of these sorts in a <code>#location</code> term (see the<br>
<code>K-LOCATIONS</code> module in <code>kast.md</code>). The metadata can thus be accessed with<br>
ordinary rewrite rules:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> #location<span class="token punctuation">(</span>_ <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">,</span> File<span class="token punctuation">,</span> StartLine<span class="token punctuation">,</span> _StartColumn<span class="token punctuation">,</span> _EndLine<span class="token punctuation">,</span> _EndColumn<span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
  <span class="token string">&quot;Error: Division by zero at &quot;</span> <span class="token operator">+</span><span class="token keyword keyword-String">String</span> File <span class="token operator">+</span><span class="token keyword keyword-String">String</span> <span class="token string">&quot;:&quot;</span> Int2String<span class="token punctuation">(</span>StartLine<span class="token punctuation">)</span>
</pre><p>Sometimes it is desirable to allow code to be written in a file which<br>
overwrites the current location information provided by the parser. This can be<br>
done via a combination of the <code>#LineMarker</code> sort and the <code>--bison-file</code> flag to<br>
the parser generator. If you declare a production of sort <code>#LineMarker</code> which<br>
contains a regular expression terminal, this will be treated as a<br>
<strong>line marker</strong> by the bison parser. The user will then be expected to provide<br>
an implementation of the parser for the line marker in C. The function expected<br>
by the parser has the signature <code>void line_marker(char *, yyscan_t)</code>, where<br>
<code>yyscan_t</code> is a<br>
<a href="https://westes.github.io/flex/manual/Reentrant.html">reentrant flex scanner</a>.<br>
The string value of the line marker token as specified by your regular<br>
expression can be found in the first parameter of the function, and you can<br>
set the line number used by the scanner using <code>yyset_lineno(int, yyscan_t)</code>. If<br>
you declare the variable <code>extern char *filename</code>, you can also set the current<br>
file name by writing a malloc&apos;d, zero-terminated string to that variable.</p>
<h2>Unparsing</h2>
<p>A number of factors go into how terms are unparsed in K. Here we describe some<br>
of the features the user can use to control how unparsing happens.</p>
<h3 class="mume-header" id="brackets">Brackets</h3>

<p>One of the phases that the unparser goes through is to insert productions<br>
tagged with the <code>bracket</code> attribute where it believes this is necessary<br>
in order to create a correct string that will be parsed back into the original<br>
AST. The most common case of this is in expression grammars. For example,<br>
consider the following grammar:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span>
             <span class="token operator">|</span> Exp <span class="token string">&quot;*&quot;</span> Exp
             &gt; Exp <span class="token string">&quot;+&quot;</span> Exp
</pre><p>Here we have declared that expressions can contain integer addition and<br>
multiplication, and that multiplication binds tighter than addition. As a<br>
result, when writing a program, if we want to write an expression that first<br>
applies addition, then multiplication, we must use brackets: <code>(1 + 2) * 3</code>.<br>
Similarly, if we have such an AST, we must <strong>insert</strong> brackets into the AST<br>
in order to faithfully unparse the term in a manner that will be parsed back<br>
into the same ast, because if we do not, we end up unparsing the term as<br>
<code>1 + 2 * 3</code>, which will be parsed back as <code>1 + (2 * 3)</code> because of the priority<br>
declaration in the grammar.</p>
<p>You can control how the unparser will insert such brackets by adding a<br>
production with the <code>bracket</code> attribute and the correct sort. For example, if,<br>
instead of parentheses, you want to use curly braces, you could write:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;{&quot;</span> Exp <span class="token string">&quot;}&quot;</span> <span class="token punctuation">[</span><span class="token class-name">bracket</span><span class="token punctuation">]</span>
</pre><p>This would signal to the unparser how brackets should look for terms of sort<br>
<code>Exp</code>, and it will use this syntax when unparsing terms of sort <code>Exp</code>.</p>
<h3 class="mume-header" id="commutative-collections">Commutative collections</h3>

<p>One thing that K will do (unless you pass the <code>--no-sort-collections</code> flag to<br>
krun) is to sort associative, commutative collections (such as <code>Set</code> and <code>Map</code>)<br>
alphanumerically. For example, if I have a collection whose keys are sort <code>Id</code><br>
and they have the values a, b, c, and d, then unparsing will always print<br>
first the key a, then b, then c, then d, because this is the alphabetic order<br>
of these keys when unparsed.</p>
<p>Furthermore, K will sort numeric keys numerically. For example, if I have a<br>
collection whose keys are <code>1, 2, 5, 10, 30</code>, it will first display 1, then 2,<br>
then 5, then 10, then 30, because it will sort these keys numerically. Note<br>
that this is different than an alphabetic sort, which would sort them as<br>
<code>1, 10, 2, 30, 5</code>. We believe the former is more intuitive to users.</p>
<h3 class="mume-header" id="substitution-filtering">Substitution filtering</h3>

<p>K will remove substitution terms corresponding to anonymous variables when<br>
using the <code>--pattern</code> flag if those anonymous variables provide no information<br>
about the named variables in your serach pattern. You can disable this behavior<br>
by passing <code>--no-substitution-filtering</code> to krun. When this flag is not passed,<br>
and you are using the Haskell backend, any equality in a substitution (ie, an<br>
<code>#Equals</code> under an <code>#And</code> under an <code>#Or</code>), will be hidden from the user if the<br>
left hand side is a variable that was anonymous in the <code>--pattern</code> passed by<br>
the user, unless that variable appears elsewhere in the substitution. If you<br>
want to see that variable in the substitution, you can either disable this<br>
filtering, or give that variable a name in the original search pattern.</p>
<h3 class="mume-header" id="variable-alpha-renaming">Variable alpha renaming</h3>

<p>K will automatically rename variables that appear in the output configuration.<br>
Similar to commutative collections, this is done to <strong>normalize</strong> the resulting<br>
configuration so that equivalent configurations will be printed identically<br>
regardless of how they happen to be reached. This pass can be disabled by<br>
passing <code>--no-alpha-renaming</code> to krun.</p>
<h3 class="mume-header" id="macro-expansion">Macro expansion</h3>

<p>K will apply macros in reverse on the output configuration if the macro was<br>
created with the <code>alias</code> or <code>alias-rec</code> attribute. See the section on macro<br>
expansion for more details.</p>
<h3 class="mume-header" id="formatting">Formatting</h3>

<h4 class="mume-header" id="format-attribute"><code>format</code> attribute</h4>

<p>K allows you to control how terms are unparsed using the <code>format</code> attribute.<br>
By default, a domain value is unparsed by printing its string value verbatim,<br>
and an application pattern is unparsed by printing its terminals and children<br>
in the sequence implied by its concrete syntax, separated by spaces. However,<br>
K gives you complete control over how you want to unparse the symbol.</p>
<p>A format attribute is a string containing zero or more escape sequences that<br>
tell K how to unparse the symbol. Escape sequences begin with a &apos;%&apos; and are<br>
followed by either an integer, or a single non-digit character. Below is a<br>
list of escape sequences recognized by the formatter:</p>
<table>
<thead>
<tr>
<th>Escape Sequence</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>n</td>
<td>Insert &apos;\n&apos; followed by the current indentation level</td>
</tr>
<tr>
<td>i</td>
<td>Increase the current indentation level by 1</td>
</tr>
<tr>
<td>d</td>
<td>Decrease the current indentation level by 1</td>
</tr>
<tr>
<td>c</td>
<td>Move to the next color in the list of colors for this production</td>
</tr>
<tr>
<td>r</td>
<td>Reset color to the default foreground color for the terminal (See below for more information on how colors work)</td>
</tr>
<tr>
<td>an integer</td>
<td>Print a terminal or nonterminal from the production (See below for more information)</td>
</tr>
<tr>
<td>any other char</td>
<td>Print that character verbatim</td>
</tr>
</tbody>
</table>
<h4 class="mume-header" id="using-the-integer-escape-sequence">Using the integer escape sequence</h4>

<p>In the integer escape sequence <code>%a</code>, the integer <code>a</code> is treated as a 1-based<br>
index into the terminals and nonterminals of the production.</p>
<ul>
<li>
<p>If the offset refers to a terminal, move to the next color in the list of<br>
colors for this production, print the value of that terminal, then reset the<br>
color to the default foreground color for the terminal.</p>
</li>
<li>
<p>If the offset refers to a regular expression terminal, it is an error.</p>
</li>
<li>
<p>If the offset refers to a nonterminal, print the unparsed representation of<br>
the corresponding child of the current term.</p>
</li>
</ul>
<h4 class="mume-header" id="color-and-colors-attributes"><code>color</code> and <code>colors</code> attributes</h4>

<p>K allows you to take advantage of ANSI terminal codes for foreground color<br>
in order to colorize output pretty-printed by the unparser. This is controlled<br>
via the <code>color</code> and <code>colors</code> attributes of productions. These attributes<br>
combine with the <code>format</code> attribute to control how a term is colorized.</p>
<p>The first thing to understand about how colorization works is that the <code>color</code><br>
and <code>colors</code> attributes are used to construct a <strong>list</strong> of colors associated<br>
with each production, and the format attribute then uses that list to choose<br>
the color for each part of the production. For more information on how the<br>
format attribute chooses a color from the list, see above, but essentially,<br>
each terminal or <code>%c</code> in the format attribute advances the pointer in the list<br>
by one element, and terminals and <code>%r</code> reset the current color to the default<br>
foreground color of the terminal afterwards.</p>
<p>There are two ways you can construct a list of colors associated with a<br>
production:</p>
<ul>
<li>
<p>The <code>color</code> attribute creates the entire list all with the same color, as<br>
specified by the value of the attribute. When combined with the default format<br>
attribute, this will color all the terminals in that production that color, but<br>
more advanced techniques can be used as well.</p>
</li>
<li>
<p>The <code>colors</code> attribute creates the list from a manual, comma-separated list<br>
of colors. The attribute is invalid if the length of the list is not equal to<br>
the number of terminals in the production plus the number of <code>%c</code> substrings in<br>
the <code>format</code> attribute.</p>
</li>
</ul>
<h2>Attributes Reference</h2>
<h3 class="mume-header" id="attribute-syntax-overview">Attribute Syntax Overview</h3>

<p>In K, many different syntactic categories accept an optional trailing list of<br>
keywords known as <em>attributes</em>. Attribute lists have two different syntaxes,<br>
depending on where they occur. Each attribute also has a type which describes<br>
where it may occur.</p>
<p>The first syntax is a square-bracketed (<code>[]</code>) list of words. This syntax is<br>
available for following attribute types:</p>
<ol>
<li><code>module</code> attributes - may appear immediately after the <code>module</code> keyword</li>
<li><code>sort</code> attributes - may appear immediately after a sort declaration</li>
<li><code>production</code> attributes - may appear immediately after a BNF production<br>
alternative</li>
<li><code>rule</code> attributes - may appear immediately after a rule</li>
<li><code>context</code> attributes - may appear immediately after a context or context<br>
alias</li>
<li><code>context alias</code> attributes - may appear immediately after a context alias</li>
<li><code>claim</code> attributes - may appear immediately after a claim</li>
</ol>
<p>The second syntax is the XML attribute syntax, i.e., a space delemited list of<br>
key-and-quoted-value pairs appearing inside the start tag of an XML element:<br>
<code>&lt;element key1=&quot;value&quot; key2=&quot;value2&quot; ... &gt; &lt;/element&gt;</code>. This syntax is<br>
available for the following attribute types:</p>
<ol>
<li><code>cell</code> attributes - may appear inside of the cell start tag in<br>
configuration declarations</li>
</ol>
<p>Unrecognized attributes are reported as an error. When we talk about<br>
the <em>type</em> of an attribute, we mean a syntactic category to which an attribute<br>
can be attached where the attribute has some semantic effect.</p>
<h3 class="mume-header" id="attribute-index">Attribute Index</h3>

<p>We now provide an index of available attributes organized alphabetically with a<br>
brief description of each. Note that the same attribute may appear in the index<br>
multiple times to indicate its effect in different contexts or with/without<br>
arguments. A legend describing how to interpret the index follows.</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Backend</th>
<th>Reference</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>alias-rec</code></td>
<td>prod</td>
<td>all</td>
<td><a href="#macros-and-aliases">Macros and Aliases</a></td>
</tr>
<tr>
<td><code>alias</code></td>
<td>prod</td>
<td>all</td>
<td><a href="#macros-and-aliases">Macros and Aliases</a></td>
</tr>
<tr>
<td><code>all-path</code></td>
<td>claim</td>
<td>haskell</td>
<td><a href="#all-path-and-one-path-attributes-to-distinguish-reachability-claims"><code>all-path</code> and <code>one-path</code> attributes to distinguish reachability claims</a></td>
</tr>
<tr>
<td><code>anywhere</code></td>
<td>rule</td>
<td>all</td>
<td><a href="#anywhere-rules"><code>anywhere</code> rules</a></td>
</tr>
<tr>
<td><code>applyPriority(_)</code></td>
<td>prod</td>
<td>all</td>
<td><a href="#symbol-priority-and-associativity">Symbol priority and associativity</a></td>
</tr>
<tr>
<td><code>avoid</code></td>
<td>prod</td>
<td>all</td>
<td><a href="#symbol-priority-and-associativity">Symbol priority and associativity</a></td>
</tr>
<tr>
<td><code>binder</code></td>
<td>prod</td>
<td>all</td>
<td>No reference yet.</td>
</tr>
<tr>
<td><code>bracket</code></td>
<td>prod</td>
<td>all</td>
<td><a href="#parametric-productions-and-bracket-attributes">Parametric productions and <code>bracket</code> attributes</a></td>
</tr>
<tr>
<td><code>color(_)</code></td>
<td>prod</td>
<td>all</td>
<td><a href="#color-and-colors-attributes"><code>color</code> and <code>colors</code> attributes</a></td>
</tr>
<tr>
<td><code>colors(_)</code></td>
<td>prod</td>
<td>all</td>
<td><a href="#color-and-colors-attributes"><code>color</code> and <code>colors</code> attributes</a></td>
</tr>
<tr>
<td><code>concrete</code></td>
<td>mod</td>
<td>llvm</td>
<td><a href="#symbolic-and-concrete-attribute"><code>symbolic</code> and <code>concrete</code> attribute</a></td>
</tr>
<tr>
<td><code>concrete(_)</code></td>
<td>rule</td>
<td>haskell</td>
<td><a href="#concrete-and-symbolic-attributes-haskell-backend"><code>concrete</code> and <code>symbolic</code> attributes (Haskell backend)</a></td>
</tr>
<tr>
<td><code>concrete</code></td>
<td>rule</td>
<td>haskell</td>
<td><a href="#concrete-and-symbolic-attributes-haskell-backend"><code>concrete</code> and <code>symbolic</code> attributes (Haskell backend)</a></td>
</tr>
<tr>
<td><code>context(_)</code></td>
<td>alias</td>
<td>all</td>
<td><a href="#context-aliases">Context aliases</a></td>
</tr>
<tr>
<td><code>deprecated</code></td>
<td>prod</td>
<td>all</td>
<td><a href="#deprecated-attribute"><code>deprecated</code> attribute</a></td>
</tr>
<tr>
<td><code>exit = &quot;&quot;</code></td>
<td>cell</td>
<td>all</td>
<td><a href="#exit-attribute"><code>exit</code> attribute</a></td>
</tr>
<tr>
<td><code>format</code></td>
<td>prod</td>
<td>all</td>
<td><a href="#format-attribute"><code>format</code> attribute</a></td>
</tr>
<tr>
<td><code>freshGenerator</code></td>
<td>prod</td>
<td>all</td>
<td><a href="#freshgenerator-attribute"><code>freshGenerator</code> attribute</a></td>
</tr>
<tr>
<td><code>function</code></td>
<td>prod</td>
<td>all</td>
<td><a href="#function-and-total-attributes"><code>function</code> and <code>total</code> attributes</a></td>
</tr>
<tr>
<td><code>group(_)</code></td>
<td>all</td>
<td>all</td>
<td><a href="#symbol-priority-and-associativity">Symbol priority and associativity</a></td>
</tr>
<tr>
<td><code>hook(_)</code></td>
<td>prod</td>
<td>all</td>
<td>No reference yet</td>
</tr>
<tr>
<td><code>hybrid(_)</code></td>
<td>prod</td>
<td>all</td>
<td><a href="#hybrid-attribute"><code>hybrid</code> attribute</a></td>
</tr>
<tr>
<td><code>hybrid</code></td>
<td>prod</td>
<td>all</td>
<td><a href="#hybrid-attribute"><code>hybrid</code> attribute</a></td>
</tr>
<tr>
<td><code>klabel(_)</code></td>
<td>prod</td>
<td>all</td>
<td><a href="#klabel_-and-symbol-attributes"><code>klabel(_)</code> and <code>symbol</code> attributes</a></td>
</tr>
<tr>
<td><code>left</code></td>
<td>prod</td>
<td>all</td>
<td><a href="#symbol-priority-and-associativity">Symbol priority and associativity</a></td>
</tr>
<tr>
<td><code>locations</code></td>
<td>sort</td>
<td>all</td>
<td><a href="#location-information">Location Information</a></td>
</tr>
<tr>
<td><code>macro-rec</code></td>
<td>prod</td>
<td>all</td>
<td><a href="#macros-and-aliases">Macros and Aliases</a></td>
</tr>
<tr>
<td><code>macro</code></td>
<td>prod</td>
<td>all</td>
<td><a href="#macros-and-aliases">Macros and Aliases</a></td>
</tr>
<tr>
<td><code>memo</code></td>
<td>rule</td>
<td>haskell</td>
<td><a href="#the-memo-attribute">The <code>memo</code> attribute</a></td>
</tr>
<tr>
<td><code>multiplicity = &quot;_&quot;</code></td>
<td>cell</td>
<td>all</td>
<td><a href="#collection-cells-multiplicity-and-type-attributes">Collection Cells: <code>multiplicity</code> and <code>type</code> attributes</a></td>
</tr>
<tr>
<td><code>non-assoc</code></td>
<td>prod</td>
<td>all</td>
<td><a href="#symbol-priority-and-associativity">Symbol priority and associativity</a></td>
</tr>
<tr>
<td><code>one-path</code></td>
<td>claim</td>
<td>haskell</td>
<td><a href="#all-path-and-one-path-attributes-to-distinguish-reachability-claims"><code>all-path</code> and <code>one-path</code> attributes to distinguish reachability claims</a></td>
</tr>
<tr>
<td><code>overload(_)</code></td>
<td>prod</td>
<td>all</td>
<td><a href="#overload-attribute"><code>overload(_)</code> attribute</a></td>
</tr>
<tr>
<td><code>owise</code></td>
<td>rule</td>
<td>all</td>
<td><a href="#owise-and-priority-attributes"><code>owise</code> and <code>priority</code> attributes</a></td>
</tr>
<tr>
<td><code>prec(_)</code></td>
<td>token</td>
<td>all</td>
<td><a href="#prec-attribute"><code>prec</code> attribute</a></td>
</tr>
<tr>
<td><code>prefer</code></td>
<td>prod</td>
<td>all</td>
<td><a href="#symbol-priority-and-associativity">Symbol priority and associativity</a></td>
</tr>
<tr>
<td><code>priority(_)</code></td>
<td>rule</td>
<td>all</td>
<td><a href="#owise-and-priority-attributes"><code>owise</code> and <code>priority</code> attributes</a></td>
</tr>
<tr>
<td><code>private</code></td>
<td>mod</td>
<td>all</td>
<td><a href="#private-attribute"><code>private</code> attribute</a></td>
</tr>
<tr>
<td><code>private</code></td>
<td>prod</td>
<td>all</td>
<td><a href="#public-and-private-attribute"><code>public</code> and <code>private</code> attribute</a></td>
</tr>
<tr>
<td><code>public</code></td>
<td>mod</td>
<td>all</td>
<td>No reference yet.</td>
</tr>
<tr>
<td><code>public</code></td>
<td>prod</td>
<td>all</td>
<td><a href="#public-and-private-attribute"><code>public</code> and <code>private</code> attribute</a></td>
</tr>
<tr>
<td><code>result(_)</code></td>
<td>ctxt</td>
<td>all</td>
<td><a href="#result-attribute"><code>result</code> attribute</a></td>
</tr>
<tr>
<td><code>result(_)</code></td>
<td>rule</td>
<td>all</td>
<td><a href="#result-attribute"><code>result</code> attribute</a></td>
</tr>
<tr>
<td><code>right</code></td>
<td>prod</td>
<td>all</td>
<td><a href="#symbol-priority-and-associativity">Symbol priority and associativity</a></td>
</tr>
<tr>
<td><code>seqstrict(_)</code></td>
<td>prod</td>
<td>all</td>
<td><a href="#strict-and-seqstrict-attributes"><code>strict</code> and <code>seqstrict</code> attributes</a></td>
</tr>
<tr>
<td><code>seqstrict</code></td>
<td>prod</td>
<td>all</td>
<td><a href="#strict-and-seqstrict-attributes"><code>strict</code> and <code>seqstrict</code> attributes</a></td>
</tr>
<tr>
<td><code>simplification</code></td>
<td>rule</td>
<td>haskell</td>
<td><a href="#simplification-attribute-haskell-backend"><code>simplification</code> attribute (Haskell backend)</a></td>
</tr>
<tr>
<td><code>simplification(_)</code></td>
<td>rule</td>
<td>haskell</td>
<td><a href="#simplification-attribute-haskell-backend"><code>simplification</code> attribute (Haskell backend)</a></td>
</tr>
<tr>
<td><code>smt-hook(_)</code></td>
<td>prod</td>
<td>haskell</td>
<td><a href="#smt-translation">SMT Translation</a></td>
</tr>
<tr>
<td><code>smtlib(_)</code></td>
<td>prod</td>
<td>haskell</td>
<td><a href="#smt-translation">SMT Translation</a></td>
</tr>
<tr>
<td><code>smt-lemma</code></td>
<td>rule</td>
<td>haskell</td>
<td><a href="#smt-translation">SMT Translation</a></td>
</tr>
<tr>
<td><code>strict</code></td>
<td>prod</td>
<td>all</td>
<td><a href="#strict-and-seqstrict-attributes"><code>strict</code> and <code>seqstrict</code> attributes</a></td>
</tr>
<tr>
<td><code>strict(_)</code></td>
<td>prod</td>
<td>all</td>
<td><a href="#strict-and-seqstrict-attributes"><code>strict</code> and <code>seqstrict</code> attributes</a></td>
</tr>
<tr>
<td><code>symbolic</code></td>
<td>mod</td>
<td>haskell</td>
<td><a href="#symbolic-and-concrete-attribute"><code>symbolic</code> and <code>concrete</code> attribute</a></td>
</tr>
<tr>
<td><code>symbolic</code></td>
<td>rule</td>
<td>haskell</td>
<td><a href="#concrete-and-symbolic-attributes-haskell-backend"><code>concrete</code> and <code>symbolic</code> attributes (Haskell backend)</a></td>
</tr>
<tr>
<td><code>symbolic(_)</code></td>
<td>rule</td>
<td>haskell</td>
<td><a href="#concrete-and-symbolic-attributes-haskell-backend"><code>concrete</code> and <code>symbolic</code> attributes (Haskell backend)</a></td>
</tr>
<tr>
<td><code>symbol</code></td>
<td>prod</td>
<td>all</td>
<td><a href="#klabel_-and-symbol-attributes"><code>klabel(_)</code> and <code>symbol</code> attributes</a></td>
</tr>
<tr>
<td><code>terminator-symbol(_)</code></td>
<td>prod</td>
<td>all</td>
<td><a href="file:///home/runner/work/k/k/gh-pages/docs/..."><code>klabel(_)</code> and <code>symbol</code> attributes</a></td>
</tr>
<tr>
<td><code>token</code></td>
<td>prod</td>
<td>all</td>
<td><a href="#token-attribute"><code>token</code> attribute</a></td>
</tr>
<tr>
<td><code>token</code></td>
<td>sort</td>
<td>all</td>
<td><a href="#token-attribute"><code>token</code> attribute</a></td>
</tr>
<tr>
<td><code>total</code></td>
<td>prod</td>
<td>all</td>
<td><a href="#function-and-total-attributes"><code>function</code> and <code>total</code> attributes</a></td>
</tr>
<tr>
<td><code>trusted</code></td>
<td>claim</td>
<td>haskell</td>
<td><a href="#trusted-claims"><code>trusted</code> attribute</a></td>
</tr>
<tr>
<td><code>type = &quot;_&quot;</code></td>
<td>cell</td>
<td>all</td>
<td><a href="#collection-cells-multiplicity-and-type-attributes">Collection Cells: <code>multiplicity</code> and <code>type</code> attributes</a></td>
</tr>
<tr>
<td><code>unboundVariables(_)</code></td>
<td>rule</td>
<td>all</td>
<td><a href="#the-unboundvariables-attribute">The <code>unboundVariables</code> attribute</a></td>
</tr>
<tr>
<td><code>unused</code></td>
<td>prod</td>
<td>all</td>
<td><a href="#unused-attribute"><code>unused</code> attribute</a></td>
</tr>
<tr>
<td><code>concrete</code></td>
<td>mod</td>
<td>all</td>
<td>Specify that this module should only be included in concrete backends (LLVM backend).</td>
</tr>
<tr>
<td><code>symbolic</code></td>
<td>mod</td>
<td>all</td>
<td>Specify that this module should only be included in symbolic backends (Haskell backend).</td>
</tr>
<tr>
<td><code>stream = &quot;_&quot;</code></td>
<td>cell</td>
<td>all</td>
<td>Specify that this cell should be hooked up to a stream, either <code>stdin</code>, <code>stdout</code>, or <code>stderr</code>.</td>
</tr>
</tbody>
</table>
<h3 class="mume-header" id="internal-attribute-index">Internal Attribute Index</h3>

<p>Some attributes should not generally appear in user code, except in some<br>
unusual or complex examples. Such attributes are typically generated by the<br>
compiler and used internally. We list these attributes below as a reference for<br>
interested readers:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Backend</th>
<th>Reference</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>assoc</code></td>
<td>prod</td>
<td>all</td>
<td><a href="#assoc-comm-idem-and-unit-attributes"><code>assoc</code>, <code>comm</code>, <code>idem</code> and <code>unit</code> attributes</a></td>
</tr>
<tr>
<td><code>comm</code></td>
<td>prod</td>
<td>all</td>
<td><a href="#assoc-comm-idem-and-unit-attributes"><code>assoc</code>, <code>comm</code>, <code>idem</code> and <code>unit</code> attributes</a></td>
</tr>
<tr>
<td><code>digest</code></td>
<td>mod</td>
<td>all</td>
<td>Contains the hash of the textual contents of the module.</td>
</tr>
<tr>
<td><code>idem</code></td>
<td>prod</td>
<td>all</td>
<td><a href="#assoc-comm-idem-and-unit-attributes"><code>assoc</code>, <code>comm</code>, <code>idem</code> and <code>unit</code> attributes</a></td>
</tr>
<tr>
<td><code>unit</code></td>
<td>prod</td>
<td>all</td>
<td><a href="#assoc-comm-idem-and-unit-attributes"><code>assoc</code>, <code>comm</code>, <code>idem</code> and <code>unit</code> attributes</a></td>
</tr>
<tr>
<td><code>userList</code></td>
<td>prod</td>
<td>all</td>
<td>Identifies the desugared form of <code>Lst ::= List{Elm,&quot;delim&quot;}</code></td>
</tr>
<tr>
<td><code>predicate</code></td>
<td>prod</td>
<td>all</td>
<td>Specifies the sort of a predicate label</td>
</tr>
<tr>
<td><code>element</code></td>
<td>prod</td>
<td>all</td>
<td>Specifies the label of the elements in a list</td>
</tr>
<tr>
<td><code>bracketLabel</code></td>
<td>prod</td>
<td>all</td>
<td>Keep track of the label of a bracket production since it can&apos;t have a klabel</td>
</tr>
<tr>
<td><code>injective</code></td>
<td>prod</td>
<td>all</td>
<td>Label a given production as injective (unique output for each input)</td>
</tr>
<tr>
<td><code>internal</code></td>
<td>prod</td>
<td>all</td>
<td>Production is reserved for internal use by the compiler</td>
</tr>
<tr>
<td><code>cool</code></td>
<td>rule</td>
<td>all</td>
<td><a href="#strict-and-seqstrict-attributes"><code>strict</code> and <code>seqstrict</code> attributes</a></td>
</tr>
<tr>
<td><code>heat</code></td>
<td>rule</td>
<td>all</td>
<td><a href="#strict-and-seqstrict-attributes"><code>strict</code> and <code>seqstrict</code> attributes</a></td>
</tr>
</tbody>
</table>
<h3 class="mume-header" id="index-legend">Index Legend</h3>

<ul>
<li>
<p><code>Name</code> - the attribute&apos;s name (optionally followed by an underscore <code>_</code> to indicate the attribute takes arguments)</p>
</li>
<li>
<p><code>Type</code> - the syntactic categories where this attribute is <em>not</em> ignored;<br>
the possible values are the types mentioned above or shorthands:</p>
<ol>
<li><code>all</code> - short for any type except <code>cell</code></li>
<li><code>mod</code> - short for <code>module</code></li>
<li><code>sort</code></li>
<li><code>prod</code> - short for <code>production</code></li>
<li><code>rule</code></li>
<li><code>ctxt</code> - short for <code>context</code> or <code>context alias</code></li>
<li><code>claim</code></li>
<li><code>cell</code></li>
</ol>
</li>
<li>
<p><code>Backend</code> - the backends that do <em>not</em> ignore this attribute; possible values:</p>
<ol>
<li><code>all</code> - all backends</li>
<li><code>llvm</code> - the LLVM backend</li>
<li><code>haskell</code> - the Haskell backend</li>
</ol>
</li>
<li>
<p><code>Effect</code> - the attribute&apos;s effect (when it applies)</p>
</li>
</ul>
<h2>Pending Documentation</h2>
<p>Backend features not yet given documentation:</p>
<ul>
<li>Parser of KORE terms and definitions</li>
<li>Term representation of K terms</li>
<li>Hooked sorts and symbols</li>
<li>Substituting a substitution into the RHS of a rule
<ul>
<li>domain values</li>
<li>functions</li>
<li>variables</li>
<li>symbols</li>
<li>polymorphism</li>
<li>hooks</li>
<li>injection compaction</li>
<li>overload compaction</li>
</ul>
</li>
<li>Pattern Matching / Unification of subject and LHS of rule
<ul>
<li>domain values</li>
<li>symbols</li>
<li>side conditions</li>
<li>and/or patterns</li>
<li>list patterns</li>
<li>nonlinear variables</li>
<li>map/set patterns
<ul>
<li>deterministic</li>
<li>nondeterministic</li>
</ul>
</li>
<li>modulo injections</li>
<li>modulo overloads</li>
</ul>
</li>
<li>Stepping
<ul>
<li>initialization</li>
<li>termination</li>
</ul>
</li>
<li>Print kore terms</li>
<li>Equality/comparison of terms</li>
<li>Owise rules</li>
<li>Strategy #STUCK axiom</li>
<li>User substitution
<ul>
<li>binders</li>
<li>kvar</li>
</ul>
</li>
</ul>
<p>To get a complete list of hooks supported by K, you can run:</p>
<pre data-role="codeBlock" data-info class="language-"><code>grep -P -R &quot;(?&lt;=[^-])hook\([^)]*\)&quot; k-distribution/include/kframework/builtin/ \
     --include &quot;*.k&quot; -ho | \
sed &apos;s/hook(//&apos; | sed &apos;s/)//&apos; | sort | uniq | grep -v org.kframework
</code></pre><p>All of these hooks will also eventually need documentation.</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>Except for in a very limited number of special cases from the<br>
K standard library. <a href="#fnref1" class="footnote-backref">&#x21A9;&#xFE0E;</a></p>
</li>
<li id="fn2" class="footnote-item"><p>The <a href="https://maude.lcc.uma.es/maude-manual/maude-manualch3.html#x15-310003.6">Maude documentation</a><br>
has an example in a context that&apos;s somewhat similar to K; discussion of<br>
<em>ad-hoc</em> overloading is not relevant. <a href="#fnref2" class="footnote-backref">&#x21A9;&#xFE0E;</a></p>
</li>
</ol>
</section>
</div></div><div id="ebook-heading-k-cheat-sheet" ebook-toc-level-1 heading="K Cheat Sheet"><div><h1>K Cheat Sheet</h1>
<p>This is a quick reference of the most commonly used K tools.</p>
<pre data-role="codeBlock" data-info class="language-"><code>kompile (--gen-bison-parser)? {file}                : generate parser, optionally with ahead of time
krun {file}                                         : interpret file
krun -cPGM=&apos;{string}&apos;                               : interpret string
kast --output (kore | kast) (-e|{file})             : parse expression or file
kompile (--enable-search --backend haskell)? {file} : generate parser, enabling non-deterministic run
krun (--search-all)? {file}                         : interpret file, evaluating non-deterministic runs as well
foo-kompiled/parser_PGM {file}                      : ahead of time parse
kompile (--main-module)? (--syntax-module)? {file}  : generate parser for {file}.k {file}-syntax.k, explicitly state main modules
kparse &lt;file&gt; | kore-print -                        : parse and unparse a file
kompile {file} --enable-llvm-debug                  : generate debuggable output for {file}.k
krun {file} --debugger                              : debug K code
kprove {file}                                       : Verify specs in {file}
</code></pre><p>During GDB debugging session (see <a href="https://lldb.llvm.org/use/map.html">here</a> for<br>
LLDB breakpoint syntax):</p>
<pre data-role="codeBlock" data-info class="language-"><code>break {file}:{linenum}                              : add a breakpoint to {file}&apos;s {linenum} numbered line
k match {module}.{label} subject                    : investigate matching
</code></pre></div></div><div id="ebook-heading-k-tool-reference" ebook-toc-level-1 heading="K Tool Reference"><div><h1>K Tools</h1>
<p>Here we document how to use some of the most commonly used K tools.</p>
<h2>Minimizing Output</h2>
<p>When one is working with <code>kore-repl</code> or the prover in general and looking at<br>
specific configurations using config, sometimes the configurations can be huge.</p>
<p>One tool to help print configuration compactly is the <code>pyk print</code> utility:</p>
<pre data-role="codeBlock" data-info="sh" class="language-bash">pyk print
</pre><p>We are going to use <code>--minimize</code> option (which is actually used automatically<br>
when printing with pyk). This will filter out many uninteresting cells for the<br>
current config and make the result more compact.</p>
<p>Then, when invoking the prover, you can minimize your output by piping it into<br>
the <code>pyk print ...</code> facility with arguments for controlling the output:</p>
<pre data-role="codeBlock" data-info="sh" class="language-bash">kprove --output json --definition DEFN <span class="token punctuation">..</span>. <span class="token punctuation">\</span>
    <span class="token operator">|</span> jq .term                             <span class="token punctuation">\</span>
    <span class="token operator">|</span> pyk print DEFN /dev/stdin --omit-labels <span class="token punctuation">..</span>. --keep-labels <span class="token punctuation">..</span>.
</pre><p>You can also use this in the <code>kore-repl</code> more easily, by making a help script.<br>
In your current directory, save a new script <code>pykprint.sh</code>:</p>
<pre data-role="codeBlock" data-info="sh" class="language-bash"><span class="token shebang important">#!/bin/bash</span>

kast --input kore --output json --definition <span class="token variable">$1</span> /dev/stdin <span class="token punctuation">\</span>
    <span class="token operator">|</span> jq .term                                             <span class="token punctuation">\</span>
    <span class="token operator">|</span> pyk print <span class="token variable">$1</span> /dev/stdin --omit-labels <span class="token variable">$2</span>
</pre><p>Now call <code>config | bash pykprint.sh DEFN</code> in Kore REPL to make the output<br>
smaller.</p>
<p>The options you have to control the output are as follows:</p>
<ul>
<li><code>--no-minimize</code>: do not remove uninteresting cells.</li>
<li><code>--omit-cells</code>: remove the selected cells from the output.</li>
<li><code>--keep-cells</code>: keep only the selected cells in the output.</li>
</ul>
<p>Note: Make sure that there is no whitespace around , in the omit list,<br>
otherwise you&apos;ll get an error (, is a list separator, so this<br>
requirement is strict).</p>
<h2>Debugging</h2>
<p>The LLVM Backend has support for integration with GDB. You can run the debugger<br>
on a particular program by passing the <code>--debugger</code> flag to krun, or by<br>
invoking the llvm backend interpreter directly. Below we provide a simple<br>
tutorial to explain some of the basic commands supported by the LLVM backend.</p>
<h3 class="mume-header" id="lldb-support">LLDB Support</h3>

<p>GDB is not well-supported on macOS, particularly on newer OS versions and Apple<br>
Silicon ARM hardware. Consequently, if the <code>--debugger</code> option is passed to krun<br>
on macOS, LLDB[^1] is launched instead of GDB. However, the K-specific debugger<br>
scripts that GDB uses have not been ported to LLDB yet, and so the instructions<br>
in the rest of this section will not work.</p>
<h3 class="mume-header" id="the-k-definition">The K Definition</h3>

<p>Here is a sample K definition we will use to demonstrate debugging<br>
capabilities:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> TEST
  <span class="token keyword keyword-imports">imports</span> INT

  <span class="token keyword keyword-configuration">configuration</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> foo<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">[</span>test<span class="token punctuation">]</span><span class="token punctuation">:</span> I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">=&gt;</span> I <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span> <span class="token keyword keyword-requires">requires</span> I &lt;<span class="token keyword keyword-Int">Int</span> <span class="token number">10</span>

  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> foo<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> foo<span class="token punctuation">(</span>I<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token number">0</span> <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> I

<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>You should compile this definition with <code>--backend llvm --enable-llvm-debug</code> to<br>
use the debugger most effectively.</p>
<h3 class="mume-header" id="stepping">Stepping</h3>

<p><strong>Important:</strong> When you first run <code>krun</code> with option <code>--debugger</code>, GDB / LLDB<br>
will instruct you on how to modify <code>~/.gdbinit</code> or <code>~/.lldbinit</code> to enable<br>
printing abstract syntax of K terms in the debugger. If you do not perform this<br>
step, you can still use all the other features, but K terms will be printed as<br>
their raw address in memory.</p>
<p>GDB will need the kompiled interpreter in its safe path in order to access the<br>
pretty printing python script within it. A good way to do this would be to pick<br>
a minimum top-level path that covers all of your kompiled semantics (ie. <code>set auto-load safe-path ~/k-semantics</code>). LLDB has slightly different security<br>
policies that do not require fully-arbitrary code execution.</p>
<p>This section uses GDB syntax to demonstrate the debugging features. Please<br>
refer to the <a href="https://lldb.llvm.org/use/map.html">GDB to LLDB command map</a> on<br>
macOS.</p>
<p>You can break before every step of execution is taken by setting a breakpoint<br>
on the <code>k_step</code> function.</p>
<pre data-role="codeBlock" data-info class="language-"><code>(gdb) break definition.kore:k_step
Breakpoint 1 at 0x25e340
(gdb) run
Breakpoint 1, 0x000000000025e340 in step (subject=`&lt;generatedTop&gt;{}`(`&lt;k&gt;{}`(`kseq{}`(`inj{Int{}, KItem{}}`(#token(&quot;0&quot;, &quot;Int&quot;)),dotk{}(.KList))),`&lt;generatedCounter&gt;{}`(#token(&quot;0&quot;, &quot;Int&quot;))))
(gdb) continue
Continuing.

Breakpoint 1, 0x000000000025e340 in step (subject=`&lt;generatedTop&gt;{}`(`&lt;k&gt;{}`(`kseq{}`(`inj{Int{}, KItem{}}`(#token(&quot;1&quot;, &quot;Int&quot;)),dotk{}(.KList))),`&lt;generatedCounter&gt;{}`(#token(&quot;0&quot;, &quot;Int&quot;))))
(gdb) continue 2
Will ignore next crossing of breakpoint 1.  Continuing.

Breakpoint 1, 0x000000000025e340 in step (subject=`&lt;generatedTop&gt;{}`(`&lt;k&gt;{}`(`kseq{}`(`inj{Int{}, KItem{}}`(#token(&quot;3&quot;, &quot;Int&quot;)),dotk{}(.KList))),`&lt;generatedCounter&gt;{}`(#token(&quot;0&quot;, &quot;Int&quot;))))
(gdb)
</code></pre><h3 class="mume-header" id="breaking-on-a-specific-rule">Breaking on a specific rule</h3>

<p>You can break when a rule is applied by giving the rule a rule label. If the<br>
module name is TEST and the rule label is test, you can break when the rule<br>
applies by setting a breakpoint on the <code>TEST.test.rhs</code> function:</p>
<pre data-role="codeBlock" data-info class="language-"><code>(gdb) break TEST.test.rhs
Breakpoint 1 at 0x25e250: file /home/dwightguth/test/./test.k, line 4.
(gdb) run
Breakpoint 1, TEST.test.rhs (VarDotVar0=`&lt;generatedCounter&gt;{}`(#token(&quot;0&quot;, &quot;Int&quot;)), VarDotVar1=dotk{}(.KList), VarI=#token(&quot;0&quot;, &quot;Int&quot;)) at /home/dwightguth/test/./test.k:4
4         rule [test]: I:Int =&gt; I +Int 1 requires I &lt;Int 10
(gdb)
</code></pre><p>Note that the substitution associated with that rule is visible in the<br>
description of the frame.</p>
<p>You can also break when a side condition is applied using the <code>TEST.test.sc</code><br>
function:</p>
<pre data-role="codeBlock" data-info class="language-"><code>(gdb) break TEST.test.sc
Breakpoint 1 at 0x25e230: file /home/dwightguth/test/./test.k, line 4.
(gdb) run
Breakpoint 1, TEST.test.sc (VarI=#token(&quot;0&quot;, &quot;Int&quot;)) at /home/dwightguth/test/./test.k:4
4         rule [test]: I:Int =&gt; I +Int 1 requires I &lt;Int 10
(gdb)
</code></pre><p>Note that every variable used in the side condition can have its value<br>
inspected when stopped at this breakpoint, but other variables are not visible.</p>
<p>You can also break on a rule by its location:</p>
<pre data-role="codeBlock" data-info class="language-"><code>(gdb) break test.k:4
Breakpoint 1 at 0x25e230: test.k:4. (2 locations)
(gdb) run
Breakpoint 1, TEST.test.sc (VarI=#token(&quot;0&quot;, &quot;Int&quot;)) at /home/dwightguth/test/./test.k:4
4         rule [test]: I:Int =&gt; I +Int 1 requires I &lt;Int 10
(gdb) continue
Continuing.

Breakpoint 1, TEST.test.rhs (VarDotVar0=`&lt;generatedCounter&gt;{}`(#token(&quot;0&quot;, &quot;Int&quot;)), VarDotVar1=dotk{}(.KList), VarI=#token(&quot;0&quot;, &quot;Int&quot;)) at /home/dwightguth/test/./test.k:4
4         rule [test]: I:Int =&gt; I +Int 1 requires I &lt;Int 10
(gdb) continue
Continuing.

Breakpoint 1, TEST.test.sc (VarI=#token(&quot;1&quot;, &quot;Int&quot;)) at /home/dwightguth/test/./test.k:4
4         rule [test]: I:Int =&gt; I +Int 1 requires I &lt;Int 10
(gdb)
</code></pre><p>Note that this sets a breakpoint at two locations: one on the side condition<br>
and one on the right hand side. If the rule had no side condition, the first<br>
would not be set. You can also view the locations of the breakpoints and<br>
disable them individually:</p>
<pre data-role="codeBlock" data-info class="language-"><code>(gdb) info breakpoint
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   &lt;MULTIPLE&gt;
        breakpoint already hit 3 times
1.1                         y     0x000000000025e230 in TEST.test.sc at /home/dwightguth/test/./test.k:4
1.2                         y     0x000000000025e250 in TEST.test.rhs at /home/dwightguth/test/./test.k:4
(gdb) disable 1.1
(gdb) continue
Continuing.

Breakpoint 1, TEST.test.rhs (VarDotVar0=`&lt;generatedCounter&gt;{}`(#token(&quot;0&quot;, &quot;Int&quot;)), VarDotVar1=dotk{}(.KList), VarI=#token(&quot;1&quot;, &quot;Int&quot;)) at /home/dwightguth/test/./test.k:4
4         rule [test]: I:Int =&gt; I +Int 1 requires I &lt;Int 10
(gdb) continue
Continuing.

Breakpoint 1, TEST.test.rhs (VarDotVar0=`&lt;generatedCounter&gt;{}`(#token(&quot;0&quot;, &quot;Int&quot;)), VarDotVar1=dotk{}(.KList), VarI=#token(&quot;2&quot;, &quot;Int&quot;)) at /home/dwightguth/test/./test.k:4
4         rule [test]: I:Int =&gt; I +Int 1 requires I &lt;Int 10
(gdb)
</code></pre><p>Now only the breakpoint when the rule applies is enabled.</p>
<h3 class="mume-header" id="breaking-on-a-function">Breaking on a function</h3>

<p>You can also break when a particular function in your semantics is invoked:</p>
<pre data-role="codeBlock" data-info class="language-"><code>(gdb) info functions foo
All functions matching regular expression &quot;foo&quot;:

File /home/dwightguth/test/./test.k:
struct __mpz_struct *Lblfoo&apos;LParUndsRParUnds&apos;TEST&apos;UndsUnds&apos;Int(struct __mpz_struct *);
(gdb) break Lblfoo&apos;LParUndsRParUnds&apos;TEST&apos;UndsUnds&apos;Int
Breakpoint 1 at 0x25e640: file /home/dwightguth/test/./test.k, line 6.
(gdb) run
Breakpoint 1, Lblfoo&apos;LParUndsRParUnds&apos;TEST&apos;UndsUnds&apos;Int (_1=#token(&quot;1&quot;, &quot;Int&quot;)) at /home/dwightguth/test/./test.k:6
6         syntax Int ::= foo(Int) [function]
(gdb)
</code></pre><p>In this case, the variables have numbers instead of names because the names of<br>
arguments in functions in K come from rules, and we are stopped before any<br>
specific rule has applied. For example, <code>_1</code> is the first argument to the<br>
function.</p>
<p>You can also set a breakpoint in this location by setting it on the line<br>
associated with its production:</p>
<pre data-role="codeBlock" data-info class="language-"><code>(gdb) break test.k:6
Breakpoint 1 at 0x25e640: file /home/dwightguth/test/./test.k, line 6.
(gdb) run
Breakpoint 1, Lblfoo&apos;LParUndsRParUnds&apos;TEST&apos;UndsUnds&apos;Int (_1=#token(&quot;1&quot;, &quot;Int&quot;)) at /home/dwightguth/test/./test.k:6
6         syntax Int ::= foo(Int) [function]
</code></pre><p>These two syntaxes are equivalent; use whichever is easier for you.</p>
<p>You can also view the stack of function applications:</p>
<pre data-role="codeBlock" data-info class="language-"><code>(gdb) bt
#0  Lblfoo&apos;LParUndsRParUnds&apos;TEST&apos;UndsUnds&apos;Int (_1=#token(&quot;1&quot;, &quot;Int&quot;)) at /home/dwightguth/test/./test.k:6
#1  0x000000000025e5f8 in apply_rule_111 (VarDotVar0=`&lt;generatedCounter&gt;{}`(#token(&quot;0&quot;, &quot;Int&quot;)), VarDotVar1=dotk{}(.KList)) at /home/dwightguth/test/./test.k:9
#2  0x0000000000268a52 in take_steps ()
#3  0x000000000026b7b4 in main ()
(gdb)
</code></pre><p>Here we see that <code>foo</code> was invoked while applying the rule on line 9 of test.k,<br>
and we also can see the substitution of that rule. If foo was evaluated while<br>
evaluating another function, we would also be able to see the arguments of that<br>
function as well, unless the function was tail recursive, in which case no<br>
stack frame would exist once the tail call was performed.</p>
<h3 class="mume-header" id="breaking-on-a-set-of-rules-or-functions">Breaking on a set of rules or functions</h3>

<p>Using <code>rbreak &lt;regex&gt;</code> you can set breakpoints on multiple functions.</p>
<ul>
<li>
<p><code>rbreak Lbl</code> - sets a breakpoint on all non hooked <code>function</code>s</p>
</li>
<li>
<p><code>rbreak Lbl.*TEST</code> - sets a breakpoint on all <code>function</code>s from module <code>TEST</code></p>
</li>
<li>
<p><code>rbreak hook_INT</code> - sets a breakpoint on all hooks from module <code>INT</code></p>
</li>
</ul>
<h3 class="mume-header" id="other-debugger-issues">Other debugger issues</h3>

<ul>
<li><code>&lt;optimized out&gt;</code> try kompiling without <code>-O1</code>, <code>-O2</code>, or <code>-O3</code>.</li>
<li><code>(gdb) break definition.kore:break -&gt; No source file named definition.kore.</code><br>
send <code>--enable-llvm-debug</code> to kompile in order to generate debug info symbols.</li>
</ul>
<h2>Profiling your K semantics</h2>
<p>The first thing to be aware of is in order to get meaningful data,<br>
you need to build the semantics and all of its dependencies with<br>
optimizations enabled but <em>without the frame pointer elimination<br>
optimization</em>. For example, for EVM, this means rebuilding GMP, MPFR,<br>
JEMalloc, Crypto++, SECP256K1, etc with the following <code>exports</code>.</p>
<pre data-role="codeBlock" data-info="sh" class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">CFLAGS</span><span class="token operator">=</span><span class="token string">&quot;-DNDEBUG -O2 -fno-omit-frame-pointer&quot;</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable">CXXFLAGS</span><span class="token operator">=</span><span class="token string">&quot;-DNDEBUG -O2 -fno-omit-frame-pointer&quot;</span>
</pre><p>You can skip this step, but if you do, any samples within these<br>
libraries will not have correct stack trace information, which means<br>
you will likely not get a meaningful set of data that will tell you<br>
where the majority of time is really being spent. Don&apos;t worry about<br>
rebuilding literally every single dependency though. Just focus on the<br>
ones that you expect to take a non-negligible amount of runtime. You<br>
will be able to tell if you haven&apos;t done enough later, and you can go<br>
back and rebuild more.  Once this is done, you then build K with<br>
optimizations and debug info enabled, like so:</p>
<pre data-role="codeBlock" data-info="sh" class="language-bash">mvn package -Dproject.build.type<span class="token operator">=</span><span class="token string">&quot;FastBuild&quot;</span>
</pre><p>Next, you build the semantics with optimizations and debug info<br>
enabled (i.e., <code>kompile -ccopt -O2 --iterated -ccopt -fno-omit-frame-pointer</code>).</p>
<p>Once all this is done, you should be ready to profile your<br>
application. Essentially, you should run whatever test suite you<br>
usually run, but with <code>perf record -g --</code> prefixed to the front. For<br>
example, for KEVM it&apos;s the following command. (For best data, don&apos;t<br>
run this step in parallel.)</p>
<pre data-role="codeBlock" data-info="sh" class="language-bash">perf record -g -- <span class="token function">make</span> test-conformance
</pre><p>Finally, you want to filter out just the samples that landed within<br>
the llvm backend and view the report. For this, you need to know the<br>
name of the binary that was generated by your build system. Normally<br>
it is <code>interpreter</code>, but e.g. if you are building the web3 client for<br>
kevm, it would be <code>kevm-client</code>. You will want to run the following<br>
command.</p>
<pre data-role="codeBlock" data-info="sh" class="language-bash">perf report -g -c <span class="token variable">$binary_name</span>
</pre><p>If all goes well, you should see a breakdown of where CPU time has<br>
been spent executing the application. You will know that sufficient<br>
time was spent rebuilding dependencies with the correct flags when the<br>
total time reported by the main method is close to 100%. If it&apos;s not<br>
close to 100%, this is probably because a decent amount of self time<br>
was reported in stack traces that were not built with frame pointers<br>
enabled, meaning that perf was unable to walk the stack. You will have<br>
to go back, rebuild the appropriate libraries, and then record your<br>
trace again.</p>
<p>Your ultimate goal is to identify the hotspots that take the most<br>
time, and make them execute faster. Entries like <code>step</code> and<br>
<code>step_1234</code> like functions refer to the cost of matching. An entry<br>
like <code>side_condition_1234</code> is a side condition and <code>apply_rule_1234</code><br>
is constructing the rhs of a rule. You can convert from this rule<br>
ordinal to a location using the <code>llvm-kompile-compute-loc</code> script in<br>
the bin folder of the llvm backend repo. For example,</p>
<pre data-role="codeBlock" data-info="sh" class="language-bash">llvm-kompile-compute-loc <span class="token number">5868</span> evm-semantics/.build/defn/llvm/driver-kompiled
</pre><p>spits out the following text.</p>
<pre data-role="codeBlock" data-info class="language-"><code>Line: 18529
/home/dwightguth/evm-semantics/./.build/defn/llvm/driver.k:493:10
</code></pre><p>This is the line of <code>definition.kore</code> that the axiom appears on as<br>
well as the original location of the rule in the K semantics. You can<br>
use this information to figure out which rules and functions are<br>
causing the most time and optimize them to be more efficient.</p>
<h2>Running tests - kserver</h2>
<p>The <code>kserver</code> is a front-end tool based on <a href="https://github.com/facebookarchive/nailgun">Nailgun</a><br>
which helps to reduce the startup time of the JVM. Calling <code>kserver</code> in a terminal<br>
window will wait for all kompile/kprove calls and force them to run in the same process<br>
and share the same threads. This also reduces the thread contention significantly. <code>kompile</code><br>
uses all the threads available to do rule parsing. Another benefit is that it saves caches,<br>
and each time you call kprove/kast, you can access those directly w/o extra disk usage.<br>
Running the <code>regression-new</code> integration tests on a powerful machine (32 threads) takes 8m,<br>
with the kserver active it takes 2m. You can start the kserver in two ways.</p>
<ul>
<li>blocking: call <code>kserver</code> in the command line. Close it after you are done testing. Useful for quick testing.</li>
<li>non-blocking: call <code>spawn-kserver &lt;log.flie&gt;</code> and close it with <code>stop-kserver</code> - this is used for automation on CI</li>
</ul>
<p>Because we reuse caches, you should stop and restart the server between runs.<br>
The Nailgun implementation hasn&apos;t been updated in the last 3-5 years, and it&apos;s not compatible with Java 18 onwards.</p>
</div></div><div id="ebook-heading-k-builtins" ebook-toc-level-1 heading="K Builtins"><div><h1>K Builtins</h1>
<p>The K Builtins (also referred to as the K Prelude or the K Standard Library)<br>
consists of several files which contain definitions that make working with K<br>
simpler. These files can be found under <code>include/kframework/builtin</code> in your K<br>
installation directory, and can be imported with <code>requires &quot;FILENAME&quot;</code> (without<br>
the path prefix).</p>
<ul>
<li><a href="#ebook-heading-domains">domains</a>: Basic datatypes which are universally useful.</li>
<li><a href="#ebook-heading-kast">kast</a>: Representation of K internal data-structures (not to be<br>
included in normal definitions).</li>
<li><a href="#ebook-heading-prelude">prelude</a>: Automatically included into every K definition.</li>
<li><a href="#ebook-heading-ffi">ffi</a>: FFI interface for calling out to native C code from K.</li>
<li><a href="#ebook-heading-json">json</a>: JSON datatype and parsers/unparsers for JSON strings.</li>
<li><a href="#ebook-heading-rat">rat</a>: Rational number representation.</li>
<li><a href="#ebook-heading-substitution">substitution</a>: Hooked implementation of capture-aware<br>
sustitution for K definitions.</li>
<li><a href="https://github.com/runtimeverification/k/blob/master/k-distribution/include/kframework/builtin/unification.k">unification</a>: Hooked implementation of unification<br>
exposed directly to K definitions.</li>
</ul>
</div></div><div id="ebook-heading-domains" ebook-toc-level-2 heading="domains"><div><h1>Basic Builtin Types in K</h1>
<p>A major piece of the K prelude consists of a series of modules that contain<br>
implementations of basic data types and language features in K. You do not need<br>
to require this file yourself; it is required automatically in every K<br>
definition unless <code>--no-prelude</code> is passed to kompile. K may not work correctly<br>
if some of these modules do not exist or do not declare certain functions.</p>
<p>Note that some functions in the K prelude functions are not total, that is,<br>
they are not defined on all possible input values. When you invoke such a<br>
function on an undefined input, the behavior is undefined. In particular, when<br>
this happens, interpreters generated by the K LLVM backend may crash.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-requires">requires</span> <span class="token string">&quot;kast.md&quot;</span>
</pre><h2>Default Modules</h2>
<p>K declares certain modules that contain most of the builtins you usually want<br>
when defining a language in K. In particular, this includes integers, booleans,<br>
strings, identifiers, I/O, lists, maps, and sets. The <code>DOMAINS-SYNTAX</code> module<br>
is designed to be imported by the syntax module of the language and contains<br>
only the program-level syntax of identifiers, integers, booleans, and strings.<br>
The <code>DOMAINS</code> module contains the rest of the syntax, including builtin<br>
functions over those and the remaining types.</p>
<p>Note that not all modules are included in DOMAINS. A few less-common modules<br>
are not, including <code>ARRAY</code>, <code>COLLECTIONS</code>, <code>FLOAT</code>, <code>STRING-BUFFER</code>, <code>BYTES</code>,<br>
<code>K-REFLECTION</code>, <code>MINT</code>.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> DOMAINS<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> SORT<span class="token operator">-</span>K
  <span class="token keyword keyword-imports">imports</span> ID<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> UNSIGNED<span class="token operator">-</span>INT<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> BOOL<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> STRING<span class="token operator">-</span>SYNTAX
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> DOMAINS
  <span class="token keyword keyword-imports">imports</span> DOMAINS<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> INT
  <span class="token keyword keyword-imports">imports</span> BOOL
  <span class="token keyword keyword-imports">imports</span> STRING
  <span class="token keyword keyword-imports">imports</span> BASIC<span class="token operator">-</span>K
  <span class="token keyword keyword-imports">imports</span> LIST
  <span class="token keyword keyword-imports">imports</span> K<span class="token operator">-</span>IO
  <span class="token keyword keyword-imports">imports</span> MAP
  <span class="token keyword keyword-imports">imports</span> SET
  <span class="token keyword keyword-imports">imports</span> ID
  <span class="token keyword keyword-imports">imports</span> K<span class="token operator">-</span>EQUAL
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><h2>Arrays</h2>
<p>Provided here is an implementation for fixed-sized, contiguous maps from <code>Int</code><br>
to <code>KItem</code>. In some previous versions of K, the <code>Array</code> type was a builtin type<br>
backed by mutable arrays of objects. However, in modern K, the <code>Array</code> type is<br>
implemented by means of the <code>List</code> type; users should not access this interface<br>
directly and should instead make only of the functions listed below. Users of<br>
this module should import only the <code>ARRAY</code> module.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> ARRAY<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> private LIST

  <span class="token keyword keyword-syntax">syntax</span> Array
</pre><h3 class="mume-header" id="array-lookup">Array lookup</h3>

<p>You can look up an element in an <code>Array</code> by its index in O(log(N)) time. Note<br>
that the base of the logarithm is a relatively high number and thus the time is<br>
effectively constant.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Array <span class="token string">&quot;[&quot;</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;]&quot;</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="array-update">Array update</h3>

<p>You can create a new <code>Array</code> with a new value for a key in O(log(N)) time, or<br>
effectively constant.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Array <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Array <span class="token string">&quot;[&quot;</span> key<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;&lt;-&quot;</span> value<span class="token punctuation">:</span> KItem <span class="token string">&quot;]&quot;</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_<span class="token punctuation">[</span>_&lt;<span class="token operator">-</span>_<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="array-reset">Array reset</h3>

<p>You can create a new <code>Array</code> where a particular key is reset to its default<br>
value in O(log(N)) time, or effectively constant.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Array <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Array <span class="token string">&quot;[&quot;</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;&lt;-&quot;</span> <span class="token string">&quot;undef&quot;</span> <span class="token string">&quot;]&quot;</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="multiple-array-update">Multiple array update</h3>

<p>You can create a new <code>Array</code> from a <code>List</code> <code>L</code> of size <code>N</code> where the <code>N</code><br>
elements starting at <code>index</code> are replaced with the contents of <code>L</code>, in<br>
O(N*log(K)) time (where K is the size of the array), or effectively linear.<br>
Having <code>index + N &gt; K</code> yields an exception.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Array <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> updateArray<span class="token punctuation">(</span>Array<span class="token punctuation">,</span> index<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> List<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="array-fill">Array fill</h3>

<p>You can create a new <code>Array</code> where the <code>length</code> elements starting at <code>index</code><br>
are replaced with <code>value</code>, in O(length*log(N)) time, or effectively linear.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Array <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> fillArray<span class="token punctuation">(</span>Array<span class="token punctuation">,</span> index<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> length<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> value<span class="token punctuation">:</span> KItem<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="array-range-check">Array range check</h3>

<p>You can test whether an integer is within the bounds of an array in O(1) time.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;in_keys&quot;</span> <span class="token string">&quot;(&quot;</span> Array <span class="token string">&quot;)&quot;</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">]</span>
</pre><pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> ARRAY<span class="token operator">-</span>IN<span class="token operator">-</span>K <span class="token punctuation">[</span>private<span class="token punctuation">]</span>
  <span class="token keyword keyword-imports">imports</span> public ARRAY<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> private LIST
  <span class="token keyword keyword-imports">imports</span> private K<span class="token operator">-</span>EQUAL
  <span class="token keyword keyword-imports">imports</span> private INT
  <span class="token keyword keyword-imports">imports</span> private BOOL
</pre><h3 class="mume-header" id="array-creation">Array creation</h3>

<p>You can create an array with <code>length</code> elements where each element is<br>
initialized to <code>value</code> in O(1) time. Note that the array is stored in a manner<br>
where only the highest element that is actually modified is given a value<br>
in its internal representation, which means that subsequent array operations<br>
may incur a one-time O(N) resizing cost, possibly amortized across multiple<br>
operations.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Array <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> makeArray<span class="token punctuation">(</span>length<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> value<span class="token punctuation">:</span> KItem<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> public<span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="implementation-of-arrays">Implementation of Arrays</h3>

<p>The remainder of this section consists of an implementation in K of the<br>
operations listed above. Users of the <code>ARRAY</code> module should not make use<br>
of any of the syntax defined in any of these modules.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Array <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> arr<span class="token punctuation">(</span>List<span class="token punctuation">,</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> KItem<span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> makeArray<span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> D<span class="token punctuation">:</span><span class="token punctuation">:</span>KItem<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> arr<span class="token punctuation">(</span><span class="token punctuation">.</span>List<span class="token punctuation">,</span> I<span class="token punctuation">,</span> D<span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> arr<span class="token punctuation">(</span>L<span class="token punctuation">:</span><span class="token punctuation">:</span>List<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _       <span class="token punctuation">)</span> <span class="token punctuation">[</span> IDX<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">]</span> <span class="token operator">=&gt;</span> L<span class="token punctuation">[</span>IDX<span class="token punctuation">]</span> <span class="token keyword keyword-requires">requires</span> <span class="token number">0</span> <span class="token operator">&lt;=</span><span class="token keyword keyword-Int">Int</span> IDX andBool IDX  &lt;<span class="token keyword keyword-Int">Int</span> size<span class="token punctuation">(</span>L<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> arr<span class="token punctuation">(</span>_      <span class="token punctuation">,</span> _<span class="token punctuation">,</span> D<span class="token punctuation">:</span><span class="token punctuation">:</span>KItem<span class="token punctuation">)</span> <span class="token punctuation">[</span> _        <span class="token punctuation">]</span> <span class="token operator">=&gt;</span> D      <span class="token punctuation">[</span>owise<span class="token punctuation">]</span>

  <span class="token keyword keyword-syntax">syntax</span> List <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> ensureOffsetList<span class="token punctuation">(</span>List<span class="token punctuation">,</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> KItem<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> ensureOffsetList<span class="token punctuation">(</span>L<span class="token punctuation">:</span><span class="token punctuation">:</span>List<span class="token punctuation">,</span> IDX<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> D<span class="token punctuation">:</span><span class="token punctuation">:</span>KItem<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> L makeList<span class="token punctuation">(</span>IDX <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span> <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> size<span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">,</span> D<span class="token punctuation">)</span> <span class="token keyword keyword-requires">requires</span>         IDX <span class="token operator">&gt;=</span><span class="token keyword keyword-Int">Int</span> size<span class="token punctuation">(</span>L<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> ensureOffsetList<span class="token punctuation">(</span>L<span class="token punctuation">:</span><span class="token punctuation">:</span>List<span class="token punctuation">,</span> IDX<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> _<span class="token punctuation">:</span><span class="token punctuation">:</span>KItem<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> L                                      <span class="token keyword keyword-requires">requires</span> notBool IDX <span class="token operator">&gt;=</span><span class="token keyword keyword-Int">Int</span> size<span class="token punctuation">(</span>L<span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> arr<span class="token punctuation">(</span>L<span class="token punctuation">:</span><span class="token punctuation">:</span>List<span class="token punctuation">,</span> I<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> D<span class="token punctuation">:</span><span class="token punctuation">:</span>KItem<span class="token punctuation">)</span> <span class="token punctuation">[</span> IDX<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> &lt;<span class="token operator">-</span> VAL<span class="token punctuation">:</span><span class="token punctuation">:</span>KItem <span class="token punctuation">]</span> <span class="token operator">=&gt;</span> arr<span class="token punctuation">(</span>ensureOffsetList<span class="token punctuation">(</span>L<span class="token punctuation">,</span> IDX<span class="token punctuation">,</span> D<span class="token punctuation">)</span> <span class="token punctuation">[</span> IDX &lt;<span class="token operator">-</span> VAL <span class="token punctuation">]</span><span class="token punctuation">,</span> I<span class="token punctuation">,</span> D<span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> arr<span class="token punctuation">(</span>L<span class="token punctuation">:</span><span class="token punctuation">:</span>List<span class="token punctuation">,</span> I<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> D<span class="token punctuation">:</span><span class="token punctuation">:</span>KItem<span class="token punctuation">)</span> <span class="token punctuation">[</span> IDX<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> &lt;<span class="token operator">-</span> undef <span class="token punctuation">]</span> <span class="token operator">=&gt;</span> arr<span class="token punctuation">(</span>L<span class="token punctuation">,</span> I<span class="token punctuation">,</span> D<span class="token punctuation">)</span> <span class="token punctuation">[</span> IDX &lt;<span class="token operator">-</span> D <span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> updateArray<span class="token punctuation">(</span>arr<span class="token punctuation">(</span>L<span class="token punctuation">:</span><span class="token punctuation">:</span>List<span class="token punctuation">,</span> I<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> D<span class="token punctuation">:</span><span class="token punctuation">:</span>KItem<span class="token punctuation">)</span><span class="token punctuation">,</span> IDX<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> L2<span class="token punctuation">:</span><span class="token punctuation">:</span>List<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> arr<span class="token punctuation">(</span>updateList<span class="token punctuation">(</span>ensureOffsetList<span class="token punctuation">(</span>L<span class="token punctuation">,</span> IDX <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> size<span class="token punctuation">(</span>L2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">,</span> D<span class="token punctuation">)</span><span class="token punctuation">,</span> IDX<span class="token punctuation">,</span> L2<span class="token punctuation">)</span><span class="token punctuation">,</span> I<span class="token punctuation">,</span> D<span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> fillArray<span class="token punctuation">(</span>arr<span class="token punctuation">(</span>L<span class="token punctuation">:</span><span class="token punctuation">:</span>List<span class="token punctuation">,</span> I<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> D<span class="token punctuation">:</span><span class="token punctuation">:</span>KItem<span class="token punctuation">)</span><span class="token punctuation">,</span> IDX<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> LEN<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> VAL<span class="token punctuation">:</span><span class="token punctuation">:</span>KItem<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> arr<span class="token punctuation">(</span>fillList<span class="token punctuation">(</span>ensureOffsetList<span class="token punctuation">(</span>L<span class="token punctuation">,</span> IDX <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> LEN <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">,</span> D<span class="token punctuation">)</span><span class="token punctuation">,</span> IDX<span class="token punctuation">,</span> LEN<span class="token punctuation">,</span> VAL<span class="token punctuation">)</span><span class="token punctuation">,</span> I<span class="token punctuation">,</span> D<span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> IDX<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> in_keys<span class="token punctuation">(</span>arr<span class="token punctuation">(</span>_<span class="token punctuation">,</span> I<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> IDX <span class="token operator">&gt;=</span><span class="token keyword keyword-Int">Int</span> <span class="token number">0</span> andBool IDX &lt;<span class="token keyword keyword-Int">Int</span> I
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> ARRAY<span class="token operator">-</span>SYMBOLIC <span class="token punctuation">[</span>symbolic<span class="token punctuation">]</span>
  <span class="token keyword keyword-imports">imports</span> ARRAY<span class="token operator">-</span>IN<span class="token operator">-</span>K
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> ARRAY<span class="token operator">-</span>KORE
  <span class="token keyword keyword-imports">imports</span> ARRAY<span class="token operator">-</span>IN<span class="token operator">-</span>K
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> ARRAY
  <span class="token keyword keyword-imports">imports</span> ARRAY<span class="token operator">-</span>SYMBOLIC
  <span class="token keyword keyword-imports">imports</span> ARRAY<span class="token operator">-</span>KORE
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><h2>Maps</h2>
<p>Provided here is the syntax of an implementation of immutable, associative,<br>
commutative maps from <code>KItem</code> to <code>KItem</code>. This type is hooked to an<br>
implementation of maps provided by the backend. For more information on<br>
matching on maps and allowable patterns for doing so, refer to K&apos;s<br>
<a href="file:///home/runner/work/k/k/gh-pages/k-distribution/include/kframework/builtin/USER_MANUAL.md">user documentation</a>.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> MAP
  <span class="token keyword keyword-imports">imports</span> private BOOL<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> private INT<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> private LIST
  <span class="token keyword keyword-imports">imports</span> private SET

  <span class="token keyword keyword-syntax">syntax</span> Map <span class="token punctuation">[</span>hook<span class="token punctuation">(</span>MAP<span class="token punctuation">.</span>Map<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="map-concatenation">Map concatenation</h3>

<p>The <code>Map</code> sort represents a generalized associative array. Each key can be<br>
paired with an arbitrary value, and can be used to reference its associated<br>
value. Multiple bindings for the same key are not allowed.</p>
<p>You can construct a new Map consisting of key/value pairs of two Maps. The<br>
result is <code>#False</code> if the maps have keys in common (in particular, this will<br>
yield an exception during concrete execution). This operation is O(N<em>log(M))<br>
where N is the size of the smaller map, when it appears on the right hand side.<br>
When it appears on the left hand side and all variables are bound, it is<br>
O(N</em>log(M)) where M is the size of the map it is matching and N is the number<br>
of elements being matched. When it appears on the left hand side containing<br>
variables not bound elsewhere in the term, it is O(N^K) where N is the size of<br>
the map it is matching and K is the number of unbound keys being matched. In<br>
other words, one unbound variable is linear, two is quadratic, three is cubic,<br>
etc.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Map <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Map Map                        <span class="token punctuation">[</span><span class="token class-name">left</span><span class="token punctuation">,</span> function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MAP<span class="token punctuation">.</span>concat<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_Map_<span class="token punctuation">)</span><span class="token punctuation">,</span> assoc<span class="token punctuation">,</span> comm<span class="token punctuation">,</span> unit<span class="token punctuation">(</span><span class="token punctuation">.</span>Map<span class="token punctuation">)</span><span class="token punctuation">,</span> element<span class="token punctuation">(</span>_<span class="token operator">|</span><span class="token operator">-</span>&gt;_<span class="token punctuation">)</span><span class="token punctuation">,</span> index<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">format</span><span class="token punctuation">(</span><span class="token operator">%</span><span class="token number">1</span><span class="token operator">%</span>n<span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="map-unit">Map unit</h3>

<p>The map with zero elements is represented by <code>.Map</code>.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Map <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;.Map&quot;</span>                         <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MAP<span class="token punctuation">.</span>unit<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span><span class="token punctuation">.</span>Map<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="map-elements">Map elements</h3>

<p>An element of a <code>Map</code> is constructed via the <code>|-&gt;</code> operator. The key is on the<br>
left and the value is on the right.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Map <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> KItem <span class="token string">&quot;|-&gt;&quot;</span> KItem                      <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MAP<span class="token punctuation">.</span>element<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_<span class="token operator">|</span><span class="token operator">-</span>&gt;_<span class="token punctuation">)</span><span class="token punctuation">,</span> injective<span class="token punctuation">]</span>

  <span class="token keyword keyword-syntax priority">syntax priority</span> _<span class="token operator">|</span><span class="token operator">-</span>&gt;_ &gt; _Map_ <span class="token punctuation">.</span>Map
  <span class="token keyword keyword-syntax non-assoc">syntax non-assoc</span> _<span class="token operator">|</span><span class="token operator">-</span>&gt;_
</pre><h3 class="mume-header" id="map-lookup">Map lookup</h3>

<p>You can look up the value associated with the key of a map in O(log(N)) time.<br>
Note that the base of the logarithm is a relatively high number and thus the<br>
time is effectively constant. The value is <code>#False</code> if the key is not in the<br>
map (in particular, this will yield an exception during concrete execution).</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Map <span class="token string">&quot;[&quot;</span> KItem <span class="token string">&quot;]&quot;</span>                    <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MAP<span class="token punctuation">.</span>lookup<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>Map<span class="token punctuation">:</span>lookup<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="map-lookup-with-default">Map lookup with default</h3>

<p>You can also look up the value associated with the key of a map using a<br>
total function that assigns a specific default value if the key is not present<br>
in the map. This operation is also O(log(N)), or effectively constant.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Map <span class="token string">&quot;[&quot;</span> KItem <span class="token string">&quot;]&quot;</span> <span class="token string">&quot;orDefault&quot;</span> KItem      <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MAP<span class="token punctuation">.</span>lookupOrDefault<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>Map<span class="token punctuation">:</span>lookupOrDefault<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="map-update">Map update</h3>

<p>You can insert a key/value pair into a map in O(log(N)) time, or effectively<br>
constant.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Map <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Map <span class="token string">&quot;[&quot;</span> key<span class="token punctuation">:</span> KItem <span class="token string">&quot;&lt;-&quot;</span> value<span class="token punctuation">:</span> KItem <span class="token string">&quot;]&quot;</span>           <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>Map<span class="token punctuation">:</span>update<span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MAP<span class="token punctuation">.</span>update<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">prefer</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="map-delete">Map delete</h3>

<p>You can remove a key/value pair from a map via its key in O(log(N)) time, or<br>
effectively constant.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Map <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Map <span class="token string">&quot;[&quot;</span> KItem <span class="token string">&quot;&lt;-&quot;</span> <span class="token string">&quot;undef&quot;</span> <span class="token string">&quot;]&quot;</span>     <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MAP<span class="token punctuation">.</span>remove<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_<span class="token punctuation">[</span>_&lt;<span class="token operator">-</span>undef<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="map-difference">Map difference</h3>

<p>You can remove the key/value pairs in a map that are present in another map in<br>
O(N*log(M)) time (where M is the size of the first map and N is the size of the<br>
second), or effectively linear. Note that only keys whose value is the same<br>
in both maps are removed. To remove all the keys in one map from another map,<br>
you can say <code>removeAll(M1, keys(M2))</code>.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Map <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Map <span class="token string">&quot;-Map&quot;</span> Map                 <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MAP<span class="token punctuation">.</span>difference<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="multiple-map-update">Multiple map update</h3>

<p>You can update a map by adding all the key/value pairs in the second map in<br>
O(N*log(M)) time (where M is the size of the first map and N is the size of the<br>
second map), or effectively linear. If any keys are present in both maps, the<br>
value from the second map overwrites the value in the first. This function is<br>
total, which is distinct from map concatenation, a partial function only<br>
defined on maps with disjoint keys.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Map <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> updateMap<span class="token punctuation">(</span>Map<span class="token punctuation">,</span> Map<span class="token punctuation">)</span>            <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MAP<span class="token punctuation">.</span>updateAll<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="multiple-map-removal">Multiple map removal</h3>

<p>You can remove a <code>Set</code> of keys from a map in O(N*log(M)) time (where M is the<br>
size of the <code>Map</code> and <code>N</code> is the size of the <code>Set</code>), or effectively linear.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Map <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> removeAll<span class="token punctuation">(</span>Map<span class="token punctuation">,</span> Set<span class="token punctuation">)</span>            <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MAP<span class="token punctuation">.</span>removeAll<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="map-keys-as-set">Map keys (as <code>Set</code>)</h3>

<p>You can get a <code>Set</code> of all the keys in a Map in O(N) time.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Set <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> keys<span class="token punctuation">(</span>Map<span class="token punctuation">)</span>                      <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MAP<span class="token punctuation">.</span>keys<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="map-keys-as-list">Map keys (as <code>List</code>)</h3>

<p>You can get a <code>List</code> of all the keys in a Map in O(N) time.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> List <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;keys_list&quot;</span> <span class="token string">&quot;(&quot;</span> Map <span class="token string">&quot;)&quot;</span>       <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MAP<span class="token punctuation">.</span>keys_list<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="map-key-membership">Map key membership</h3>

<p>You can check whether a key is present in a map in O(1) time.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> KItem <span class="token string">&quot;in_keys&quot;</span> <span class="token string">&quot;(&quot;</span> Map <span class="token string">&quot;)&quot;</span>       <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MAP<span class="token punctuation">.</span>in_keys<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="map-values-as-list">Map values (as <code>List</code>)</h3>

<p>You can get a <code>List</code> of all the values in a map in O(N) time.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> List <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> values<span class="token punctuation">(</span>Map<span class="token punctuation">)</span>                   <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MAP<span class="token punctuation">.</span>values<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="map-size">Map size</h3>

<p>You can get the number of key/value pairs in a map in O(1) time.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> size<span class="token punctuation">(</span>Map<span class="token punctuation">)</span>                      <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MAP<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>sizeMap<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="map-inclusion">Map inclusion</h3>

<p>You can determine whether a <code>Map</code> is a strict subset of another <code>Map</code> in O(N)<br>
time (where N is the size of the first map). Only keys that are bound to the<br>
same value are considered equal.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Map <span class="token string">&quot;&lt;=Map&quot;</span> Map               <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MAP<span class="token punctuation">.</span>inclusion<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="map-choice">Map choice</h3>

<p>You can get an arbitrarily chosen key of a <code>Map</code> in O(1) time. The same key<br>
will always be returned for the same map, but no guarantee is given that two<br>
different maps will return the same element, even if they are similar.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> choice<span class="token punctuation">(</span>Map<span class="token punctuation">)</span>                      <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MAP<span class="token punctuation">.</span>choice<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>Map<span class="token punctuation">:</span>choice<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="implementation-of-maps">Implementation of Maps</h3>

<p>The remainder of this section contains lemmas used by the Java and Haskell<br>
backend to simplify expressions of sort <code>Map</code>. They do not affect the semantics<br>
of maps, merely describing additional rules that the backend can use to<br>
simplify terms.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> MAP<span class="token operator">-</span>KORE<span class="token operator">-</span>SYMBOLIC <span class="token punctuation">[</span>symbolic<span class="token punctuation">,</span>haskell<span class="token punctuation">]</span>
  <span class="token keyword keyword-imports">imports</span> MAP
  <span class="token keyword keyword-imports">imports</span> private K<span class="token operator">-</span>EQUAL
  <span class="token keyword keyword-imports">imports</span> private BOOL

  <span class="token keyword keyword-rule">rule</span> #Ceil<span class="token punctuation">(</span>@M<span class="token punctuation">:</span>Map <span class="token punctuation">[</span>@K<span class="token punctuation">:</span>KItem<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">(</span>@K in_keys<span class="token punctuation">(</span>@M<span class="token punctuation">)</span><span class="token punctuation">)</span> #Equals <span class="token boolean">true</span><span class="token punctuation">}</span> #And #Ceil<span class="token punctuation">(</span>@M<span class="token punctuation">)</span> #And #Ceil<span class="token punctuation">(</span>@K<span class="token punctuation">)</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>

  <span class="token comment">// Symbolic update</span>

  <span class="token comment">// Adding the definedness condition `notBool (K in_keys(M))` in the ensures clause of the following rule would be redundant</span>
  <span class="token comment">// because K also appears in the rhs, preserving the case when it&apos;s #Bottom.</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>K <span class="token operator">|</span><span class="token operator">-</span>&gt; _ M<span class="token punctuation">:</span>Map<span class="token punctuation">)</span> <span class="token punctuation">[</span> K &lt;<span class="token operator">-</span> V <span class="token punctuation">]</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>K <span class="token operator">|</span><span class="token operator">-</span>&gt; V M<span class="token punctuation">)</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> M<span class="token punctuation">:</span>Map <span class="token punctuation">[</span> K &lt;<span class="token operator">-</span> V <span class="token punctuation">]</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>K <span class="token operator">|</span><span class="token operator">-</span>&gt; V M<span class="token punctuation">)</span> <span class="token keyword keyword-requires">requires</span> notBool <span class="token punctuation">(</span>K in_keys<span class="token punctuation">(</span>M<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> M<span class="token punctuation">:</span>Map <span class="token punctuation">[</span> K &lt;<span class="token operator">-</span> _ <span class="token punctuation">]</span> <span class="token punctuation">[</span> K &lt;<span class="token operator">-</span> V <span class="token punctuation">]</span> <span class="token operator">=&gt;</span> M <span class="token punctuation">[</span> K &lt;<span class="token operator">-</span> V <span class="token punctuation">]</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token comment">// Adding the definedness condition `notBool (K1 in_keys(M))` in the ensures clause of the following rule would be redundant</span>
  <span class="token comment">// because K1 also appears in the rhs, preserving the case when it&apos;s #Bottom.</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>K1 <span class="token operator">|</span><span class="token operator">-</span>&gt; V1 M<span class="token punctuation">:</span>Map<span class="token punctuation">)</span> <span class="token punctuation">[</span> K2 &lt;<span class="token operator">-</span> V2 <span class="token punctuation">]</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>K1 <span class="token operator">|</span><span class="token operator">-</span>&gt; V1 <span class="token punctuation">(</span>M <span class="token punctuation">[</span> K2 &lt;<span class="token operator">-</span> V2 <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword keyword-requires">requires</span> K1 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K K2 <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>

  <span class="token comment">// Symbolic remove</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>K <span class="token operator">|</span><span class="token operator">-</span>&gt; _ M<span class="token punctuation">:</span>Map<span class="token punctuation">)</span> <span class="token punctuation">[</span> K &lt;<span class="token operator">-</span> undef <span class="token punctuation">]</span> <span class="token operator">=&gt;</span> M ensures notBool <span class="token punctuation">(</span>K in_keys<span class="token punctuation">(</span>M<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> M<span class="token punctuation">:</span>Map <span class="token punctuation">[</span> K &lt;<span class="token operator">-</span> undef <span class="token punctuation">]</span> <span class="token operator">=&gt;</span> M <span class="token keyword keyword-requires">requires</span> notBool <span class="token punctuation">(</span>K in_keys<span class="token punctuation">(</span>M<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token comment">// Adding the definedness condition `notBool (K1 in_keys(M))` in the ensures clause of the following rule would be redundant</span>
  <span class="token comment">// because K1 also appears in the rhs, preserving the case when it&apos;s #Bottom.</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>K1 <span class="token operator">|</span><span class="token operator">-</span>&gt; V1 M<span class="token punctuation">:</span>Map<span class="token punctuation">)</span> <span class="token punctuation">[</span> K2 &lt;<span class="token operator">-</span> undef <span class="token punctuation">]</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>K1 <span class="token operator">|</span><span class="token operator">-</span>&gt; V1 <span class="token punctuation">(</span>M <span class="token punctuation">[</span> K2 &lt;<span class="token operator">-</span> undef <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword keyword-requires">requires</span> K1 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K K2 <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>

  <span class="token comment">// Symbolic lookup</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>K  <span class="token operator">|</span><span class="token operator">-</span>&gt;  V M<span class="token punctuation">:</span>Map<span class="token punctuation">)</span> <span class="token punctuation">[</span> K <span class="token punctuation">]</span>  <span class="token operator">=&gt;</span> V ensures notBool <span class="token punctuation">(</span>K in_keys<span class="token punctuation">(</span>M<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>K1 <span class="token operator">|</span><span class="token operator">-</span>&gt; _V M<span class="token punctuation">:</span>Map<span class="token punctuation">)</span> <span class="token punctuation">[</span> K2 <span class="token punctuation">]</span> <span class="token operator">=&gt;</span> M <span class="token punctuation">[</span>K2<span class="token punctuation">]</span> <span class="token keyword keyword-requires">requires</span> K1 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K K2 ensures notBool <span class="token punctuation">(</span>K1 in_keys<span class="token punctuation">(</span>M<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>_MAP<span class="token punctuation">:</span>Map <span class="token punctuation">[</span> K  &lt;<span class="token operator">-</span>  V1 <span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">[</span> K <span class="token punctuation">]</span>  <span class="token operator">=&gt;</span> V1 <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span> MAP<span class="token punctuation">:</span>Map <span class="token punctuation">[</span> K1 &lt;<span class="token operator">-</span> _V1 <span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">[</span> K2 <span class="token punctuation">]</span> <span class="token operator">=&gt;</span> MAP <span class="token punctuation">[</span> K2 <span class="token punctuation">]</span> <span class="token keyword keyword-requires">requires</span> K1 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K K2 <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>K  <span class="token operator">|</span><span class="token operator">-</span>&gt;  V M<span class="token punctuation">:</span>Map<span class="token punctuation">)</span> <span class="token punctuation">[</span>  K <span class="token punctuation">]</span> orDefault _ <span class="token operator">=&gt;</span> V ensures notBool <span class="token punctuation">(</span>K in_keys<span class="token punctuation">(</span>M<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>K1 <span class="token operator">|</span><span class="token operator">-</span>&gt; _V M<span class="token punctuation">:</span>Map<span class="token punctuation">)</span> <span class="token punctuation">[</span> K2 <span class="token punctuation">]</span> orDefault D <span class="token operator">=&gt;</span> M <span class="token punctuation">[</span>K2<span class="token punctuation">]</span> orDefault D <span class="token keyword keyword-requires">requires</span> K1 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K K2 ensures notBool <span class="token punctuation">(</span>K1 in_keys<span class="token punctuation">(</span>M<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>_MAP<span class="token punctuation">:</span>Map <span class="token punctuation">[</span> K  &lt;<span class="token operator">-</span>  V1 <span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">[</span> K <span class="token punctuation">]</span> orDefault _ <span class="token operator">=&gt;</span> V1 <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span> MAP<span class="token punctuation">:</span>Map <span class="token punctuation">[</span> K1 &lt;<span class="token operator">-</span> _V1 <span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">[</span> K2 <span class="token punctuation">]</span> orDefault D <span class="token operator">=&gt;</span> MAP <span class="token punctuation">[</span> K2 <span class="token punctuation">]</span> orDefault D <span class="token keyword keyword-requires">requires</span> K1 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K K2 <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">.</span>Map <span class="token punctuation">[</span> _ <span class="token punctuation">]</span> orDefault D <span class="token operator">=&gt;</span> D <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>

  <span class="token comment">// Symbolic in_keys</span>
  <span class="token keyword keyword-rule">rule</span> K in_keys<span class="token punctuation">(</span>_M <span class="token punctuation">[</span> K &lt;<span class="token operator">-</span> undef <span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">false</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> K in_keys<span class="token punctuation">(</span>_M <span class="token punctuation">[</span> K &lt;<span class="token operator">-</span> _ <span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">true</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> K1 in_keys<span class="token punctuation">(</span>M <span class="token punctuation">[</span> K2 &lt;<span class="token operator">-</span> _ <span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">true</span> <span class="token keyword keyword-requires">requires</span> K1 <span class="token operator">==</span>K K2 orBool K1 in_keys<span class="token punctuation">(</span>M<span class="token punctuation">)</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> K1 in_keys<span class="token punctuation">(</span>M <span class="token punctuation">[</span> K2 &lt;<span class="token operator">-</span> _ <span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> K1 in_keys<span class="token punctuation">(</span>M<span class="token punctuation">)</span> <span class="token keyword keyword-requires">requires</span> K1 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K K2 <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">{</span><span class="token boolean">false</span> #Equals @Key in_keys<span class="token punctuation">(</span><span class="token punctuation">.</span>Map<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token operator">=&gt;</span> #Ceil<span class="token punctuation">(</span>@Key<span class="token punctuation">)</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">{</span>@Key in_keys<span class="token punctuation">(</span><span class="token punctuation">.</span>Map<span class="token punctuation">)</span> #Equals <span class="token boolean">false</span><span class="token punctuation">}</span> <span class="token operator">=&gt;</span> #Ceil<span class="token punctuation">(</span>@Key<span class="token punctuation">)</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">{</span><span class="token boolean">false</span> #Equals @Key in_keys<span class="token punctuation">(</span>Key<span class="token string">&apos; |-&gt; Val @M)} =&gt; #Ceil(@Key) #And #Ceil(Key&apos;</span> <span class="token operator">|</span><span class="token operator">-</span>&gt; Val @M<span class="token punctuation">)</span> #And #Not<span class="token punctuation">(</span><span class="token punctuation">{</span>@Key #Equals Key&apos;<span class="token punctuation">}</span><span class="token punctuation">)</span> #And <span class="token punctuation">{</span><span class="token boolean">false</span> #Equals @Key in_keys<span class="token punctuation">(</span>@M<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">{</span>@Key in_keys<span class="token punctuation">(</span>Key<span class="token string">&apos; |-&gt; Val @M) #Equals false} =&gt; #Ceil(@Key) #And #Ceil(Key&apos;</span> <span class="token operator">|</span><span class="token operator">-</span>&gt; Val @M<span class="token punctuation">)</span> #And #Not<span class="token punctuation">(</span><span class="token punctuation">{</span>@Key #Equals Key&apos;<span class="token punctuation">}</span><span class="token punctuation">)</span> #And <span class="token punctuation">{</span>@Key in_keys<span class="token punctuation">(</span>@M<span class="token punctuation">)</span> #Equals <span class="token boolean">false</span><span class="token punctuation">}</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>

<span class="token comment">/*
// The rule below is automatically generated by the frontend for every sort
// hooked to MAP.Map. It is left here to serve as documentation.

  rule #Ceil(@M:Map (@K:KItem |-&gt; @V:KItem)) =&gt; {(@K in_keys(@M)) #Equals false} #And #Ceil(@M) #And #Ceil(@K) #And #Ceil(@V)
    [simplification]
*/</span>
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> MAP<span class="token operator">-</span>SYMBOLIC
  <span class="token keyword keyword-imports">imports</span> MAP<span class="token operator">-</span>KORE<span class="token operator">-</span>SYMBOLIC
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><h2>Range Maps</h2>
<p>Provided here is the syntax of an implementation of immutable, associative,<br>
commutative range maps from <code>Int</code> to <code>KItem</code>. This type is hooked to an<br>
implementation of range maps provided by the LLVM backend.<br>
Currently, this type is not supported by other backends.<br>
Although the underlying range map data structure supports any key sort, the<br>
current implementation by the backend only supports <code>Int</code> keys due to<br>
limitations of the underlying ordering function.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> RANGEMAP
  <span class="token keyword keyword-imports">imports</span> private BOOL<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> private INT<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> private LIST
  <span class="token keyword keyword-imports">imports</span> private SET

</pre><h3 class="mume-header" id="range-bounded-inclusively-below-and-exclusively-above">Range, bounded inclusively below and exclusively above.</h3>

<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Range <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;[&quot;</span> KItem <span class="token string">&quot;,&quot;</span> KItem <span class="token string">&quot;)&quot;</span>    <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>RangeMap<span class="token punctuation">:</span>Range<span class="token punctuation">)</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-syntax">syntax</span> RangeMap <span class="token punctuation">[</span>hook<span class="token punctuation">(</span>RANGEMAP<span class="token punctuation">.</span>RangeMap<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="range-map-concatenation">Range map concatenation</h3>

<p>The <code>RangeMap</code> sort represents a map whose keys are stored as ranges, bounded<br>
inclusively below and exclusively above. Contiguous or overlapping ranges that<br>
map to the same value are merged into a single range.</p>
<p>You can construct a new <code>RangeMap</code> consisting of range/value pairs of two<br>
RangeMaps. If the RangeMaps have overlapping ranges an exception will be<br>
thrown during concrete execution. This operation is O(N*log(M)) (where N is<br>
the size of the smaller map and M is the size of the larger map).</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> RangeMap <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> RangeMap RangeMap                        <span class="token punctuation">[</span><span class="token class-name">left</span><span class="token punctuation">,</span> function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>RANGEMAP<span class="token punctuation">.</span>concat<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_RangeMap_<span class="token punctuation">)</span><span class="token punctuation">,</span> assoc<span class="token punctuation">,</span> comm<span class="token punctuation">,</span> unit<span class="token punctuation">(</span><span class="token punctuation">.</span>RangeMap<span class="token punctuation">)</span><span class="token punctuation">,</span> element<span class="token punctuation">(</span>_r<span class="token operator">|</span><span class="token operator">-</span>&gt;_<span class="token punctuation">)</span><span class="token punctuation">,</span> index<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">format</span><span class="token punctuation">(</span><span class="token operator">%</span><span class="token number">1</span><span class="token operator">%</span>n<span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="range-map-unit">Range map unit</h3>

<p>The <code>RangeMap</code> with zero elements is represented by <code>.RangeMap</code>.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> RangeMap <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;.RangeMap&quot;</span>                         <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>RANGEMAP<span class="token punctuation">.</span>unit<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span><span class="token punctuation">.</span>RangeMap<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="range-map-elements">Range map elements</h3>

<p>An element of a <code>RangeMap</code> is constructed via the <code>r|-&gt;</code> operator. The range<br>
of keys is on the left, and the value is on the right.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> RangeMap <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Range <span class="token string">&quot;r|-&gt;&quot;</span> KItem                      <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>RANGEMAP<span class="token punctuation">.</span>elementRng<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_r<span class="token operator">|</span><span class="token operator">-</span>&gt;_<span class="token punctuation">)</span><span class="token punctuation">,</span> injective<span class="token punctuation">]</span>

  <span class="token keyword keyword-syntax priority">syntax priority</span> _r<span class="token operator">|</span><span class="token operator">-</span>&gt;_ &gt; _RangeMap_ <span class="token punctuation">.</span>RangeMap
  <span class="token keyword keyword-syntax non-assoc">syntax non-assoc</span> _r<span class="token operator">|</span><span class="token operator">-</span>&gt;_
</pre><h3 class="mume-header" id="range-map-lookup">Range map lookup</h3>

<p>You can look up the value associated with a key of a <code>RangeMap</code> in O(log(N))<br>
time (where N is the size of the <code>RangeMap</code>). This will yield an exception<br>
during concrete execution if the key is not in the range map.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> RangeMap <span class="token string">&quot;[&quot;</span> KItem <span class="token string">&quot;]&quot;</span>                    <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>RANGEMAP<span class="token punctuation">.</span>lookup<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>RangeMap<span class="token punctuation">:</span>lookup<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="range-map-lookup-with-default">Range map lookup with default</h3>

<p>You can also look up the value associated with a key of a <code>RangeMap</code> using a<br>
total function that assigns a specific default value if the key is not present<br>
in the <code>RangeMap</code>. This operation is also O(log(N)) (where N is the size of<br>
the range map).</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> RangeMap <span class="token string">&quot;[&quot;</span> KItem <span class="token string">&quot;]&quot;</span> <span class="token string">&quot;orDefault&quot;</span> KItem      <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>RANGEMAP<span class="token punctuation">.</span>lookupOrDefault<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>RangeMap<span class="token punctuation">:</span>lookupOrDefault<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="range-map-lookup-for-range-of-key">Range map lookup for range of key</h3>

<p>You can look up for the range that a key of a <code>RangeMap</code> is stored in in<br>
O(log(N)) time (where N is the size of the <code>RangeMap</code>). This will yield an<br>
exception during concrete execution if the key is not in the range map.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Range <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;find_range&quot;</span> <span class="token string">&quot;(&quot;</span> RangeMap <span class="token string">&quot;,&quot;</span> KItem <span class="token string">&quot;)&quot;</span>                    <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>RANGEMAP<span class="token punctuation">.</span>find_range<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>RangeMap<span class="token punctuation">:</span>find_range<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="range-map-update">Range map update</h3>

<p>You can insert a range/value pair into a <code>RangeMap</code> in O(log(N)) time (where N<br>
is the size of the <code>RangeMap</code>). Any ranges adjacent to or overlapping with the<br>
range to be inserted will be updated accordingly.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> RangeMap <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> RangeMap <span class="token string">&quot;[&quot;</span> keyRange<span class="token punctuation">:</span> Range <span class="token string">&quot;&lt;-&quot;</span> value<span class="token punctuation">:</span> KItem <span class="token string">&quot;]&quot;</span>           <span class="token punctuation">[</span>function<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>RangeMap<span class="token punctuation">:</span>update<span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>RANGEMAP<span class="token punctuation">.</span>updateRng<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">prefer</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="range-map-delete">Range map delete</h3>

<p>You can remove a range/value pair from a <code>RangeMap</code> in O(log(N)) time (where N<br>
is the size of the <code>RangeMap</code>). If all or any part of the range is present in<br>
the range map, it will be removed.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> RangeMap <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> RangeMap <span class="token string">&quot;[&quot;</span> Range <span class="token string">&quot;&lt;-&quot;</span> <span class="token string">&quot;undef&quot;</span> <span class="token string">&quot;]&quot;</span>     <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>RANGEMAP<span class="token punctuation">.</span>removeRng<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_r<span class="token punctuation">[</span>_&lt;<span class="token operator">-</span>undef<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="range-map-difference">Range map difference</h3>

<p>You can remove the range/value pairs in a <code>RangeMap</code> that are also present in<br>
another <code>RangeMap</code> in O(max{M,N}*log(M)) time (where M is the size of the<br>
first <code>RangeMap</code> and N is the size of the second <code>RangeMap</code>). Note that only<br>
the parts of overlapping ranges whose value is the same in both range maps<br>
will be removed.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> RangeMap <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> RangeMap <span class="token string">&quot;-RangeMap&quot;</span> RangeMap                 <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>RANGEMAP<span class="token punctuation">.</span>difference<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="multiple-range-map-update">Multiple range map update</h3>

<p>You can update a <code>RangeMap</code> by adding all the range/value pairs in the second<br>
<code>RangeMap</code> in O(N*log(M+N)) time (where M is the size of the first <code>RangeMap</code><br>
and N is the size of the second <code>RangeMap</code>). If any ranges are overlapping,<br>
the value from the second range map overwrites the value in the first for the<br>
parts where ranges are overlapping. This function is total, which is distinct<br>
from range map concatenation, a partial function only defined on range maps<br>
with non overlapping ranges.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> RangeMap <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> updateRangeMap<span class="token punctuation">(</span>RangeMap<span class="token punctuation">,</span> RangeMap<span class="token punctuation">)</span>            <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>RANGEMAP<span class="token punctuation">.</span>updateAll<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="multiple-range-map-removal">Multiple range map removal</h3>

<p>You can remove a <code>Set</code> of ranges from a <code>RangeMap</code> in O(N*log(M)) time (where<br>
M is the size of the <code>RangeMap</code> and N is the size of the <code>Set</code>). For every<br>
range in the set, all or any part of it that is present in the range map will<br>
be removed.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> RangeMap <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> removeAll<span class="token punctuation">(</span>RangeMap<span class="token punctuation">,</span> Set<span class="token punctuation">)</span>            <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>RANGEMAP<span class="token punctuation">.</span>removeAll<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="range-map-keys-as-set">Range map keys (as <code>Set</code>)</h3>

<p>You can get a <code>Set</code> of all the ranges in a <code>RangeMap</code> in O(N) time (where N<br>
is the size of the <code>RangeMap</code>).</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Set <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> keys<span class="token punctuation">(</span>RangeMap<span class="token punctuation">)</span>                      <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>RANGEMAP<span class="token punctuation">.</span>keys<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="range-map-keys-as-list">Range map keys (as <code>List</code>)</h3>

<p>You can get a <code>List</code> of all the ranges in a <code>RangeMap</code> in O(N) time (where N<br>
is the size of the <code>RangeMap</code>).</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> List <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;keys_list&quot;</span> <span class="token string">&quot;(&quot;</span> RangeMap <span class="token string">&quot;)&quot;</span>       <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>RANGEMAP<span class="token punctuation">.</span>keys_list<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="range-map-key-membership">Range map key membership</h3>

<p>You can check whether a key is present in a <code>RangeMap</code> in O(log(N)) time (where<br>
N is the size of the <code>RangeMap</code>).</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> KItem <span class="token string">&quot;in_keys&quot;</span> <span class="token string">&quot;(&quot;</span> RangeMap <span class="token string">&quot;)&quot;</span>       <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>RANGEMAP<span class="token punctuation">.</span>in_keys<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="range-map-values-as-list">Range map values (as <code>List</code>)</h3>

<p>You can get a <code>List</code> of all values in a <code>RangeMap</code> in O(N) time (where N is the<br>
size of the <code>RangeMap</code>).</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> List <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> values<span class="token punctuation">(</span>RangeMap<span class="token punctuation">)</span>                   <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>RANGEMAP<span class="token punctuation">.</span>values<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="range-map-size">Range map size</h3>

<p>You can get the number of range/value pairs in a <code>RangeMap</code> in O(1) time.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> size<span class="token punctuation">(</span>RangeMap<span class="token punctuation">)</span>                      <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>RANGEMAP<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>sizeRangeMap<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="range-map-inclusion">Range map inclusion</h3>

<p>You can determine whether a <code>RangeMap</code> is a strict subset of another <code>RangeMap</code><br>
in O(M+N) time (where M is the size of the first <code>RangeMap</code> and N is the size<br>
of the second <code>RangeMap</code>). Only keys within equal or overlapping ranges that<br>
are bound to the same value are considered equal.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> RangeMap <span class="token string">&quot;&lt;=RangeMap&quot;</span> RangeMap               <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>RANGEMAP<span class="token punctuation">.</span>inclusion<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="range-map-choice">Range map choice</h3>

<p>You can get an arbitrarily chosen key of a <code>RangeMap</code> in O(1) time. The same<br>
key will always be returned for the same range map, but no guarantee is given<br>
that two different range maps will return the same element, even if they are<br>
similar.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> choice<span class="token punctuation">(</span>RangeMap<span class="token punctuation">)</span>                      <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>RANGEMAP<span class="token punctuation">.</span>choice<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>RangeMap<span class="token punctuation">:</span>choice<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><h2>Sets</h2>
<p>Provided here is the syntax of an implementation of immutable, associative,<br>
commutative sets of <code>KItem</code>. This type is hooked to an implementation of sets<br>
provided by the backend. For more information on matching on sets and allowable<br>
patterns for doing so, refer to K&apos;s<br>
<a href="file:///home/runner/work/k/k/gh-pages/k-distribution/include/kframework/builtin/USER_MANUAL.md">user documentation</a>.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> SET
  <span class="token keyword keyword-imports">imports</span> private INT<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> private BASIC<span class="token operator">-</span>K

  <span class="token keyword keyword-syntax">syntax</span> Set <span class="token punctuation">[</span>hook<span class="token punctuation">(</span>SET<span class="token punctuation">.</span>Set<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="set-concatenation">Set concatenation</h3>

<p>The <code>Set</code> sort represents a mathematical set (A collection of unique items).<br>
The sets are nilpotent, i.e., the concatenation of two sets containing elements<br>
in common is <code>#False</code> (note however, this may be silently allowed during<br>
concrete execution). If you intend to add an element to a set that might<br>
already be present in the set, use the <code>|Set</code> operator instead.</p>
<p>The concatenation operator is O(N<em>log(M)) where N is the size of the smaller<br>
set, when it appears on the right hand side. When it appears on the left hand<br>
side and all variables are bound, it is O(N</em>log(M)) where M is the size of the<br>
set it is matching and N is the number of elements being matched. When it<br>
appears on the left hand side containing variables not bound elsewhere in the<br>
term, it is O(N^K) where N is the size of the set it is matching and K is the<br>
number of unbound keys being mached. In other words, one unbound variable is<br>
linear, two is quadratic, three is cubic, etc.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Set <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Set Set                  <span class="token punctuation">[</span><span class="token class-name">left</span><span class="token punctuation">,</span> function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>SET<span class="token punctuation">.</span>concat<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_Set_<span class="token punctuation">)</span><span class="token punctuation">,</span> assoc<span class="token punctuation">,</span> comm<span class="token punctuation">,</span> unit<span class="token punctuation">(</span><span class="token punctuation">.</span>Set<span class="token punctuation">)</span><span class="token punctuation">,</span> idem<span class="token punctuation">,</span> element<span class="token punctuation">(</span>SetItem<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">format</span><span class="token punctuation">(</span><span class="token operator">%</span><span class="token number">1</span><span class="token operator">%</span>n<span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="set-unit">Set unit</h3>

<p>The set with zero elements is represented by <code>.Set</code>.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Set <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;.Set&quot;</span>                   <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>SET<span class="token punctuation">.</span>unit<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span><span class="token punctuation">.</span>Set<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="set-elements">Set elements</h3>

<p>An element of a <code>Set</code> is constructed via the <code>SetItem</code> operator.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Set <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> SetItem<span class="token punctuation">(</span>KItem<span class="token punctuation">)</span>               <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>SET<span class="token punctuation">.</span>element<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>SetItem<span class="token punctuation">)</span><span class="token punctuation">,</span> injective<span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="set-union">Set union</h3>

<p>You can compute the union of two sets in O(N*log(M)) time (Where N is the size<br>
of the smaller set). Note that the base of the logarithm is a relatively high<br>
number and thus the time is effectively linear. The union consists of all the<br>
elements present in either set.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Set <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Set <span class="token string">&quot;|Set&quot;</span> Set              <span class="token punctuation">[</span><span class="token class-name">left</span><span class="token punctuation">,</span> function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>SET<span class="token punctuation">.</span>union<span class="token punctuation">)</span><span class="token punctuation">,</span> comm<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> S1<span class="token punctuation">:</span>Set <span class="token operator">|</span>Set S2<span class="token punctuation">:</span>Set <span class="token operator">=&gt;</span> S1 <span class="token punctuation">(</span>S2 <span class="token operator">-</span>Set S1<span class="token punctuation">)</span> <span class="token punctuation">[</span>concrete<span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="set-intersection">Set intersection</h3>

<p>You can compute the intersection of two sets in O(N*log(M)) time (where N<br>
is the size of the smaller set), or effectively linear. The intersection<br>
consists of all the elements present in both sets.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Set <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> intersectSet<span class="token punctuation">(</span>Set<span class="token punctuation">,</span> Set<span class="token punctuation">)</span>   <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>SET<span class="token punctuation">.</span>intersection<span class="token punctuation">)</span><span class="token punctuation">,</span> comm<span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="set-complement">Set complement</h3>

<p>You can compute the relative complement of two sets in O(N*log(M)) time (where<br>
N is the size of the second set), or effectively linear. This is the set of<br>
elements in the first set that are not present in the second set.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Set <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Set <span class="token string">&quot;-Set&quot;</span> Set           <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>SET<span class="token punctuation">.</span>difference<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>Set<span class="token punctuation">:</span>difference<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="set-membership">Set membership</h3>

<p>You can compute whether an element is a member of a set in O(1) time.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> KItem <span class="token string">&quot;in&quot;</span> Set              <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>SET<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>Set<span class="token punctuation">:</span>in<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="set-inclusion">Set inclusion</h3>

<p>You can determine whether a <code>Set</code> is a strict subset of another <code>Set</code> in O(N)<br>
time (where N is the size of the first set).</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Set <span class="token string">&quot;&lt;=Set&quot;</span> Set         <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>SET<span class="token punctuation">.</span>inclusion<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="set-size">Set size</h3>

<p>You can get the number of elements (the cardinality) of a set in O(1) time.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> size<span class="token punctuation">(</span>Set<span class="token punctuation">)</span>                <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>SET<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="set-choice">Set choice</h3>

<p>You can get an arbitrarily chosen element of a <code>Set</code> in O(1) time. The same<br>
element will always be returned for the same set, but no guarantee is given<br>
that two different sets will return the same element, even if they are similar.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> choice<span class="token punctuation">(</span>Set<span class="token punctuation">)</span>                <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>SET<span class="token punctuation">.</span>choice<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>Set<span class="token punctuation">:</span>choice<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-endmodule">endmodule</span>
</pre><h3 class="mume-header" id="implementation-of-sets">Implementation of Sets</h3>

<p>The following lemmas are simplifications that the Haskell backend can<br>
apply to simplify expressions of sort <code>Set</code>.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> SET<span class="token operator">-</span>KORE<span class="token operator">-</span>SYMBOLIC <span class="token punctuation">[</span>symbolic<span class="token punctuation">,</span>haskell<span class="token punctuation">]</span>
  <span class="token keyword keyword-imports">imports</span> SET
  <span class="token keyword keyword-imports">imports</span> private K<span class="token operator">-</span>EQUAL
  <span class="token keyword keyword-imports">imports</span> private BOOL

  <span class="token comment">//Temporarly rule for #Ceil simplification, should be generated in front-end</span>

<span class="token comment">// Matching for this version not implemented.</span>
  <span class="token comment">// rule #Ceil(@S1:Set @S2:Set) =&gt;</span>
  <span class="token comment">//        {intersectSet(@S1, @S2) #Equals .Set} #And #Ceil(@S1) #And #Ceil(@S2)</span>
  <span class="token comment">//   [simplification]</span>

<span class="token comment">//simpler version</span>
  <span class="token keyword keyword-rule">rule</span> #Ceil<span class="token punctuation">(</span>@S<span class="token punctuation">:</span>Set SetItem<span class="token punctuation">(</span>@E<span class="token punctuation">:</span>KItem<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
         <span class="token punctuation">{</span><span class="token punctuation">(</span>@E in @S<span class="token punctuation">)</span> #Equals <span class="token boolean">false</span><span class="token punctuation">}</span> #And #Ceil<span class="token punctuation">(</span>@S<span class="token punctuation">)</span> #And #Ceil<span class="token punctuation">(</span>@E<span class="token punctuation">)</span>
    <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>

  <span class="token comment">// -Set simplifications</span>
  <span class="token keyword keyword-rule">rule</span> S              <span class="token operator">-</span>Set <span class="token punctuation">.</span>Set           <span class="token operator">=&gt;</span> S          <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">.</span>Set           <span class="token operator">-</span>Set  _             <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Set       <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> SetItem<span class="token punctuation">(</span>X<span class="token punctuation">)</span>     <span class="token operator">-</span>Set <span class="token punctuation">(</span>S SetItem<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Set
                               ensures notBool <span class="token punctuation">(</span>X in S<span class="token punctuation">)</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> S              <span class="token operator">-</span>Set <span class="token punctuation">(</span>S SetItem<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Set
                               ensures notBool <span class="token punctuation">(</span>X in S<span class="token punctuation">)</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>S SetItem<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span>Set S              <span class="token operator">=&gt;</span> SetItem<span class="token punctuation">(</span>X<span class="token punctuation">)</span>
                               ensures notBool <span class="token punctuation">(</span>X in S<span class="token punctuation">)</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>S SetItem<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span>Set SetItem<span class="token punctuation">(</span>X<span class="token punctuation">)</span>     <span class="token operator">=&gt;</span> S
                               ensures notBool <span class="token punctuation">(</span>X in S<span class="token punctuation">)</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token comment">// rule SetItem(X)     -Set S              =&gt; SetItem(X)</span>
  <span class="token comment">//                            requires notBool (X in S)  [simplification]</span>
  <span class="token comment">// rule (S1 SetItem(X)) -Set (S2 SetItem(X))  =&gt; S1 -Set S2</span>
  <span class="token comment">//                             ensures notBool (X in S1)</span>
  <span class="token comment">//                             andBool notBool (X in S2) [simplification]</span>



  <span class="token comment">// |Set simplifications</span>
  <span class="token keyword keyword-rule">rule</span> S    <span class="token operator">|</span>Set <span class="token punctuation">.</span>Set <span class="token operator">=&gt;</span> S    <span class="token punctuation">[</span>simplification<span class="token punctuation">,</span> comm<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> S    <span class="token operator">|</span>Set S    <span class="token operator">=&gt;</span> S    <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>S SetItem<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">|</span>Set SetItem<span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> S SetItem<span class="token punctuation">(</span>X<span class="token punctuation">)</span>
                             ensures notBool <span class="token punctuation">(</span>X in S<span class="token punctuation">)</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">,</span> comm<span class="token punctuation">]</span>
  <span class="token comment">// Currently disabled, see runtimeverification/haskell-backend#3301</span>
  <span class="token comment">// rule (S SetItem(X)) |Set S          =&gt; S SetItem(X)</span>
  <span class="token comment">//                            ensures notBool (X in S) [simplification, comm]</span>

  <span class="token comment">// intersectSet simplifications</span>
  <span class="token keyword keyword-rule">rule</span> intersectSet<span class="token punctuation">(</span><span class="token punctuation">.</span>Set<span class="token punctuation">,</span> _   <span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Set    <span class="token punctuation">[</span>simplification<span class="token punctuation">,</span> comm<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> intersectSet<span class="token punctuation">(</span> S  <span class="token punctuation">,</span> S   <span class="token punctuation">)</span> <span class="token operator">=&gt;</span>  S      <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> intersectSet<span class="token punctuation">(</span> S SetItem<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">,</span> SetItem<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token operator">=&gt;</span> SetItem<span class="token punctuation">(</span>X<span class="token punctuation">)</span>
                                                        ensures notBool <span class="token punctuation">(</span>X in S<span class="token punctuation">)</span>      <span class="token punctuation">[</span>simplification<span class="token punctuation">,</span> comm<span class="token punctuation">]</span>
  <span class="token comment">// Currently disabled, see runtimeverification/haskell-backend#3294</span>
  <span class="token comment">// rule intersectSet( S SetItem(X) , S)             =&gt; S ensures notBool (X in S)      [simplification, comm]</span>
  <span class="token keyword keyword-rule">rule</span> intersectSet<span class="token punctuation">(</span> S1 SetItem<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">,</span> S2 SetItem<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> intersectSet<span class="token punctuation">(</span>S1<span class="token punctuation">,</span> S2<span class="token punctuation">)</span> SetItem<span class="token punctuation">(</span>X<span class="token punctuation">)</span>
                                                        ensures notBool <span class="token punctuation">(</span>X in S1<span class="token punctuation">)</span>
                                                        andBool notBool <span class="token punctuation">(</span>X in S2<span class="token punctuation">)</span>     <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>

  <span class="token comment">// membership simplifications</span>
  <span class="token keyword keyword-rule">rule</span> _E in <span class="token punctuation">.</span>Set           <span class="token operator">=&gt;</span> <span class="token boolean">false</span>   <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> E  in <span class="token punctuation">(</span>S SetItem<span class="token punctuation">(</span>E<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
              ensures notBool <span class="token punctuation">(</span>E in S<span class="token punctuation">)</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>

<span class="token comment">// These two rules would be sound but impose a giant overhead on `in` evaluation:</span>
  <span class="token comment">// rule E1 in (S SetItem(E2)) =&gt; true requires E1 in S</span>
  <span class="token comment">//                                 ensures notBool (E2 in S) [simplification]</span>
  <span class="token comment">// rule E1 in (S SetItem(E2)) =&gt; E1 in S requires E1 =/=K E2</span>
  <span class="token comment">//                                 ensures notBool (E2 in S) [simplification]</span>

  <span class="token keyword keyword-rule">rule</span> X in <span class="token punctuation">(</span><span class="token punctuation">(</span>SetItem<span class="token punctuation">(</span>X<span class="token punctuation">)</span> S<span class="token punctuation">)</span> <span class="token operator">|</span>Set  _            <span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
                                    ensures notBool <span class="token punctuation">(</span>X in S<span class="token punctuation">)</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> X in <span class="token punctuation">(</span> _             <span class="token operator">|</span>Set <span class="token punctuation">(</span>SetItem<span class="token punctuation">(</span>X<span class="token punctuation">)</span> S<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
                                    ensures notBool <span class="token punctuation">(</span>X in S<span class="token punctuation">)</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>

<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> SET<span class="token operator">-</span>SYMBOLIC
  <span class="token keyword keyword-imports">imports</span> SET<span class="token operator">-</span>KORE<span class="token operator">-</span>SYMBOLIC
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><h2>Lists</h2>
<p>Provided here is the syntax of an implementation of immutable, associative<br>
lists of <code>KItem</code>. This type is hooked to an implementation of lists provided<br>
by the backend. For more information on matching on lists and allowable<br>
patterns for doing so, refer to K&apos;s<br>
<a href="file:///home/runner/work/k/k/gh-pages/k-distribution/include/kframework/builtin/USER_MANUAL.md">user documentation</a>.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> LIST
  <span class="token keyword keyword-imports">imports</span> private INT<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> private MINT<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> private BASIC<span class="token operator">-</span>K

  <span class="token keyword keyword-syntax">syntax</span> List <span class="token punctuation">[</span>hook<span class="token punctuation">(</span>LIST<span class="token punctuation">.</span>List<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="list-concatenation">List concatenation</h3>

<p>The <code>List</code> sort is an ordered collection that may contain duplicate elements.<br>
They are backed by relaxed radix balanced trees, which means that they support<br>
efficiently adding elements to both sides of the list, concatenating two lists,<br>
indexing, and updating elements.</p>
<p>The concatenation operator is O(log(N)) (where N is the size of the longer<br>
list) when it appears on the right hand side. When it appears on the left hand<br>
side, it is O(N), where N is the number of elements matched on the front and<br>
back of the list.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> List <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List List               <span class="token punctuation">[</span><span class="token class-name">left</span><span class="token punctuation">,</span> function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>LIST<span class="token punctuation">.</span>concat<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_List_<span class="token punctuation">)</span><span class="token punctuation">,</span> smtlib<span class="token punctuation">(</span>smt_seq_concat<span class="token punctuation">)</span><span class="token punctuation">,</span> assoc<span class="token punctuation">,</span> unit<span class="token punctuation">(</span><span class="token punctuation">.</span>List<span class="token punctuation">)</span><span class="token punctuation">,</span> element<span class="token punctuation">(</span>ListItem<span class="token punctuation">)</span><span class="token punctuation">,</span> update<span class="token punctuation">(</span>List<span class="token punctuation">:</span>set<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">format</span><span class="token punctuation">(</span><span class="token operator">%</span><span class="token number">1</span><span class="token operator">%</span>n<span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="list-unit">List unit</h3>

<p>The list with zero elements is represented by <code>.List</code>.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> List <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;.List&quot;</span>                 <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>LIST<span class="token punctuation">.</span>unit<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span><span class="token punctuation">.</span>List<span class="token punctuation">)</span><span class="token punctuation">,</span> smtlib<span class="token punctuation">(</span>smt_seq_nil<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="list-elements">List elements</h3>

<p>An element of a <code>List</code> is constucted via the <code>ListItem</code> operator.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> List <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> ListItem<span class="token punctuation">(</span>KItem<span class="token punctuation">)</span>             <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>LIST<span class="token punctuation">.</span>element<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>ListItem<span class="token punctuation">)</span><span class="token punctuation">,</span> smtlib<span class="token punctuation">(</span>smt_seq_elem<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="list-prepend">List prepend</h3>

<p>An element can be added to the front of a <code>List</code> using the <code>pushList</code> operator.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> List <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> pushList<span class="token punctuation">(</span>KItem<span class="token punctuation">,</span> List<span class="token punctuation">)</span>       <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>LIST<span class="token punctuation">.</span>push<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>pushList<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> pushList<span class="token punctuation">(</span>K<span class="token punctuation">:</span><span class="token punctuation">:</span>KItem<span class="token punctuation">,</span> L1<span class="token punctuation">:</span><span class="token punctuation">:</span>List<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> ListItem<span class="token punctuation">(</span>K<span class="token punctuation">)</span> L1
</pre><h3 class="mume-header" id="list-indexing">List indexing</h3>

<p>You can get an element of a list by its integer offset in O(log(N)) time, or<br>
effectively constant. Positive <code>Int</code> indices are 0-indexed from the beginning of the<br>
list, and negative indices are -1-indexed from the end of the list. In other<br>
words, 0 is the first element and -1 is the last element. The indice can also be<br>
<code>MInt</code>, which is interprested as an unsigned integer, and therefore, don&apos;t support<br>
negative indices feature. Currently, only 64-bit and 256-bit <code>MInt</code> types are supported.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List <span class="token string">&quot;[&quot;</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;]&quot;</span>           <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>LIST<span class="token punctuation">.</span>get<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>List<span class="token punctuation">:</span>get<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>Width<span class="token punctuation">}</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List <span class="token string">&quot;[&quot;</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token string">&quot;]&quot;</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>LIST<span class="token punctuation">.</span>getMInt<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>List<span class="token punctuation">:</span>getMInt<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="list-update">List update</h3>

<p>You can create a new <code>List</code> with a new value at a particular index in<br>
O(log(N)) time, or effectively constant. The index can be either as an <code>Int</code> or as an <code>MInt</code>. Currently, only 64-bit <code>MInt</code> type is supported.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> List <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List <span class="token string">&quot;[&quot;</span> index<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;&lt;-&quot;</span> value<span class="token punctuation">:</span> KItem <span class="token string">&quot;]&quot;</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>LIST<span class="token punctuation">.</span>update<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>List<span class="token punctuation">:</span>set<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>Width<span class="token punctuation">}</span> List <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List <span class="token string">&quot;[&quot;</span> index<span class="token punctuation">:</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token string">&quot;&lt;-&quot;</span> value<span class="token punctuation">:</span> KItem <span class="token string">&quot;]&quot;</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>LIST<span class="token punctuation">.</span>updateMInt<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>List<span class="token punctuation">:</span>setMInt<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="list-of-identical-elements">List of identical elements</h3>

<p>You can create a list with <code>length</code> elements, each containing <code>value</code>, in O(N)<br>
time.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> List <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> makeList<span class="token punctuation">(</span>length<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> value<span class="token punctuation">:</span> KItem<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>LIST<span class="token punctuation">.</span>make<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="multiple-list-update">Multiple list update</h3>

<p>You can create a new <code>List</code> which is equal to <code>dest</code> except the <code>N</code> elements<br>
starting at <code>index</code> are replaced with the contents of <code>src</code> in O(N*log(K)) time<br>
(where <code>K</code> is the size of <code>dest</code>and <code>N</code> is the size of <code>src</code>), or effectively linear. Having <code>index + N &gt; K</code> yields an exception.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> List <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> updateList<span class="token punctuation">(</span>dest<span class="token punctuation">:</span> List<span class="token punctuation">,</span> index<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> src<span class="token punctuation">:</span> List<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>LIST<span class="token punctuation">.</span>updateAll<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="list-fill">List fill</h3>

<p>You can create a new <code>List</code> where the <code>length</code> elements starting at <code>index</code><br>
are replaced with <code>value</code>, in O(length*log(N)) time, or effectively linear.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> List <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> fillList<span class="token punctuation">(</span>List<span class="token punctuation">,</span> index<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> length<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> value<span class="token punctuation">:</span> KItem<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>LIST<span class="token punctuation">.</span>fill<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="list-slicing">List slicing</h3>

<p>You can compute a new <code>List</code> by removing <code>fromFront</code> elements from the front<br>
of the list and <code>fromBack</code> elements from the back of the list in<br>
O((fromFront+fromBack)*log(N)) time, or effectively linear.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> List <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> range<span class="token punctuation">(</span>List<span class="token punctuation">,</span> fromFront<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> fromBack<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span>   <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>LIST<span class="token punctuation">.</span>range<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>List<span class="token punctuation">:</span>range<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="list-membership">List membership</h3>

<p>You can compute whether an element is in a list in O(N) time. For repeated<br>
comparisons, it is much better to first convert to a set using <code>List2Set</code>.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> KItem <span class="token string">&quot;in&quot;</span> List             <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>LIST<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_inList_<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="list-size">List size</h3>

<p>You can get the number of elements of a list in O(1) time. The output<br>
size can be either as an <code>Int</code> or as an <code>MInt</code>. Currently, only 64-bit<br>
and 256-bit <code>MInt</code> types are supported. When using <code>MInt</code>, the size is<br>
interpreted as an unsigned integer, and the size of the list must match<br>
the bounds of this <code>MInt</code> type, that is the size can&apos;t be larger than<br>
<code>2^64 - 1</code> for <code>MInt{64}</code> and <code>2^256 - 1</code> for <code>MInt{256}</code>.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> size<span class="token punctuation">(</span>List<span class="token punctuation">)</span>               <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>LIST<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>sizeList<span class="token punctuation">)</span><span class="token punctuation">,</span> smtlib<span class="token punctuation">(</span>smt_seq_len<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>Width<span class="token punctuation">}</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> size<span class="token punctuation">(</span>List<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>LIST<span class="token punctuation">.</span>sizeMInt<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>sizeMInt<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-endmodule">endmodule</span>
</pre><h2>Collection Conversions</h2>
<p>It is possible to convert from a <code>List</code> to a <code>Set</code> or from a <code>Set</code> to a list.<br>
Converting from a <code>List</code> to a <code>Set</code> and back will not provide the same list;<br>
duplicates will have been removed and the list may be reordered. Converting<br>
from a <code>Set</code> to a <code>List</code> and back will generate the same set.</p>
<p>Note that because sets are unordered and lists are ordered, converting from a<br>
Set to a List will generate some arbitrary ordering of elements, which may<br>
be different from the natural ordering you might assume, or may not. Two<br>
equal sets are guaranteed to generate the same ordering, but no guarantee is<br>
otherwise provided about what the ordering will be. In particular, adding an<br>
element to a set may completely reorder the elements already in the set, when<br>
it is converted to a list.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> COLLECTIONS
  <span class="token keyword keyword-imports">imports</span> LIST
  <span class="token keyword keyword-imports">imports</span> SET
  <span class="token keyword keyword-imports">imports</span> MAP

  <span class="token keyword keyword-syntax">syntax</span> List <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Set2List<span class="token punctuation">(</span>Set<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>SET<span class="token punctuation">.</span>set2list<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Set <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List2Set<span class="token punctuation">(</span>List<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>SET<span class="token punctuation">.</span>list2set<span class="token punctuation">)</span><span class="token punctuation">]</span>

<span class="token keyword keyword-endmodule">endmodule</span>
</pre><h2>Booleans</h2>
<p>Provided here is the syntax of an implementation of boolean algebra in K.<br>
This type is hooked to an implementation of booleans provided by the backend.<br>
Note that this algebra is different from the builtin truth in matching logic.<br>
You can, however, convert from the truth of the <code>Bool</code> sort to the truth in<br>
matching logic via the expression <code>{B #Equals true}</code>.</p>
<p>The boolean values are <code>true</code> and <code>false</code>.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> SORT<span class="token operator">-</span>BOOL
  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">[</span>hook<span class="token punctuation">(</span>BOOL<span class="token punctuation">.</span><span class="token keyword keyword-Bool">Bool</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> BOOL<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> SORT<span class="token operator">-</span>BOOL
  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;true&quot;</span>  <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;false&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> BOOL<span class="token operator">-</span>COMMON
  <span class="token keyword keyword-imports">imports</span> private BASIC<span class="token operator">-</span>K
  <span class="token keyword keyword-imports">imports</span> BOOL<span class="token operator">-</span>SYNTAX
</pre><h3 class="mume-header" id="basic-boolean-arithmetic">Basic boolean arithmetic</h3>

<p>You can:</p>
<ul>
<li>Negate a boolean value.</li>
<li>AND two boolean values.</li>
<li>XOR two boolean values.</li>
<li>OR two boolean values.</li>
<li>IMPLIES two boolean values (i.e., <code>P impliesBool Q</code> is the same as<br>
<code>notBool P orBool Q</code>)</li>
<li>Check equality of two boolean values.</li>
<li>Check inequality of two boolean values.</li>
</ul>
<p>Note that only <code>andThenBool</code> and <code>orElseBool</code> are short-circuiting. <code>andBool</code><br>
and <code>orBool</code> may be short-circuited in concrete backends, but in symbolic<br>
backends, both arguments will be evaluated.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;notBool&quot;</span> <span class="token keyword keyword-Bool">Bool</span>          <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>notBool_<span class="token punctuation">)</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>not<span class="token punctuation">)</span><span class="token punctuation">,</span> group<span class="token punctuation">(</span>boolOperation<span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>BOOL<span class="token punctuation">.</span>not<span class="token punctuation">)</span><span class="token punctuation">]</span>
                &gt; <span class="token keyword keyword-Bool">Bool</span> <span class="token string">&quot;andBool&quot;</span> <span class="token keyword keyword-Bool">Bool</span>     <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_andBool_<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>and<span class="token punctuation">)</span><span class="token punctuation">,</span> group<span class="token punctuation">(</span>boolOperation<span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>BOOL<span class="token punctuation">.</span>and<span class="token punctuation">)</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token string">&quot;andThenBool&quot;</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_andThenBool_<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>and<span class="token punctuation">)</span><span class="token punctuation">,</span> group<span class="token punctuation">(</span>boolOperation<span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>BOOL<span class="token punctuation">.</span>andThen<span class="token punctuation">)</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token string">&quot;xorBool&quot;</span> <span class="token keyword keyword-Bool">Bool</span>     <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_xorBool_<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>xor<span class="token punctuation">)</span><span class="token punctuation">,</span> group<span class="token punctuation">(</span>boolOperation<span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>BOOL<span class="token punctuation">.</span>xor<span class="token punctuation">)</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token string">&quot;orBool&quot;</span> <span class="token keyword keyword-Bool">Bool</span>      <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_orBool_<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>or<span class="token punctuation">)</span><span class="token punctuation">,</span> group<span class="token punctuation">(</span>boolOperation<span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>BOOL<span class="token punctuation">.</span>or<span class="token punctuation">)</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token string">&quot;orElseBool&quot;</span> <span class="token keyword keyword-Bool">Bool</span>  <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_orElseBool_<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>or<span class="token punctuation">)</span><span class="token punctuation">,</span> group<span class="token punctuation">(</span>boolOperation<span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>BOOL<span class="token punctuation">.</span>orElse<span class="token punctuation">)</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token string">&quot;impliesBool&quot;</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_impliesBool_<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span><span class="token operator">=&gt;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> group<span class="token punctuation">(</span>boolOperation<span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>BOOL<span class="token punctuation">.</span>implies<span class="token punctuation">)</span><span class="token punctuation">]</span>
                &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                  <span class="token keyword keyword-Bool">Bool</span> <span class="token string">&quot;==Bool&quot;</span> <span class="token keyword keyword-Bool">Bool</span>      <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_<span class="token operator">==</span>Bool_<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> comm<span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span><span class="token operator">=</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>BOOL<span class="token punctuation">.</span>eq<span class="token punctuation">)</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token string">&quot;=/=Bool&quot;</span> <span class="token keyword keyword-Bool">Bool</span>     <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_<span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>Bool_<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> comm<span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>distinct<span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>BOOL<span class="token punctuation">.</span>ne<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="implementation-of-booleans">Implementation of Booleans</h3>

<p>The remainder of this section consists of an implementation in K of the<br>
operations listed above.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> notBool <span class="token boolean">true</span> <span class="token operator">=&gt;</span> <span class="token boolean">false</span>
  <span class="token keyword keyword-rule">rule</span> notBool <span class="token boolean">false</span> <span class="token operator">=&gt;</span> <span class="token boolean">true</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">true</span> andBool B<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span> <span class="token operator">=&gt;</span> B<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span>
  <span class="token keyword keyword-rule">rule</span> B<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span> andBool <span class="token boolean">true</span> <span class="token operator">=&gt;</span> B<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">false</span> andBool _<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span> <span class="token operator">=&gt;</span> <span class="token boolean">false</span>
  <span class="token keyword keyword-rule">rule</span> _<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span> andBool <span class="token boolean">false</span> <span class="token operator">=&gt;</span> <span class="token boolean">false</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">true</span> andThenBool K<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span> <span class="token operator">=&gt;</span> K
  <span class="token keyword keyword-rule">rule</span> K<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span> andThenBool <span class="token boolean">true</span> <span class="token operator">=&gt;</span> K <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">false</span> andThenBool _ <span class="token operator">=&gt;</span> <span class="token boolean">false</span>
  <span class="token keyword keyword-rule">rule</span> _ andThenBool <span class="token boolean">false</span> <span class="token operator">=&gt;</span> <span class="token boolean">false</span>  <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">false</span> xorBool B<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span> <span class="token operator">=&gt;</span> B<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span>
  <span class="token keyword keyword-rule">rule</span> B<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span> xorBool <span class="token boolean">false</span> <span class="token operator">=&gt;</span> B<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> B<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span> xorBool B<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span> <span class="token operator">=&gt;</span> <span class="token boolean">false</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">true</span> orBool _<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span> <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
  <span class="token keyword keyword-rule">rule</span> _<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span> orBool <span class="token boolean">true</span> <span class="token operator">=&gt;</span> <span class="token boolean">true</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">false</span> orBool B<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span> <span class="token operator">=&gt;</span> B
  <span class="token keyword keyword-rule">rule</span> B<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span> orBool <span class="token boolean">false</span> <span class="token operator">=&gt;</span> B   <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">true</span> orElseBool _ <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
  <span class="token keyword keyword-rule">rule</span> _ orElseBool <span class="token boolean">true</span> <span class="token operator">=&gt;</span> <span class="token boolean">true</span>     <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">false</span> orElseBool K<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span> <span class="token operator">=&gt;</span> K
  <span class="token keyword keyword-rule">rule</span> K<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span> orElseBool <span class="token boolean">false</span> <span class="token operator">=&gt;</span> K <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">true</span> impliesBool B<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span> <span class="token operator">=&gt;</span> B
  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">false</span> impliesBool _<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span> <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
  <span class="token keyword keyword-rule">rule</span> _<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span> impliesBool <span class="token boolean">true</span> <span class="token operator">=&gt;</span> <span class="token boolean">true</span>       <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> B<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span> impliesBool <span class="token boolean">false</span> <span class="token operator">=&gt;</span> notBool B <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> B1<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span> <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span><span class="token keyword keyword-Bool">Bool</span> B2<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span> <span class="token operator">=&gt;</span> notBool <span class="token punctuation">(</span>B1 <span class="token operator">==</span><span class="token keyword keyword-Bool">Bool</span> B2<span class="token punctuation">)</span>
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> BOOL<span class="token operator">-</span>KORE <span class="token punctuation">[</span>symbolic<span class="token punctuation">]</span>
  <span class="token keyword keyword-imports">imports</span> BOOL<span class="token operator">-</span>COMMON

  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">{</span><span class="token boolean">true</span> #Equals notBool @B<span class="token punctuation">}</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token boolean">false</span> #Equals @B<span class="token punctuation">}</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">{</span>notBool @B #Equals <span class="token boolean">true</span><span class="token punctuation">}</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>@B #Equals <span class="token boolean">false</span><span class="token punctuation">}</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">{</span><span class="token boolean">false</span> #Equals notBool @B<span class="token punctuation">}</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token boolean">true</span> #Equals @B<span class="token punctuation">}</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">{</span>notBool @B #Equals <span class="token boolean">false</span><span class="token punctuation">}</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>@B #Equals <span class="token boolean">true</span><span class="token punctuation">}</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">{</span><span class="token boolean">true</span> #Equals @B1 andBool @B2<span class="token punctuation">}</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token boolean">true</span> #Equals @B1<span class="token punctuation">}</span> #And <span class="token punctuation">{</span><span class="token boolean">true</span> #Equals @B2<span class="token punctuation">}</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">{</span>@B1 andBool @B2 #Equals <span class="token boolean">true</span><span class="token punctuation">}</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>@B1 #Equals <span class="token boolean">true</span><span class="token punctuation">}</span> #And <span class="token punctuation">{</span>@B2 #Equals <span class="token boolean">true</span><span class="token punctuation">}</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">{</span><span class="token boolean">false</span> #Equals @B1 orBool @B2<span class="token punctuation">}</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token boolean">false</span> #Equals @B1<span class="token punctuation">}</span> #And <span class="token punctuation">{</span><span class="token boolean">false</span> #Equals @B2<span class="token punctuation">}</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">{</span>@B1 orBool @B2 #Equals <span class="token boolean">false</span><span class="token punctuation">}</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>@B1 #Equals <span class="token boolean">false</span><span class="token punctuation">}</span> #And <span class="token punctuation">{</span>@B2 #Equals <span class="token boolean">false</span><span class="token punctuation">}</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> BOOL
  <span class="token keyword keyword-imports">imports</span> BOOL<span class="token operator">-</span>COMMON
  <span class="token keyword keyword-imports">imports</span> BOOL<span class="token operator">-</span>KORE
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><h2>Integers</h2>
<p>Provided here is the syntax of an implementation of arbitrary-precision<br>
integer arithmetic in K. This type is hooked to an implementation of integers<br>
provided by the backend. For a fixed-width integer type, see the <code>MINT</code> module<br>
below.</p>
<p>The <code>UNSIGNED-INT-SYNTAX</code> module provides a syntax of whole numbers in K.<br>
This is useful because often programming languages implement the sign of an<br>
integer as a unary operator rather than part of the lexical syntax of integers.<br>
However, you can also directly reference integers with a sign using the<br>
<code>INT-SYNTAX</code> module.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> UNSIGNED<span class="token operator">-</span>INT<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">[</span>hook<span class="token punctuation">(</span>INT<span class="token punctuation">.</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> r<span class="token string">&quot;[0-9]+&quot;</span> <span class="token punctuation">[</span><span class="token class-name">prefer</span><span class="token punctuation">,</span> <span class="token class-name">token</span><span class="token punctuation">,</span> prec<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> INT<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> UNSIGNED<span class="token operator">-</span>INT<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> r<span class="token string">&quot;[\\+\\-]?[0-9]+&quot;</span> <span class="token punctuation">[</span><span class="token class-name">prefer</span><span class="token punctuation">,</span> <span class="token class-name">token</span><span class="token punctuation">,</span> prec<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> INT<span class="token operator">-</span>COMMON
  <span class="token keyword keyword-imports">imports</span> INT<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> private BOOL
</pre><h3 class="mume-header" id="integer-arithmetic">Integer arithmetic</h3>

<p>You can:</p>
<ul>
<li>Compute the bitwise complement <code>~Int</code> of an integer value in twos-complement.</li>
<li>Compute the exponentiation <code>^Int</code> of two integers.</li>
<li>Compute the exponentiation of two integers modulo another integer (<code>^%Int</code>).<br>
<code>A ^%Int B C</code> is equal in value to <code>(A ^Int B) %Int C</code>, but has a better<br>
asymptotic complexity.</li>
<li>Compute the product <code>*Int</code> of two integers.</li>
<li>Compute the quotient <code>/Int</code> or modulus <code>%Int</code> of two integers using<br>
t-division, which rounds towards zero. Division by zero is <code>#False</code>.</li>
<li>Compute the quotient <code>divInt</code> or modulus <code>modInt</code> of two integers using<br>
Euclidean division, in which the remainder is always non-negative. Division<br>
by zero is <code>#False</code>.</li>
<li>Compute the sum <code>+Int</code> or difference <code>-Int</code> of two integers.</li>
<li>Compute the arithmetic right shift <code>&gt;&gt;Int</code> of two integers. Shifting by a<br>
negative quantity is <code>#False</code>.</li>
<li>Compute the left shift of two integers. Shifting by a negative quantity is<br>
<code>#False</code>.</li>
<li>Compute the bitwise and of two integers in twos-complement.</li>
<li>Compute the bitwise xor of two integers in twos-complement.</li>
<li>Compute the bitwise inclusive-or of two integers in twos-complement.</li>
</ul>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;~Int&quot;</span> <span class="token keyword keyword-Int">Int</span>                     <span class="token punctuation">[</span>function<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span><span class="token operator">~</span>Int_<span class="token punctuation">)</span><span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>INT<span class="token punctuation">.</span>not<span class="token punctuation">)</span><span class="token punctuation">,</span> smtlib<span class="token punctuation">(</span>notInt<span class="token punctuation">)</span><span class="token punctuation">]</span>
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                 <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;^Int&quot;</span> <span class="token keyword keyword-Int">Int</span>                 <span class="token punctuation">[</span>function<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_<span class="token operator">^</span>Int_<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span><span class="token operator">^</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>INT<span class="token punctuation">.</span>pow<span class="token punctuation">)</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;^%Int&quot;</span> <span class="token keyword keyword-Int">Int</span> <span class="token keyword keyword-Int">Int</span>            <span class="token punctuation">[</span>function<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_<span class="token operator">^</span><span class="token operator">%</span>Int__<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span><span class="token punctuation">(</span>mod <span class="token punctuation">(</span><span class="token operator">^</span> #<span class="token number">1</span> #<span class="token number">2</span><span class="token punctuation">)</span> #<span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>INT<span class="token punctuation">.</span>powmod<span class="token punctuation">)</span><span class="token punctuation">]</span>
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                 <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;*Int&quot;</span> <span class="token keyword keyword-Int">Int</span>                 <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_<span class="token operator">*</span>Int_<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> comm<span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>INT<span class="token punctuation">.</span>mul<span class="token punctuation">)</span><span class="token punctuation">]</span>
               <span class="token comment">/* FIXME: translate /Int and %Int into smtlib */</span>
               <span class="token comment">/* /Int and %Int implement t-division, which rounds towards 0. SMT hooks need to convert from Euclidian division operations */</span>
               <span class="token operator">|</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;/Int&quot;</span> <span class="token keyword keyword-Int">Int</span>                 <span class="token punctuation">[</span>function<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_<span class="token operator">/</span>Int_<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span>
                                                 smt<span class="token operator">-</span>hook<span class="token punctuation">(</span><span class="token punctuation">(</span>ite <span class="token punctuation">(</span>or <span class="token punctuation">(</span><span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">(</span>mod #<span class="token number">1</span> #<span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">&gt;=</span> #<span class="token number">1</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>div #<span class="token number">1</span> #<span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>ite <span class="token punctuation">(</span>&gt; #<span class="token number">2</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token punctuation">(</span>div #<span class="token number">1</span> #<span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">-</span> <span class="token punctuation">(</span>div #<span class="token number">1</span> #<span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                                 hook<span class="token punctuation">(</span>INT<span class="token punctuation">.</span>tdiv<span class="token punctuation">)</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;%Int&quot;</span> <span class="token keyword keyword-Int">Int</span>                 <span class="token punctuation">[</span>function<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_<span class="token operator">%</span>Int_<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span>
                                                 smt<span class="token operator">-</span>hook<span class="token punctuation">(</span><span class="token punctuation">(</span>ite <span class="token punctuation">(</span>or <span class="token punctuation">(</span><span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">(</span>mod #<span class="token number">1</span> #<span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">&gt;=</span> #<span class="token number">1</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>mod #<span class="token number">1</span> #<span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>ite <span class="token punctuation">(</span>&gt; #<span class="token number">2</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">-</span> <span class="token punctuation">(</span>mod #<span class="token number">1</span> #<span class="token number">2</span><span class="token punctuation">)</span> #<span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token punctuation">(</span>mod #<span class="token number">1</span> #<span class="token number">2</span><span class="token punctuation">)</span> #<span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                                 hook<span class="token punctuation">(</span>INT<span class="token punctuation">.</span>tmod<span class="token punctuation">)</span><span class="token punctuation">]</span>
               <span class="token comment">/* divInt and modInt implement e-division according to the Euclidean division theorem, therefore the remainder is always positive */</span>
               <span class="token operator">|</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;divInt&quot;</span> <span class="token keyword keyword-Int">Int</span>               <span class="token punctuation">[</span>function<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_divInt_<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>div<span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>INT<span class="token punctuation">.</span>ediv<span class="token punctuation">)</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;modInt&quot;</span> <span class="token keyword keyword-Int">Int</span>               <span class="token punctuation">[</span>function<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_modInt_<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>mod<span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>INT<span class="token punctuation">.</span>emod<span class="token punctuation">)</span><span class="token punctuation">]</span>
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                 <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;+Int&quot;</span> <span class="token keyword keyword-Int">Int</span>                 <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_<span class="token operator">+</span>Int_<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> comm<span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>INT<span class="token punctuation">.</span>add<span class="token punctuation">)</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;-Int&quot;</span> <span class="token keyword keyword-Int">Int</span>                 <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_<span class="token operator">-</span>Int_<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span><span class="token operator">-</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>INT<span class="token punctuation">.</span>sub<span class="token punctuation">)</span><span class="token punctuation">]</span>
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                 <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;&gt;&gt;Int&quot;</span> <span class="token keyword keyword-Int">Int</span>                <span class="token punctuation">[</span>function<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_&gt;&gt;Int_<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>INT<span class="token punctuation">.</span>shr<span class="token punctuation">)</span><span class="token punctuation">,</span> smtlib<span class="token punctuation">(</span>shrInt<span class="token punctuation">)</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;&lt;&lt;Int&quot;</span> <span class="token keyword keyword-Int">Int</span>                <span class="token punctuation">[</span>function<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_&lt;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Int_),</span> <span class="token attr-name">left,</span> <span class="token attr-name">hook(INT.shl),</span> <span class="token attr-name">smtlib(shlInt)]</span>
               <span class="token punctuation">&gt;</span></span> <span class="token class-name">left</span><span class="token punctuation">:</span>
                 <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;&amp;Int&quot;</span> <span class="token keyword keyword-Int">Int</span>                 <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_<span class="token operator">&amp;</span>Int_<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> comm<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>INT<span class="token punctuation">.</span>and<span class="token punctuation">)</span><span class="token punctuation">,</span> smtlib<span class="token punctuation">(</span>andInt<span class="token punctuation">)</span><span class="token punctuation">]</span>
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                 <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;xorInt&quot;</span> <span class="token keyword keyword-Int">Int</span>               <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_xorInt_<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> comm<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>INT<span class="token punctuation">.</span>xor<span class="token punctuation">)</span><span class="token punctuation">,</span> smtlib<span class="token punctuation">(</span>xorInt<span class="token punctuation">)</span><span class="token punctuation">]</span>
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                 <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;|Int&quot;</span> <span class="token keyword keyword-Int">Int</span>                 <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_<span class="token operator">|</span>Int_<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> comm<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>INT<span class="token punctuation">.</span>or<span class="token punctuation">)</span><span class="token punctuation">,</span> smtlib<span class="token punctuation">(</span>orInt<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="integer-minimum-and-maximum">Integer minimum and maximum</h3>

<p>You can compute the minimum and maximum <code>minInt</code> and <code>maxInt</code> of two integers.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;minInt&quot;</span> <span class="token string">&quot;(&quot;</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;,&quot;</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;)&quot;</span>   <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span><span class="token punctuation">(</span>ite <span class="token punctuation">(</span>&lt; #<span class="token number">1</span> #<span class="token number">2</span><span class="token punctuation">)</span> #<span class="token number">1</span> #<span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>INT<span class="token punctuation">.</span>min<span class="token punctuation">)</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;maxInt&quot;</span> <span class="token string">&quot;(&quot;</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;,&quot;</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;)&quot;</span>   <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span><span class="token punctuation">(</span>ite <span class="token punctuation">(</span>&lt; #<span class="token number">1</span> #<span class="token number">2</span><span class="token punctuation">)</span> #<span class="token number">2</span> #<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>INT<span class="token punctuation">.</span>max<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="absolute-value">Absolute value</h3>

<p>You can compute the absolute value <code>absInt</code> of an integer.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> absInt <span class="token punctuation">(</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">)</span>                 <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span><span class="token punctuation">(</span>ite <span class="token punctuation">(</span>&lt; #<span class="token number">1</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">-</span> <span class="token number">0</span> #<span class="token number">1</span><span class="token punctuation">)</span> #<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>INT<span class="token punctuation">.</span>abs<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="log-base-2">Log base 2</h3>

<p>You can compute the log base 2, rounded towards zero, of an integer. The log<br>
base 2 of an integer is equal to the index of the highest bit set in the<br>
representation of a positive integer. Log base 2 of zero or a negative number<br>
is <code>#False</code>.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> log2Int <span class="token punctuation">(</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">)</span>                <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>INT<span class="token punctuation">.</span>log2<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="bit-slicing">Bit slicing</h3>

<p>You can compute the value of a range of bits in the twos-complement<br>
representation of an integer, as interpeted either unsigned or signed, of an<br>
integer. <code>index</code> is offset from 0 and <code>length</code> is the number of bits, starting<br>
with <code>index</code>, that should be read. The number is assumed to be represented<br>
in little endian notation with each byte going from least significant to<br>
most significant. In other words, 0 is the least-significant bit, and each<br>
successive bit is more significant than the last.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> bitRangeInt           <span class="token punctuation">(</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> index<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> length<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>INT<span class="token punctuation">.</span>bitRange<span class="token punctuation">)</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> signExtendBitRangeInt <span class="token punctuation">(</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> index<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> length<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>INT<span class="token punctuation">.</span>signExtendBitRange<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="integer-comparisons">Integer comparisons</h3>

<p>You can compute whether two integers are less than or equal to, less than,<br>
greater than or equal to, greater than, equal, or unequal to another integer.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;&lt;=Int&quot;</span> <span class="token keyword keyword-Int">Int</span>         <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_<span class="token operator">&lt;=</span>Int_<span class="token punctuation">)</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span><span class="token operator">&lt;=</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>INT<span class="token punctuation">.</span>le<span class="token punctuation">)</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;&lt;Int&quot;</span> <span class="token keyword keyword-Int">Int</span>          <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Int_),</span> <span class="token attr-name">smt-hook(&lt;),</span> <span class="token attr-name">hook(INT.lt)]</span>
                <span class="token attr-name">|</span> <span class="token attr-name">Int</span> <span class="token attr-name">&quot;</span><span class="token punctuation">&gt;</span></span><span class="token operator">=</span><span class="token keyword keyword-Int">Int</span>&quot; <span class="token keyword keyword-Int">Int</span>         <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_<span class="token operator">&gt;=</span>Int_<span class="token punctuation">)</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span><span class="token operator">&gt;=</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>INT<span class="token punctuation">.</span>ge<span class="token punctuation">)</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;&gt;Int&quot;</span> <span class="token keyword keyword-Int">Int</span>          <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_&gt;Int_<span class="token punctuation">)</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>&gt;<span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>INT<span class="token punctuation">.</span>gt<span class="token punctuation">)</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;==Int&quot;</span> <span class="token keyword keyword-Int">Int</span>         <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_<span class="token operator">==</span>Int_<span class="token punctuation">)</span><span class="token punctuation">,</span> comm<span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span><span class="token operator">=</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>INT<span class="token punctuation">.</span>eq<span class="token punctuation">)</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;=/=Int&quot;</span> <span class="token keyword keyword-Int">Int</span>        <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_<span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>Int_<span class="token punctuation">)</span><span class="token punctuation">,</span> comm<span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>distinct<span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>INT<span class="token punctuation">.</span>ne<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="divides">Divides</h3>

<p>You can compute whether one integer evenly divides another. This is the<br>
case when the second integer modulo the first integer is equal to zero.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;dividesInt&quot;</span> <span class="token keyword keyword-Int">Int</span>    <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="random-integers">Random integers</h3>

<p>You can, on concrete backends, compute a pseudorandom integer, or seed the<br>
pseudorandom number generator. These operations are represented as<br>
uninterpreted functions on symbolic backends.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> randInt<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>INT<span class="token punctuation">.</span>rand<span class="token punctuation">)</span><span class="token punctuation">,</span> impure<span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> K <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> srandInt<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>INT<span class="token punctuation">.</span>srand<span class="token punctuation">)</span><span class="token punctuation">,</span> impure<span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="implementation-of-integers">Implementation of Integers</h3>

<p>The remainder of this section consists of an implementation in K of some<br>
of the operators above, as well as lemmas used  by the Java and Haskell backend<br>
to simplify expressions of sort <code>Int</code>. They do not affect the semantics of<br>
integers, merely describing additional rules that the backend can use to<br>
simplify terms.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> INT<span class="token operator">-</span>SYMBOLIC <span class="token punctuation">[</span>symbolic<span class="token punctuation">]</span>
  <span class="token keyword keyword-imports">imports</span> INT<span class="token operator">-</span>COMMON
  <span class="token keyword keyword-imports">imports</span> INT<span class="token operator">-</span>SYMBOLIC<span class="token operator">-</span>KORE
  <span class="token keyword keyword-imports">imports</span> private BOOL

  <span class="token comment">// Arithmetic Normalization</span>
  <span class="token keyword keyword-rule">rule</span> I <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">0</span> <span class="token operator">=&gt;</span> I <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> I <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> <span class="token number">0</span> <span class="token operator">=&gt;</span> I <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> X modInt N <span class="token operator">=&gt;</span> X <span class="token keyword keyword-requires">requires</span> <span class="token number">0</span> <span class="token operator">&lt;=</span><span class="token keyword keyword-Int">Int</span> X andBool X &lt;<span class="token keyword keyword-Int">Int</span> N <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> X   <span class="token operator">%</span><span class="token keyword keyword-Int">Int</span> N <span class="token operator">=&gt;</span> X <span class="token keyword keyword-requires">requires</span> <span class="token number">0</span> <span class="token operator">&lt;=</span><span class="token keyword keyword-Int">Int</span> X andBool X &lt;<span class="token keyword keyword-Int">Int</span> N <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>

  <span class="token comment">// Bit-shifts</span>
  <span class="token keyword keyword-rule">rule</span> X &lt;&lt;<span class="token keyword keyword-Int">Int</span> <span class="token number">0</span> <span class="token operator">=&gt;</span> X                    <span class="token punctuation">[</span>simplification<span class="token punctuation">,</span> preserves<span class="token operator">-</span>definedness<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token number">0</span> &lt;&lt;<span class="token keyword keyword-Int">Int</span> Y <span class="token operator">=&gt;</span> <span class="token number">0</span> <span class="token keyword keyword-requires">requires</span> <span class="token number">0</span> <span class="token operator">&lt;=</span><span class="token keyword keyword-Int">Int</span> Y <span class="token punctuation">[</span>simplification<span class="token punctuation">,</span> preserves<span class="token operator">-</span>definedness<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> X &gt;&gt;<span class="token keyword keyword-Int">Int</span> <span class="token number">0</span> <span class="token operator">=&gt;</span> X                    <span class="token punctuation">[</span>simplification<span class="token punctuation">,</span> preserves<span class="token operator">-</span>definedness<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token number">0</span> &gt;&gt;<span class="token keyword keyword-Int">Int</span> Y <span class="token operator">=&gt;</span> <span class="token number">0</span> <span class="token keyword keyword-requires">requires</span> <span class="token number">0</span> <span class="token operator">&lt;=</span><span class="token keyword keyword-Int">Int</span> Y <span class="token punctuation">[</span>simplification<span class="token punctuation">,</span> preserves<span class="token operator">-</span>definedness<span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> INT<span class="token operator">-</span>SYMBOLIC<span class="token operator">-</span>KORE <span class="token punctuation">[</span>symbolic<span class="token punctuation">,</span> haskell<span class="token punctuation">]</span>
  <span class="token keyword keyword-imports">imports</span> INT<span class="token operator">-</span>COMMON
  <span class="token keyword keyword-imports">imports</span> ML<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> private BOOL

  <span class="token comment">// Definability Conditions</span>
  <span class="token keyword keyword-rule">rule</span> #Ceil<span class="token punctuation">(</span>@I1<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">/</span><span class="token keyword keyword-Int">Int</span>   @I2<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">(</span>@I2 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span><span class="token keyword keyword-Int">Int</span> <span class="token number">0</span><span class="token punctuation">)</span> #Equals <span class="token boolean">true</span><span class="token punctuation">}</span> #And #Ceil<span class="token punctuation">(</span>@I1<span class="token punctuation">)</span> #And #Ceil<span class="token punctuation">(</span>@I2<span class="token punctuation">)</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> #Ceil<span class="token punctuation">(</span>@I1<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">%</span><span class="token keyword keyword-Int">Int</span>   @I2<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">(</span>@I2 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span><span class="token keyword keyword-Int">Int</span> <span class="token number">0</span><span class="token punctuation">)</span> #Equals <span class="token boolean">true</span><span class="token punctuation">}</span> #And #Ceil<span class="token punctuation">(</span>@I1<span class="token punctuation">)</span> #And #Ceil<span class="token punctuation">(</span>@I2<span class="token punctuation">)</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> #Ceil<span class="token punctuation">(</span>@I1<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> modInt @I2<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">(</span>@I2 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span><span class="token keyword keyword-Int">Int</span> <span class="token number">0</span><span class="token punctuation">)</span> #Equals <span class="token boolean">true</span><span class="token punctuation">}</span> #And #Ceil<span class="token punctuation">(</span>@I1<span class="token punctuation">)</span> #And #Ceil<span class="token punctuation">(</span>@I2<span class="token punctuation">)</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> #Ceil<span class="token punctuation">(</span>@I1<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> &gt;&gt;<span class="token keyword keyword-Int">Int</span>  @I2<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">(</span>@I2 <span class="token operator">&gt;=</span><span class="token keyword keyword-Int">Int</span> <span class="token number">0</span><span class="token punctuation">)</span>  #Equals <span class="token boolean">true</span><span class="token punctuation">}</span> #And #Ceil<span class="token punctuation">(</span>@I1<span class="token punctuation">)</span> #And #Ceil<span class="token punctuation">(</span>@I2<span class="token punctuation">)</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> #Ceil<span class="token punctuation">(</span>@I1<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> &lt;&lt;<span class="token keyword keyword-Int">Int</span>  @I2<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">(</span>@I2 <span class="token operator">&gt;=</span><span class="token keyword keyword-Int">Int</span> <span class="token number">0</span><span class="token punctuation">)</span>  #Equals <span class="token boolean">true</span><span class="token punctuation">}</span> #And #Ceil<span class="token punctuation">(</span>@I1<span class="token punctuation">)</span> #And #Ceil<span class="token punctuation">(</span>@I2<span class="token punctuation">)</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> INT<span class="token operator">-</span>KORE <span class="token punctuation">[</span>symbolic<span class="token punctuation">]</span>
  <span class="token keyword keyword-imports">imports</span> private K<span class="token operator">-</span>EQUAL
  <span class="token keyword keyword-imports">imports</span> private BOOL
  <span class="token keyword keyword-imports">imports</span> INT<span class="token operator">-</span>COMMON

  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">[</span>eq<span class="token operator">-</span>k<span class="token operator">-</span>to<span class="token operator">-</span>eq<span class="token operator">-</span>int<span class="token punctuation">]</span>     <span class="token punctuation">:</span> I1<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">==</span>K I2<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span>            <span class="token operator">=&gt;</span> I1 <span class="token operator">==</span><span class="token keyword keyword-Int">Int</span> I2           <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">[</span>eq<span class="token operator">-</span>int<span class="token operator">-</span><span class="token boolean">true</span><span class="token operator">-</span><span class="token class-name">left</span><span class="token punctuation">]</span>   <span class="token punctuation">:</span> <span class="token punctuation">{</span>K1 <span class="token operator">==</span><span class="token keyword keyword-Int">Int</span> K2 #Equals <span class="token boolean">true</span><span class="token punctuation">}</span>   <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>K1 #Equals K2<span class="token punctuation">}</span>       <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">[</span>eq<span class="token operator">-</span>int<span class="token operator">-</span><span class="token boolean">true</span><span class="token operator">-</span>rigth<span class="token punctuation">]</span>  <span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token boolean">true</span> #Equals K1 <span class="token operator">==</span><span class="token keyword keyword-Int">Int</span> K2<span class="token punctuation">}</span>   <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>K1 #Equals K2<span class="token punctuation">}</span>       <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">[</span>eq<span class="token operator">-</span>int<span class="token operator">-</span><span class="token boolean">false</span><span class="token operator">-</span><span class="token class-name">left</span><span class="token punctuation">]</span>  <span class="token punctuation">:</span> <span class="token punctuation">{</span>K1 <span class="token operator">==</span><span class="token keyword keyword-Int">Int</span> K2 #Equals <span class="token boolean">false</span><span class="token punctuation">}</span>  <span class="token operator">=&gt;</span> #Not<span class="token punctuation">(</span><span class="token punctuation">{</span>K1 #Equals K2<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">[</span>eq<span class="token operator">-</span>int<span class="token operator">-</span><span class="token boolean">false</span><span class="token operator">-</span>rigth<span class="token punctuation">]</span> <span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token boolean">false</span> #Equals K1 <span class="token operator">==</span><span class="token keyword keyword-Int">Int</span> K2<span class="token punctuation">}</span>  <span class="token operator">=&gt;</span> #Not<span class="token punctuation">(</span><span class="token punctuation">{</span>K1 #Equals K2<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">[</span>neq<span class="token operator">-</span>int<span class="token operator">-</span><span class="token boolean">true</span><span class="token operator">-</span><span class="token class-name">left</span><span class="token punctuation">]</span>  <span class="token punctuation">:</span> <span class="token punctuation">{</span>K1 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span><span class="token keyword keyword-Int">Int</span> K2 #Equals <span class="token boolean">true</span><span class="token punctuation">}</span>  <span class="token operator">=&gt;</span> #Not<span class="token punctuation">(</span><span class="token punctuation">{</span>K1 #Equals K2<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">[</span>neq<span class="token operator">-</span>int<span class="token operator">-</span><span class="token boolean">true</span><span class="token operator">-</span><span class="token class-name">right</span><span class="token punctuation">]</span> <span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token boolean">true</span> #Equals K1 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span><span class="token keyword keyword-Int">Int</span> K2<span class="token punctuation">}</span>  <span class="token operator">=&gt;</span> #Not<span class="token punctuation">(</span><span class="token punctuation">{</span>K1 #Equals K2<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">[</span>neq<span class="token operator">-</span>int<span class="token operator">-</span><span class="token boolean">false</span><span class="token operator">-</span><span class="token class-name">left</span><span class="token punctuation">]</span> <span class="token punctuation">:</span> <span class="token punctuation">{</span>K1 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span><span class="token keyword keyword-Int">Int</span> K2 #Equals <span class="token boolean">false</span><span class="token punctuation">}</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>K1 #Equals K2<span class="token punctuation">}</span>       <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">[</span>neq<span class="token operator">-</span>int<span class="token operator">-</span><span class="token boolean">false</span><span class="token operator">-</span><span class="token class-name">right</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token boolean">false</span> #Equals K1 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span><span class="token keyword keyword-Int">Int</span> K2<span class="token punctuation">}</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>K1 #Equals K2<span class="token punctuation">}</span>       <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>

  <span class="token comment">// Arithmetic Normalization</span>
  <span class="token keyword keyword-rule">rule</span> I <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> B <span class="token operator">=&gt;</span> B <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> I          <span class="token punctuation">[</span>concrete<span class="token punctuation">(</span>I<span class="token punctuation">)</span><span class="token punctuation">,</span> symbolic<span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">,</span> simplification<span class="token punctuation">(</span><span class="token number">51</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> A <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> I <span class="token operator">=&gt;</span> A <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> I<span class="token punctuation">)</span> <span class="token punctuation">[</span>concrete<span class="token punctuation">(</span>I<span class="token punctuation">)</span><span class="token punctuation">,</span> symbolic<span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">,</span> simplification<span class="token punctuation">(</span><span class="token number">51</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>A <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> I2<span class="token punctuation">)</span> <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> I3 <span class="token operator">=&gt;</span> A <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">(</span>I2 <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> I3<span class="token punctuation">)</span> <span class="token punctuation">[</span>concrete<span class="token punctuation">(</span>I2<span class="token punctuation">,</span> I3<span class="token punctuation">)</span><span class="token punctuation">,</span> symbolic<span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">,</span> simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">(</span>B <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> I3<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> B <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">(</span>I1 <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> I3<span class="token punctuation">)</span> <span class="token punctuation">[</span>concrete<span class="token punctuation">(</span>I1<span class="token punctuation">,</span> I3<span class="token punctuation">)</span><span class="token punctuation">,</span> symbolic<span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">,</span> simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">(</span>B <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> I3<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>I1 <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> I3<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> B <span class="token punctuation">[</span>concrete<span class="token punctuation">(</span>I1<span class="token punctuation">,</span> I3<span class="token punctuation">)</span><span class="token punctuation">,</span> symbolic<span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">,</span> simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">(</span>I2 <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> C<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>I1 <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> I2<span class="token punctuation">)</span> <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> C <span class="token punctuation">[</span>concrete<span class="token punctuation">(</span>I1<span class="token punctuation">,</span> I2<span class="token punctuation">)</span><span class="token punctuation">,</span> symbolic<span class="token punctuation">(</span>C<span class="token punctuation">)</span><span class="token punctuation">,</span> simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">(</span>I2 <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> C<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>I1 <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> I2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> C <span class="token punctuation">[</span>concrete<span class="token punctuation">(</span>I1<span class="token punctuation">,</span> I2<span class="token punctuation">)</span><span class="token punctuation">,</span> symbolic<span class="token punctuation">(</span>C<span class="token punctuation">)</span><span class="token punctuation">,</span> simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>I1 <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> B<span class="token punctuation">)</span> <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> I3 <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>I1 <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> I3<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> B <span class="token punctuation">[</span>concrete<span class="token punctuation">(</span>I1<span class="token punctuation">,</span> I3<span class="token punctuation">)</span><span class="token punctuation">,</span> symbolic<span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">,</span> simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">(</span>I2 <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> C<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>I1 <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> I2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> C <span class="token punctuation">[</span>concrete<span class="token punctuation">(</span>I1<span class="token punctuation">,</span> I2<span class="token punctuation">)</span><span class="token punctuation">,</span> symbolic<span class="token punctuation">(</span>C<span class="token punctuation">)</span><span class="token punctuation">,</span> simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">(</span>I2 <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> C<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>I1 <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> I2<span class="token punctuation">)</span> <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> C <span class="token punctuation">[</span>concrete<span class="token punctuation">(</span>I1<span class="token punctuation">,</span> I2<span class="token punctuation">)</span><span class="token punctuation">,</span> symbolic<span class="token punctuation">(</span>C<span class="token punctuation">)</span><span class="token punctuation">,</span> simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>C <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> I2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> I3 <span class="token operator">=&gt;</span> C <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">(</span>I2 <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> I3<span class="token punctuation">)</span> <span class="token punctuation">[</span>concrete<span class="token punctuation">(</span>I2<span class="token punctuation">,</span> I3<span class="token punctuation">)</span><span class="token punctuation">,</span> symbolic<span class="token punctuation">(</span>C<span class="token punctuation">)</span><span class="token punctuation">,</span> simplification<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">&amp;</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">(</span>I2 <span class="token operator">&amp;</span><span class="token keyword keyword-Int">Int</span> C<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>I1 <span class="token operator">&amp;</span><span class="token keyword keyword-Int">Int</span> I2<span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token keyword keyword-Int">Int</span> C <span class="token punctuation">[</span>concrete<span class="token punctuation">(</span>I1<span class="token punctuation">,</span> I2<span class="token punctuation">)</span><span class="token punctuation">,</span> symbolic<span class="token punctuation">(</span>C<span class="token punctuation">)</span><span class="token punctuation">,</span> simplification<span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> INT
  <span class="token keyword keyword-imports">imports</span> INT<span class="token operator">-</span>COMMON
  <span class="token keyword keyword-imports">imports</span> INT<span class="token operator">-</span>SYMBOLIC
  <span class="token keyword keyword-imports">imports</span> INT<span class="token operator">-</span>KORE
  <span class="token keyword keyword-imports">imports</span> private K<span class="token operator">-</span>EQUAL
  <span class="token keyword keyword-imports">imports</span> private BOOL

  <span class="token keyword keyword-rule">rule</span> bitRangeInt<span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> IDX<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> LEN<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>I &gt;&gt;<span class="token keyword keyword-Int">Int</span> IDX<span class="token punctuation">)</span> modInt <span class="token punctuation">(</span><span class="token number">1</span> &lt;&lt;<span class="token keyword keyword-Int">Int</span> LEN<span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> signExtendBitRangeInt<span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> IDX<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> LEN<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>bitRangeInt<span class="token punctuation">(</span>I<span class="token punctuation">,</span> IDX<span class="token punctuation">,</span> LEN<span class="token punctuation">)</span> <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">(</span><span class="token number">1</span> &lt;&lt;<span class="token keyword keyword-Int">Int</span> <span class="token punctuation">(</span>LEN <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> modInt <span class="token punctuation">(</span><span class="token number">1</span> &lt;&lt;<span class="token keyword keyword-Int">Int</span> LEN<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">(</span><span class="token number">1</span> &lt;&lt;<span class="token keyword keyword-Int">Int</span> <span class="token punctuation">(</span>LEN <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> I1<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> divInt I2<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>I1 <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">(</span>I1 modInt I2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span><span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-requires">requires</span> I2 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span><span class="token keyword keyword-Int">Int</span> <span class="token number">0</span>
  <span class="token keyword keyword-rule">rule</span>
    I1<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> modInt I2<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span>
  <span class="token operator">=&gt;</span>
    <span class="token punctuation">(</span><span class="token punctuation">(</span>I1 <span class="token operator">%</span><span class="token keyword keyword-Int">Int</span> absInt<span class="token punctuation">(</span>I2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> absInt<span class="token punctuation">(</span>I2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token keyword keyword-Int">Int</span> absInt<span class="token punctuation">(</span>I2<span class="token punctuation">)</span>
  <span class="token keyword keyword-requires">requires</span> I2 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span><span class="token keyword keyword-Int">Int</span> <span class="token number">0</span>    <span class="token punctuation">[</span>concrete<span class="token punctuation">,</span> simplification<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> minInt<span class="token punctuation">(</span>I1<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> I2<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> I1 <span class="token keyword keyword-requires">requires</span> I1 &lt;<span class="token keyword keyword-Int">Int</span>  I2
  <span class="token keyword keyword-rule">rule</span> minInt<span class="token punctuation">(</span>I1<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> I2<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> I2 <span class="token keyword keyword-requires">requires</span> I1 <span class="token operator">&gt;=</span><span class="token keyword keyword-Int">Int</span> I2

  <span class="token keyword keyword-rule">rule</span> I1<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span><span class="token keyword keyword-Int">Int</span> I2<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">=&gt;</span> notBool <span class="token punctuation">(</span>I1 <span class="token operator">==</span><span class="token keyword keyword-Int">Int</span> I2<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>I1<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> dividesInt I2<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>I2 <span class="token operator">%</span><span class="token keyword keyword-Int">Int</span> I1<span class="token punctuation">)</span> <span class="token operator">==</span><span class="token keyword keyword-Int">Int</span> <span class="token number">0</span>

  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> freshInt<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span>    <span class="token punctuation">[</span>freshGenerator<span class="token punctuation">,</span> function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> private<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> freshInt<span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> I
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><h2>IEEE 754 Floating-point Numbers</h2>
<p>Provided here is the syntax of an implementation of arbitrary-precision<br>
floating-point arithmetic in K based on a generalization of the IEEE 754<br>
standard. This type is hooked to an implementation of floats provided by the<br>
backend.</p>
<p>The syntax of ordinary floating-point values in K consists of an optional sign<br>
(+ or -) followed by an optional integer part, followed by a decimal point,<br>
followed by an optional fractional part. Either the integer part or the<br>
fractional part must be specified. The mantissa is followed by an optional<br>
exponent part, which consists of an <code>e</code> or <code>E</code>, an optional sign (+ or -),<br>
and an integer. The expoennt is followed by an optional suffix, which can be<br>
either <code>f</code>, <code>F</code>, <code>d</code>, <code>D</code>, or <code>pNxM</code> where <code>N</code> and <code>M</code> are positive integers.<br>
<code>p</code> and <code>x</code> can be either upper or lowercase.</p>
<p>The value of a floating-point literal is computed as follows: First the<br>
mantissa is read as a rational number. Then it is multiplied by 10 to the<br>
power of the exponent, which is interpreted as an integer, and defaults to<br>
zero if it is not present. Finally, it is rounded to the nearest possible<br>
value in a floating-point type represented like an IEEE754 floating-point type,<br>
with the number of bits of precision and exponent specified by the suffix.<br>
A suffix of <code>f</code> or <code>f</code> represents the IEEE <code>binary32</code> format. A suffix of <code>d</code><br>
or <code>D</code>, or no suffix, represents the IEEE <code>binary64</code> format. A suffix of<br>
<code>pNxM</code> (either upper or lowercase) specifies exactly <code>N</code> bits of precision and<br>
<code>M</code> bits of exponent. The number of bits of precision is assumed to include<br>
any optional <code>1</code> that precedes the IEEE 754 mantissa. In other words, <code>p24x8</code><br>
is equal to the IEEE <code>binary32</code> format, and <code>p53x11</code> is equal to the IEEE<br>
<code>binary64</code> format.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> FLOAT<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Float">Float</span> <span class="token punctuation">[</span>hook<span class="token punctuation">(</span>FLOAT<span class="token punctuation">.</span><span class="token keyword keyword-Float">Float</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Float">Float</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> r<span class="token string">&quot;([\\+\\-]?[0-9]+(\\.[0-9]*)?|\\.[0-9]+)([eE][\\+\\-]?[0-9]+)?([fFdD]|([pP][0-9]+[xX][0-9]+))?&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">,</span> prec<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Float">Float</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> r<span class="token string">&quot;[\\+\\-]?Infinity([fFdD]|([pP][0-9]+[xX][0-9]+))?&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">,</span> prec<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Float">Float</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> r<span class="token string">&quot;NaN([fFdD]|([pP][0-9]+[xX][0-9]+))?&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">,</span> prec<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> FLOAT
  <span class="token keyword keyword-imports">imports</span> FLOAT<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> private BOOL
  <span class="token keyword keyword-imports">imports</span> private INT<span class="token operator">-</span>SYNTAX
</pre><h3 class="mume-header" id="float-precision">Float precision</h3>

<p>You can retrieve the number of bits of precision in a <code>Float</code>.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> precisionFloat<span class="token punctuation">(</span><span class="token keyword keyword-Float">Float</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FLOAT<span class="token punctuation">.</span>precision<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="float-exponent-bits">Float exponent bits</h3>

<p>You can retrieve the number of bits of exponent range in a <code>Float</code>.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> exponentBitsFloat<span class="token punctuation">(</span><span class="token keyword keyword-Float">Float</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FLOAT<span class="token punctuation">.</span>exponentBits<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="float-exponent">Float exponent</h3>

<p>You can retrieve the value of the exponent bits of a <code>Float</code> as an integer.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> exponentFloat<span class="token punctuation">(</span><span class="token keyword keyword-Float">Float</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FLOAT<span class="token punctuation">.</span>exponent<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="float-sign">Float sign</h3>

<p>You can retrieve the value of the sign bit of a <code>Float</code> as a boolean. True<br>
means the sign bit is set.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> signFloat<span class="token punctuation">(</span><span class="token keyword keyword-Float">Float</span><span class="token punctuation">)</span>      <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FLOAT<span class="token punctuation">.</span>sign<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="float-special-values">Float special values</h3>

<p>You can check whether a <code>Float</code> value is infinite or Not-a-Number.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> isNaN<span class="token punctuation">(</span><span class="token keyword keyword-Float">Float</span><span class="token punctuation">)</span>          <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>fp<span class="token punctuation">.</span>isNaN<span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FLOAT<span class="token punctuation">.</span>isNaN<span class="token punctuation">)</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> isInfinite<span class="token punctuation">(</span><span class="token keyword keyword-Float">Float</span><span class="token punctuation">)</span>     <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="float-arithmetic">Float arithmetic</h3>

<p>You can:</p>
<ul>
<li>Compute the unary negation <code>--Float</code> of a float. <code>--Float X</code> is distinct<br>
from <code>0.0 -Float X</code>. For example, <code>0.0 -Float 0.0</code> is positive zero.<br>
<code>--Float 0.0</code> is negative zero.</li>
<li>Compute the exponentation <code>^Float</code> of two floats.</li>
<li>Compute the product <code>*Float</code>, quotient <code>/Float</code>, or remainder <code>%Float</code> of two<br>
floats. The remainder is computed based on rounding the quotient of the two<br>
floats to the nearest integer.</li>
<li>Compute the sum <code>+Float</code> or difference <code>-Float</code> of two floats.</li>
</ul>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Float">Float</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;--Float&quot;</span> <span class="token keyword keyword-Float">Float</span>             <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>fp<span class="token punctuation">.</span>neg<span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FLOAT<span class="token punctuation">.</span>neg<span class="token punctuation">)</span><span class="token punctuation">]</span>
                 &gt; <span class="token keyword keyword-Float">Float</span> <span class="token string">&quot;^Float&quot;</span> <span class="token keyword keyword-Float">Float</span>        <span class="token punctuation">[</span>function<span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FLOAT<span class="token punctuation">.</span>pow<span class="token punctuation">)</span><span class="token punctuation">]</span>
                 &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                   <span class="token keyword keyword-Float">Float</span> <span class="token string">&quot;*Float&quot;</span> <span class="token keyword keyword-Float">Float</span>        <span class="token punctuation">[</span>function<span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span><span class="token punctuation">(</span>fp<span class="token punctuation">.</span>mul roundNearestTiesToEven #<span class="token number">1</span> #<span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FLOAT<span class="token punctuation">.</span>mul<span class="token punctuation">)</span><span class="token punctuation">]</span>
                 <span class="token operator">|</span> <span class="token keyword keyword-Float">Float</span> <span class="token string">&quot;/Float&quot;</span> <span class="token keyword keyword-Float">Float</span>        <span class="token punctuation">[</span>function<span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span><span class="token punctuation">(</span>fp<span class="token punctuation">.</span>div roundNearestTiesToEven #<span class="token number">1</span> #<span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FLOAT<span class="token punctuation">.</span>div<span class="token punctuation">)</span><span class="token punctuation">]</span>
                 <span class="token operator">|</span> <span class="token keyword keyword-Float">Float</span> <span class="token string">&quot;%Float&quot;</span> <span class="token keyword keyword-Float">Float</span>        <span class="token punctuation">[</span>function<span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span><span class="token punctuation">(</span>fp<span class="token punctuation">.</span>rem roundNearestTiesToEven #<span class="token number">1</span> #<span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FLOAT<span class="token punctuation">.</span>rem<span class="token punctuation">)</span><span class="token punctuation">]</span>
                 &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                   <span class="token keyword keyword-Float">Float</span> <span class="token string">&quot;+Float&quot;</span> <span class="token keyword keyword-Float">Float</span>        <span class="token punctuation">[</span>function<span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span><span class="token punctuation">(</span>fp<span class="token punctuation">.</span>add roundNearestTiesToEven #<span class="token number">1</span> #<span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FLOAT<span class="token punctuation">.</span>add<span class="token punctuation">)</span><span class="token punctuation">]</span>
                 <span class="token operator">|</span> <span class="token keyword keyword-Float">Float</span> <span class="token string">&quot;-Float&quot;</span> <span class="token keyword keyword-Float">Float</span>        <span class="token punctuation">[</span>function<span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span><span class="token punctuation">(</span>fp<span class="token punctuation">.</span>sub roundNearestTiesToEven #<span class="token number">1</span> #<span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FLOAT<span class="token punctuation">.</span>sub<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="floating-point-mathematics">Floating-point mathematics</h3>

<p>You can:</p>
<ul>
<li>Compute the Nth integer root <code>rootFloat</code> of a float.</li>
<li>Compute the absolute value <code>absFloat</code> of a float.</li>
<li>Round a floating-point number to a specified precision and exponent<br>
range (<code>roundFloat</code>). The resulting <code>Float</code> will yield the specified values<br>
when calling <code>precisionFloat</code> and <code>exponentBitsFloat</code> and when performing<br>
further computation.</li>
<li>Round a float to the next lowest floating-point value which is an integer<br>
(<code>floorFloat</code>).</li>
<li>Round a float to the next highest floating-point value which is an integer<br>
(<code>ceilFloat</code>).</li>
<li>Round a float to the next closest floating-point value which is an integer, in<br>
the direction of zero (<code>truncFloat</code>).</li>
<li>Compute the natural exponential <code>expFloat</code> of a float (i.e. e^x).</li>
<li>Compute the natural logarithm <code>logFloat</code> of a float.</li>
<li>Compute the sine <code>sinFloat</code> of a float.</li>
<li>Compute the cosine <code>cosFloat</code> of a float.</li>
<li>Compute the tangent <code>tanFlooat</code> of a float.</li>
<li>Compute the arcsine <code>asinFloat</code> of a float.</li>
<li>Compute the arccosine <code>acosFloat</code> of a float.</li>
<li>Compute the arctangent <code>atanFloat</code> of a float.</li>
<li>Compute the arctangent <code>atan2Float</code> of two floats.</li>
<li>Compute the maximum <code>maxFloat</code> of two floats.</li>
<li>Compute the minimum <code>minFloat</code> of two floats.</li>
<li>Compute the square root <code>sqrtFloat</code> of a float.</li>
<li>Compute the largest finite value expressible in a specified precision and<br>
exponent range (<code>maxValueFloat</code>).</li>
<li>Compute the smallest positive finite value expressible in a specified<br>
precision and exponent range (<code>minValueFloat</code>).</li>
</ul>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Float">Float</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> rootFloat<span class="token punctuation">(</span><span class="token keyword keyword-Float">Float</span><span class="token punctuation">,</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span>        <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FLOAT<span class="token punctuation">.</span>root<span class="token punctuation">)</span><span class="token punctuation">]</span>
                 <span class="token operator">|</span> absFloat<span class="token punctuation">(</span><span class="token keyword keyword-Float">Float</span><span class="token punctuation">)</span>              <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>fp<span class="token punctuation">.</span>abs<span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FLOAT<span class="token punctuation">.</span>abs<span class="token punctuation">)</span><span class="token punctuation">]</span>
                 <span class="token operator">|</span> roundFloat<span class="token punctuation">(</span><span class="token keyword keyword-Float">Float</span><span class="token punctuation">,</span> precision<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> exponentBits<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span>  <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FLOAT<span class="token punctuation">.</span>round<span class="token punctuation">)</span><span class="token punctuation">]</span>
                 <span class="token operator">|</span> floorFloat<span class="token punctuation">(</span><span class="token keyword keyword-Float">Float</span><span class="token punctuation">)</span>            <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FLOAT<span class="token punctuation">.</span>floor<span class="token punctuation">)</span><span class="token punctuation">]</span>
                 <span class="token operator">|</span> ceilFloat<span class="token punctuation">(</span><span class="token keyword keyword-Float">Float</span><span class="token punctuation">)</span>             <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FLOAT<span class="token punctuation">.</span>ceil<span class="token punctuation">)</span><span class="token punctuation">]</span>
                 <span class="token operator">|</span> truncFloat<span class="token punctuation">(</span><span class="token keyword keyword-Float">Float</span><span class="token punctuation">)</span>            <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FLOAT<span class="token punctuation">.</span>trunc<span class="token punctuation">)</span><span class="token punctuation">]</span>
                 <span class="token operator">|</span> expFloat<span class="token punctuation">(</span><span class="token keyword keyword-Float">Float</span><span class="token punctuation">)</span>              <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FLOAT<span class="token punctuation">.</span>exp<span class="token punctuation">)</span><span class="token punctuation">]</span>
                 <span class="token operator">|</span> logFloat<span class="token punctuation">(</span><span class="token keyword keyword-Float">Float</span><span class="token punctuation">)</span>              <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FLOAT<span class="token punctuation">.</span>log<span class="token punctuation">)</span><span class="token punctuation">]</span>
                 <span class="token operator">|</span> sinFloat<span class="token punctuation">(</span><span class="token keyword keyword-Float">Float</span><span class="token punctuation">)</span>              <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FLOAT<span class="token punctuation">.</span>sin<span class="token punctuation">)</span><span class="token punctuation">]</span>
                 <span class="token operator">|</span> cosFloat<span class="token punctuation">(</span><span class="token keyword keyword-Float">Float</span><span class="token punctuation">)</span>              <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FLOAT<span class="token punctuation">.</span>cos<span class="token punctuation">)</span><span class="token punctuation">]</span>
                 <span class="token operator">|</span> tanFloat<span class="token punctuation">(</span><span class="token keyword keyword-Float">Float</span><span class="token punctuation">)</span>              <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FLOAT<span class="token punctuation">.</span>tan<span class="token punctuation">)</span><span class="token punctuation">]</span>
                 <span class="token operator">|</span> asinFloat<span class="token punctuation">(</span><span class="token keyword keyword-Float">Float</span><span class="token punctuation">)</span>             <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FLOAT<span class="token punctuation">.</span>asin<span class="token punctuation">)</span><span class="token punctuation">]</span>
                 <span class="token operator">|</span> acosFloat<span class="token punctuation">(</span><span class="token keyword keyword-Float">Float</span><span class="token punctuation">)</span>             <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FLOAT<span class="token punctuation">.</span>acos<span class="token punctuation">)</span><span class="token punctuation">]</span>
                 <span class="token operator">|</span> atanFloat<span class="token punctuation">(</span><span class="token keyword keyword-Float">Float</span><span class="token punctuation">)</span>             <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FLOAT<span class="token punctuation">.</span>atan<span class="token punctuation">)</span><span class="token punctuation">]</span>
                 <span class="token operator">|</span> atan2Float<span class="token punctuation">(</span><span class="token keyword keyword-Float">Float</span><span class="token punctuation">,</span> <span class="token keyword keyword-Float">Float</span><span class="token punctuation">)</span>     <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FLOAT<span class="token punctuation">.</span>atan2<span class="token punctuation">)</span><span class="token punctuation">]</span>
                 <span class="token operator">|</span> maxFloat<span class="token punctuation">(</span><span class="token keyword keyword-Float">Float</span><span class="token punctuation">,</span> <span class="token keyword keyword-Float">Float</span><span class="token punctuation">)</span>       <span class="token punctuation">[</span>function<span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>fp<span class="token punctuation">.</span>max<span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FLOAT<span class="token punctuation">.</span>max<span class="token punctuation">)</span><span class="token punctuation">]</span>
                 <span class="token operator">|</span> minFloat<span class="token punctuation">(</span><span class="token keyword keyword-Float">Float</span><span class="token punctuation">,</span> <span class="token keyword keyword-Float">Float</span><span class="token punctuation">)</span>       <span class="token punctuation">[</span>function<span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>fp<span class="token punctuation">.</span>min<span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FLOAT<span class="token punctuation">.</span>min<span class="token punctuation">)</span><span class="token punctuation">]</span>
                 <span class="token operator">|</span> sqrtFloat<span class="token punctuation">(</span><span class="token keyword keyword-Float">Float</span><span class="token punctuation">)</span>             <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
                 <span class="token operator">|</span> maxValueFloat<span class="token punctuation">(</span>precision<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> exponentBits<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span>      <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FLOAT<span class="token punctuation">.</span>maxValue<span class="token punctuation">)</span><span class="token punctuation">]</span>
                 <span class="token operator">|</span> minValueFloat<span class="token punctuation">(</span>precision<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> exponentBits<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span>      <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FLOAT<span class="token punctuation">.</span>minValue<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="floating-point-comparisons">Floating-point comparisons</h3>

<p>Compute whether a float is less than or equasl to, less than, greater than or<br>
equal to, greater than, equal, or unequal to another float. Note that<br>
<code>X ==Float Y</code> and <code>X ==K Y</code> might yield different values. The latter should be<br>
used in cases where you want to compare whether two values of sort <code>Float</code><br>
contain the same term. The former should be used when you want to implement<br>
the <code>==</code> operator of a programming language. In particular, <code>NaN =/=Float NaN</code><br>
is true, because <code>NaN</code> compares unequal to all values, including itself, in<br>
IEEE 754 arithmetic. <code>0.0 ==Float -0.0</code> is also true.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Float">Float</span> <span class="token string">&quot;&lt;=Float&quot;</span> <span class="token keyword keyword-Float">Float</span>       <span class="token punctuation">[</span>function<span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>fp<span class="token punctuation">.</span>leq<span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FLOAT<span class="token punctuation">.</span>le<span class="token punctuation">)</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token keyword keyword-Float">Float</span> <span class="token string">&quot;&lt;Float&quot;</span> <span class="token keyword keyword-Float">Float</span>        <span class="token punctuation">[</span>function<span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>fp<span class="token punctuation">.</span>lt<span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FLOAT<span class="token punctuation">.</span>lt<span class="token punctuation">)</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token keyword keyword-Float">Float</span> <span class="token string">&quot;&gt;=Float&quot;</span> <span class="token keyword keyword-Float">Float</span>       <span class="token punctuation">[</span>function<span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>fp<span class="token punctuation">.</span>geq<span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FLOAT<span class="token punctuation">.</span>ge<span class="token punctuation">)</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token keyword keyword-Float">Float</span> <span class="token string">&quot;&gt;Float&quot;</span> <span class="token keyword keyword-Float">Float</span>        <span class="token punctuation">[</span>function<span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>fg<span class="token punctuation">.</span>gt<span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FLOAT<span class="token punctuation">.</span>gt<span class="token punctuation">)</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token keyword keyword-Float">Float</span> <span class="token string">&quot;==Float&quot;</span> <span class="token keyword keyword-Float">Float</span>       <span class="token punctuation">[</span>function<span class="token punctuation">,</span> comm<span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>fp<span class="token punctuation">.</span>eq<span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FLOAT<span class="token punctuation">.</span>eq<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_<span class="token operator">==</span>Float_<span class="token punctuation">)</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token keyword keyword-Float">Float</span> <span class="token string">&quot;=/=Float&quot;</span> <span class="token keyword keyword-Float">Float</span>      <span class="token punctuation">[</span>function<span class="token punctuation">,</span> comm<span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span><span class="token punctuation">(</span>not <span class="token punctuation">(</span>fp<span class="token punctuation">.</span>eq #<span class="token number">1</span> #<span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> F1<span class="token punctuation">:</span><span class="token keyword keyword-Float">Float</span> <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span><span class="token keyword keyword-Float">Float</span> F2<span class="token punctuation">:</span><span class="token keyword keyword-Float">Float</span> <span class="token operator">=&gt;</span> notBool <span class="token punctuation">(</span>F1 <span class="token operator">==</span><span class="token keyword keyword-Float">Float</span> F2<span class="token punctuation">)</span>
</pre><h3 class="mume-header" id="conversion-between-integer-and-float">Conversion between integer and float</h3>

<p>You can convert an integer to a floating-point number with the specified<br>
precision and exponent range. You can also convert a floating-point number<br>
to the nearest integer. This operation rounds to the nearest integer, but it<br>
also avoids the double-rounding that is present in <code>ceilFloat</code> and <code>floorFloat</code><br>
if the nearest integer is not representable in the specified floating-point<br>
type.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Float">Float</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Int2Float<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> precision<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> exponentBits<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span>    <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FLOAT<span class="token punctuation">.</span>int2float<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Float2Int<span class="token punctuation">(</span><span class="token keyword keyword-Float">Float</span><span class="token punctuation">)</span>    <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FLOAT<span class="token punctuation">.</span>float2int<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="implementation-of-floats">Implementation of Floats</h3>

<p>The remainder of this section consists of an implementation in K of some of the<br>
operators above.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> sqrtFloat<span class="token punctuation">(</span>F<span class="token punctuation">:</span><span class="token keyword keyword-Float">Float</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> rootFloat<span class="token punctuation">(</span>F<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> isInfinite<span class="token punctuation">(</span>F<span class="token punctuation">:</span><span class="token keyword keyword-Float">Float</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> F &gt;<span class="token keyword keyword-Float">Float</span> maxValueFloat<span class="token punctuation">(</span>precisionFloat<span class="token punctuation">(</span>F<span class="token punctuation">)</span><span class="token punctuation">,</span> exponentBitsFloat<span class="token punctuation">(</span>F<span class="token punctuation">)</span><span class="token punctuation">)</span> orBool F &lt;<span class="token keyword keyword-Float">Float</span> <span class="token operator">--</span><span class="token keyword keyword-Float">Float</span> maxValueFloat<span class="token punctuation">(</span>precisionFloat<span class="token punctuation">(</span>F<span class="token punctuation">)</span><span class="token punctuation">,</span> exponentBitsFloat<span class="token punctuation">(</span>F<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword keyword-endmodule">endmodule</span>
</pre><h2>Strings</h2>
<p>Provided here is the syntax of an implementation of Unicode strings in K. This<br>
type is hooked to an implementation of strings provided by the backend. The<br>
implementation is currently incomplete and does not fully support encodings<br>
and code points beyond the initial 256 code points of the Basic Latin and<br>
Latin-1 Supplement blocks. In the future, there may be breaking changes to<br>
the semantics of this module in order to support this functionality.</p>
<p>The syntax of strings in K is delineated by double quotes. Inside the double<br>
quotes, any character can appear verbatim except double quotes, backslash,<br>
newline, and carriage return. K also supports the following escape sequences:</p>
<ul>
<li>&quot; - the &quot; character</li>
<li>\ - the \ character</li>
<li>\n - newline character</li>
<li>\r - carriage return character</li>
<li>\t - tab character</li>
<li>\f - form feed character</li>
<li>\xFF - \x followed by two hexadecimal characters indicates a code point<br>
between 0x00 and 0xff</li>
<li>\uFFFF - \u followed by four hexadecimal characters indicates a code point<br>
between 0x0000 and 0xffff</li>
<li>\UFFFFFFFF - \U followed by eight hexadecimal characters indicates a code<br>
point between 0x000000 and 0x10ffff</li>
</ul>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> STRING<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">[</span>hook<span class="token punctuation">(</span>STRING<span class="token punctuation">.</span><span class="token keyword keyword-String">String</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> r<span class="token string">&quot;[\\\&quot;](([^\\\&quot;\\n\\r\\\\])|([\\\\][nrtf\\\&quot;\\\\])|([\\\\][x][0-9a-fA-F]{2})|([\\\\][u][0-9a-fA-F]{4})|([\\\\][U][0-9a-fA-F]{8}))*[\\\&quot;]&quot;</span>      <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> STRING<span class="token operator">-</span>COMMON
  <span class="token keyword keyword-imports">imports</span> STRING<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> private INT
  <span class="token keyword keyword-imports">imports</span> private FLOAT<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> private K<span class="token operator">-</span>EQUAL
  <span class="token keyword keyword-imports">imports</span> private BOOL
</pre><h3 class="mume-header" id="string-concatenation">String concatenation</h3>

<p>You can concatenate two strings in O(N) time. For successive concatenation<br>
operations, it may be better to use the <code>STRING-BUFFER</code> module.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-String">String</span> <span class="token string">&quot;+String&quot;</span> <span class="token keyword keyword-String">String</span>    <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>STRING<span class="token punctuation">.</span>concat<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="string-length">String length</h3>

<p>You can get the length of a string in O(1) time.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> lengthString <span class="token punctuation">(</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>STRING<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="character-and-integer-conversion">Character and integer conversion</h3>

<p>You can convert between a character (as represented by a string containing<br>
a single code point) and an integer in O(1) time.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> chrChar <span class="token punctuation">(</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">)</span>      <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>STRING<span class="token punctuation">.</span>chr<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> ordChar <span class="token punctuation">(</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">)</span>      <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>STRING<span class="token punctuation">.</span>ord<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="string-substring">String substring</h3>

<p>You can compute a substring of a string in O(N) time (where N is the<br>
length of the substring). There are two important facts to note:</p>
<ol>
<li>the range generated includes the character at <code>startIndex</code> but excludes the<br>
character at <code>endIndex</code>, i.e., the range is <code>[startIndex..endIndex)</code>.</li>
<li>this function is only defined on valid indices (i.e., it is defined when<br>
<code>startIndex &lt; endIndex</code> and <code>endIndex</code> is less than or equal to the string<br>
length).</li>
</ol>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> substrString <span class="token punctuation">(</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">,</span> startIndex<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">,</span> endIndex<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>STRING<span class="token punctuation">.</span>substr<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="string-search">String search</h3>

<p>You can find the first (respectively, last) occurrence of a substring, starting<br>
at a certain <code>index</code>, in another string in O(N*M) time.<br>
Returns <code>-1</code> if the substring is not found.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> findString <span class="token punctuation">(</span> haystack<span class="token punctuation">:</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">,</span> needle<span class="token punctuation">:</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">,</span> index<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">)</span>   <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>STRING<span class="token punctuation">.</span>find<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> rfindString <span class="token punctuation">(</span> haystack<span class="token punctuation">:</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">,</span> needle<span class="token punctuation">:</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">,</span> index<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">)</span>  <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>STRING<span class="token punctuation">.</span>rfind<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="string-character-search">String character search</h3>

<p>You can find the first (respectively, last) occurrence of one of the characters<br>
of the search string, starting at a certain <code>index</code>, in another string in<br>
O(N*M) time.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> findChar <span class="token punctuation">(</span> haystack<span class="token punctuation">:</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">,</span> needles<span class="token punctuation">:</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">,</span> index<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">)</span>     <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>STRING<span class="token punctuation">.</span>findChar<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> rfindChar <span class="token punctuation">(</span> haystack<span class="token punctuation">:</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">,</span> needles<span class="token punctuation">:</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">,</span> index<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">)</span>    <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>STRING<span class="token punctuation">.</span>rfindChar<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="string-and-bool-conversion">String and Bool conversion</h3>

<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Bool2String<span class="token punctuation">(</span><span class="token keyword keyword-Bool">Bool</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> Bool2String<span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>  <span class="token operator">=&gt;</span> <span class="token string">&quot;true&quot;</span>
  <span class="token keyword keyword-rule">rule</span> Bool2String<span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token string">&quot;false&quot;</span>
</pre><pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> String2Bool<span class="token punctuation">(</span><span class="token keyword keyword-String">String</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> String2Bool<span class="token punctuation">(</span><span class="token string">&quot;true&quot;</span><span class="token punctuation">)</span>  <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
  <span class="token keyword keyword-rule">rule</span> String2Bool<span class="token punctuation">(</span><span class="token string">&quot;false&quot;</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">false</span>
</pre><h3 class="mume-header" id="string-and-float-conversion">String and float conversion</h3>

<p>You can convert between a <code>String</code> and a <code>Float</code>. The String will be<br>
represented in the syntax of the <code>Float</code> sort (see the section on the <code>FLOAT</code><br>
module above for details of that syntax). Which particular string is returned<br>
by <code>Float2String</code> is determined by the backend, but the same <code>Float</code> is<br>
guaranteed to return the same <code>String</code>, and converting that <code>String</code> back to a<br>
<code>Float</code> is guaranteed to return the original <code>Float</code>.</p>
<p>You can also convert a <code>Float</code> to a string in a particular syntax using the<br>
variant of <code>Float2String</code> with a <code>format</code>. In this case, the resulting string<br>
is one which results directly from passing that <code>format</code> to <code>mpfr_printf</code>. This<br>
functionality may not be supported on backends that do not use Gnu MPFR to<br>
implement floating-point numbers.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Float2String <span class="token punctuation">(</span> <span class="token keyword keyword-Float">Float</span> <span class="token punctuation">)</span>              <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>STRING<span class="token punctuation">.</span>float2string<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Float2String <span class="token punctuation">(</span> <span class="token keyword keyword-Float">Float</span> <span class="token punctuation">,</span> <span class="token class-name">format</span><span class="token punctuation">:</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">)</span>     <span class="token punctuation">[</span>function<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>FloatFormat<span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>STRING<span class="token punctuation">.</span>floatFormat<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Float">Float</span>  <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> String2Float <span class="token punctuation">(</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">)</span>             <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>STRING<span class="token punctuation">.</span>string2float<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="string-and-integer-conversions">String and integer conversions</h3>

<p>You can convert between a <code>String</code> and an <code>Int</code>. The String will be represented<br>
in the syntax of the <code>INT</code> module (i.e., a nonempty sequence of digits<br>
optionally prefixed by a sign). When converting from an <code>Int</code> to a <code>String</code>,<br>
the sign will not be present unless the integer is negative.</p>
<p>You can also convert between a <code>String</code> and an <code>Int</code> in a particular radix.<br>
This radix can be anywhere between 2 and 36. For a radix 2 &lt;= N &lt;= 10, the<br>
digits 0 to N-1 will be used. For a radix 11 &lt;= N &lt;= 36, the digits 0 to 9<br>
and the first N-10 letters of the Latin alphabet will be used. Both uppercase<br>
and lowercase letters are supported by <code>String2Base</code>. Whether the letters<br>
returned by <code>Base2String</code> are upper or lowercase is determined by the backend,<br>
but the backend will consistently choose one or the other.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span>    <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> String2Int   <span class="token punctuation">(</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">)</span>             <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>STRING<span class="token punctuation">.</span>string2int<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Int2String   <span class="token punctuation">(</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">)</span>                <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>STRING<span class="token punctuation">.</span>int2string<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Base2String  <span class="token punctuation">(</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">,</span> base<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">)</span>          <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>STRING<span class="token punctuation">.</span>base2string<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span>    <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> String2Base  <span class="token punctuation">(</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">,</span> base<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">)</span>       <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>STRING<span class="token punctuation">.</span>string2base<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="string-count-and-replace">String count and replace</h3>

<p>You can replace one, some, or all occurrences of a string within another<br>
string in O(N*M) time. The <code>replaceAll</code>, <code>replace</code>, and <code>replaceFirst</code> methods<br>
are identical, except <code>replaceFirst</code> replaces exactly one ocurrence of the<br>
string, the first occurrence. <code>replace</code> replaces the first <code>times</code> occurrences.<br>
And <code>replaceAll</code> replaces every occurrence.</p>
<p>You can also count the number of times a string occurs within another string<br>
using <code>countAllOccurrences</code>.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;replaceAll&quot;</span> <span class="token string">&quot;(&quot;</span> haystack<span class="token punctuation">:</span> <span class="token keyword keyword-String">String</span> <span class="token string">&quot;,&quot;</span> needle<span class="token punctuation">:</span> <span class="token keyword keyword-String">String</span> <span class="token string">&quot;,&quot;</span> replacement<span class="token punctuation">:</span> <span class="token keyword keyword-String">String</span> <span class="token string">&quot;)&quot;</span>      <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>STRING<span class="token punctuation">.</span>replaceAll<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;replace&quot;</span> <span class="token string">&quot;(&quot;</span> haystack<span class="token punctuation">:</span> <span class="token keyword keyword-String">String</span> <span class="token string">&quot;,&quot;</span> needle<span class="token punctuation">:</span> <span class="token keyword keyword-String">String</span> <span class="token string">&quot;,&quot;</span> replacement<span class="token punctuation">:</span> <span class="token keyword keyword-String">String</span> <span class="token string">&quot;,&quot;</span> times<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;)&quot;</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>STRING<span class="token punctuation">.</span>replace<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;replaceFirst&quot;</span> <span class="token string">&quot;(&quot;</span> haystack<span class="token punctuation">:</span> <span class="token keyword keyword-String">String</span> <span class="token string">&quot;,&quot;</span> needle<span class="token punctuation">:</span> <span class="token keyword keyword-String">String</span> <span class="token string">&quot;,&quot;</span> replacement<span class="token punctuation">:</span> <span class="token keyword keyword-String">String</span> <span class="token string">&quot;)&quot;</span>    <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>STRING<span class="token punctuation">.</span>replaceFirst<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;countAllOccurrences&quot;</span> <span class="token string">&quot;(&quot;</span> haystack<span class="token punctuation">:</span> <span class="token keyword keyword-String">String</span> <span class="token string">&quot;,&quot;</span> needle<span class="token punctuation">:</span> <span class="token keyword keyword-String">String</span> <span class="token string">&quot;)&quot;</span>            <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>STRING<span class="token punctuation">.</span>countAllOccurrences<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="string-equality-and-lexicographic-comparison">String equality and lexicographic comparison</h3>

<p>You can compare whether two strings are equal or unequal, or whether one string<br>
is less than, less than or equal to, greater than, or greater than or equal to<br>
another according to the natural lexicographic ordering of strings.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-String">String</span> <span class="token string">&quot;==String&quot;</span> <span class="token keyword keyword-String">String</span>  <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> comm<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>STRING<span class="token punctuation">.</span>eq<span class="token punctuation">)</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token keyword keyword-String">String</span> <span class="token string">&quot;=/=String&quot;</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> comm<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>STRING<span class="token punctuation">.</span>ne<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> S1<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span> <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span><span class="token keyword keyword-String">String</span> S2<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span> <span class="token operator">=&gt;</span> notBool <span class="token punctuation">(</span>S1 <span class="token operator">==</span><span class="token keyword keyword-String">String</span> S2<span class="token punctuation">)</span>

  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-String">String</span>  <span class="token string">&quot;&lt;String&quot;</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>STRING<span class="token punctuation">.</span>lt<span class="token punctuation">)</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token keyword keyword-String">String</span> <span class="token string">&quot;&lt;=String&quot;</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>STRING<span class="token punctuation">.</span>le<span class="token punctuation">)</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token keyword keyword-String">String</span>  <span class="token string">&quot;&gt;String&quot;</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>STRING<span class="token punctuation">.</span>gt<span class="token punctuation">)</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token keyword keyword-String">String</span> <span class="token string">&quot;&gt;=String&quot;</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>STRING<span class="token punctuation">.</span>ge<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="implementation-of-strings">Implementation of Strings</h3>

<p>What follows is a few String hooks which are deprecated and only are supported<br>
on certain outdated backends of K, as well as an implementation of several<br>
of the above operations in K.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> categoryChar<span class="token punctuation">(</span><span class="token keyword keyword-String">String</span><span class="token punctuation">)</span>       <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>STRING<span class="token punctuation">.</span>category<span class="token punctuation">)</span><span class="token punctuation">]</span>
                  <span class="token operator">|</span> directionalityChar<span class="token punctuation">(</span><span class="token keyword keyword-String">String</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>STRING<span class="token punctuation">.</span>directionality<span class="token punctuation">)</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;newUUID&quot;</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>STRING<span class="token punctuation">.</span>uuid<span class="token punctuation">)</span><span class="token punctuation">,</span> impure<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> S1<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span> <span class="token operator">&lt;=</span><span class="token keyword keyword-String">String</span> S2<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span> <span class="token operator">=&gt;</span> notBool <span class="token punctuation">(</span>S2 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>String</span> <span class="token attr-name">S1)</span>
  <span class="token attr-name">rule</span> <span class="token attr-name"><span class="token namespace">S1:</span>String</span> <span class="token punctuation">&gt;</span></span><span class="token keyword keyword-String">String</span> S2<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span> <span class="token operator">=&gt;</span> S2 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>String</span> <span class="token attr-name">S1</span>
  <span class="token attr-name">rule</span> <span class="token attr-name"><span class="token namespace">S1:</span>String</span> <span class="token punctuation">&gt;</span></span><span class="token operator">=</span><span class="token keyword keyword-String">String</span> S2<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span> <span class="token operator">=&gt;</span> notBool <span class="token punctuation">(</span>S1 &lt;<span class="token keyword keyword-String">String</span> S2<span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> findChar<span class="token punctuation">(</span>S1<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span><span class="token punctuation">,</span> S2<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span><span class="token punctuation">,</span> I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> #if findString<span class="token punctuation">(</span>S1<span class="token punctuation">,</span> substrString<span class="token punctuation">(</span>S2<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> I<span class="token punctuation">)</span> <span class="token operator">==</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">-</span><span class="token number">1</span> #then findChar<span class="token punctuation">(</span>S1<span class="token punctuation">,</span> substrString<span class="token punctuation">(</span>S2<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> lengthString<span class="token punctuation">(</span>S2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> I<span class="token punctuation">)</span> #else #if findChar<span class="token punctuation">(</span>S1<span class="token punctuation">,</span> substrString<span class="token punctuation">(</span>S2<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> lengthString<span class="token punctuation">(</span>S2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> I<span class="token punctuation">)</span> <span class="token operator">==</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">-</span><span class="token number">1</span> #then findString<span class="token punctuation">(</span>S1<span class="token punctuation">,</span> substrString<span class="token punctuation">(</span>S2<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> I<span class="token punctuation">)</span> #else minInt<span class="token punctuation">(</span>findString<span class="token punctuation">(</span>S1<span class="token punctuation">,</span> substrString<span class="token punctuation">(</span>S2<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> I<span class="token punctuation">)</span><span class="token punctuation">,</span> findChar<span class="token punctuation">(</span>S1<span class="token punctuation">,</span> substrString<span class="token punctuation">(</span>S2<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> lengthString<span class="token punctuation">(</span>S2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> I<span class="token punctuation">)</span><span class="token punctuation">)</span> #fi #fi <span class="token keyword keyword-requires">requires</span> S2 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span><span class="token keyword keyword-String">String</span> <span class="token string">&quot;&quot;</span>
  <span class="token keyword keyword-rule">rule</span> findChar<span class="token punctuation">(</span>_<span class="token punctuation">,</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token operator">-</span><span class="token number">1</span>
  <span class="token keyword keyword-rule">rule</span> rfindChar<span class="token punctuation">(</span>S1<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span><span class="token punctuation">,</span> S2<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span><span class="token punctuation">,</span> I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> maxInt<span class="token punctuation">(</span>rfindString<span class="token punctuation">(</span>S1<span class="token punctuation">,</span> substrString<span class="token punctuation">(</span>S2<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> I<span class="token punctuation">)</span><span class="token punctuation">,</span> rfindChar<span class="token punctuation">(</span>S1<span class="token punctuation">,</span> substrString<span class="token punctuation">(</span>S2<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> lengthString<span class="token punctuation">(</span>S2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> I<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword keyword-requires">requires</span> S2 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span><span class="token keyword keyword-String">String</span> <span class="token string">&quot;&quot;</span>
  <span class="token keyword keyword-rule">rule</span> rfindChar<span class="token punctuation">(</span>_<span class="token punctuation">,</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token operator">-</span><span class="token number">1</span>

  <span class="token keyword keyword-rule">rule</span> countAllOccurrences<span class="token punctuation">(</span>Source<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span><span class="token punctuation">,</span> ToCount<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token number">0</span>
            <span class="token keyword keyword-requires">requires</span> findString<span class="token punctuation">(</span>Source<span class="token punctuation">,</span> ToCount<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> &lt;<span class="token keyword keyword-Int">Int</span> <span class="token number">0</span>
  <span class="token keyword keyword-rule">rule</span> countAllOccurrences<span class="token punctuation">(</span>Source<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span><span class="token punctuation">,</span> ToCount<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token number">1</span> <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> countAllOccurrences<span class="token punctuation">(</span>substrString<span class="token punctuation">(</span>Source<span class="token punctuation">,</span> findString<span class="token punctuation">(</span>Source<span class="token punctuation">,</span> ToCount<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> lengthString<span class="token punctuation">(</span>ToCount<span class="token punctuation">)</span><span class="token punctuation">,</span> lengthString<span class="token punctuation">(</span>Source<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ToCount<span class="token punctuation">)</span>
            <span class="token keyword keyword-requires">requires</span> findString<span class="token punctuation">(</span>Source<span class="token punctuation">,</span> ToCount<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span><span class="token keyword keyword-Int">Int</span> <span class="token number">0</span>

  <span class="token keyword keyword-rule">rule</span> replaceFirst<span class="token punctuation">(</span>Source<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span><span class="token punctuation">,</span> ToReplace<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span><span class="token punctuation">,</span> Replacement<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> substrString<span class="token punctuation">(</span>Source<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> findString<span class="token punctuation">(</span>Source<span class="token punctuation">,</span> ToReplace<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token operator">+</span><span class="token keyword keyword-String">String</span> Replacement <span class="token operator">+</span><span class="token keyword keyword-String">String</span> substrString<span class="token punctuation">(</span>Source<span class="token punctuation">,</span> findString<span class="token punctuation">(</span>Source<span class="token punctuation">,</span> ToReplace<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> lengthString<span class="token punctuation">(</span>ToReplace<span class="token punctuation">)</span><span class="token punctuation">,</span> lengthString<span class="token punctuation">(</span>Source<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword keyword-requires">requires</span> findString<span class="token punctuation">(</span>Source<span class="token punctuation">,</span> ToReplace<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span><span class="token keyword keyword-Int">Int</span> <span class="token number">0</span>
  <span class="token keyword keyword-rule">rule</span> replaceFirst<span class="token punctuation">(</span>Source<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span><span class="token punctuation">,</span> ToReplace<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span><span class="token punctuation">,</span> _<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Source
        <span class="token keyword keyword-requires">requires</span> findString<span class="token punctuation">(</span>Source<span class="token punctuation">,</span> ToReplace<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> &lt;<span class="token keyword keyword-Int">Int</span> <span class="token number">0</span>


  <span class="token comment">// Note that the replace function is undefined when Count &lt; 0. This allows different backends to</span>
  <span class="token comment">// implement their own behavior without contradicting these semantics. For instance, a symbolic</span>
  <span class="token comment">// backend can return #Bottom for that case, while a concrete backend can throw an exception.</span>
  <span class="token keyword keyword-rule">rule</span> replace<span class="token punctuation">(</span>Source<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span><span class="token punctuation">,</span> ToReplace<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span><span class="token punctuation">,</span> Replacement<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span><span class="token punctuation">,</span> Count<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
       substrString<span class="token punctuation">(</span>Source<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> findString<span class="token punctuation">(</span>Source<span class="token punctuation">,</span> ToReplace<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span><span class="token keyword keyword-String">String</span> Replacement <span class="token operator">+</span><span class="token keyword keyword-String">String</span>
       replace<span class="token punctuation">(</span>substrString<span class="token punctuation">(</span>Source<span class="token punctuation">,</span> findString<span class="token punctuation">(</span>Source<span class="token punctuation">,</span> ToReplace<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> lengthString<span class="token punctuation">(</span>ToReplace<span class="token punctuation">)</span><span class="token punctuation">,</span> lengthString<span class="token punctuation">(</span>Source<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ToReplace<span class="token punctuation">,</span> Replacement<span class="token punctuation">,</span> Count <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword keyword-requires">requires</span> Count &gt;<span class="token keyword keyword-Int">Int</span> <span class="token number">0</span> andBool findString<span class="token punctuation">(</span>Source<span class="token punctuation">,</span> ToReplace<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span><span class="token keyword keyword-Int">Int</span> <span class="token number">0</span>
  <span class="token keyword keyword-rule">rule</span> replace<span class="token punctuation">(</span>Source<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span><span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">,</span> Count<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Source
        <span class="token keyword keyword-requires">requires</span> Count <span class="token operator">&gt;=</span><span class="token keyword keyword-Int">Int</span> <span class="token number">0</span> <span class="token punctuation">[</span>owise<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> replaceAll<span class="token punctuation">(</span>Source<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span><span class="token punctuation">,</span> ToReplace<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span><span class="token punctuation">,</span> Replacement<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> replace<span class="token punctuation">(</span>Source<span class="token punctuation">,</span> ToReplace<span class="token punctuation">,</span> Replacement<span class="token punctuation">,</span> countAllOccurrences<span class="token punctuation">(</span>Source<span class="token punctuation">,</span> ToReplace<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> STRING<span class="token operator">-</span>KORE <span class="token punctuation">[</span>symbolic<span class="token punctuation">]</span>
  <span class="token keyword keyword-imports">imports</span> private K<span class="token operator">-</span>EQUAL
  <span class="token keyword keyword-imports">imports</span> STRING<span class="token operator">-</span>COMMON

  <span class="token keyword keyword-rule">rule</span> S1<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span> <span class="token operator">==</span>K S2<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span> <span class="token operator">=&gt;</span> S1 <span class="token operator">==</span><span class="token keyword keyword-String">String</span> S2 <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>

<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> STRING
  <span class="token keyword keyword-imports">imports</span> STRING<span class="token operator">-</span>COMMON
  <span class="token keyword keyword-imports">imports</span> STRING<span class="token operator">-</span>KORE
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><h2>String Buffers</h2>
<p>It is a well known fact that repeated string concatenations are quadratic<br>
in performance whereas use of an efficient mutable representation of arrays<br>
can yield linear performance. We thus provide such a sort, the <code>StringBuffer</code><br>
sort. Axiomatically, it is implemented below on symbolic backends using the<br>
<code>String</code> module. However, on concrete backends it provides an efficient<br>
implementation of string concatenation. There are three operations:</p>
<ul>
<li><code>.StringBuffer</code> creates a new <code>StringBuffer</code> with current content equal<br>
to the empty string.</li>
<li><code>+String</code> takes a <code>StringBuffer</code> and a <code>String</code> and appends the <code>String</code> to<br>
the end of the <code>StringBuffer</code></li>
<li><code>StringBuffer2String</code> converts a <code>StringBuffer</code> to a <code>String</code>. This operation<br>
copies the string so that subsequent modifications to the <code>StringBuffer</code><br>
will not change the value of the <code>String</code> returned by this function.</li>
</ul>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> STRING<span class="token operator">-</span>BUFFER<span class="token operator">-</span>IN<span class="token operator">-</span>K <span class="token punctuation">[</span>symbolic<span class="token punctuation">]</span>
  <span class="token keyword keyword-imports">imports</span> private BASIC<span class="token operator">-</span>K
  <span class="token keyword keyword-imports">imports</span> STRING

  <span class="token keyword keyword-syntax">syntax</span> StringBuffer <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;.StringBuffer&quot;</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> StringBuffer <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> StringBuffer <span class="token string">&quot;+String&quot;</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> <span class="token class-name">avoid</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> StringBuffer <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-String">String</span>
  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> StringBuffer2String <span class="token punctuation">(</span> StringBuffer <span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">{</span>SB<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span> <span class="token operator">+</span><span class="token keyword keyword-String">String</span> S<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span><span class="token punctuation">}</span><span class="token punctuation">:</span><span class="token punctuation">:</span>StringBuffer <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>SB <span class="token operator">+</span><span class="token keyword keyword-String">String</span> S<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword keyword-String">String</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">.</span>StringBuffer <span class="token operator">=&gt;</span> <span class="token string">&quot;&quot;</span>
  <span class="token keyword keyword-rule">rule</span> StringBuffer2String<span class="token punctuation">(</span>S<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> S
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> STRING<span class="token operator">-</span>BUFFER<span class="token operator">-</span>HOOKED <span class="token punctuation">[</span>concrete<span class="token punctuation">]</span>
  <span class="token keyword keyword-imports">imports</span> private BASIC<span class="token operator">-</span>K
  <span class="token keyword keyword-imports">imports</span> STRING

  <span class="token keyword keyword-syntax">syntax</span> StringBuffer <span class="token punctuation">[</span>hook<span class="token punctuation">(</span>BUFFER<span class="token punctuation">.</span>StringBuffer<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> StringBuffer <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;.StringBuffer&quot;</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>BUFFER<span class="token punctuation">.</span>empty<span class="token punctuation">)</span><span class="token punctuation">,</span> impure<span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> StringBuffer <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> StringBuffer <span class="token string">&quot;+String&quot;</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>BUFFER<span class="token punctuation">.</span>concat<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">avoid</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> StringBuffer2String <span class="token punctuation">(</span> StringBuffer <span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>BUFFER<span class="token punctuation">.</span>toString<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> STRING<span class="token operator">-</span>BUFFER
  <span class="token keyword keyword-imports">imports</span> STRING<span class="token operator">-</span>BUFFER<span class="token operator">-</span>HOOKED
  <span class="token keyword keyword-imports">imports</span> STRING<span class="token operator">-</span>BUFFER<span class="token operator">-</span>IN<span class="token operator">-</span>K
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><h2>Byte Arrays</h2>
<p>Provided here is the syntax of an implementation of fixed-width arrays of Bytes<br>
in K. This type is hooked to an implementation of bytes provided by the backend.<br>
On the LLVM backend, it is possible to opt in to a faster, mutable<br>
representation (using the <code>--llvm-mutable-bytes</code> flag to <code>kompile</code>) where<br>
multiple references can occur to the same <code>Bytes</code> object and when one is<br>
modified, the others are also modified. Care should be taken when using this<br>
feature, however, as it is possible to experience divergent behavior with<br>
symbolic backends unless the <code>Bytes</code> type is used in a manner that preserves<br>
consistency.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> BYTES<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> private STRING<span class="token operator">-</span>SYNTAX

  <span class="token keyword keyword-syntax">syntax</span> Bytes <span class="token punctuation">[</span>hook<span class="token punctuation">(</span>BYTES<span class="token punctuation">.</span>Bytes<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Bytes <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> r<span class="token string">&quot;b[\\\&quot;](([ !#-\\[\\]-~])|([\\\\][tnfr\\\&quot;\\\\])|([\\\\][x][0-9a-fA-F]{2}))*[\\\&quot;]&quot;</span>      <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> BYTES<span class="token operator">-</span>STRING<span class="token operator">-</span>ENCODE <span class="token punctuation">[</span>symbolic<span class="token punctuation">]</span>
  <span class="token keyword keyword-imports">imports</span> BYTES<span class="token operator">-</span>SYNTAX
</pre><h3 class="mume-header" id="encodingdecoding-between-bytes-and-string">Encoding/decoding between Bytes and String</h3>

<p>You can encode/decode between Bytes and String using <code>UTF-8</code>, <code>UTF-16LE</code>, <code>UTF-16BE</code>, <code>UTF-32LE</code>, and <code>UTF-32BE</code></p>
<pre data-role="codeBlock" data-info="k" class="language-k">    <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> decodeBytes <span class="token punctuation">(</span> encoding<span class="token punctuation">:</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">,</span> contents<span class="token punctuation">:</span> Bytes <span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>BYTES<span class="token punctuation">.</span>decodeBytes<span class="token punctuation">)</span><span class="token punctuation">]</span>
    <span class="token keyword keyword-syntax">syntax</span> Bytes <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> encodeBytes <span class="token punctuation">(</span> encoding<span class="token punctuation">:</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">,</span> contents<span class="token punctuation">:</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>BYTES<span class="token punctuation">.</span>encodeBytes<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> BYTES<span class="token operator">-</span>HOOKED
  <span class="token keyword keyword-imports">imports</span> STRING<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> BYTES<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> MINT<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> BYTES<span class="token operator">-</span>STRING<span class="token operator">-</span>ENCODE
</pre><h3 class="mume-header" id="empty-byte-array">Empty byte array</h3>

<p>The byte array of length zero is represented by <code>.Bytes</code>.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Bytes <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;.Bytes&quot;</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>BYTES<span class="token punctuation">.</span>empty<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="endianness">Endianness</h3>

<p>When converting to/from an integer, byte arrays can be treated as either little<br>
endian (ie, least significant byte first) or big endian (ie, most significant<br>
byte first).</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Endianness <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;LE&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>littleEndianBytes<span class="token punctuation">)</span><span class="token punctuation">]</span>
                      <span class="token operator">|</span> <span class="token string">&quot;BE&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>bigEndianBytes<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="signedness">Signedness</h3>

<p>When converting to/from an integer, byte arrays can be treated as either signed<br>
or unsigned.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Signedness <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;Signed&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>signedBytes<span class="token punctuation">)</span><span class="token punctuation">]</span>
                      <span class="token operator">|</span> <span class="token string">&quot;Unsigned&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>unsignedBytes<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="integer-and-bytes-conversion">Integer and Bytes conversion</h3>

<p>You can convert from a <code>Bytes</code> to an <code>Int</code>. In order to do this, the endianness<br>
and signedness of the <code>Bytes</code> must be provided. The resulting integer is<br>
created by means of interpreting the <code>Bytes</code> as either a twos-complement<br>
representation, or an unsigned representation, of an integer, in the specified<br>
byte order.</p>
<p>You can also convert from an <code>Int</code> to a <code>Bytes</code>. This comes in two variants.<br>
In the first, the <code>length</code> of the resulting <code>Bytes</code> in bytes is explicitly<br>
specified. If the <code>length</code> is greater than the highest set bit in the magnitude<br>
of the integer, the result is padded with 0 bits if the number is positive<br>
and 1 bits if the number is negative. If the <code>length</code> is less than the highest<br>
bit set in the magnitude of the integer, the most-significant bits of the<br>
integer will be truncated. The endianness of the resulting <code>Bytes</code> object<br>
is as specified.</p>
<p>In the second variant, both endianness and signedness are specified, and<br>
the resulting <code>Bytes</code> object will be the smallest number of bytes necessary<br>
for the resulting <code>Bytes</code> object to be convertible back to the original integer<br>
via <code>Bytes2Int</code>. In other words, if the highest bit set in the magnitude of the<br>
integer is N, then the byte array will be at least N+1 bits long, rounded up<br>
to the nearest byte.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Bytes2Int<span class="token punctuation">(</span>Bytes<span class="token punctuation">,</span> Endianness<span class="token punctuation">,</span> Signedness<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>BYTES<span class="token punctuation">.</span>bytes2int<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Bytes <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Int2Bytes<span class="token punctuation">(</span>length<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> Endianness<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>BYTES<span class="token punctuation">.</span>int2bytes<span class="token punctuation">)</span><span class="token punctuation">]</span>
                 <span class="token operator">|</span> Int2Bytes<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> Endianness<span class="token punctuation">,</span> Signedness<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>Int2BytesNoLen<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="string-and-bytes-conversion">String and Bytes conversion</h3>

<p>You can convert between a <code>Bytes</code> and a <code>String</code> in O(N) time. The resulting<br>
value is a copy of the original and will not be affected by subsequent<br>
mutations of the input or output value. <code>Bytes2Hex</code> uses hexadecimal encoding.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Bytes2String<span class="token punctuation">(</span>Bytes<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>BYTES<span class="token punctuation">.</span>bytes2string<span class="token punctuation">)</span><span class="token punctuation">]</span>
                  <span class="token operator">|</span> Bytes2Hex<span class="token punctuation">(</span>Bytes<span class="token punctuation">)</span>    <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>BYTES<span class="token punctuation">.</span>bytes2hex<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Bytes <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> String2Bytes<span class="token punctuation">(</span><span class="token keyword keyword-String">String</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>BYTES<span class="token punctuation">.</span>string2bytes<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="bytes-update">Bytes update</h3>

<p>You can set the value of a particular byte in a <code>Bytes</code> object in O(1) time,<br>
either with index and value as <code>Int</code> or as an <code>MInt</code>. Currently, only 64-bit<br>
and 256-bit <code>MInt</code> types are supported. The result is <code>#False</code> if <code>value</code> is<br>
not in the range [0..255] or if <code>index</code> is not a valid index (ie, less than<br>
zero or greater than or equal to the length of the <code>Bytes</code> term).</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Bytes <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Bytes <span class="token string">&quot;[&quot;</span> index<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;&lt;-&quot;</span> value<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;]&quot;</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>BYTES<span class="token punctuation">.</span>update<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>Width<span class="token punctuation">}</span> Bytes <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Bytes <span class="token string">&quot;[&quot;</span> index<span class="token punctuation">:</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token string">&quot;&lt;-&quot;</span> value<span class="token punctuation">:</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token string">&quot;]&quot;</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>BYTES<span class="token punctuation">.</span>updateMInt<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="bytes-lookup">Bytes lookup</h3>

<p>You can get the value of a particular byte in a <code>Bytes</code> object in O(1) time, either as an <code>Int</code> or as an <code>MInt</code>. Currently, only 64-bit and 256-bit <code>MInt</code> types are supported.<br>
The result is <code>#False</code> if <code>index</code> is not a valid index (see above).</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Bytes <span class="token string">&quot;[&quot;</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;]&quot;</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>BYTES<span class="token punctuation">.</span>get<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>Width<span class="token punctuation">}</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Bytes <span class="token string">&quot;[&quot;</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token string">&quot;]&quot;</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>BYTES<span class="token punctuation">.</span>getMInt<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="bytes-substring">Bytes substring</h3>

<p>You can get a new <code>Bytes</code> object containing a range of bytes from the input<br>
<code>Bytes</code> in O(N) time (where N is the length of the substring). The range<br>
of bytes included is <code>[startIndex..endIndex)</code>. The resulting <code>Bytes</code> is<br>
a copy and mutations to it do not affect mutations to the original <code>Bytes</code>.<br>
Both <code>startIndex</code> and <code>endIndex</code> can be either <code>Int</code> or <code>MInt</code> values, but,<br>
currently, only 64-bit and 256-bit <code>MInt</code> types are supported.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Bytes <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> substrBytes<span class="token punctuation">(</span>Bytes<span class="token punctuation">,</span> startIndex<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> endIndex<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>BYTES<span class="token punctuation">.</span>substr<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>Width<span class="token punctuation">}</span> Bytes <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> substrBytes<span class="token punctuation">(</span>Bytes<span class="token punctuation">,</span> startIndex<span class="token punctuation">:</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span><span class="token punctuation">,</span> endIndex<span class="token punctuation">:</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>BYTES<span class="token punctuation">.</span>substrMInt<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><p>The function is not total: <code>substrBytes(B, startIndex, endIndex)</code> is <code>#Bottom</code> if</p>
<ul>
<li><code>startIndex &lt;Int 0</code> or</li>
<li><code>endIndex &lt;Int startIndex</code> or</li>
<li><code>lengthBytes(B) &lt;Int endIndex</code>.</li>
</ul>
<h3 class="mume-header" id="multiple-bytes-update">Multiple bytes update</h3>

<p>You can modify a <code>Bytes</code> to return a <code>Bytes</code> which is equal to <code>dest</code> except the<br>
<code>N</code> elements starting at <code>index</code> are replaced with the contents of <code>src</code> in O(N)<br>
time. If <code>--llvm-mutable-bytes</code> is active, this will not create a new <code>Bytes</code><br>
object and will instead modify the original on concrete backends. The result is<br>
<code>#False</code> if <code>index</code> + <code>N</code> is not a valid index. This function accepts both<br>
<code>Int</code> and <code>MInt</code> values for <code>index</code> and <code>N</code>. Currently, only 64-bit and<br>
256-bit <code>MInt</code> types are supported.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Bytes <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> replaceAtBytes<span class="token punctuation">(</span>dest<span class="token punctuation">:</span> Bytes<span class="token punctuation">,</span> index<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> src<span class="token punctuation">:</span> Bytes<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>BYTES<span class="token punctuation">.</span>replaceAt<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>Width<span class="token punctuation">}</span> Bytes <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> replaceAtBytes<span class="token punctuation">(</span>dest<span class="token punctuation">:</span> Bytes<span class="token punctuation">,</span> index<span class="token punctuation">:</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span><span class="token punctuation">,</span> src<span class="token punctuation">:</span> Bytes<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>BYTES<span class="token punctuation">.</span>replaceAtMInt<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="multiple-bytes-update-1">Multiple bytes update</h3>

<p>You can modify a <code>Bytes</code> to return a <code>Bytes</code> which is equal to <code>dest</code> except the<br>
<code>count</code> bytes starting at <code>index</code> are replaced with <code>count</code> bytes of value<br>
<code>Int2Bytes(1, v, LE/BE)</code> in O(count) time. This does not create a new <code>Bytes</code><br>
object and will instead modify the original if <code>--llvm-mutable-bytes</code> is active.<br>
This will throw an exception if <code>index</code> + <code>count</code> is not a valid index. The<br>
acceptable range of values for <code>v</code> is -128 to 127. This will throw an exception<br>
if <code>v</code> is outside of this range. This is implemented only for the LLVM backend.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Bytes <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> memsetBytes<span class="token punctuation">(</span>dest<span class="token punctuation">:</span> Bytes<span class="token punctuation">,</span> index<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> count<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> v<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>BYTES<span class="token punctuation">.</span>memset<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="bytes-padding">Bytes padding</h3>

<p>You can create a new <code>Bytes</code> object which is at least <code>length</code> bytes long by<br>
taking the input sequence and padding it on the right (respectively, on the<br>
left) with the specified <code>value</code>. If <code>--llvm-mutable-bytes</code> is active, this does<br>
not create a new <code>Bytes</code> object if the input is already at least <code>length</code> bytes<br>
long, and will instead return the input unchanged. The result is <code>#False</code> if<br>
<code>value</code> is not in the range <code>[0..255]</code>, or if the length is negative.<br>
We also provide a variant of this function which takes an <code>MInt</code> for the<br>
<code>length</code> and <code>value</code>. The current implementation only supports 64-bit and<br>
256-bit <code>MInt</code> types.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Bytes <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> padRightBytes<span class="token punctuation">(</span>Bytes<span class="token punctuation">,</span> length<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> value<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>BYTES<span class="token punctuation">.</span>padRight<span class="token punctuation">)</span><span class="token punctuation">]</span>
                 <span class="token operator">|</span> padLeftBytes<span class="token punctuation">(</span>Bytes<span class="token punctuation">,</span> length<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> value<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>BYTES<span class="token punctuation">.</span>padLeft<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>Width<span class="token punctuation">}</span> Bytes <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> padRightBytes<span class="token punctuation">(</span>Bytes<span class="token punctuation">,</span> length<span class="token punctuation">:</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span><span class="token punctuation">,</span> value<span class="token punctuation">:</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>BYTES<span class="token punctuation">.</span>padRightMInt<span class="token punctuation">)</span><span class="token punctuation">]</span>
                         <span class="token operator">|</span> padLeftBytes<span class="token punctuation">(</span>Bytes<span class="token punctuation">,</span> length<span class="token punctuation">:</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span><span class="token punctuation">,</span> value<span class="token punctuation">:</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>BYTES<span class="token punctuation">.</span>padLeftMInt<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="bytes-reverse">Bytes reverse</h3>

<p>You can reverse a <code>Bytes</code> object in O(N) time. If <code>--llvm-mutable-bytes</code> is<br>
active, this will not create a new <code>Bytes</code> object and will instead modify the<br>
original.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Bytes <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> reverseBytes<span class="token punctuation">(</span>Bytes<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>BYTES<span class="token punctuation">.</span>reverse<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="bytes-length">Bytes length</h3>

<p>You can get the length of a <code>Bytes</code> term in O(1) time. The lenghth can be either<br>
an <code>Int</code> or an <code>MInt</code>. Currently, only 64-bit and 256-bit <code>MInt</code> types are supported.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> lengthBytes<span class="token punctuation">(</span>Bytes<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>BYTES<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">,</span> smtlib<span class="token punctuation">(</span>lengthBytes<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>Width<span class="token punctuation">}</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> lengthBytes<span class="token punctuation">(</span>Bytes<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>BYTES<span class="token punctuation">.</span>lengthMInt<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="bytes-concatenation">Bytes concatenation</h3>

<p>You can create a new <code>Bytes</code> object by concatenating two <code>Bytes</code> objects<br>
together in O(N) time.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Bytes <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Bytes <span class="token string">&quot;+Bytes&quot;</span> Bytes <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>BYTES<span class="token punctuation">.</span>concat<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">right</span><span class="token punctuation">]</span>

<span class="token keyword keyword-endmodule">endmodule</span>
</pre><h3 class="mume-header" id="implementation-of-bytes">Implementation of Bytes</h3>

<p>The remainder of this module consists of an implementation of some of the<br>
operators listed above in K.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> BYTES<span class="token operator">-</span>CONCRETE <span class="token punctuation">[</span>concrete<span class="token punctuation">]</span>
  <span class="token keyword keyword-imports">imports</span> BYTES<span class="token operator">-</span>HOOKED
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> BYTES<span class="token operator">-</span>KORE
  <span class="token keyword keyword-imports">imports</span> BYTES<span class="token operator">-</span>HOOKED
  <span class="token keyword keyword-imports">imports</span> BYTES<span class="token operator">-</span>SYMBOLIC<span class="token operator">-</span>CEIL
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> BYTES<span class="token operator">-</span>SYMBOLIC<span class="token operator">-</span>CEIL <span class="token punctuation">[</span>symbolic<span class="token punctuation">]</span>
  <span class="token keyword keyword-imports">imports</span> BYTES<span class="token operator">-</span>HOOKED
  <span class="token keyword keyword-imports">imports</span> private INT
  <span class="token keyword keyword-imports">imports</span> private BOOL

  <span class="token keyword keyword-rule">rule</span> #Ceil<span class="token punctuation">(</span>padRightBytes<span class="token punctuation">(</span>_<span class="token punctuation">,</span> LEN<span class="token punctuation">,</span> VAL<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">&lt;=</span><span class="token keyword keyword-Int">Int</span> LEN andBool <span class="token number">0</span> <span class="token operator">&lt;=</span><span class="token keyword keyword-Int">Int</span> VAL andBool VAL &lt;<span class="token keyword keyword-Int">Int</span> <span class="token number">256</span><span class="token punctuation">)</span> #Equals <span class="token boolean">true</span><span class="token punctuation">}</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> #Ceil<span class="token punctuation">(</span>padLeftBytes<span class="token punctuation">(</span>_<span class="token punctuation">,</span> LEN<span class="token punctuation">,</span> VAL<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">&lt;=</span><span class="token keyword keyword-Int">Int</span> LEN andBool <span class="token number">0</span> <span class="token operator">&lt;=</span><span class="token keyword keyword-Int">Int</span> VAL andBool VAL &lt;<span class="token keyword keyword-Int">Int</span> <span class="token number">256</span><span class="token punctuation">)</span> #Equals <span class="token boolean">true</span><span class="token punctuation">}</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> BYTES
  <span class="token keyword keyword-imports">imports</span> BYTES<span class="token operator">-</span>CONCRETE
  <span class="token keyword keyword-imports">imports</span> BYTES<span class="token operator">-</span>KORE
  <span class="token keyword keyword-imports">imports</span> private INT

  <span class="token keyword keyword-rule">rule</span> Int2Bytes<span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> _<span class="token punctuation">:</span><span class="token punctuation">:</span>Endianness<span class="token punctuation">,</span> _<span class="token punctuation">)</span>        <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Bytes
    <span class="token keyword keyword-requires">requires</span> I <span class="token operator">==</span><span class="token keyword keyword-Int">Int</span> <span class="token number">0</span>
  <span class="token keyword keyword-rule">rule</span> Int2Bytes<span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> E<span class="token punctuation">:</span><span class="token punctuation">:</span>Endianness<span class="token punctuation">,</span> Unsigned<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Int2Bytes<span class="token punctuation">(</span><span class="token punctuation">(</span>log2Int<span class="token punctuation">(</span>I<span class="token punctuation">)</span> <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">/</span><span class="token keyword keyword-Int">Int</span> <span class="token number">8</span><span class="token punctuation">,</span> I<span class="token punctuation">,</span> E<span class="token punctuation">)</span>
    <span class="token keyword keyword-requires">requires</span> I &gt;<span class="token keyword keyword-Int">Int</span> <span class="token number">0</span> <span class="token punctuation">[</span>preserves<span class="token operator">-</span>definedness<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> Int2Bytes<span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> E<span class="token punctuation">:</span><span class="token punctuation">:</span>Endianness<span class="token punctuation">,</span> Signed  <span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Int2Bytes<span class="token punctuation">(</span><span class="token punctuation">(</span>log2Int<span class="token punctuation">(</span>I<span class="token punctuation">)</span> <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">9</span><span class="token punctuation">)</span> <span class="token operator">/</span><span class="token keyword keyword-Int">Int</span> <span class="token number">8</span><span class="token punctuation">,</span> I<span class="token punctuation">,</span> E<span class="token punctuation">)</span>
    <span class="token keyword keyword-requires">requires</span> I &gt;<span class="token keyword keyword-Int">Int</span> <span class="token number">0</span> <span class="token punctuation">[</span>preserves<span class="token operator">-</span>definedness<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> Int2Bytes<span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> E<span class="token punctuation">:</span><span class="token punctuation">:</span>Endianness<span class="token punctuation">,</span> Signed  <span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Int2Bytes<span class="token punctuation">(</span><span class="token punctuation">(</span>log2Int<span class="token punctuation">(</span><span class="token operator">~</span><span class="token keyword keyword-Int">Int</span> I<span class="token punctuation">)</span> <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">9</span><span class="token punctuation">)</span> <span class="token operator">/</span><span class="token keyword keyword-Int">Int</span> <span class="token number">8</span><span class="token punctuation">,</span> I<span class="token punctuation">,</span> E<span class="token punctuation">)</span>
    <span class="token keyword keyword-requires">requires</span> I &lt;<span class="token keyword keyword-Int">Int</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">[</span>preserves<span class="token operator">-</span>definedness<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> Int2Bytes<span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> E<span class="token punctuation">:</span><span class="token punctuation">:</span>Endianness<span class="token punctuation">,</span> Signed  <span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Int2Bytes<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> E<span class="token punctuation">)</span>
    <span class="token keyword keyword-requires">requires</span> I <span class="token operator">==</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">[</span>preserves<span class="token operator">-</span>definedness<span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><h2>Program identifiers</h2>
<p>Provided here is an implementation for program identifiers in K. Developers<br>
of semantics for a particular language may wish to use their own implementation<br>
instead of the one provided here if their syntax differs from the syntax<br>
defined below. However, this is provided for convenience for developers who<br>
do not care about the lexical syntax of identifiers.</p>
<p>Provided are the following pieces of functionality:</p>
<ul>
<li><code>Id2String</code> - Convert an <code>Id</code> to a <code>String</code> containing its name</li>
<li><code>String2Id</code> - Convert a <code>String</code> to an <code>Id</code> with the specified name</li>
<li>!X:Id - You can get a fresh identifier distinct from any previous identifier<br>
generated by this syntax.</li>
</ul>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> ID<span class="token operator">-</span>SYNTAX<span class="token operator">-</span>PROGRAM<span class="token operator">-</span>PARSING
  <span class="token keyword keyword-imports">imports</span> BUILTIN<span class="token operator">-</span>ID<span class="token operator">-</span>TOKENS
  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Id">Id</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> r<span class="token string">&quot;[A-Za-z\\_][A-Za-z0-9\\_]*&quot;</span>     <span class="token punctuation">[</span>prec<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">token</span><span class="token punctuation">]</span>
              <span class="token operator">|</span> #LowerId                                             <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
              <span class="token operator">|</span> #UpperId                                             <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> ID<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Id">Id</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> ID<span class="token operator">-</span>COMMON
  <span class="token keyword keyword-imports">imports</span> ID<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> private STRING

  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Id2String <span class="token punctuation">(</span> <span class="token keyword keyword-Id">Id</span> <span class="token punctuation">)</span>    <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>STRING<span class="token punctuation">.</span>token2string<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Id">Id</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> String2Id <span class="token punctuation">(</span><span class="token keyword keyword-String">String</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>STRING<span class="token punctuation">.</span>string2token<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Id">Id</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> freshId<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span>    <span class="token punctuation">[</span>freshGenerator<span class="token punctuation">,</span> function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> private<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> freshId<span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> String2Id<span class="token punctuation">(</span><span class="token string">&quot;_&quot;</span> <span class="token operator">+</span><span class="token keyword keyword-String">String</span> Int2String<span class="token punctuation">(</span>I<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> ID
  <span class="token keyword keyword-imports">imports</span> ID<span class="token operator">-</span>COMMON
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><h2>Equality and conditionals</h2>
<p>Provided here are implementations of two important primitives in K:</p>
<ul>
<li><code>==K</code> - the equality between two terms. Returns <code>true</code> if they are equal<br>
and <code>false</code> if they are not equal.</li>
<li><code>#if #then #else #fi</code> - polymorphic conditional function. If the first<br>
argument evaluates to <code>true</code>, the second argument is returned. Otherwise,<br>
the third argument is returned. Note that this does not short-circuit on<br>
symbolic backends.</li>
</ul>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> K<span class="token operator">-</span>EQUAL<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> private BOOL
  <span class="token keyword keyword-imports">imports</span> private BASIC<span class="token operator">-</span>K

  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token class-name">left</span><span class="token punctuation">:</span>
                  K <span class="token string">&quot;==K&quot;</span> K           <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> comm<span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span><span class="token operator">=</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>KEQUAL<span class="token punctuation">.</span>eq<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_<span class="token operator">==</span>K_<span class="token punctuation">)</span><span class="token punctuation">,</span> group<span class="token punctuation">(</span>equalEqualK<span class="token punctuation">)</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> K <span class="token string">&quot;=/=K&quot;</span> K          <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> comm<span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>distinct<span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>KEQUAL<span class="token punctuation">.</span>ne<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_<span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K_<span class="token punctuation">)</span><span class="token punctuation">,</span> group<span class="token punctuation">(</span>notEqualEqualK<span class="token punctuation">)</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-syntax priority">syntax priority</span> equalEqualK notEqualEqualK &gt; boolOperation mlOp

  <span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>Sort<span class="token punctuation">}</span> Sort <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;#if&quot;</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token string">&quot;#then&quot;</span> Sort <span class="token string">&quot;#else&quot;</span> Sort <span class="token string">&quot;#fi&quot;</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>ite<span class="token punctuation">)</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>ite<span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>KEQUAL<span class="token punctuation">.</span>ite<span class="token punctuation">)</span><span class="token punctuation">]</span>

<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> K<span class="token operator">-</span>EQUAL<span class="token operator">-</span>KORE <span class="token punctuation">[</span>symbolic<span class="token punctuation">]</span>
  <span class="token keyword keyword-imports">imports</span> private BOOL
  <span class="token keyword keyword-imports">imports</span> K<span class="token operator">-</span>EQUAL<span class="token operator">-</span>SYNTAX

  <span class="token keyword keyword-rule">rule</span> K1<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span> <span class="token operator">==</span>K K2<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span> <span class="token operator">=&gt;</span> K1 <span class="token operator">==</span><span class="token keyword keyword-Bool">Bool</span> K2 <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">{</span>K1 <span class="token operator">==</span>K K2 #Equals <span class="token boolean">true</span><span class="token punctuation">}</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>K1 #Equals K2<span class="token punctuation">}</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">{</span><span class="token boolean">true</span> #Equals K1 <span class="token operator">==</span>K K2<span class="token punctuation">}</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>K1 #Equals K2<span class="token punctuation">}</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">{</span>K1 <span class="token operator">==</span>K K2 #Equals <span class="token boolean">false</span><span class="token punctuation">}</span> <span class="token operator">=&gt;</span> #Not<span class="token punctuation">(</span><span class="token punctuation">{</span>K1 #Equals K2<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">{</span><span class="token boolean">false</span> #Equals K1 <span class="token operator">==</span>K K2<span class="token punctuation">}</span> <span class="token operator">=&gt;</span> #Not<span class="token punctuation">(</span><span class="token punctuation">{</span>K1 #Equals K2<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">{</span>K1 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K K2 #Equals <span class="token boolean">true</span><span class="token punctuation">}</span> <span class="token operator">=&gt;</span> #Not<span class="token punctuation">(</span><span class="token punctuation">{</span>K1 #Equals K2<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">{</span><span class="token boolean">true</span> #Equals K1 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K K2<span class="token punctuation">}</span> <span class="token operator">=&gt;</span> #Not<span class="token punctuation">(</span><span class="token punctuation">{</span>K1 #Equals K2<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">{</span>K1 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K K2 #Equals <span class="token boolean">false</span><span class="token punctuation">}</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>K1 #Equals K2<span class="token punctuation">}</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">{</span><span class="token boolean">false</span> #Equals K1 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K K2<span class="token punctuation">}</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>K1 #Equals K2<span class="token punctuation">}</span> <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>

<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> K<span class="token operator">-</span>EQUAL
  <span class="token keyword keyword-imports">imports</span> private BOOL
  <span class="token keyword keyword-imports">imports</span> K<span class="token operator">-</span>EQUAL<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> K<span class="token operator">-</span>EQUAL<span class="token operator">-</span>KORE

  <span class="token keyword keyword-rule">rule</span> K1<span class="token punctuation">:</span>K <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K K2<span class="token punctuation">:</span>K <span class="token operator">=&gt;</span> notBool <span class="token punctuation">(</span>K1 <span class="token operator">==</span>K K2<span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> #if C<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span> #then B1<span class="token punctuation">:</span><span class="token punctuation">:</span>K #else _ #fi <span class="token operator">=&gt;</span> B1 <span class="token keyword keyword-requires">requires</span> C
  <span class="token keyword keyword-rule">rule</span> #if C<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span> #then _ #else B2<span class="token punctuation">:</span><span class="token punctuation">:</span>K #fi <span class="token operator">=&gt;</span> B2 <span class="token keyword keyword-requires">requires</span> notBool C

<span class="token keyword keyword-endmodule">endmodule</span>
</pre><h2>Meta operations</h2>
<p>Provided below are a few miscellaneous, mostly deprecated functions in K.<br>
It is not recommended to use any of them directly as they are largely<br>
unsupported in modern K. There are a few exceptions:</p>
<ul>
<li><code>#getenv</code> - Returns the value of an environment variable</li>
<li><code>#kompiledDirectory</code> - Returns the path to the current compiled K definition<br>
directory.</li>
<li><code>#unparseKORE</code> - Takes a K term and converts it to a string.</li>
</ul>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> K<span class="token operator">-</span>REFLECTION
  <span class="token keyword keyword-imports">imports</span> BASIC<span class="token operator">-</span>K
  <span class="token keyword keyword-imports">imports</span> STRING

  <span class="token keyword keyword-syntax">syntax</span> K <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;#configuration&quot;</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> impure<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>KREFLECTION<span class="token punctuation">.</span><span class="token keyword keyword-configuration">configuration</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> #sort<span class="token punctuation">(</span>K<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>KREFLECTION<span class="token punctuation">.</span>sort<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> #fresh<span class="token punctuation">(</span><span class="token keyword keyword-String">String</span><span class="token punctuation">)</span>   <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>KREFLECTION<span class="token punctuation">.</span>fresh<span class="token punctuation">)</span><span class="token punctuation">,</span> impure<span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> getsymbol<span class="token punctuation">(</span>K<span class="token punctuation">)</span>  <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>KREFLECTION<span class="token punctuation">.</span>getKLabel<span class="token punctuation">)</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-syntax">syntax</span> K <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> #getenv<span class="token punctuation">(</span><span class="token keyword keyword-String">String</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> impure<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>KREFLECTION<span class="token punctuation">.</span>getenv<span class="token punctuation">)</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> #kompiledDirectory<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>KREFLECTION<span class="token punctuation">.</span>kompiledDir<span class="token punctuation">)</span><span class="token punctuation">]</span>

  <span class="token comment">// meaningful only for the purposes of compilation to a binary, otherwise</span>
  <span class="token comment">// undefined</span>
  <span class="token keyword keyword-syntax">syntax</span> List <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> #argv<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>KREFLECTION<span class="token punctuation">.</span>argv<span class="token punctuation">)</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>Sort<span class="token punctuation">}</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> #unparseKORE<span class="token punctuation">(</span>Sort<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>KREFLECTION<span class="token punctuation">.</span>printKORE<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> IOError <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;#noParse&quot;</span> <span class="token string">&quot;(&quot;</span> <span class="token keyword keyword-String">String</span> <span class="token string">&quot;)&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#noParse<span class="token punctuation">)</span><span class="token punctuation">]</span>

<span class="token keyword keyword-endmodule">endmodule</span>
</pre><h2>I/O in K</h2>
<p>Concrete execution in K supports I/O operations. This functionality is not<br>
supported during symbolic execution, because symbolic execution must exist<br>
completely free of side-effects, and I/O is an irreducible type of side effect.<br>
However, it is useful in many cases when defining concrete execution to be able<br>
to make reference to I/O operations.</p>
<p>The design of these I/O operations is based on the POSIX standard, for the most<br>
part. For example, the <code>#read</code> K function maps to the <code>read</code> POSIX function. We<br>
do not at this time have a higher-level API for I/O, but this may be<br>
implemented at some point in the future.</p>
<p>I/O operations generally return either their result, or an <code>IOError</code> term<br>
corresponding to the <code>errno</code> returned by the underlying system call.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> K<span class="token operator">-</span>IO
  <span class="token keyword keyword-imports">imports</span> private LIST
  <span class="token keyword keyword-imports">imports</span> private STRING
  <span class="token keyword keyword-imports">imports</span> private INT
</pre><h3 class="mume-header" id="io-errors">I/O errors</h3>

<p>Aside from EOF, which is returned by <code>#getc</code> if the file is at end-of-file, all<br>
of the below I/O errors correspond to possible values for <code>errno</code> after calling<br>
a library function. If the <code>errno</code> returned is not one of the below errnos<br>
known to K, <code>#unknownIOError</code> is returned along with the integer errno value.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> IOError <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;#EOF&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#EOF<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> #unknownIOError<span class="token punctuation">(</span>errno<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#unknownIOError<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#E2BIG&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#E2BIG<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#EACCES&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#EACCES<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#EAGAIN&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#EAGAIN<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#EBADF&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#EBADF<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#EBUSY&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#EBUSY<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#ECHILD&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ECHILD<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#EDEADLK&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#EDEADLK<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#EDOM&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#EDOM<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#EEXIST&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#EEXIST<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#EFAULT&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#EFAULT<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#EFBIG&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#EFBIG<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#EINTR&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#EINTR<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#EINVAL&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#EINVAL<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#EIO&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#EIO<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#EISDIR&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#EISDIR<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#EMFILE&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#EMFILE<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#EMLINK&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#EMLINK<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#ENAMETOOLONG&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ENAMETOOLONG<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#ENFILE&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ENFILE<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#ENODEV&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ENODEV<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#ENOENT&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ENOENT<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#ENOEXEC&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ENOEXEC<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#ENOLCK&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ENOLCK<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#ENOMEM&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ENOMEM<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#ENOSPC&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ENOSPC<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#ENOSYS&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ENOSYS<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#ENOTDIR&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ENOTDIR<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#ENOTEMPTY&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ENOTEMPTY<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#ENOTTY&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ENOTTY<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#ENXIO&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ENXIO<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#EPERM&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#EPERM<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#EPIPE&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#EPIPE<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#ERANGE&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ERANGE<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#EROFS&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#EROFS<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#ESPIPE&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ESPIPE<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#ESRCH&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ESRCH<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#EXDEV&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#EXDEV<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#EWOULDBLOCK&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#EWOULDBLOCK<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#EINPROGRESS&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#EINPROGRESS<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#EALREADY&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#EALREADY<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#ENOTSOCK&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ENOTSOCK<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#EDESTADDRREQ&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#EDESTADDRREQ<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#EMSGSIZE&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#EMSGSIZE<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#EPROTOTYPE&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#EPROTOTYPE<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#ENOPROTOOPT&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ENOPROTOOPT<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#EPROTONOSUPPORT&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#EPROTONOSUPPORT<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#ESOCKTNOSUPPORT&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ESOCKTNOSUPPORT<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#EOPNOTSUPP&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#EOPNOTSUPP<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#EPFNOSUPPORT&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#EPFNOSUPPORT<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#EAFNOSUPPORT&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#EAFNOSUPPORT<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#EADDRINUSE&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#EADDRINUSE<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#EADDRNOTAVAIL&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#EADDRNOTAVAIL<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#ENETDOWN&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ENETDOWN<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#ENETUNREACH&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ENETUNREACH<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#ENETRESET&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ENETRESET<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#ECONNABORTED&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ECONNABORTED<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#ECONNRESET&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ECONNRESET<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#ENOBUFS&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ENOBUFS<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#EISCONN&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#EISCONN<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#ENOTCONN&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ENOTCONN<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#ESHUTDOWN&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ESHUTDOWN<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#ETOOMANYREFS&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ETOOMANYREFS<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#ETIMEDOUT&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ETIMEDOUT<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#ECONNREFUSED&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ECONNREFUSED<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#EHOSTDOWN&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#EHOSTDOWN<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#EHOSTUNREACH&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#EHOSTUNREACH<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#ELOOP&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ELOOP<span class="token punctuation">)</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> <span class="token string">&quot;#EOVERFLOW&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#EOVERFLOW<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="io-result-sorts">I/O result sorts</h3>

<p>Here we see sorts defined to contain either an <code>Int</code> or an <code>IOError</code>, or<br>
either a <code>String</code> or an <code>IOError</code>. These sorts are used to implement the<br>
return sort of functions that may succeed, in which case they return a value,<br>
or may fail, in which case their return value indicates an error and the<br>
error indicated is returned via <code>errno</code>.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> IOInt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span> <span class="token operator">|</span> IOError
  <span class="token keyword keyword-syntax">syntax</span> IOString <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-String">String</span> <span class="token operator">|</span> IOError
</pre><h3 class="mume-header" id="opening-a-file">Opening a file</h3>

<p>You can open a file in K using <code>#open</code>. An optional mode indicates the file<br>
open mode, which can have any value allowed by the <code>fopen</code> function in C.<br>
The returned value is the file descriptor that was opened, or an error.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> IOInt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;#open&quot;</span> <span class="token string">&quot;(&quot;</span> path<span class="token punctuation">:</span> <span class="token keyword keyword-String">String</span> <span class="token string">&quot;)&quot;</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;#open&quot;</span> <span class="token string">&quot;(&quot;</span> path<span class="token punctuation">:</span> <span class="token keyword keyword-String">String</span> <span class="token string">&quot;,&quot;</span> mode<span class="token punctuation">:</span> <span class="token keyword keyword-String">String</span> <span class="token string">&quot;)&quot;</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>IO<span class="token punctuation">.</span>open<span class="token punctuation">)</span><span class="token punctuation">,</span> impure<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> #open<span class="token punctuation">(</span>S<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> #open<span class="token punctuation">(</span>S<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span><span class="token punctuation">,</span> <span class="token string">&quot;r+&quot;</span><span class="token punctuation">)</span>
</pre><h3 class="mume-header" id="getset-position-in-file">Get/set position in file</h3>

<p>You can get the current offset in a file using <code>#tell</code>. You can also seek<br>
to a particular offset using <code>#seek</code> or <code>#seekEnd</code>. <code>#seek</code> is implemented via<br>
a call to <code>lseek</code> with the <code>SEEK_SET</code> whence. <code>#seekEnd</code> is implemented via a<br>
call to <code>lseek</code> with the <code>SEEK_END</code> whence. You can emulate the <code>SEEK_CUR</code><br>
whence by means of <code>#seek(FD, #tell(FD) +Int Offset)</code>.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> IOInt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;#tell&quot;</span> <span class="token string">&quot;(&quot;</span> fd<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;)&quot;</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>IO<span class="token punctuation">.</span>tell<span class="token punctuation">)</span><span class="token punctuation">,</span> impure<span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> K <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;#seek&quot;</span> <span class="token string">&quot;(&quot;</span> fd<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;,&quot;</span> index<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;)&quot;</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>IO<span class="token punctuation">.</span>seek<span class="token punctuation">)</span><span class="token punctuation">,</span> impure<span class="token punctuation">]</span>
             <span class="token operator">|</span> <span class="token string">&quot;#seekEnd&quot;</span> <span class="token string">&quot;(&quot;</span> fd<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;,&quot;</span> fromEnd<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;)&quot;</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>IO<span class="token punctuation">.</span>seekEnd<span class="token punctuation">)</span><span class="token punctuation">,</span> impure<span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="read-from-file">Read from file</h3>

<p>You can read a single character from a file using <code>#getc</code>. <code>#EOF</code> is returned<br>
if you are at end-of-fie.</p>
<p>You can also read up to <code>length</code> characters in a file using <code>#read</code>. The<br>
resulting read characters are returned, which may be fewer characters than<br>
requested. A string of zero length being returned indicates end-of-file.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> IOInt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;#getc&quot;</span> <span class="token string">&quot;(&quot;</span> fd<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;)&quot;</span>             <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>IO<span class="token punctuation">.</span>getc<span class="token punctuation">)</span><span class="token punctuation">,</span> impure<span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> IOString <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;#read&quot;</span> <span class="token string">&quot;(&quot;</span> fd<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;,&quot;</span> length<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;)&quot;</span>    <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>IO<span class="token punctuation">.</span>read<span class="token punctuation">)</span><span class="token punctuation">,</span> impure<span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="write-to-file">Write to file</h3>

<p>You can write a single character to a file using <code>#putc</code>. You can also write<br>
a string to a file using <code>#write</code>. The returned value on success is <code>.K</code>.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> K <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;#putc&quot;</span> <span class="token string">&quot;(&quot;</span> fd<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;,&quot;</span> value<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;)&quot;</span>      <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>IO<span class="token punctuation">.</span>putc<span class="token punctuation">)</span><span class="token punctuation">,</span> impure<span class="token punctuation">]</span>
             <span class="token operator">|</span> <span class="token string">&quot;#write&quot;</span> <span class="token string">&quot;(&quot;</span> fd<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;,&quot;</span> value<span class="token punctuation">:</span> <span class="token keyword keyword-String">String</span> <span class="token string">&quot;)&quot;</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>IO<span class="token punctuation">.</span>write<span class="token punctuation">)</span><span class="token punctuation">,</span> impure<span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="closing-a-file">Closing a file</h3>

<p>You can close a file using <code>#close</code>. The returned value on success is <code>.K</code>.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> K <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;#close&quot;</span> <span class="token string">&quot;(&quot;</span> fd<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;)&quot;</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>IO<span class="token punctuation">.</span>close<span class="token punctuation">)</span><span class="token punctuation">,</span> impure<span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="lockingunlocking-a-file">Locking/unlocking a file</h3>

<p>You can lock or unlock parts of a file using the <code>#lock</code> and <code>#unlock</code><br>
functions. The lock starts at the beginning of the file and continues for<br>
<code>endIndex</code> bytes. Note that Unix systems do not actually prevent locked files<br>
from being read and modified; you will have to lock both sides of a concurrent<br>
access to guarantee exclusivity.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> K <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;#lock&quot;</span> <span class="token string">&quot;(&quot;</span> fd<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;,&quot;</span> endIndex<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;)&quot;</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>IO<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">,</span> impure<span class="token punctuation">]</span>
             <span class="token operator">|</span> <span class="token string">&quot;#unlock&quot;</span> <span class="token string">&quot;(&quot;</span> fd<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;,&quot;</span> endIndex<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;)&quot;</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>IO<span class="token punctuation">.</span>unlock<span class="token punctuation">)</span><span class="token punctuation">,</span> impure<span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="networking">Networking</h3>

<p>You can accept a connection on a socket using <code>#accept</code>, or shut down the<br>
write end of a socket with <code>#shutdownWrite</code>. Note that facility is not provided<br>
for opening, binding, and listening on sockets. These functions are implemented<br>
in order to support creating stateful request/response servers where the<br>
request loop is implemented using rewriting in K, but the connection<br>
initialization is written in native code and linked into the LLVM backend.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> IOInt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;#accept&quot;</span> <span class="token string">&quot;(&quot;</span> fd<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;)&quot;</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>IO<span class="token punctuation">.</span>accept<span class="token punctuation">)</span><span class="token punctuation">,</span> impure<span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> K <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;#shutdownWrite&quot;</span> <span class="token string">&quot;(&quot;</span> fd<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;)&quot;</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>IO<span class="token punctuation">.</span>shutdownWrite<span class="token punctuation">)</span><span class="token punctuation">,</span> impure<span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="time">Time</h3>

<p>You can get the current time in seconds since midnight UTC on January 1, 1970<br>
using <code>#time</code>.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;#time&quot;</span> <span class="token string">&quot;(&quot;</span> <span class="token string">&quot;)&quot;</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>IO<span class="token punctuation">.</span>time<span class="token punctuation">)</span><span class="token punctuation">,</span> impure<span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="builtin-file-descriptors">Builtin file descriptors</h3>

<p>Provided here are functions that return the file descriptor for standard input,<br>
standard output, and standard error.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;#stdin&quot;</span>   <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;#stdout&quot;</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;#stderr&quot;</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> #stdin <span class="token operator">=&gt;</span> <span class="token number">0</span>
  <span class="token keyword keyword-rule">rule</span> #stdout <span class="token operator">=&gt;</span> <span class="token number">1</span>
  <span class="token keyword keyword-rule">rule</span> #stderr <span class="token operator">=&gt;</span> <span class="token number">2</span>
</pre><h3 class="mume-header" id="shell-access">Shell access</h3>

<p>You can execute a command using the shell using the <code>#system</code> operator. Care<br>
must be taken to sanitize inputs to this function or security issues may<br>
result. Note that K has no facility for reasoning about logic that happens<br>
outside its process, so any functionality that you wish to be able to formally<br>
reason about in K should not be implemented via the <code>#system</code> operator.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> #system <span class="token punctuation">(</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>IO<span class="token punctuation">.</span>system<span class="token punctuation">)</span><span class="token punctuation">,</span> impure<span class="token punctuation">]</span>
                 <span class="token operator">|</span> <span class="token string">&quot;#systemResult&quot;</span> <span class="token string">&quot;(&quot;</span> <span class="token keyword keyword-Int">Int</span> <span class="token comment">/* exit code */</span> <span class="token string">&quot;,&quot;</span> <span class="token keyword keyword-String">String</span> <span class="token comment">/* stdout */</span> <span class="token string">&quot;,&quot;</span> <span class="token keyword keyword-String">String</span> <span class="token comment">/* stderr */</span> <span class="token string">&quot;)&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#systemResult<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="temporary-files">Temporary files</h3>

<p>You can get a temporary file and open it atomically using the <code>#mkstemp</code><br>
operator. The resulting file will be closed and deleted when K rewriting ends.<br>
For more info on the argument to <code>#mkstemp</code>, see <code>man mkstemp</code>.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> IOFile <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> #mkstemp<span class="token punctuation">(</span>template<span class="token punctuation">:</span> <span class="token keyword keyword-String">String</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>IO<span class="token punctuation">.</span>mkstemp<span class="token punctuation">)</span><span class="token punctuation">,</span> impure<span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> IOFile <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> IOError
                  <span class="token operator">|</span> <span class="token string">&quot;#tempFile&quot;</span> <span class="token string">&quot;(&quot;</span> path<span class="token punctuation">:</span> <span class="token keyword keyword-String">String</span> <span class="token string">&quot;,&quot;</span> fd<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;)&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#tempFile<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="deleting-a-file">Deleting a file</h3>

<p>You can delete a file using its absolute or relative path using the <code>#remove</code><br>
operator. It returns <code>.K</code> on success or an <code>IOError</code> on failure.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> K <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> #remove<span class="token punctuation">(</span>path<span class="token punctuation">:</span> <span class="token keyword keyword-String">String</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>IO<span class="token punctuation">.</span>remove<span class="token punctuation">)</span><span class="token punctuation">,</span> impure<span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="logging">Logging</h3>

<p>You can log information to disk using the <code>#logToFile</code> operator. Semantically,<br>
this operator returns <code>.K</code>. However, it has a side effect that is not reasoned<br>
about which is that <code>value</code> will be written to a uniquely-identified file<br>
containing <code>name</code> in its name. The file is only flushed to disk when rewriting<br>
finishes.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> K <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> #logToFile<span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token keyword keyword-String">String</span><span class="token punctuation">,</span> value<span class="token punctuation">:</span> <span class="token keyword keyword-String">String</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>IO<span class="token punctuation">.</span>log<span class="token punctuation">)</span><span class="token punctuation">,</span> impure<span class="token punctuation">,</span> returnsUnit<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>#logToFile<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><p>Strings can also be logged via the logging mechanisms available to the backend.<br>
On the LLVM backend, this just means logging the text to standard error. On the<br>
Haskell backend, a log message of type InfoUserLog is created with the<br>
specified text.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> K <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> #log<span class="token punctuation">(</span>value<span class="token punctuation">:</span> <span class="token keyword keyword-String">String</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>IO<span class="token punctuation">.</span>logString<span class="token punctuation">)</span><span class="token punctuation">,</span> impure<span class="token punctuation">,</span> returnsUnit<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>#log<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><p>Terms can also be logged to standard error in <em>surface syntax</em>, rather than as<br>
KORE using <code>#trace</code>. This operator has similar semantics to <code>#logToFile</code> (i.e.<br>
it returns <code>.K</code>, but prints as an impure side effect). Note that calling<br>
<code>#trace</code> is equivalent to invoking the <code>kprint</code> tool for the first term that is<br>
logged, which requires re-parsing the underlying K definition. Subsequent calls<br>
do not incur this overhead again; the definition is cached.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> K <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> #trace<span class="token punctuation">(</span>value<span class="token punctuation">:</span> KItem<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>IO<span class="token punctuation">.</span>traceTerm<span class="token punctuation">)</span><span class="token punctuation">,</span> impure<span class="token punctuation">,</span> returnsUnit<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>#trace<span class="token punctuation">)</span><span class="token punctuation">]</span>
             <span class="token operator">|</span> #traceK<span class="token punctuation">(</span>value<span class="token punctuation">:</span> K<span class="token punctuation">)</span>    <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>IO<span class="token punctuation">.</span>traceTerm<span class="token punctuation">)</span><span class="token punctuation">,</span> impure<span class="token punctuation">,</span> returnsUnit<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>#traceK<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="implementation-of-high-level-io-streams-in-k">Implementation of high-level I/O streams in K</h3>

<p>Below is an implementation of the <code>stream=&quot;stdin&quot;</code> and <code>stream=&quot;stdout&quot;</code><br>
cell attributes in K. You should not refer to these symbols or modules directly<br>
in your definition. It is provided only so that the K compiler can make use of<br>
it. For more information on how to use this feature, refer to IMP++ in the K<br>
tutorial.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Stream <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> #buffer<span class="token punctuation">(</span>K<span class="token punctuation">)</span>
                  <span class="token operator">|</span> #istream<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span>
                  <span class="token operator">|</span> #parseInput<span class="token punctuation">(</span><span class="token keyword keyword-String">String</span><span class="token punctuation">,</span> <span class="token keyword keyword-String">String</span><span class="token punctuation">)</span>
                  <span class="token operator">|</span> #ostream<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span>

<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token comment">// NOTE: DO NOT DIRECTLY IMPORT *-STREAM MODULES</span>
<span class="token comment">// These stream modules will be automatically instantiated and implicitly imported</span>
<span class="token comment">// into the main module when `stream` attributes appear in configuration cells.</span>
<span class="token comment">// Only `Stream` productions and `[stream]` rules will be imported.</span>
<span class="token comment">// The cell name will be replaced with the one of the main configuration.</span>

<span class="token keyword keyword-module">module</span> STDIN<span class="token operator">-</span>STREAM
  <span class="token keyword keyword-imports">imports</span> K<span class="token operator">-</span>IO
  <span class="token keyword keyword-imports">imports</span> K<span class="token operator">-</span>REFLECTION
  <span class="token keyword keyword-imports">imports</span> LIST
  <span class="token keyword keyword-imports">imports</span> INT
  <span class="token keyword keyword-imports">imports</span> BOOL

  <span class="token keyword keyword-configuration">configuration</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>stdin</span><span class="token punctuation">&gt;</span></span> ListItem<span class="token punctuation">(</span>#buffer<span class="token punctuation">(</span>$STDIN<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span><span class="token punctuation">)</span><span class="token punctuation">)</span> ListItem<span class="token punctuation">(</span>$IO<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span><span class="token punctuation">)</span> ListItem<span class="token punctuation">(</span>#istream<span class="token punctuation">(</span>#stdin<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>stdin</span><span class="token punctuation">&gt;</span></span>

  <span class="token comment">// read one character at a time until we read whitespace</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">[</span>stdinGetc<span class="token punctuation">]</span><span class="token punctuation">:</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>stdin</span><span class="token punctuation">&gt;</span></span>
       ListItem<span class="token punctuation">(</span>#parseInput<span class="token punctuation">(</span>_<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span><span class="token punctuation">,</span> Delimiters<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
       ListItem<span class="token punctuation">(</span>#buffer<span class="token punctuation">(</span>S<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span> <span class="token operator">=&gt;</span> S <span class="token operator">+</span><span class="token keyword keyword-String">String</span> chrChar<span class="token punctuation">(</span><span class="token punctuation">{</span>#getc<span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">:</span>&gt;<span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
       ListItem<span class="token punctuation">(</span><span class="token string">&quot;on&quot;</span><span class="token punctuation">)</span>
       ListItem<span class="token punctuation">(</span>#istream<span class="token punctuation">(</span>N<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>stdin</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> findChar<span class="token punctuation">(</span>S<span class="token punctuation">,</span> Delimiters<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token comment">// [stdin]</span>
       <span class="token punctuation">[</span>stream<span class="token punctuation">,</span> priority<span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

  <span class="token comment">// when we reach whitespace, if it parses create a ListItem</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">[</span>stdinParseString<span class="token punctuation">]</span><span class="token punctuation">:</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>stdin</span><span class="token punctuation">&gt;</span></span>
       <span class="token punctuation">(</span>ListItem<span class="token punctuation">(</span>#parseInput<span class="token punctuation">(</span><span class="token string">&quot;String&quot;</span><span class="token punctuation">,</span> Delimiters<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> ListItem<span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span>
       ListItem<span class="token punctuation">(</span>#buffer<span class="token punctuation">(</span>S<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span> <span class="token operator">=&gt;</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
       _<span class="token punctuation">:</span>List
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>stdin</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> findChar<span class="token punctuation">(</span>S<span class="token punctuation">,</span> Delimiters<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token comment">// [stdin]</span>
       <span class="token punctuation">[</span>stream<span class="token punctuation">]</span>

  <span class="token comment">// a hack: handle the case when we read integers without the help of the IO server</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">[</span>stdinParseInt<span class="token punctuation">]</span><span class="token punctuation">:</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>stdin</span><span class="token punctuation">&gt;</span></span>
       <span class="token punctuation">(</span>ListItem<span class="token punctuation">(</span>#parseInput<span class="token punctuation">(</span><span class="token string">&quot;Int&quot;</span><span class="token punctuation">,</span> Delimiters<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
       <span class="token operator">=&gt;</span> ListItem<span class="token punctuation">(</span>String2Int<span class="token punctuation">(</span>substrString<span class="token punctuation">(</span>S<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> findChar<span class="token punctuation">(</span>S<span class="token punctuation">,</span> Delimiters<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
       ListItem<span class="token punctuation">(</span>#buffer<span class="token punctuation">(</span>S<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span> <span class="token operator">=&gt;</span> substrString<span class="token punctuation">(</span>S<span class="token punctuation">,</span>findChar<span class="token punctuation">(</span>S<span class="token punctuation">,</span> Delimiters<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">,</span> lengthString<span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
       _<span class="token punctuation">:</span>List
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>stdin</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> findChar<span class="token punctuation">(</span>S<span class="token punctuation">,</span> Delimiters<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">-</span><span class="token number">1</span>
       andBool lengthString<span class="token punctuation">(</span>S<span class="token punctuation">)</span> &gt;<span class="token keyword keyword-Int">Int</span> <span class="token number">1</span> <span class="token comment">// [stdin]</span>
       <span class="token punctuation">[</span>stream<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">[</span>stdinTrim<span class="token punctuation">]</span><span class="token punctuation">:</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>stdin</span><span class="token punctuation">&gt;</span></span>
       ListItem<span class="token punctuation">(</span>#parseInput<span class="token punctuation">(</span>Sort<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span><span class="token punctuation">,</span> Delimiters<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
       ListItem<span class="token punctuation">(</span>#buffer<span class="token punctuation">(</span>S<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span> <span class="token operator">=&gt;</span> substrString<span class="token punctuation">(</span>S<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> lengthString<span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
       _<span class="token punctuation">:</span>List
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>stdin</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> findChar<span class="token punctuation">(</span>S<span class="token punctuation">,</span> Delimiters<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">-</span><span class="token number">1</span>
       andBool Sort <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span><span class="token keyword keyword-String">String</span> <span class="token string">&quot;String&quot;</span>
       andBool lengthString<span class="token punctuation">(</span>S<span class="token punctuation">)</span> <span class="token operator">&lt;=</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span> <span class="token comment">// [stdin]</span>
       <span class="token punctuation">[</span>stream<span class="token punctuation">]</span>

  <span class="token comment">// NOTE: This unblocking rule will be instantiated and inserted carefully</span>
  <span class="token comment">// when necessary according to user-defined rules, since otherwise it will</span>
  <span class="token comment">// lead to a diverging (i.e., non-terminating) transition system definition.</span>
  <span class="token comment">// Currently, it supports only a simple pattern matching on the top of the</span>
  <span class="token comment">// input stream cell, e.g.,</span>
  <span class="token comment">//   rule &lt;k&gt; read() =&gt; V ... &lt;/k&gt; &lt;in&gt; ListItem(V:Int) =&gt; .List ...  &lt;/in&gt;</span>
  <span class="token comment">// Non-supported rules that refer to the input stream cell in a sophisticated</span>
  <span class="token comment">// way will get stuck in concrete execution mode with real IO enabled (i.e.,</span>
  <span class="token comment">// under `--io on` option), while they will still work in symbolic execution</span>
  <span class="token comment">// mode or concrete execution mode with real IO disabled (i.e., under `--io</span>
  <span class="token comment">// off`, `--search`, or `--debug` options).</span>
  <span class="token comment">//</span>
  <span class="token comment">// TODO: More patterns need to be supported as well. In that case, we need to</span>
  <span class="token comment">// have a way to specify such patterns.</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">[</span>stdinUnblock<span class="token punctuation">]</span><span class="token punctuation">:</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>stdin</span><span class="token punctuation">&gt;</span></span>
         <span class="token punctuation">(</span><span class="token punctuation">.</span>List <span class="token operator">=&gt;</span> ListItem<span class="token punctuation">(</span>#parseInput<span class="token punctuation">(</span><span class="token operator">?</span>Sort<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span><span class="token punctuation">,</span> <span class="token operator">?</span>Delimiters<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
         ListItem<span class="token punctuation">(</span>#buffer<span class="token punctuation">(</span>_<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
         <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>stdin</span><span class="token punctuation">&gt;</span></span>

  <span class="token comment">/*
  syntax Stream ::= &quot;#noIO&quot;

  rule ListItem(#buffer(_))
       (ListItem(#noIO) ListItem(#istream(_:Int)) =&gt; .List) [stdin]
  */</span>

<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> STDOUT<span class="token operator">-</span>STREAM
  <span class="token keyword keyword-imports">imports</span> K<span class="token operator">-</span>IO
  <span class="token keyword keyword-imports">imports</span> LIST
  <span class="token keyword keyword-imports">imports</span> STRING

  <span class="token keyword keyword-configuration">configuration</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>stdout</span><span class="token punctuation">&gt;</span></span> ListItem<span class="token punctuation">(</span>#ostream<span class="token punctuation">(</span>#stdout<span class="token punctuation">)</span><span class="token punctuation">)</span> ListItem<span class="token punctuation">(</span>$IO<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span><span class="token punctuation">)</span> ListItem<span class="token punctuation">(</span>#buffer<span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>stdout</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">//configuration &lt;stderr&gt; ListItem(#ostream(#stderr)) ListItem($IO:String) ListItem(#buffer(&quot;&quot;)) &lt;/stderr&gt;</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">[</span>stdoutBufferFloat<span class="token punctuation">]</span><span class="token punctuation">:</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>stdout</span><span class="token punctuation">&gt;</span></span>
       ListItem<span class="token punctuation">(</span>#ostream<span class="token punctuation">(</span>_<span class="token punctuation">)</span><span class="token punctuation">)</span>
       ListItem<span class="token punctuation">(</span>_<span class="token punctuation">)</span>
       ListItem<span class="token punctuation">(</span>#buffer<span class="token punctuation">(</span>Buffer<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span> <span class="token operator">=&gt;</span> Buffer <span class="token operator">+</span><span class="token keyword keyword-String">String</span> Float2String<span class="token punctuation">(</span>F<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
       <span class="token punctuation">(</span>ListItem<span class="token punctuation">(</span>F<span class="token punctuation">:</span><span class="token keyword keyword-Float">Float</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>List<span class="token punctuation">)</span>
       _<span class="token punctuation">:</span>List
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>stdout</span><span class="token punctuation">&gt;</span></span>
       <span class="token comment">// [stdout, stderr]</span>
       <span class="token punctuation">[</span>stream<span class="token punctuation">,</span> priority<span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">[</span>stdoutBufferInt<span class="token punctuation">]</span><span class="token punctuation">:</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>stdout</span><span class="token punctuation">&gt;</span></span>
       ListItem<span class="token punctuation">(</span>#ostream<span class="token punctuation">(</span>_<span class="token punctuation">)</span><span class="token punctuation">)</span>
       ListItem<span class="token punctuation">(</span>_<span class="token punctuation">)</span>
       ListItem<span class="token punctuation">(</span>#buffer<span class="token punctuation">(</span>Buffer<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span> <span class="token operator">=&gt;</span> Buffer <span class="token operator">+</span><span class="token keyword keyword-String">String</span> Int2String<span class="token punctuation">(</span>I<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
       <span class="token punctuation">(</span>ListItem<span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>List<span class="token punctuation">)</span>
       _<span class="token punctuation">:</span>List
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>stdout</span><span class="token punctuation">&gt;</span></span>
       <span class="token comment">// [stdout, stderr]</span>
       <span class="token punctuation">[</span>stream<span class="token punctuation">,</span> priority<span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">[</span>stdoutBufferString<span class="token punctuation">]</span><span class="token punctuation">:</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>stdout</span><span class="token punctuation">&gt;</span></span>
       ListItem<span class="token punctuation">(</span>#ostream<span class="token punctuation">(</span>_<span class="token punctuation">)</span><span class="token punctuation">)</span>
       ListItem<span class="token punctuation">(</span>_<span class="token punctuation">)</span>
       ListItem<span class="token punctuation">(</span>#buffer<span class="token punctuation">(</span>Buffer<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span> <span class="token operator">=&gt;</span> Buffer <span class="token operator">+</span><span class="token keyword keyword-String">String</span> S<span class="token punctuation">)</span><span class="token punctuation">)</span>
       <span class="token punctuation">(</span>ListItem<span class="token punctuation">(</span>S<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>List<span class="token punctuation">)</span>
       _<span class="token punctuation">:</span>List
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>stdout</span><span class="token punctuation">&gt;</span></span>
       <span class="token comment">// [stdout, stderr]</span>
       <span class="token punctuation">[</span>stream<span class="token punctuation">,</span> priority<span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

  <span class="token comment">// Send first char from the buffer to the server</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">[</span>stdoutWrite<span class="token punctuation">]</span><span class="token punctuation">:</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>stdout</span><span class="token punctuation">&gt;</span></span>
       ListItem<span class="token punctuation">(</span>#ostream<span class="token punctuation">(</span>N<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>#write<span class="token punctuation">(</span>N<span class="token punctuation">,</span> S<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> N<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">}</span><span class="token punctuation">:</span>&gt;<span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
       ListItem<span class="token punctuation">(</span><span class="token string">&quot;on&quot;</span><span class="token punctuation">)</span>
       ListItem<span class="token punctuation">(</span>#buffer<span class="token punctuation">(</span>S<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span> <span class="token operator">=&gt;</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
       _<span class="token punctuation">:</span>List
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>stdout</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> S <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span><span class="token keyword keyword-String">String</span> <span class="token string">&quot;&quot;</span> <span class="token comment">// [stdout, stderr]</span>
       <span class="token punctuation">[</span>stream<span class="token punctuation">,</span> priority<span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

  <span class="token comment">/*
  syntax Stream ::= &quot;#noIO&quot;

  rule ListItem(#buffer(Buffer:String =&gt; Buffer +String Float2String(F)))
       (ListItem(F:Float) =&gt; .List)
       _:List [stdout, stderr]
  rule ListItem(#buffer(Buffer:String =&gt; Buffer +String Int2String(I)))
       (ListItem(I:Int) =&gt; .List)
       _:List [stdout, stderr]
  rule ListItem(#buffer(Buffer:String =&gt; Buffer +String S))
       (ListItem(S:String) =&gt; .List)
       _:List [stdout, stderr]

  rule (ListItem(#ostream(_:Int)) ListItem(#noIO) =&gt; .List)
       ListItem(#buffer(_))
       _:List [stdout, stderr]
  */</span>

<span class="token keyword keyword-endmodule">endmodule</span>
</pre><h2>Machine Integers</h2>
<p>Provided here is an implementation of arbitrarily large fixed-precision binary<br>
integers in K. This type is hooked to an implementation of integers provided<br>
by the backend, and in particular makes use of native machine integers for<br>
certain sizes of integer. For arbitrary-precision integers, see the <code>INT</code><br>
module above.</p>
<p>The syntax of machine integers in K is the same as arbitrary-precision integers<br>
(i.e., an optional sign followed by a sequence of digits) except that machine<br>
integers always end in a suffix <code>pN</code> where <code>N</code> is an integer indicating the<br>
width in bits of the integer. The <code>MInt</code> sort is parametric, and this is<br>
reflected in the literals. For example, the sort of <code>0p8</code> is <code>MInt{8}</code>.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> MINT<span class="token operator">-</span>SYNTAX
  <span class="token comment">/*@\section{Description} The MInt implements machine integers of arbitrary
   * bit width represented in 2&apos;s complement. */</span>
  <span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>Width<span class="token punctuation">}</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token punctuation">[</span>hook<span class="token punctuation">(</span>MINT<span class="token punctuation">.</span>MInt<span class="token punctuation">)</span><span class="token punctuation">]</span>

  <span class="token comment">/*@ Machine integer of bit width and value. */</span>
  <span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>Width<span class="token punctuation">}</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> r<span class="token string">&quot;[\\+\\-]?[0-9]+[pP][0-9]+&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">,</span> prec<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MINT<span class="token punctuation">.</span>literal<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> MINT
  <span class="token keyword keyword-imports">imports</span> MINT<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> private INT
  <span class="token keyword keyword-imports">imports</span> private BYTES
  <span class="token keyword keyword-imports">imports</span> private BOOL
</pre><h3 class="mume-header" id="bitwidth-of-mint">Bitwidth of MInt</h3>

<p>You can get the number of bits of width in an MInt using <code>bitwidthMInt</code>.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> bitwidthMInt<span class="token punctuation">(</span>MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span><span class="token punctuation">)</span>   <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MINT<span class="token punctuation">.</span>bitwidth<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="int-and-mint-conversions">Int and MInt conversions</h3>

<p>You can convert from an <code>MInt</code> to an <code>Int</code> using the <code>MInt2Signed</code> and<br>
<code>MInt2Unsigned</code> functions. an <code>MInt</code> does not have a sign; its sign is instead<br>
reflected in how operators interpret its value either as a signed integer or as<br>
an unsigned integer. Thus, you can interpret a <code>MInt</code> as a signed integer witth<br>
<code>MInt2Signed</code>, or as an unsigned integer respectively using <code>MInt2Unsigned</code>.</p>
<p>You can also convert from an <code>Int</code> to an <code>MInt</code> using <code>Int2MInt</code>. Care must<br>
be given to ensure that the sort context where the <code>Int2MInt</code> operator appears<br>
has the correct bitwidth, as this will influence the width of the resulting<br>
<code>MInt</code>.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> MInt2Signed<span class="token punctuation">(</span>MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span><span class="token punctuation">)</span>     <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MINT<span class="token punctuation">.</span>svalue<span class="token punctuation">)</span><span class="token punctuation">]</span>
                       <span class="token operator">|</span> MInt2Unsigned<span class="token punctuation">(</span>MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span><span class="token punctuation">)</span>     <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MINT<span class="token punctuation">.</span>uvalue<span class="token punctuation">)</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>bv2int<span class="token punctuation">)</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>Width<span class="token punctuation">}</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Int2MInt<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MINT<span class="token punctuation">.</span>integer<span class="token punctuation">)</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>int2bv<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="mint-and-bytes-conversion">Mint and Bytes conversion</h3>

<p>You can convert from an <code>MInt</code> to a <code>Bytes</code> using the <code>MInt2Bytes</code> function.<br>
Currently we only support converting <code>MInt</code>s of width 256 to <code>Bytes</code> in a Big Endian format.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>Width<span class="token punctuation">}</span> Bytes <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> MInt2Bytes<span class="token punctuation">(</span>MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MINT<span class="token punctuation">.</span>MInt2bytes<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>Width<span class="token punctuation">}</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Bytes2MInt<span class="token punctuation">(</span>Bytes<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MINT<span class="token punctuation">.</span>bytes2MInt<span class="token punctuation">)</span><span class="token punctuation">]</span> 
</pre><h3 class="mume-header" id="mint-min-and-max-values">MInt min and max values</h3>

<p>You can get the minimum and maximum values of a signed or unsigned <code>MInt</code><br>
with az specified bit width using <code>sminMInt</code>, <code>smaxMInt</code>, <code>uminMInt</code>, and<br>
<code>umaxMInt</code>.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> sminMInt<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span>    <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
               <span class="token operator">|</span> smaxMInt<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span>    <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
               <span class="token operator">|</span> uminMInt<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span>    <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
               <span class="token operator">|</span> umaxMInt<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span>    <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> sminMInt<span class="token punctuation">(</span>N<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token number">0</span> <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">(</span><span class="token number">1</span> &lt;&lt;<span class="token keyword keyword-Int">Int</span> <span class="token punctuation">(</span>N <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> smaxMInt<span class="token punctuation">(</span>N<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token number">1</span> &lt;&lt;<span class="token keyword keyword-Int">Int</span> <span class="token punctuation">(</span>N <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span>
  <span class="token keyword keyword-rule">rule</span> uminMInt<span class="token punctuation">(</span>_<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token number">0</span>
  <span class="token keyword keyword-rule">rule</span> umaxMInt<span class="token punctuation">(</span>N<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token number">1</span> &lt;&lt;<span class="token keyword keyword-Int">Int</span> N<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span>
</pre><h3 class="mume-header" id="mint-bounds-checking">MInt bounds checking</h3>

<p>You can check whether a specified <code>Int</code> will be represented in an <code>MInt</code><br>
with a specified <code>width</code> without any loss of precision when interpreted as<br>
a signed or unsigned integer using <code>soverflowMInt</code> and <code>uoverflowMInt</code>.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> soverflowMInt<span class="token punctuation">(</span>width<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span>   <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
                <span class="token operator">|</span> uoverflowMInt<span class="token punctuation">(</span>width<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span>   <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span>
    soverflowMInt<span class="token punctuation">(</span>N<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span>
  <span class="token operator">=&gt;</span>
    I <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Int</span> <span class="token attr-name">sminMInt(N)</span> <span class="token attr-name">orBool</span> <span class="token attr-name">I</span> <span class="token punctuation">&gt;</span></span><span class="token keyword keyword-Int">Int</span> smaxMInt<span class="token punctuation">(</span>N<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span>
    uoverflowMInt<span class="token punctuation">(</span>N<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span>
  <span class="token operator">=&gt;</span>
    I <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Int</span> <span class="token attr-name">uminMInt(N)</span> <span class="token attr-name">orBool</span> <span class="token attr-name">I</span> <span class="token punctuation">&gt;</span></span><span class="token keyword keyword-Int">Int</span> umaxMInt<span class="token punctuation">(</span>N<span class="token punctuation">)</span>
</pre><h3 class="mume-header" id="mint-arithmetic">MInt arithmetic</h3>

<p>You can:</p>
<ul>
<li>Compute the bitwise complement <code>~MInt</code> of an <code>MInt</code>.</li>
<li>Compute the unary negation <code>--MInt</code> of an <code>MInt</code>.</li>
<li>Compute the power <code>^MInt</code> of two <code>MInt</code>s interpreted as unsigned integers.<br>
Currently, only 64 and 256-bits is supported.</li>
<li>Compute the product <code>*MInt</code> of two <code>MInt</code>s.</li>
<li>Compute the quotient <code>/sMInt</code> of two <code>MInt</code>s interpreted as signed integers.</li>
<li>Compute the modulus <code>%sMInt</code> of two <code>MInt</code>s interpreted as signed integers.</li>
<li>Compute the quotient <code>/uMInt</code> of two <code>MInt</code>s interpreted as unsigned<br>
integers.</li>
<li>Compute the modulus <code>%uMInt</code> of two <code>MInt</code>s interpreted as unsigned integers.</li>
<li>Compute the sum <code>+MInt</code> of two <code>MInt</code>s.</li>
<li>Compute the difference <code>-MInt</code> of two <code>MInt</code>s.</li>
<li>Compute the left shift <code>&lt;&lt;MInt</code> of two <code>MInt</code>s. The second <code>MInt</code> is always<br>
interpreted as positive.</li>
<li>Compute the arithmetic right shift <code>&gt;&gt;aMInt</code> of two <code>MInt</code>s. The second<br>
<code>MInt</code> is always interpreted as positve.</li>
<li>Compute the logical right shift <code>&gt;&gt;lMInt</code> of two <code>MInt</code>s. The second <code>MInt</code><br>
is always interpreted as positive.</li>
<li>Compute the bitwise and <code>&amp;MInt</code> of two <code>MInt</code>s.</li>
<li>Compute the bitwise xor <code>xorMInt</code> of two <code>MInt</code>s.</li>
<li>Compute the bitwise inclusive or <code>|MInt</code> of two <code>MInt</code>s.</li>
</ul>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>Width<span class="token punctuation">}</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;~MInt&quot;</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MINT<span class="token punctuation">.</span>not<span class="token punctuation">)</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>bvnot<span class="token punctuation">)</span><span class="token punctuation">]</span>
                               <span class="token operator">|</span> <span class="token string">&quot;--MInt&quot;</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MINT<span class="token punctuation">.</span>neg<span class="token punctuation">)</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>bvuminus<span class="token punctuation">)</span><span class="token punctuation">]</span>
                               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                                 MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token string">&quot;^MInt&quot;</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MINT<span class="token punctuation">.</span>pow<span class="token punctuation">)</span><span class="token punctuation">]</span>
                               <span class="token operator">|</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token string">&quot;*MInt&quot;</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MINT<span class="token punctuation">.</span>mul<span class="token punctuation">)</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>bvmul<span class="token punctuation">)</span><span class="token punctuation">]</span>
                               <span class="token operator">|</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token string">&quot;/sMInt&quot;</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MINT<span class="token punctuation">.</span>sdiv<span class="token punctuation">)</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>bvsdiv<span class="token punctuation">)</span><span class="token punctuation">]</span>
                               <span class="token operator">|</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token string">&quot;%sMInt&quot;</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MINT<span class="token punctuation">.</span>srem<span class="token punctuation">)</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>bvsrem<span class="token punctuation">)</span><span class="token punctuation">]</span>
                               <span class="token operator">|</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token string">&quot;/uMInt&quot;</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MINT<span class="token punctuation">.</span>udiv<span class="token punctuation">)</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>bvudiv<span class="token punctuation">)</span><span class="token punctuation">]</span>
                               <span class="token operator">|</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token string">&quot;%uMInt&quot;</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MINT<span class="token punctuation">.</span>urem<span class="token punctuation">)</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>bvurem<span class="token punctuation">)</span><span class="token punctuation">]</span>
                               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                                 MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token string">&quot;+MInt&quot;</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MINT<span class="token punctuation">.</span>add<span class="token punctuation">)</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>bvadd<span class="token punctuation">)</span><span class="token punctuation">]</span>
                               <span class="token operator">|</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token string">&quot;-MInt&quot;</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MINT<span class="token punctuation">.</span>sub<span class="token punctuation">)</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>bvsub<span class="token punctuation">)</span><span class="token punctuation">]</span>
                               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                                 MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token string">&quot;&lt;&lt;MInt&quot;</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MINT<span class="token punctuation">.</span>shl<span class="token punctuation">)</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>bvshl<span class="token punctuation">)</span><span class="token punctuation">]</span>
                               <span class="token operator">|</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token string">&quot;&gt;&gt;aMInt&quot;</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MINT<span class="token punctuation">.</span>ashr<span class="token punctuation">)</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>bvashr<span class="token punctuation">)</span><span class="token punctuation">]</span>
                               <span class="token operator">|</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token string">&quot;&gt;&gt;lMInt&quot;</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MINT<span class="token punctuation">.</span>lshr<span class="token punctuation">)</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>bvlshr<span class="token punctuation">)</span><span class="token punctuation">]</span>
                               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                                 MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token string">&quot;&amp;MInt&quot;</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MINT<span class="token punctuation">.</span>and<span class="token punctuation">)</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>bvand<span class="token punctuation">)</span><span class="token punctuation">]</span>
                               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                                 MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token string">&quot;xorMInt&quot;</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MINT<span class="token punctuation">.</span>xor<span class="token punctuation">)</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>bvxor<span class="token punctuation">)</span><span class="token punctuation">]</span>
                               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                                 MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token string">&quot;|MInt&quot;</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MINT<span class="token punctuation">.</span>or<span class="token punctuation">)</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>bvor<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="mint-comparison">MInt comparison</h3>

<p>You can compute whether one <code>MInt</code> is less than, less than or equal to, greater<br>
than, or greater than or equal to another <code>MInt</code> when interpreted as signed<br>
or unsigned integers. You can also compute whether one <code>MInt</code> is equal to or<br>
unequal to another <code>MInt</code>.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token string">&quot;&lt;sMInt&quot;</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MINT<span class="token punctuation">.</span>slt<span class="token punctuation">)</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>bvslt<span class="token punctuation">)</span><span class="token punctuation">]</span>
                        <span class="token operator">|</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token string">&quot;&lt;uMInt&quot;</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MINT<span class="token punctuation">.</span>ult<span class="token punctuation">)</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>bvult<span class="token punctuation">)</span><span class="token punctuation">]</span>
                        <span class="token operator">|</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token string">&quot;&lt;=sMInt&quot;</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MINT<span class="token punctuation">.</span>sle<span class="token punctuation">)</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>bvsle<span class="token punctuation">)</span><span class="token punctuation">]</span>
                        <span class="token operator">|</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token string">&quot;&lt;=uMInt&quot;</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MINT<span class="token punctuation">.</span>ule<span class="token punctuation">)</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>bvule<span class="token punctuation">)</span><span class="token punctuation">]</span>
                        <span class="token operator">|</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token string">&quot;&gt;sMInt&quot;</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MINT<span class="token punctuation">.</span>sgt<span class="token punctuation">)</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>bvsgt<span class="token punctuation">)</span><span class="token punctuation">]</span>
                        <span class="token operator">|</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token string">&quot;&gt;uMInt&quot;</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MINT<span class="token punctuation">.</span>ugt<span class="token punctuation">)</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>bvugt<span class="token punctuation">)</span><span class="token punctuation">]</span>
                        <span class="token operator">|</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token string">&quot;&gt;=sMInt&quot;</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MINT<span class="token punctuation">.</span>sge<span class="token punctuation">)</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>bvsge<span class="token punctuation">)</span><span class="token punctuation">]</span>
                        <span class="token operator">|</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token string">&quot;&gt;=uMInt&quot;</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MINT<span class="token punctuation">.</span>uge<span class="token punctuation">)</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>bvuge<span class="token punctuation">)</span><span class="token punctuation">]</span>
                        <span class="token operator">|</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token string">&quot;==MInt&quot;</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MINT<span class="token punctuation">.</span>eq<span class="token punctuation">)</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span><span class="token operator">=</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
                        <span class="token operator">|</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token string">&quot;=/=MInt&quot;</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MINT<span class="token punctuation">.</span>ne<span class="token punctuation">)</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span>distinct<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="mint-minmax">MInt min/max</h3>

<p>You can compute the signed minimum <code>sMinMInt</code>, the signed maximum <code>sMaxMInt</code>,<br>
the unsigned minimum <code>uMinMInt</code>, and the unsigned maximum <code>uMaxMInt</code> of two<br>
<code>MInt</code>s.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>Width<span class="token punctuation">}</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> sMaxMInt<span class="token punctuation">(</span>MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span><span class="token punctuation">,</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MINT<span class="token punctuation">.</span>smax<span class="token punctuation">)</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span><span class="token punctuation">(</span>ite <span class="token punctuation">(</span>bvslt #<span class="token number">1</span> #<span class="token number">2</span><span class="token punctuation">)</span> #<span class="token number">2</span> #<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
                               <span class="token operator">|</span> sMinMInt<span class="token punctuation">(</span>MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span><span class="token punctuation">,</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MINT<span class="token punctuation">.</span>smin<span class="token punctuation">)</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span><span class="token punctuation">(</span>ite <span class="token punctuation">(</span>bvslt #<span class="token number">1</span> #<span class="token number">2</span><span class="token punctuation">)</span> #<span class="token number">1</span> #<span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
                               <span class="token operator">|</span> uMaxMInt<span class="token punctuation">(</span>MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span><span class="token punctuation">,</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MINT<span class="token punctuation">.</span>umax<span class="token punctuation">)</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span><span class="token punctuation">(</span>ite <span class="token punctuation">(</span>bvult #<span class="token number">1</span> #<span class="token number">2</span><span class="token punctuation">)</span> #<span class="token number">2</span> #<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
                               <span class="token operator">|</span> uMinMInt<span class="token punctuation">(</span>MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span><span class="token punctuation">,</span> MInt<span class="token punctuation">{</span>Width<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MINT<span class="token punctuation">.</span>umin<span class="token punctuation">)</span><span class="token punctuation">,</span> smt<span class="token operator">-</span>hook<span class="token punctuation">(</span><span class="token punctuation">(</span>ite <span class="token punctuation">(</span>bvult #<span class="token number">1</span> #<span class="token number">2</span><span class="token punctuation">)</span> #<span class="token number">1</span> #<span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="mint-to-mint-conversion">MInt to MInt conversion</h3>

<p>You can convert an <code>MInt</code> of one width to another width with <code>roundMInt</code>.<br>
The resulting <code>MInt</code> will be truncated starting from the most significant bit<br>
if the resulting width is smaller than the input. The resulting <code>MInt</code> will be<br>
zero-extended with the same low-order bits if the resulting width is larger<br>
than the input.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>Width1<span class="token punctuation">,</span> Width2<span class="token punctuation">}</span> MInt<span class="token punctuation">{</span>Width1<span class="token punctuation">}</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> roundMInt<span class="token punctuation">(</span>MInt<span class="token punctuation">{</span>Width2<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MINT<span class="token punctuation">.</span>round<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>Width1<span class="token punctuation">,</span> Width2<span class="token punctuation">}</span> MInt<span class="token punctuation">{</span>Width1<span class="token punctuation">}</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> signExtendMInt<span class="token punctuation">(</span>MInt<span class="token punctuation">{</span>Width2<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>MINT<span class="token punctuation">.</span>sext<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-endmodule">endmodule</span>
</pre></div></div><div id="ebook-heading-kast" ebook-toc-level-2 heading="kast"><div><h1>K Language Features</h1>
<p>Defined below is a series of modules used to parse inner syntax in K (ie, the<br>
contents of rules, configuration declarations, and contexts).</p>
<p>Much of this file exists in tight correspondence with the K implementation, and<br>
K will not work correctly if it is altered without corresponding changes to the<br>
source code of the K tools.</p>
<p>Users should only import a few modules from this file. In particular, this<br>
includes <code>SORT-K</code>, <code>BASIC-K</code>, <code>ML-SYNTAX</code>, <code>DEFAULT-LAYOUT</code>,<br>
<code>DEFAULT-CONFIGURATION</code>, and <code>K-AMBIGUITIES</code>. The remaining modules should not<br>
be imported by the user; they are used implicitly by the implementation of K.</p>
<h2>Basic K Sorts</h2>
<p>The <code>SORT-K</code> module declares the <code>K</code> sort, and nothing else.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> SORT<span class="token operator">-</span>K
  <span class="token keyword keyword-syntax">syntax</span> K <span class="token punctuation">[</span>hook<span class="token punctuation">(</span>K<span class="token punctuation">.</span>K<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>The <code>BASIC-K</code> module declares the <code>K</code>, <code>KItem</code>, and <code>KConfigVar</code> sorts, and<br>
imports the syntax of matching logic.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> BASIC<span class="token operator">-</span>K
  <span class="token keyword keyword-imports">imports</span> ML<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> SORT<span class="token operator">-</span>BOOL
  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">[</span>hook<span class="token punctuation">(</span>K<span class="token punctuation">.</span>KItem<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> K     <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> KItem
  <span class="token keyword keyword-syntax">syntax</span> KConfigVar <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> KConfigVar
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><h2>KAST Abstract Syntax</h2>
<p>Below is defined the abstract syntax of concrete terms in K, the <code>KAST</code> syntax.<br>
Users should rarely if ever have to refer to this syntax; in general, it<br>
suffices to use concrete syntax in rules, configuration declarations, contexts,<br>
etc.</p>
<p>This syntax is used directly by the K implementation, and exists here as a<br>
reference for the syntax of <code>KAST</code>, but it should not be imported directly by<br>
the user.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> KSTRING
  <span class="token keyword keyword-syntax">syntax</span> KString <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> r<span class="token string">&quot;[\\\&quot;](([^\\\&quot;\\n\\r\\\\])|([\\\\][nrtf\\\&quot;\\\\])|([\\\\][x][0-9a-fA-F]{2})|([\\\\][u][0-9a-fA-F]{4})|([\\\\][U][0-9a-fA-F]{8}))*[\\\&quot;]&quot;</span>      <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
  <span class="token comment">// optionally qualified strings, like in Scala &quot;abc&quot;, i&quot;abc&quot;, r&quot;a*bc&quot;, etc.</span>
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> BUILTIN<span class="token operator">-</span>ID<span class="token operator">-</span>TOKENS
  <span class="token keyword keyword-syntax">syntax</span> #LowerId <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> r<span class="token string">&quot;[a-z][a-zA-Z0-9]*&quot;</span>                    <span class="token punctuation">[</span>prec<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">token</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> #UpperId <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> r<span class="token string">&quot;[A-Z][a-zA-Z0-9]*&quot;</span>                    <span class="token punctuation">[</span>prec<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">token</span><span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> SORT<span class="token operator">-</span>KBOTT
  <span class="token keyword keyword-imports">imports</span> SORT<span class="token operator">-</span>K
  <span class="token keyword keyword-syntax">syntax</span> KBott
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> KAST
  <span class="token keyword keyword-imports">imports</span> BASIC<span class="token operator">-</span>K
  <span class="token keyword keyword-imports">imports</span> SORT<span class="token operator">-</span>KBOTT
  <span class="token keyword keyword-imports">imports</span> KSTRING
  <span class="token keyword keyword-imports">imports</span> BUILTIN<span class="token operator">-</span>ID<span class="token operator">-</span>TOKENS

  <span class="token keyword keyword-syntax">syntax</span> KBott <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;#token&quot;</span> <span class="token string">&quot;(&quot;</span> KString <span class="token string">&quot;,&quot;</span> KString <span class="token string">&quot;)&quot;</span>  <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#KToken<span class="token punctuation">)</span><span class="token punctuation">]</span>
                 <span class="token operator">|</span> <span class="token string">&quot;#klabel&quot;</span> <span class="token string">&quot;(&quot;</span> KLabel <span class="token string">&quot;)&quot;</span>              <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#WrappedKLabel<span class="token punctuation">)</span><span class="token punctuation">]</span>
                 <span class="token operator">|</span> KLabel <span class="token string">&quot;(&quot;</span> KList <span class="token string">&quot;)&quot;</span>                  <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#KApply<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> KBott

  <span class="token keyword keyword-syntax">syntax</span> KLabel <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> r<span class="token string">&quot;`(\\\\`|\\\\\\\\|[^`\\\\\\n\\r])+`&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
                  <span class="token operator">|</span> #LowerId                                   <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
                  <span class="token operator">|</span> r<span class="token string">&quot;[#a-z][a-zA-Z0-9]*&quot;</span>               <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">,</span> prec<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-syntax">syntax</span> KList <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> K
                 <span class="token operator">|</span> <span class="token string">&quot;.KList&quot;</span>          <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#EmptyKList<span class="token punctuation">)</span><span class="token punctuation">]</span>
                 <span class="token operator">|</span> KList <span class="token string">&quot;,&quot;</span> KList   <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#KList<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> assoc<span class="token punctuation">,</span> unit<span class="token punctuation">(</span>#EmptyKList<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">prefer</span><span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>


<span class="token comment">// To be used when parsing/pretty-printing ground configurations</span>
<span class="token keyword keyword-module">module</span> KSEQ
  <span class="token keyword keyword-imports">imports</span> KAST
  <span class="token keyword keyword-imports">imports</span> K<span class="token operator">-</span>TOP<span class="token operator">-</span>SORT
  <span class="token keyword keyword-syntax">syntax</span> K <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;.K&quot;</span>      <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#EmptyK<span class="token punctuation">)</span><span class="token punctuation">]</span>
             <span class="token operator">|</span> <span class="token string">&quot;.&quot;</span>       <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#EmptyK<span class="token punctuation">)</span><span class="token punctuation">,</span> deprecated<span class="token punctuation">,</span> unparseAvoid<span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> K <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> K <span class="token string">&quot;~&gt;&quot;</span> K  <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#KSequence<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> assoc<span class="token punctuation">,</span> unit<span class="token punctuation">(</span>#EmptyK<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax left">syntax left</span> #KSequence
  <span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>Sort<span class="token punctuation">}</span> Sort     <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;(&quot;</span> Sort <span class="token string">&quot;)&quot;</span>    <span class="token punctuation">[</span><span class="token class-name">bracket</span><span class="token punctuation">,</span> group<span class="token punctuation">(</span>defaultBracket<span class="token punctuation">)</span><span class="token punctuation">,</span> applyPriority<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><h2>Syntax of Matching Logic</h2>
<p>K provides direct access to the symbols of Matching Logic, while giving them<br>
their own concrete syntax distinct from the syntax of the <code>KORE</code> intermediate<br>
representation. These symbols are primarily used during symbolic execution.<br>
The LLVM Backend has relatively little understanding of Matching Logic directly<br>
and use of these symbols directly in rules is likely to cause it to crash.<br>
However, these symbols are necessary when providing lemmas and other types of<br>
logical assistance to proofs and symbolic execution in the Haskell Backend.</p>
<p>The correspondance between K symbols and KORE symbols is as follows:</p>
<ul>
<li><code>#Top</code> - <code>\top</code></li>
<li><code>#Bottom</code> - <code>\bottom</code></li>
<li><code>#Not</code> - <code>\not</code></li>
<li><code>#Ceil</code> - <code>\ceil</code></li>
<li><code>#Floor</code> - <code>\floor</code></li>
<li><code>#Equals</code> - <code>\equals</code></li>
<li><code>#And</code> - <code>\and</code></li>
<li><code>#Or</code> - <code>\or</code></li>
<li><code>#Implies</code> - <code>\implies</code></li>
<li><code>#Exists</code> - <code>\exists</code></li>
<li><code>#Forall</code> - <code>\forall</code></li>
<li><code>#AG</code> - <code>allPathGlobally</code></li>
<li><code>#wEF</code> - <code>weakExistsFinally</code></li>
<li><code>#wAF</code> - <code>weakAlwaysFinally</code></li>
</ul>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> ML<span class="token operator">-</span>SYNTAX <span class="token punctuation">[</span>not<span class="token operator">-</span>lr1<span class="token punctuation">]</span>
  <span class="token keyword keyword-imports">imports</span> SORT<span class="token operator">-</span>K

  <span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>Sort<span class="token punctuation">}</span> Sort <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;#Top&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#Top<span class="token punctuation">)</span><span class="token punctuation">,</span> group<span class="token punctuation">(</span>mlUnary<span class="token punctuation">)</span><span class="token punctuation">]</span>
                       <span class="token operator">|</span> <span class="token string">&quot;#Bottom&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#Bottom<span class="token punctuation">)</span><span class="token punctuation">,</span> group<span class="token punctuation">(</span>mlUnary<span class="token punctuation">)</span><span class="token punctuation">]</span>
                       <span class="token operator">|</span> <span class="token string">&quot;#Not&quot;</span> <span class="token string">&quot;(&quot;</span> Sort <span class="token string">&quot;)&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#Not<span class="token punctuation">)</span><span class="token punctuation">,</span> mlOp<span class="token punctuation">,</span> group<span class="token punctuation">(</span>mlUnary<span class="token punctuation">,</span> mlOp<span class="token punctuation">)</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>Sort1<span class="token punctuation">,</span> Sort2<span class="token punctuation">}</span> Sort2 <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;#Ceil&quot;</span> <span class="token string">&quot;(&quot;</span> Sort1 <span class="token string">&quot;)&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#Ceil<span class="token punctuation">)</span><span class="token punctuation">,</span> mlOp<span class="token punctuation">,</span> group<span class="token punctuation">(</span>mlUnary<span class="token punctuation">,</span> mlOp<span class="token punctuation">)</span><span class="token punctuation">]</span>
                                <span class="token operator">|</span> <span class="token string">&quot;#Floor&quot;</span> <span class="token string">&quot;(&quot;</span> Sort1 <span class="token string">&quot;)&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#Floor<span class="token punctuation">)</span><span class="token punctuation">,</span> mlOp<span class="token punctuation">,</span> group<span class="token punctuation">(</span>mlUnary<span class="token punctuation">,</span> mlOp<span class="token punctuation">)</span><span class="token punctuation">]</span>
                                <span class="token operator">|</span> <span class="token string">&quot;{&quot;</span> Sort1 <span class="token string">&quot;#Equals&quot;</span> Sort1 <span class="token string">&quot;}&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#Equals<span class="token punctuation">)</span><span class="token punctuation">,</span> mlOp<span class="token punctuation">,</span> group<span class="token punctuation">(</span>mlEquals<span class="token punctuation">,</span> mlOp<span class="token punctuation">)</span><span class="token punctuation">,</span> comm<span class="token punctuation">,</span> <span class="token class-name">format</span><span class="token punctuation">(</span><span class="token operator">%</span><span class="token number">1</span><span class="token operator">%</span>i<span class="token operator">%</span>n<span class="token operator">%</span><span class="token number">2</span><span class="token operator">%</span>d<span class="token operator">%</span>n<span class="token operator">%</span><span class="token number">3</span><span class="token operator">%</span>i<span class="token operator">%</span>n<span class="token operator">%</span><span class="token number">4</span><span class="token operator">%</span>d<span class="token operator">%</span>n<span class="token operator">%</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-syntax priority">syntax priority</span> mlUnary &gt; mlEquals &gt; mlAnd

  <span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>Sort<span class="token punctuation">}</span> Sort <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Sort <span class="token string">&quot;#And&quot;</span> Sort <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#And<span class="token punctuation">)</span><span class="token punctuation">,</span> assoc<span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> comm<span class="token punctuation">,</span> unit<span class="token punctuation">(</span>#Top<span class="token punctuation">)</span><span class="token punctuation">,</span> mlOp<span class="token punctuation">,</span> group<span class="token punctuation">(</span>mlAnd<span class="token punctuation">,</span> mlOp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">format</span><span class="token punctuation">(</span><span class="token operator">%</span>i<span class="token operator">%</span><span class="token number">1</span><span class="token operator">%</span>d<span class="token operator">%</span>n<span class="token operator">%</span><span class="token number">2</span><span class="token operator">%</span>n<span class="token operator">%</span>i<span class="token operator">%</span><span class="token number">3</span><span class="token operator">%</span>d<span class="token punctuation">)</span><span class="token punctuation">]</span>
                       &gt; Sort <span class="token string">&quot;#Or&quot;</span> Sort <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#Or<span class="token punctuation">)</span><span class="token punctuation">,</span> assoc<span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> comm<span class="token punctuation">,</span> unit<span class="token punctuation">(</span>#Bottom<span class="token punctuation">)</span><span class="token punctuation">,</span> mlOp<span class="token punctuation">,</span> group<span class="token punctuation">(</span>mlOp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">format</span><span class="token punctuation">(</span><span class="token operator">%</span>i<span class="token operator">%</span><span class="token number">1</span><span class="token operator">%</span>d<span class="token operator">%</span>n<span class="token operator">%</span><span class="token number">2</span><span class="token operator">%</span>n<span class="token operator">%</span>i<span class="token operator">%</span><span class="token number">3</span><span class="token operator">%</span>d<span class="token punctuation">)</span><span class="token punctuation">]</span>
                       &gt; Sort <span class="token string">&quot;#Implies&quot;</span> Sort <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#Implies<span class="token punctuation">)</span><span class="token punctuation">,</span> mlOp<span class="token punctuation">,</span> group<span class="token punctuation">(</span>mlImplies<span class="token punctuation">,</span> mlOp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">format</span><span class="token punctuation">(</span><span class="token operator">%</span>i<span class="token operator">%</span><span class="token number">1</span><span class="token operator">%</span>d<span class="token operator">%</span>n<span class="token operator">%</span><span class="token number">2</span><span class="token operator">%</span>n<span class="token operator">%</span>i<span class="token operator">%</span><span class="token number">3</span><span class="token operator">%</span>d<span class="token punctuation">)</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-syntax priority">syntax priority</span> mlImplies &gt; mlQuantifier

  <span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>Sort1<span class="token punctuation">,</span> Sort2<span class="token punctuation">}</span> Sort2 <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;#Exists&quot;</span> Sort1 <span class="token string">&quot;.&quot;</span> Sort2 <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#Exists<span class="token punctuation">)</span><span class="token punctuation">,</span> mlOp<span class="token punctuation">,</span> mlBinder<span class="token punctuation">,</span> group<span class="token punctuation">(</span>mlQuantifier<span class="token punctuation">,</span> mlOp<span class="token punctuation">)</span><span class="token punctuation">]</span>
                                <span class="token operator">|</span> <span class="token string">&quot;#Forall&quot;</span> Sort1 <span class="token string">&quot;.&quot;</span> Sort2 <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#Forall<span class="token punctuation">)</span><span class="token punctuation">,</span> mlOp<span class="token punctuation">,</span> mlBinder<span class="token punctuation">,</span> group<span class="token punctuation">(</span>mlQuantifier<span class="token punctuation">,</span> mlOp<span class="token punctuation">)</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>Sort<span class="token punctuation">}</span> Sort <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;#AG&quot;</span> <span class="token string">&quot;(&quot;</span> Sort <span class="token string">&quot;)&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#AG<span class="token punctuation">)</span><span class="token punctuation">,</span> mlOp<span class="token punctuation">,</span> group<span class="token punctuation">(</span>mlOp<span class="token punctuation">)</span><span class="token punctuation">]</span>
                       <span class="token operator">|</span> <span class="token string">&quot;#wEF&quot;</span> <span class="token string">&quot;(&quot;</span> Sort <span class="token string">&quot;)&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>weakExistsFinally<span class="token punctuation">)</span><span class="token punctuation">,</span> mlOp<span class="token punctuation">,</span> group<span class="token punctuation">(</span>mlOp<span class="token punctuation">)</span><span class="token punctuation">]</span>
                       <span class="token operator">|</span> <span class="token string">&quot;#wAF&quot;</span> <span class="token string">&quot;(&quot;</span> Sort <span class="token string">&quot;)&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>weakAlwaysFinally<span class="token punctuation">)</span><span class="token punctuation">,</span> mlOp<span class="token punctuation">,</span> group<span class="token punctuation">(</span>mlOp<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><h2>Variables in K</h2>
<p>Provided below is the syntax of variables in K. There are four types of<br>
variables in K:</p>
<ol>
<li>Regular variables. These are denoted by variables that begin with an<br>
underscore or a capital letter. These variables match exactly one value<br>
and can be used to refer to it on the right-hand-side.</li>
<li>Fresh constants. These are denoted by variables that begin with an <code>!</code>. This<br>
is a convenience syntax which can be used on the right-hand-side only, and<br>
refer to a unique value of the specified sort which is distinct from any<br>
other value that has been generated or will be generated by the <code>!X</code> syntax.<br>
Note that this may not be distinct from values produced via other means.</li>
<li>Existential variables. This refers to variables that are existentially<br>
quantified and begin with a <code>?</code>. They are not required to appear on the<br>
left-hand-side prior to appearing on the right-hand-side, and generally<br>
refer to symbolic quantities that are introduced during rewriting. Refer to<br>
K&apos;s documentation for more details.</li>
<li>Set variables. These are denoted by variables that begin with a <code>@</code>.<br>
These variables refer to a set of values and are generally used when writing<br>
simplification rules in the Haskell Backend. For more information, refer to<br>
K&apos;s documentation.</li>
</ol>
<p>There is also a fifth type of &quot;variable&quot;, although it is not technically a<br>
variable. This refers to configuration variables, which are used to insert<br>
values into the initial configuration that come from outside the semantics.<br>
The most common of these is the <code>$PGM</code> variable, which conventionally contains<br>
the program being executed and is placed in the <code>&lt;k&gt;</code> cell in the configuration<br>
declaration. These &quot;variables&quot; begin with a <code>$</code> and their values are populated<br>
by the frontend prior to symbolic or concrete execution of a program.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> KVARIABLE<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-syntax">syntax</span> #KVariable
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token comment">// To be used when parsing/pretty-printing symbolic configurations</span>
<span class="token keyword keyword-module">module</span> KSEQ<span class="token operator">-</span>SYMBOLIC
  <span class="token keyword keyword-imports">imports</span> KSEQ
  <span class="token keyword keyword-imports">imports</span> ML<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> KVARIABLE<span class="token operator">-</span>SYNTAX

  <span class="token keyword keyword-syntax">syntax</span> #KVariable <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> r<span class="token string">&quot;(\\!|\\?|@)?([A-Z][A-Za-z0-9&apos;_]*|_|_[A-Z][A-Za-z0-9&apos;_]*)&quot;</span>   <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">,</span> prec<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
                      <span class="token operator">|</span> #UpperId                                                          <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> KConfigVar <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> r<span class="token string">&quot;(\\$)([A-Z][A-Za-z0-9&apos;_]*)&quot;</span>            <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> KBott      <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> #KVariable
  <span class="token keyword keyword-syntax">syntax</span> KBott      <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> KConfigVar
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><h2>Syntax of Cells</h2>
<p>While the backend treats cells as regular productions like any other, the<br>
frontend provides a significant amount of convenience notation for dealing with<br>
groups of cells, in order to make writing modular definitions easier. As a<br>
result, we need a syntax for groups of cells and for referring to cells within<br>
rules, configuration declarations, and functions.</p>
<p>For historical reasons, the <code>Bag</code> sort is used to refer to groups of cells.<br>
This may change in a future release. Users can combine cells in any order<br>
by concatenating them together, and can refer to the absence of any cells with<br>
the <code>.Bag</code> symbol. You can also refer to cells within a function by placing<br>
the cell context symbol, <code>[[ K ]]</code> at the top of a rule, placing a function<br>
symbol inside, and referring to cells afterwards. This implicitly inserts<br>
a reference to the configuration at the time prior to the currently-applied<br>
rule being applied which can be matched on within the function. Functions with<br>
such context cannot be referred to in the initial configuration, because the<br>
prior configuration does not yet exist.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> KCELLS
  <span class="token keyword keyword-imports">imports</span> KAST

  <span class="token keyword keyword-syntax">syntax</span> Cell
  <span class="token keyword keyword-syntax">syntax</span> Bag <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Bag Bag  <span class="token punctuation">[</span><span class="token class-name">left</span><span class="token punctuation">,</span> assoc<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>#cells<span class="token punctuation">)</span><span class="token punctuation">,</span> unit<span class="token punctuation">(</span>#cells<span class="token punctuation">)</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;.Bag&quot;</span>   <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#cells<span class="token punctuation">)</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;.::Bag&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#cells<span class="token punctuation">)</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Cell
  <span class="token keyword keyword-syntax">syntax</span> Bag <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;(&quot;</span> Bag <span class="token string">&quot;)&quot;</span> <span class="token punctuation">[</span><span class="token class-name">bracket</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Bag
  <span class="token keyword keyword-syntax">syntax</span> #RuleBody <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;[&quot;</span> <span class="token string">&quot;[&quot;</span> K <span class="token string">&quot;]&quot;</span> <span class="token string">&quot;]&quot;</span> Bag    <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#withConfig<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">avoid</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax non-assoc">syntax non-assoc</span> #withConfig
  <span class="token keyword keyword-syntax">syntax</span> Bag <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> KBott
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>Users can also refer to cells in rules. When doing so, an optional <code>...</code> can<br>
be placed immediately after the start of the cell or immediately before the<br>
end. In a cell whose contents are commutative, these are equivalent to one<br>
another and are also equivalent to placing <code>...</code> in both places. This means<br>
that what is placed in the cell will be combined with the cell contents&apos;<br>
concatenation operator with an unnamed variable. In other words, you match on<br>
some number of elements in the collection and do not care about the rest of<br>
the collection.</p>
<p>In a cell whose contents are not commutative, the <code>...</code> operators correspond<br>
to a variable on the respective side of the contents of the cell that the<br>
<code>...</code> appears. For example, <code>&lt;foo&gt;... L &lt;/foo&gt;</code>, if <code>L</code> is a list, means<br>
some number of elements followed by L. Note that not all combinations are<br>
supported. Cells whose contents are sort <code>K</code> can only have <code>...</code> appear at the<br>
tail of the cell, and cells whose contents are sort <code>List</code> can only have <code>...</code><br>
appear on at most one side in a single rule.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> RULE<span class="token operator">-</span>CELLS
  <span class="token keyword keyword-imports">imports</span> KCELLS
  <span class="token keyword keyword-imports">imports</span> RULE<span class="token operator">-</span>LISTS
  <span class="token comment">// if this module is imported, the parser automatically</span>
  <span class="token comment">// generates, for all productions that have the attribute &apos;cell&apos; or &apos;maincell&apos;,</span>
  <span class="token comment">// a production like below:</span>
  <span class="token comment">//syntax Cell ::= &quot;&lt;top&gt;&quot; #OptionalDots K #OptionalDots &quot;&lt;/top&gt;&quot; [symbol(&lt;top&gt;)]</span>

  <span class="token keyword keyword-syntax">syntax</span> #OptionalDots <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;...&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#dots<span class="token punctuation">)</span><span class="token punctuation">]</span>
                         <span class="token operator">|</span> <span class="token string">&quot;&quot;</span>    <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#noDots<span class="token punctuation">)</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span>
  <span class="token comment">// this production will be added by the compiler to help handle bang variables,</span>
  <span class="token comment">// however, it is valuable to put it here because without this production, it</span>
  <span class="token comment">// will not exist at the point in time when rules and claims are parsed, and</span>
  <span class="token comment">// as a result it makes it very difficult to write proof claims over fragments</span>
  <span class="token comment">// of code that exercise rules containing bang variables. We put it here because</span>
  <span class="token comment">// this production will &quot;vanish&quot; after parsing finishes and not be picked up</span>
  <span class="token comment">// by the compiler, which is the behavior we want in this case since an actual</span>
  <span class="token comment">// production will be generated by the compiler later on.</span>
  <span class="token keyword keyword-syntax">syntax</span> GeneratedCounterCell <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;&lt;generatedCounter&gt;&quot;</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;&lt;/generatedCounter&gt;&quot;</span> <span class="token punctuation">[</span>cell<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>generatedCounter</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span> internal<span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>Users can also declare cells in a configuration declaration. This generates a<br>
specific set of productions that is used internally to implement the cell. The<br>
most important of these is the cell itself, and attributes on this production<br>
can be specified in an xml-attribute-like syntax.</p>
<p>You can also use an xml-short-tag-like syntax to compose configuration cells<br>
together which were defined in different modules. However, it is a requirement<br>
that any K definition have at most one fully-composed configuration; thus, all<br>
other configuration declarations must appear composed within another<br>
configuration declaration.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> CONFIG<span class="token operator">-</span>CELLS
  <span class="token keyword keyword-imports">imports</span> KCELLS
  <span class="token keyword keyword-imports">imports</span> RULE<span class="token operator">-</span>LISTS
  <span class="token keyword keyword-syntax">syntax</span> #CellName <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> r<span class="token string">&quot;[a-zA-Z][a-zA-Z0-9\\-]*&quot;</span>  <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">,</span> prec<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
                     <span class="token operator">|</span> #LowerId            <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
                     <span class="token operator">|</span> #UpperId            <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-syntax">syntax</span> Cell <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;&lt;&quot;</span> #CellName #CellProperties <span class="token string">&quot;&gt;&quot;</span> K <span class="token string">&quot;&lt;/&quot;</span> #CellName <span class="token string">&quot;&gt;&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#configCell<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Cell <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;&lt;&quot;</span> #CellName <span class="token string">&quot;/&gt;&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#externalCell<span class="token punctuation">)</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-syntax">syntax</span> #CellProperties <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> #CellProperty #CellProperties <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#cellPropertyList<span class="token punctuation">)</span><span class="token punctuation">]</span>
                           <span class="token operator">|</span> <span class="token string">&quot;&quot;</span>                            <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#cellPropertyListTerminator<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> #CellProperty <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> #CellName <span class="token string">&quot;=&quot;</span> KString           <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#cellProperty<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><h2>Syntax of Rules</h2>
<p>Rules can have an optional requires clause or an ensures clause. For backwards-<br>
compatibility, you can refer to the requires clause with both the <code>requires</code><br>
and <code>when</code> keywords; The latter, however, is deprecated and may be removed in<br>
a future release.</p>
<p>The requires clause specifies the preconditions that must be true in order<br>
for the rule to apply. The ensures clause specifies the information which<br>
becomes true after the rule has applied. It is a requirement that information<br>
present in the <code>ensures</code> clause refer to existential variables only.</p>
<p>When doing concrete execution, you can think of the <code>requires</code> clause as a<br>
side-condition. In other words, even if the rule matches, it will not apply<br>
unless the <code>requires</code> clause, which must be of sort <code>Bool</code>, evaluates to<br>
<code>true</code>.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> REQUIRES<span class="token operator">-</span>ENSURES
  <span class="token keyword keyword-imports">imports</span> BASIC<span class="token operator">-</span>K

  <span class="token keyword keyword-syntax">syntax</span> #RuleBody <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> K

  <span class="token keyword keyword-syntax">syntax</span> #RuleContent <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> #RuleBody                                 <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span><span class="token string">&quot;#ruleNoConditions&quot;</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
                        <span class="token operator">|</span> #RuleBody <span class="token string">&quot;requires&quot;</span> <span class="token keyword keyword-Bool">Bool</span>                 <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span><span class="token string">&quot;#ruleRequires&quot;</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
                        <span class="token operator">|</span> #RuleBody <span class="token string">&quot;ensures&quot;</span>  <span class="token keyword keyword-Bool">Bool</span>                 <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span><span class="token string">&quot;#ruleEnsures&quot;</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
                        <span class="token operator">|</span> #RuleBody <span class="token string">&quot;requires&quot;</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token string">&quot;ensures&quot;</span> <span class="token keyword keyword-Bool">Bool</span>  <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span><span class="token string">&quot;#ruleRequiresEnsures&quot;</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><h2>Miscellaneous modules</h2>
<p>The below modules are used in various ways as indicators to the implementation<br>
that certain automatically generated syntax should be created by the parser.<br>
These modules should not be imported directly by the user.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> K<span class="token operator">-</span>TOP<span class="token operator">-</span>SORT
  <span class="token keyword keyword-imports">imports</span> SORT<span class="token operator">-</span>KBOTT
  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> KBott
  <span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>Sort<span class="token punctuation">}</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Sort
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> K<span class="token operator">-</span>BOTTOM<span class="token operator">-</span>SORT
  <span class="token keyword keyword-imports">imports</span> SORT<span class="token operator">-</span>KBOTT
  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> KBott
  <span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>Sort<span class="token punctuation">}</span> Sort <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> KBott
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> K<span class="token operator">-</span>SORT<span class="token operator">-</span>LATTICE
  <span class="token keyword keyword-imports">imports</span> K<span class="token operator">-</span>TOP<span class="token operator">-</span>SORT
  <span class="token keyword keyword-imports">imports</span> K<span class="token operator">-</span>BOTTOM<span class="token operator">-</span>SORT
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> AUTO<span class="token operator">-</span>CASTS
  <span class="token comment">// if this module is imported, the parser automatically</span>
  <span class="token comment">// generates, for all sorts, productions of the form:</span>
  <span class="token comment">// Sort  ::= Sort &quot;:Sort&quot;  // semantic cast - force the inner term to be `Sort` or a subsort</span>
  <span class="token comment">// Sort  ::= Sort &quot;::Sort&quot; // strict cast - force the inner term to be exactly `Sort`. Useful for disambiguation</span>
  <span class="token comment">// Sort ::= &quot;{&quot; Sort &quot;}&quot; &quot;::Sort&quot; // synonym for strict cast</span>
  <span class="token comment">// Sort  ::= &quot;{&quot; K &quot;}&quot;    &quot;:&gt;Sort&quot; // projection cast. Allows any term to be placed in a context that expects `Sort`</span>
  <span class="token comment">// this is part of the mechanism that allows concrete user syntax in K</span>
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> AUTO<span class="token operator">-</span>FOLLOW
  <span class="token comment">// if this module is imported, the parser automatically</span>
  <span class="token comment">// generates a follow restriction for every terminal which is a prefix</span>
  <span class="token comment">// of another terminal. This is useful to prevent ambiguities such as:</span>
  <span class="token comment">// syntax K ::= &quot;a&quot;</span>
  <span class="token comment">// syntax K ::= &quot;b&quot;</span>
  <span class="token comment">// syntax K ::= &quot;ab&quot;</span>
  <span class="token comment">// syntax K ::= K K</span>
  <span class="token comment">// #parse(&quot;ab&quot;, &quot;K&quot;)</span>
  <span class="token comment">// In the above example, the terminal &quot;a&quot; is not allowed to be followed by a &quot;b&quot;</span>
  <span class="token comment">// because it would turn the terminal into the terminal &quot;ab&quot;.</span>
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> PROGRAM<span class="token operator">-</span>LISTS
  <span class="token keyword keyword-imports">imports</span> SORT<span class="token operator">-</span>K
  <span class="token comment">// if this module is imported, the parser automatically</span>
  <span class="token comment">// replaces the default productions for lists:</span>
  <span class="token comment">// Es ::= E &quot;,&quot; Es [userList(&quot;*&quot;), symbol(&apos;_,_)]</span>
  <span class="token comment">//      | &quot;.Es&quot;    [userList(&quot;*&quot;), symbol(&apos;.Es)]</span>
  <span class="token comment">// into a series of productions more suitable for programs:</span>
  <span class="token comment">// Es#Terminator ::= &quot;&quot;      [symbol(&apos;.Es)]</span>
  <span class="token comment">// Ne#Es ::= E &quot;,&quot; Ne#Es     [symbol(&apos;_,_)]</span>
  <span class="token comment">//         | E Es#Terminator [symbol(&apos;_,_)]</span>
  <span class="token comment">// Es ::= Ne#Es</span>
  <span class="token comment">//      | Es#Terminator      // if the list is *</span>
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> RULE<span class="token operator">-</span>LISTS
  <span class="token comment">// if this module is imported, the parser automatically</span>
  <span class="token comment">// adds the subsort production to the parsing module only:</span>
  <span class="token comment">// Es ::= E        [userList(&quot;*&quot;)]</span>

<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> RECORD<span class="token operator">-</span>PRODUCTIONS
  <span class="token comment">// if this module is imported, prefix productions of the form</span>
  <span class="token comment">// syntax Sort ::= name(Args)</span>
  <span class="token comment">// will be able to be parsed with don&apos;t-care variables according</span>
  <span class="token comment">// to their nonterminal&apos;s names</span>
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> SORT<span class="token operator">-</span>PREDICATES
  <span class="token comment">// if this module is imported, the Bool sort will be annotated with</span>
  <span class="token comment">// syntax Bool ::= isSort(K) [function]</span>
  <span class="token comment">// and all sorts will be annotated with</span>
  <span class="token comment">// syntax Sort ::= project:Sort(K) [function]</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><h2>Additional Syntax for K Terms in Rules</h2>
<p>Certain additional features are available when parsing the contents of rules<br>
and contexts. For more information on each of these, refer to K&apos;s<br>
documentation.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> KREWRITE
  <span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>Sort<span class="token punctuation">}</span> Sort <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Sort <span class="token string">&quot;=&gt;&quot;</span> Sort <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#KRewrite<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax non-assoc">syntax non-assoc</span> #KRewrite
  <span class="token keyword keyword-syntax priority">syntax priority</span> #KRewrite &gt; #withConfig
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token comment">// To be used to parse semantic rules</span>
<span class="token keyword keyword-module">module</span> K
  <span class="token keyword keyword-imports">imports</span> KSEQ<span class="token operator">-</span>SYMBOLIC
  <span class="token keyword keyword-imports">imports</span> REQUIRES<span class="token operator">-</span>ENSURES
  <span class="token keyword keyword-imports">imports</span> RECORD<span class="token operator">-</span>PRODUCTIONS
  <span class="token keyword keyword-imports">imports</span> SORT<span class="token operator">-</span>PREDICATES
  <span class="token keyword keyword-imports">imports</span> K<span class="token operator">-</span>SORT<span class="token operator">-</span>LATTICE
  <span class="token keyword keyword-imports">imports</span> AUTO<span class="token operator">-</span>CASTS
  <span class="token keyword keyword-imports">imports</span> AUTO<span class="token operator">-</span>FOLLOW
  <span class="token keyword keyword-imports">imports</span> KREWRITE

  <span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>Sort<span class="token punctuation">}</span> Sort <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Sort <span class="token string">&quot;#as&quot;</span> Sort <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#KAs<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token comment">// functions that preserve sorts and can therefore have inner rewrites</span>
  <span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>Sort<span class="token punctuation">}</span> Sort <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;#fun&quot;</span> <span class="token string">&quot;(&quot;</span> Sort <span class="token string">&quot;)&quot;</span> <span class="token string">&quot;(&quot;</span> Sort <span class="token string">&quot;)&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#fun2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">prefer</span><span class="token punctuation">]</span>
  <span class="token comment">// functions that do not preserve sort and therefore cannot have inner rewrites</span>
  <span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>Sort1<span class="token punctuation">,</span> Sort2<span class="token punctuation">}</span> Sort1 <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;#fun&quot;</span> <span class="token string">&quot;(&quot;</span> Sort2 <span class="token string">&quot;=&gt;&quot;</span> Sort1 <span class="token string">&quot;)&quot;</span> <span class="token string">&quot;(&quot;</span> Sort2 <span class="token string">&quot;)&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#fun3<span class="token punctuation">)</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>Sort1<span class="token punctuation">,</span> Sort2<span class="token punctuation">}</span> Sort1 <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;#let&quot;</span> Sort2 <span class="token string">&quot;=&quot;</span> Sort2 <span class="token string">&quot;#in&quot;</span> Sort1 <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#let<span class="token punctuation">)</span><span class="token punctuation">]</span>

  <span class="token comment">/*@ Set membership over terms. In addition to equality over
      concrete patterns, K also supports computing equality
      between a concrete pattern and a symbolic pattern.
      This is compiled efficiently down to pattern matching,
      and can be used by putting a term with unbound variables
      in the left child of :=K or =/=K. Note that this does not
      bind variables used on the lhs however (although this may
      change in the future).*/</span>

  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token class-name">left</span><span class="token punctuation">:</span>
                  K <span class="token string">&quot;:=K&quot;</span> K           <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_<span class="token punctuation">:</span><span class="token operator">=</span>K_<span class="token punctuation">)</span><span class="token punctuation">,</span> group<span class="token punctuation">(</span>equalEqualK<span class="token punctuation">)</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> K <span class="token string">&quot;:/=K&quot;</span> K          <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">=</span>K_<span class="token punctuation">)</span><span class="token punctuation">,</span> group<span class="token punctuation">(</span>notEqualEqualK<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token comment">// To be used to parse terms in full K</span>
<span class="token keyword keyword-module">module</span> K<span class="token operator">-</span>TERM
  <span class="token keyword keyword-imports">imports</span> KSEQ<span class="token operator">-</span>SYMBOLIC
  <span class="token keyword keyword-imports">imports</span> RECORD<span class="token operator">-</span>PRODUCTIONS
  <span class="token keyword keyword-imports">imports</span> SORT<span class="token operator">-</span>PREDICATES
  <span class="token keyword keyword-imports">imports</span> K<span class="token operator">-</span>SORT<span class="token operator">-</span>LATTICE
  <span class="token keyword keyword-imports">imports</span> AUTO<span class="token operator">-</span>CASTS
  <span class="token keyword keyword-imports">imports</span> AUTO<span class="token operator">-</span>FOLLOW
  <span class="token keyword keyword-imports">imports</span> KREWRITE
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><h2>Layout Information</h2>
<p>When constructing a scanner for use during parsing, often you wish to ignore<br>
certain types of text, such as whitespace and comments. However, the specific<br>
syntax which each language must ignore is a little different from language<br>
to language, and thus you wish to specify it manually. You can do this by<br>
defining productions of the <code>#Layout</code> sort. For more information, refer to<br>
K&apos;s documentation. However, this module will be implicitly imported if no<br>
productions are declared of sort <code>#Layout</code>. This module will also be used<br>
for the purposes of parsing K rules. If you wish to declare a language with<br>
no layout productions, simply create a sort declaration for the <code>#Layout</code> sort<br>
in your code (e.g. <code>syntax #Layout</code>).</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> DEFAULT<span class="token operator">-</span>LAYOUT
    <span class="token keyword keyword-syntax">syntax</span> #Layout <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> r<span class="token string">&quot;(\\/\\*([^\\*]|(\\*+([^\\*\\/])))*\\*+\\/)&quot;</span> <span class="token comment">// C-style multi-line comments</span>
                     <span class="token operator">|</span> r<span class="token string">&quot;(\\/\\/[^\\n\\r]*)&quot;</span>                         <span class="token comment">// C-style single-line comments</span>
                     <span class="token operator">|</span> r<span class="token string">&quot;([\\ \\n\\r\\t])&quot;</span>                           <span class="token comment">// Whitespace</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><h2>Default Configuration</h2>
<p>If the user has no configuration declaration in their seamantics, the below<br>
configuration declaration will be implicitly imported.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> DEFAULT<span class="token operator">-</span>CONFIGURATION
  <span class="token keyword keyword-imports">imports</span> BASIC<span class="token operator">-</span>K

  <span class="token keyword keyword-configuration">configuration</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> $PGM<span class="token punctuation">:</span>K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><h2>Parsing Ambiguous Languages</h2>
<p>On occasion, it may be desirable to parse a language with an ambiguous grammar<br>
when parsing a program, and perform additional semantic analysis at a later<br>
time in order to resolve the ambiguities. A good example of this is as a<br>
substitute for the lexer hack in parsers of the <code>C</code> programming language.</p>
<p>The following module contains a declaration for ambiguities in K. Usually,<br>
an ambiguous parse is an error. However, when you use the <code>--gen-glr-parser</code><br>
flag to <code>kast</code>, or the <code>--gen-glr-bison-parser</code> flag to <code>kompile</code>, ambiguities<br>
instead become instances of the below parametric production, which you can use<br>
regular K rules to disambiguate as necessary.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> K<span class="token operator">-</span>AMBIGUITIES

  <span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>Sort<span class="token punctuation">}</span> Sort <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> amb<span class="token punctuation">(</span>Sort<span class="token punctuation">,</span> Sort<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>amb<span class="token punctuation">)</span><span class="token punctuation">]</span>

<span class="token keyword keyword-endmodule">endmodule</span>
</pre><h2>Annotating Parses with Locations</h2>
<p>Another feature of K&apos;s Bison parser is the ability to annotate terms parsed<br>
with location information about the file and line where they occurred. For<br>
more information about how to use this, refer to K&apos;s documentation. However,<br>
the below module exists to provide a user syntax for the annotations that<br>
are generated by the parser.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> K<span class="token operator">-</span>LOCATIONS
  <span class="token keyword keyword-imports">imports</span> STRING<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> INT<span class="token operator">-</span>SYNTAX

  <span class="token comment">// filename, startLine, startCol, endLine, endCol</span>
  <span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>Sort<span class="token punctuation">}</span> Sort <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> #location<span class="token punctuation">(</span>Sort<span class="token punctuation">,</span> <span class="token keyword keyword-String">String</span><span class="token punctuation">,</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#location<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">format</span><span class="token punctuation">(</span><span class="token operator">%</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

<span class="token keyword keyword-endmodule">endmodule</span>
</pre></div></div><div id="ebook-heading-prelude" ebook-toc-level-2 heading="prelude"><div><h1>K Prelude</h1>
<p>The following files, integral to defining semantics in K, are automatically<br>
required by every definition via this file. This behavior can be disabled<br>
via <code>kompile --no-prelude</code>, however, semantics will likely break unless<br>
they provide their own versions of these files, which are assumed to exist<br>
by the compiler. There are, however, circumstances where passing this flag is<br>
appropriate, such as if you are manually requiring these files in your<br>
definition, if your definition was automatically condensed into a single file<br>
with <code>kompile -E</code>, or if you wish to modify the inner syntax of K by providing<br>
your own version of these files with different syntax.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-requires">requires</span> <span class="token string">&quot;kast.md&quot;</span>
<span class="token keyword keyword-requires">requires</span> <span class="token string">&quot;domains.md&quot;</span>
</pre></div></div><div id="ebook-heading-ffi" ebook-toc-level-2 heading="ffi"><div><h1>K Foreign Function Interface</h1>
<p>The K Foreign Function Interface (FFI) module provides a way to call native<br>
functions directly from a K semantics using the C ABI. It also provides<br>
utilities for allocating and deallocating byte buffers with static addresses<br>
that are suitable for being passed to native code.</p>
<p>It is built off of the underlying libffi library<br>
(<a href="https://sourceware.org/libffi/">https://sourceware.org/libffi/</a>) and is subject to some of the same<br>
limitations as that library. Bear in mind, because this library exposes<br>
a number of unsafe C APIs directly, misuse of the library is likely to lead<br>
to memory corruption in your interpreter and can cause segmentation faults or<br>
corrupted term representations that lead to undefined behavior at runtime.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-requires">requires</span> <span class="token string">&quot;domains.md&quot;</span>

<span class="token keyword keyword-module">module</span> FFI<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> private LIST
</pre><p>The FFIType sort is used to declare the native C ABI types of operands passed<br>
to the <code>#ffiCall</code> function. These types roughly correspond to the types<br>
declared in <code>ffi.h</code> by libffi.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> FFIType <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;#void&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ffi_void<span class="token punctuation">)</span><span class="token punctuation">]</span>
                  <span class="token operator">|</span> <span class="token string">&quot;#uint8&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ffi_uint8<span class="token punctuation">)</span><span class="token punctuation">]</span>
                  <span class="token operator">|</span> <span class="token string">&quot;#sint8&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ffi_sint8<span class="token punctuation">)</span><span class="token punctuation">]</span>
                  <span class="token operator">|</span> <span class="token string">&quot;#uint16&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ffi_uint16<span class="token punctuation">)</span><span class="token punctuation">]</span>
                  <span class="token operator">|</span> <span class="token string">&quot;#sint16&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ffi_sint16<span class="token punctuation">)</span><span class="token punctuation">]</span>
                  <span class="token operator">|</span> <span class="token string">&quot;#uint32&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ffi_uint32<span class="token punctuation">)</span><span class="token punctuation">]</span>
                  <span class="token operator">|</span> <span class="token string">&quot;#sint32&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ffi_sint32<span class="token punctuation">)</span><span class="token punctuation">]</span>
                  <span class="token operator">|</span> <span class="token string">&quot;#uint64&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ffi_uint64<span class="token punctuation">)</span><span class="token punctuation">]</span>
                  <span class="token operator">|</span> <span class="token string">&quot;#sint64&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ffi_sint64<span class="token punctuation">)</span><span class="token punctuation">]</span>
                  <span class="token operator">|</span> <span class="token string">&quot;#float&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ffi_float<span class="token punctuation">)</span><span class="token punctuation">]</span>
                  <span class="token operator">|</span> <span class="token string">&quot;#double&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ffi_double<span class="token punctuation">)</span><span class="token punctuation">]</span>
                  <span class="token operator">|</span> <span class="token string">&quot;#uchar&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ffi_uchar<span class="token punctuation">)</span><span class="token punctuation">]</span>
                  <span class="token operator">|</span> <span class="token string">&quot;#schar&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ffi_schar<span class="token punctuation">)</span><span class="token punctuation">]</span>
                  <span class="token operator">|</span> <span class="token string">&quot;#ushort&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ffi_ushort<span class="token punctuation">)</span><span class="token punctuation">]</span>
                  <span class="token operator">|</span> <span class="token string">&quot;#sshort&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ffi_sshort<span class="token punctuation">)</span><span class="token punctuation">]</span>
                  <span class="token operator">|</span> <span class="token string">&quot;#uint&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ffi_uint<span class="token punctuation">)</span><span class="token punctuation">]</span>
                  <span class="token operator">|</span> <span class="token string">&quot;#sint&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ffi_sint<span class="token punctuation">)</span><span class="token punctuation">]</span>
                  <span class="token operator">|</span> <span class="token string">&quot;#ulong&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ffi_ulong<span class="token punctuation">)</span><span class="token punctuation">]</span>
                  <span class="token operator">|</span> <span class="token string">&quot;#slong&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ffi_slong<span class="token punctuation">)</span><span class="token punctuation">]</span>
                  <span class="token operator">|</span> <span class="token string">&quot;#longdouble&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ffi_longdouble<span class="token punctuation">)</span><span class="token punctuation">]</span>
                  <span class="token operator">|</span> <span class="token string">&quot;#pointer&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ffi_pointer<span class="token punctuation">)</span><span class="token punctuation">]</span>
                  <span class="token operator">|</span> <span class="token string">&quot;#complexfloat&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ffi_complexfloat<span class="token punctuation">)</span><span class="token punctuation">]</span>
                  <span class="token operator">|</span> <span class="token string">&quot;#complexdouble&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ffi_complexdouble<span class="token punctuation">)</span><span class="token punctuation">]</span>
                  <span class="token operator">|</span> <span class="token string">&quot;#complexlongdouble&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ffi_complexlongdouble<span class="token punctuation">)</span><span class="token punctuation">]</span>
                  <span class="token operator">|</span> <span class="token string">&quot;#struct&quot;</span> <span class="token string">&quot;(&quot;</span> List <span class="token string">&quot;)&quot;</span> <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>#ffi_struct<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> FFI
  <span class="token keyword keyword-imports">imports</span> FFI<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> private BYTES
  <span class="token keyword keyword-imports">imports</span> private STRING
  <span class="token keyword keyword-imports">imports</span> private BOOL
  <span class="token keyword keyword-imports">imports</span> private LIST
  <span class="token keyword keyword-imports">imports</span> private INT

</pre><h2>FFI Calls</h2>
<p>The <code>#ffiCall</code> functions are designed to call a native C ABI function and<br>
return a native result. They come in three variants:</p>
<h3 class="mume-header" id="non-variadic">Non-variadic</h3>

<p>In the first variant, <code>#ffiCall(Address, Args, ArgTypes, ReturnType)</code> takes<br>
an integer address of a function (which can be obtained from<br>
<code>#functionAddress</code>), a <code>List</code> of <code>Bytes</code> containing the arguments of the<br>
function, a <code>List</code> of <code>FFIType</code>s containing the types of the parameters of the<br>
function, and an <code>FFIType</code> containing the return type of the function, and<br>
returns the return value of the function as a <code>Bytes</code>.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Bytes <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;#ffiCall&quot;</span> <span class="token string">&quot;(&quot;</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;,&quot;</span> List <span class="token string">&quot;,&quot;</span> List <span class="token string">&quot;,&quot;</span> FFIType <span class="token string">&quot;)&quot;</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FFI<span class="token punctuation">.</span>call<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="variadic">Variadic</h3>

<p>In the second variant,<br>
<code>#ffiCall(Address, Args, FixedTypes, VariadicTypes, ReturnType</code> takes an<br>
integer address of a function, a <code>List</code> of <code>Bytes</code> containing the arguments<br>
of the call, a <code>List</code> of <code>FFIType</code>s containing the types of the fixed<br>
parameters of the function, a <code>List</code> of <code>FFIType</code>s containing the types of the<br>
variadic parameters of the function, and an <code>FFIType</code> containing the return<br>
type of the function, and returns the return value of the function as a<br>
<code>Bytes</code>.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Bytes <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;#ffiCall&quot;</span> <span class="token string">&quot;(&quot;</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;,&quot;</span> List <span class="token string">&quot;,&quot;</span> List <span class="token string">&quot;,&quot;</span> List <span class="token string">&quot;,&quot;</span> FFIType <span class="token string">&quot;)&quot;</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FFI<span class="token punctuation">.</span>call_variadic<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="generic">Generic</h3>

<p>In the third variant,<br>
<code>#ffiCall(IsVariadic, Address, Args, ArgTypes, NFixed, ReturnType</code> takes<br>
a boolean indicating whether the function is variadic or not, an integer<br>
address of a function, a <code>List</code> of <code>Bytes</code> containing the arguments of the<br>
call, a <code>List</code> of <code>FFIType</code>s containing the parameter typess of the call<br>
followed by the types of the variadic arguments of the call, if any, an <code>Int</code><br>
containing how many of the arguments of the call are fixed or not, and an<br>
<code>FFIType</code> containing the return type of the function, and returns the return<br>
value of the function as a <code>Bytes</code>.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Bytes <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;#ffiCall&quot;</span> <span class="token string">&quot;(&quot;</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token string">&quot;,&quot;</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;,&quot;</span> List <span class="token string">&quot;,&quot;</span> List <span class="token string">&quot;,&quot;</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;,&quot;</span> FFIType <span class="token string">&quot;)&quot;</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> #ffiCall<span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> Addr<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> Args<span class="token punctuation">:</span><span class="token punctuation">:</span>List<span class="token punctuation">,</span> Types<span class="token punctuation">:</span><span class="token punctuation">:</span>List<span class="token punctuation">,</span> _<span class="token punctuation">,</span> Ret<span class="token punctuation">:</span><span class="token punctuation">:</span>FFIType<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> #ffiCall<span class="token punctuation">(</span>Addr<span class="token punctuation">,</span> Args<span class="token punctuation">,</span> Types<span class="token punctuation">,</span> Ret<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> #ffiCall<span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> Addr<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> Args<span class="token punctuation">:</span><span class="token punctuation">:</span>List<span class="token punctuation">,</span> Types<span class="token punctuation">:</span><span class="token punctuation">:</span>List<span class="token punctuation">,</span> NFixed<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> Ret<span class="token punctuation">:</span><span class="token punctuation">:</span>FFIType<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> #ffiCall<span class="token punctuation">(</span>Addr<span class="token punctuation">,</span> Args<span class="token punctuation">,</span> range<span class="token punctuation">(</span>Types<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size<span class="token punctuation">(</span>Types<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> NFixed<span class="token punctuation">)</span><span class="token punctuation">,</span> range<span class="token punctuation">(</span>Types<span class="token punctuation">,</span> NFixed<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Ret<span class="token punctuation">)</span>
</pre><h2>Symbol Lookup</h2>
<p>The FFI module provides a mechanism to look up any function symbol and return<br>
that function&apos;s address.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;#functionAddress&quot;</span> <span class="token string">&quot;(&quot;</span> <span class="token keyword keyword-String">String</span> <span class="token string">&quot;)&quot;</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FFI<span class="token punctuation">.</span>address<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h2>Direct Memory Management</h2>
<p>Most memory used by the LLVM backend to represent terms is managed<br>
automatically via garbage collection. However, a consequence of this is that<br>
a particular term does not have a fixed address across its entire lifetime<br>
in most cases. Sometimes this is undesirable, especially if you intend for<br>
the address of the memory to be taken by the semantics or if you intend<br>
to pass this memory directly to native code. As a result, the FFI module<br>
exposes the following unsafe APIs for memory management. Note that use of<br>
these APIs leaves the burden of memory management completely on the user,<br>
and thus misuse of these functions can lead to things like use-after-free<br>
and other memory corruption bugs.</p>
<h3 class="mume-header" id="allocation">Allocation</h3>

<p><code>#alloc(Key, Size, Align)</code> will allocate <code>Size</code> bytes with an alignment<br>
requirement of <code>Align</code> (which must be a power of two), and return it as a<br>
<code>Bytes</code> term. The memory is uniquely identified by its key and that key will<br>
be used later to free the memory. The memory is not implicitly freed by garbage<br>
collection; failure to call <code>#free</code> on the memory at a later date can lead to<br>
memory leaks.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Bytes <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;#alloc&quot;</span> <span class="token string">&quot;(&quot;</span> KItem <span class="token string">&quot;,&quot;</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;,&quot;</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;)&quot;</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FFI<span class="token punctuation">.</span>alloc<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="addressing">Addressing</h3>

<p><code>#addess(B)</code> will return an <code>Int</code> representing the address of the first byte of<br>
B, which must be a <code>Bytes</code>. Unless the <code>Bytes</code> term was allocated by <code>#alloc</code>,<br>
the return value is unspecified and may not be the same across multipl<br>
invocations on the same byte buffer. However, it is guaranteed that memory<br>
allocated by <code>#alloc</code> will have the same address throughout its lifetime.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;#address&quot;</span> <span class="token string">&quot;(&quot;</span> Bytes <span class="token string">&quot;)&quot;</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FFI<span class="token punctuation">.</span>bytes_address<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="deallocation">Deallocation</h3>

<p><code>#free(Key)</code> will free the memory of the <code>Bytes</code> object that was allocated<br>
by a previous call to <code>#alloc</code>. If <code>Key</code> was not used in a previous call to<br>
<code>#alloc</code>, or the memory was already freed, no action is taken. It will generate<br>
undefined behavior if the <code>Bytes</code> term returned by the previous call to<br>
<code>#alloc</code> is still referenced by any other term in the configuration or a<br>
currently evaluating rule. The function returns <code>.K</code>.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> K <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;#free&quot;</span> <span class="token string">&quot;(&quot;</span> KItem <span class="token string">&quot;)&quot;</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FFI<span class="token punctuation">.</span>free<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="reading">Reading</h3>

<p><code>#nativeRead(Addr, Mem)</code> will read native memory at address <code>Addr</code> into <code>Mem</code>,<br>
reading exactly <code>lengthBytes(Mem)</code> bytes. This will generate undefined behavior<br>
if <code>Addr</code> does not point to a readable segment of memory at least<br>
<code>lengthBytes(Mem)</code> bytes long.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> K <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;#nativeRead&quot;</span> <span class="token string">&quot;(&quot;</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;,&quot;</span> Bytes <span class="token string">&quot;)&quot;</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FFI<span class="token punctuation">.</span>read<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="writing">Writing</h3>

<p><code>#nativeWrite(Addr, Mem)</code> will write the contents of <code>Mem</code> to native memory at<br>
address <code>Addr</code>. The memory will be read prior to being written, and a write<br>
will only happen if the memory has a different value than the current value of<br>
<code>Mem</code>. This will generate undefined behavior if <code>Addr</code> does not point to a<br>
readable segment of memory at least <code>lengthBytes(Mem)</code> bytes long, or if the<br>
memory at address <code>Addr</code> has a different value than currently contained in<br>
<code>Mem</code>, and the memory in question is not writeable.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> K <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;#nativeWrite&quot;</span> <span class="token string">&quot;(&quot;</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;,&quot;</span> Bytes <span class="token string">&quot;)&quot;</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FFI<span class="token punctuation">.</span>write<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre></div></div><div id="ebook-heading-json" ebook-toc-level-2 heading="json"><div><h1>Syntax of JSON</h1>
<p>K provides builtin support for reading/writing to JSON. While the <code>JSON-SYNTAX</code><br>
module is not precisely the syntax of JSON (utilizing K&apos;s syntax for strings,<br>
integers, and floating point numbers rather than the syntax used by JSON),<br>
you can still convert directly to/from the actual syntax of JSON using<br>
the <code>JSON2String</code> and <code>String2JSON</code> hooks.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> JSON<span class="token operator">-</span>SYNTAX
    <span class="token keyword keyword-imports">imports</span> INT<span class="token operator">-</span>SYNTAX
    <span class="token keyword keyword-imports">imports</span> STRING<span class="token operator">-</span>SYNTAX
    <span class="token keyword keyword-imports">imports</span> BOOL<span class="token operator">-</span>SYNTAX
    <span class="token keyword keyword-imports">imports</span> FLOAT<span class="token operator">-</span>SYNTAX

    <span class="token keyword keyword-syntax">syntax</span> JSONs   <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>JSON<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>      <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>JSONs<span class="token punctuation">)</span><span class="token punctuation">]</span>
    <span class="token keyword keyword-syntax">syntax</span> JSONKey <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-String">String</span>
    <span class="token keyword keyword-syntax">syntax</span> JSON    <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;null&quot;</span>              <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>JSONnull<span class="token punctuation">)</span><span class="token punctuation">]</span>
                     <span class="token operator">|</span> <span class="token keyword keyword-String">String</span> <span class="token operator">|</span> <span class="token keyword keyword-Int">Int</span> <span class="token operator">|</span> <span class="token keyword keyword-Float">Float</span> <span class="token operator">|</span> <span class="token keyword keyword-Bool">Bool</span>
                     <span class="token operator">|</span> JSONKey <span class="token string">&quot;:&quot;</span> JSON    <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>JSONEntry<span class="token punctuation">)</span><span class="token punctuation">]</span>
                     <span class="token operator">|</span> <span class="token string">&quot;{&quot;</span> JSONs <span class="token string">&quot;}&quot;</span>       <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>JSONObject<span class="token punctuation">)</span><span class="token punctuation">]</span>
                     <span class="token operator">|</span> <span class="token string">&quot;[&quot;</span> JSONs <span class="token string">&quot;]&quot;</span>       <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>JSONList<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><h2>Conversion between <code>JSON</code> and <code>String</code></h2>
<p>Given a string written in valid JSON, you can convert it to the <code>JSON</code><br>
sort with the <code>String2JSON</code> function. Assuming the user has not extended<br>
the syntax of the <code>JSON</code> sort with their own constructors, any term of sort<br>
<code>JSON</code> can also be converted to a <code>String</code> using the <code>JSON2String</code> function.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> JSON
    <span class="token keyword keyword-imports">imports</span> JSON<span class="token operator">-</span>SYNTAX

    <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-String">String</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> JSON2String<span class="token punctuation">(</span>JSON<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>JSON2String<span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>JSON<span class="token punctuation">.</span>json2string<span class="token punctuation">)</span><span class="token punctuation">]</span>

    <span class="token keyword keyword-syntax">syntax</span> JSON <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> String2JSON<span class="token punctuation">(</span><span class="token keyword keyword-String">String</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>String2JSON<span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>JSON<span class="token punctuation">.</span>string2json<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre></div></div><div id="ebook-heading-rat" ebook-toc-level-2 heading="rat"><div><h1>Rational Numbers in K</h1>
<p>K provides support for arbitrary-precision rational numbers represented as a<br>
quotient between two integers. The sort representing these values is <code>Rat</code>.<br>
<code>Int</code> is a subsort of <code>Rat</code>, and it is guaranteed that any integer will be<br>
represented as an <code>Int</code> and can be matched as such on the left hand side<br>
of rules. K also supports the usual arithmetic operators over rational numbers.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> RAT<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> INT<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> private BOOL

  <span class="token keyword keyword-syntax">syntax</span> Rat

  <span class="token keyword keyword-syntax">syntax</span> Rat <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span>
</pre><h2>Arithmetic</h2>
<p>You can:</p>
<ul>
<li>Raise a rational number to any negative or nonnegative integer.</li>
<li>Multiply or divide two rational numbers to obtain a product or quotient.</li>
<li>Add or subtract two rational numbers to obtain a sum or difference.</li>
</ul>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Rat <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token class-name">left</span><span class="token punctuation">:</span>
                 Rat <span class="token string">&quot;^Rat&quot;</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_<span class="token operator">^</span>Rat_<span class="token punctuation">)</span><span class="token punctuation">,</span>  smtlib<span class="token punctuation">(</span>ratpow<span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>RAT<span class="token punctuation">.</span>pow<span class="token punctuation">)</span><span class="token punctuation">]</span>
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                 Rat <span class="token string">&quot;*Rat&quot;</span> Rat <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_<span class="token operator">*</span>Rat_<span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token class-name">left</span><span class="token punctuation">,</span> smtlib<span class="token punctuation">(</span>ratmul<span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>RAT<span class="token punctuation">.</span>mul<span class="token punctuation">)</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Rat <span class="token string">&quot;/Rat&quot;</span> Rat <span class="token punctuation">[</span>function<span class="token punctuation">,</span>             <span class="token class-name">symbol</span><span class="token punctuation">(</span>_<span class="token operator">/</span>Rat_<span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token class-name">left</span><span class="token punctuation">,</span> smtlib<span class="token punctuation">(</span>ratdiv<span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>RAT<span class="token punctuation">.</span>div<span class="token punctuation">)</span><span class="token punctuation">]</span>
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                 Rat <span class="token string">&quot;+Rat&quot;</span> Rat <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_<span class="token operator">+</span>Rat_<span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token class-name">left</span><span class="token punctuation">,</span> smtlib<span class="token punctuation">(</span>ratadd<span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>RAT<span class="token punctuation">.</span>add<span class="token punctuation">)</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Rat <span class="token string">&quot;-Rat&quot;</span> Rat <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_<span class="token operator">-</span>Rat_<span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token class-name">left</span><span class="token punctuation">,</span> smtlib<span class="token punctuation">(</span>ratsub<span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>RAT<span class="token punctuation">.</span>sub<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h2>Comparison</h2>
<p>You can determine whether two rational numbers are equal, unequal, or compare<br>
one of less than, less than or equalto, greater than, or greater than or equal<br>
to the other:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Rat  <span class="token string">&quot;==Rat&quot;</span> Rat <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_<span class="token operator">==</span>Rat_<span class="token punctuation">)</span><span class="token punctuation">,</span>  smtlib<span class="token punctuation">(</span>rateq<span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>RAT<span class="token punctuation">.</span>eq<span class="token punctuation">)</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> Rat <span class="token string">&quot;=/=Rat&quot;</span> Rat <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_<span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>Rat_<span class="token punctuation">)</span><span class="token punctuation">,</span> smtlib<span class="token punctuation">(</span>ratne<span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>RAT<span class="token punctuation">.</span>ne<span class="token punctuation">)</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> Rat   <span class="token string">&quot;&gt;Rat&quot;</span> Rat <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_&gt;Rat_<span class="token punctuation">)</span><span class="token punctuation">,</span>   smtlib<span class="token punctuation">(</span>ratgt<span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>RAT<span class="token punctuation">.</span>gt<span class="token punctuation">)</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> Rat  <span class="token string">&quot;&gt;=Rat&quot;</span> Rat <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_<span class="token operator">&gt;=</span>Rat_<span class="token punctuation">)</span><span class="token punctuation">,</span>  smtlib<span class="token punctuation">(</span>ratge<span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>RAT<span class="token punctuation">.</span>ge<span class="token punctuation">)</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> Rat   <span class="token string">&quot;&lt;Rat&quot;</span> Rat <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_&lt;Rat_<span class="token punctuation">)</span><span class="token punctuation">,</span>   smtlib<span class="token punctuation">(</span>ratlt<span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>RAT<span class="token punctuation">.</span>lt<span class="token punctuation">)</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> Rat  <span class="token string">&quot;&lt;=Rat&quot;</span> Rat <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>_<span class="token operator">&lt;=</span>Rat_<span class="token punctuation">)</span><span class="token punctuation">,</span>  smtlib<span class="token punctuation">(</span>ratle<span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>RAT<span class="token punctuation">.</span>le<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h2>Min/Max</h2>
<p>You can compute the minimum and maximum of two rational numbers:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Rat <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> minRat<span class="token punctuation">(</span>Rat<span class="token punctuation">,</span> Rat<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>minRat<span class="token punctuation">)</span><span class="token punctuation">,</span> smtlib<span class="token punctuation">(</span>ratmin<span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>RAT<span class="token punctuation">.</span>min<span class="token punctuation">)</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> maxRat<span class="token punctuation">(</span>Rat<span class="token punctuation">,</span> Rat<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">(</span>maxRat<span class="token punctuation">)</span><span class="token punctuation">,</span> smtlib<span class="token punctuation">(</span>ratmax<span class="token punctuation">)</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>RAT<span class="token punctuation">.</span>max<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h2>Conversion to Floating Point</h2>
<p>You can convert a rational number to the nearest floating point number that<br>
is representable in a <code>Float</code> of a specified number of precision and exponent<br>
bits:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Float">Float</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Rat2Float<span class="token punctuation">(</span>Rat<span class="token punctuation">,</span> precision<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> exponentBits<span class="token punctuation">:</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><h2>Implementation of Rational Numbers</h2>
<p>The remainder of this file consists of an implementation in K of the<br>
operations listed above. Users of the RAT module should not use any of the<br>
syntax defined in any of these modules.</p>
<p>As a point of reference for users, it is worth noting that rational numbers<br>
are normalized to a canonical form by this module,. with the canonical form<br>
bearing the property that it is either an <code>Int</code>, or a pair of integers<br>
<code>I /Rat J</code> such that<br>
<code>I =/=Int 0 andBool J &gt;=Int 2 andBool gcdInt(I, J) ==Int 1</code> is always true.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> RAT<span class="token operator">-</span>COMMON
  <span class="token keyword keyword-imports">imports</span> RAT<span class="token operator">-</span>SYNTAX

  <span class="token comment">// invariant of &lt; I , J &gt;Rat : I =/= 0, J &gt;= 2, and I and J are coprime</span>
  <span class="token keyword keyword-syntax">syntax</span> Rat <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;&lt;&quot;</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;,&quot;</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;&gt;Rat&quot;</span> <span class="token punctuation">[</span><span class="token class-name">format</span><span class="token punctuation">(</span><span class="token operator">%</span><span class="token number">2</span> <span class="token operator">/</span>Rat <span class="token operator">%</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> RAT<span class="token operator">-</span>SYMBOLIC <span class="token punctuation">[</span>symbolic<span class="token punctuation">]</span>
  <span class="token keyword keyword-imports">imports</span> private RAT<span class="token operator">-</span>COMMON
  <span class="token keyword keyword-imports">imports</span> ML<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> private BOOL

  <span class="token keyword keyword-rule">rule</span>
    #Ceil<span class="token punctuation">(</span>@R1<span class="token punctuation">:</span>Rat <span class="token operator">/</span>Rat @R2<span class="token punctuation">:</span>Rat<span class="token punctuation">)</span>
  <span class="token operator">=&gt;</span>
    <span class="token punctuation">{</span><span class="token punctuation">(</span>@R2 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>Rat <span class="token number">0</span><span class="token punctuation">)</span> #Equals <span class="token boolean">true</span><span class="token punctuation">}</span> #And #Ceil<span class="token punctuation">(</span>@R1<span class="token punctuation">)</span> #And #Ceil<span class="token punctuation">(</span>@R2<span class="token punctuation">)</span>
  <span class="token punctuation">[</span>simplification<span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> RAT<span class="token operator">-</span>KORE
  <span class="token keyword keyword-imports">imports</span> private RAT<span class="token operator">-</span>COMMON
  <span class="token keyword keyword-imports">imports</span> private K<span class="token operator">-</span>EQUAL

  <span class="token comment">/*
   * equalities
   */</span>

  <span class="token comment">// NOTE: the two rules below may not work correctly in non-kore backends</span>

  <span class="token keyword keyword-rule">rule</span> R <span class="token operator">==</span>Rat S <span class="token operator">=&gt;</span> R <span class="token operator">==</span>K S

  <span class="token keyword keyword-rule">rule</span> R <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>Rat S <span class="token operator">=&gt;</span> R <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K S
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> RAT <span class="token punctuation">[</span>private<span class="token punctuation">]</span>
  <span class="token keyword keyword-imports">imports</span> private RAT<span class="token operator">-</span>COMMON
  <span class="token keyword keyword-imports">imports</span> public RAT<span class="token operator">-</span>SYMBOLIC
  <span class="token keyword keyword-imports">imports</span> public RAT<span class="token operator">-</span>KORE
  <span class="token keyword keyword-imports">imports</span> public RAT<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> private INT
  <span class="token keyword keyword-imports">imports</span> private BOOL

  <span class="token comment">/*
   * arithmetic
   */</span>

  <span class="token keyword keyword-rule">rule</span> &lt; I <span class="token punctuation">,</span> I<span class="token string">&apos; &gt;Rat +Rat &lt; J , J&apos;</span> &gt;Rat <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>I <span class="token operator">*</span><span class="token keyword keyword-Int">Int</span> J<span class="token string">&apos;) +Int (I&apos;</span> <span class="token operator">*</span><span class="token keyword keyword-Int">Int</span> J<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span>Rat <span class="token punctuation">(</span>I<span class="token string">&apos; *Int J&apos;</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span>         <span class="token operator">+</span>Rat &lt; J <span class="token punctuation">,</span> J<span class="token string">&apos; &gt;Rat =&gt; ((I *Int J&apos;</span><span class="token punctuation">)</span> <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> J<span class="token punctuation">)</span> <span class="token operator">/</span>Rat J&apos;
  <span class="token keyword keyword-rule">rule</span> &lt; J <span class="token punctuation">,</span> J<span class="token string">&apos; &gt;Rat +Rat I:Int         =&gt; I +Rat &lt; J , J&apos;</span> &gt;Rat
  <span class="token keyword keyword-rule">rule</span> I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span>         <span class="token operator">+</span>Rat J<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span>         <span class="token operator">=&gt;</span> I <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> J

  <span class="token keyword keyword-rule">rule</span> &lt; I <span class="token punctuation">,</span> I<span class="token string">&apos; &gt;Rat *Rat &lt; J , J&apos;</span> &gt;Rat <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>I <span class="token operator">*</span><span class="token keyword keyword-Int">Int</span> J<span class="token punctuation">)</span> <span class="token operator">/</span>Rat <span class="token punctuation">(</span>I<span class="token string">&apos; *Int J&apos;</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span>         <span class="token operator">*</span>Rat &lt; J <span class="token punctuation">,</span> J<span class="token string">&apos; &gt;Rat =&gt; (I *Int J) /Rat J&apos;</span>
  <span class="token keyword keyword-rule">rule</span> &lt; J <span class="token punctuation">,</span> J<span class="token string">&apos; &gt;Rat *Rat I:Int         =&gt; I *Rat &lt; J , J&apos;</span> &gt;Rat
  <span class="token keyword keyword-rule">rule</span> I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span>         <span class="token operator">*</span>Rat J<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span>         <span class="token operator">=&gt;</span> I <span class="token operator">*</span><span class="token keyword keyword-Int">Int</span> J

  <span class="token keyword keyword-rule">rule</span> &lt; I <span class="token punctuation">,</span> I<span class="token string">&apos; &gt;Rat /Rat &lt; J , J&apos;</span> &gt;Rat <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>I <span class="token operator">*</span><span class="token keyword keyword-Int">Int</span> J<span class="token string">&apos;) /Rat (I&apos;</span> <span class="token operator">*</span><span class="token keyword keyword-Int">Int</span> J<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span>         <span class="token operator">/</span>Rat &lt; J <span class="token punctuation">,</span> J<span class="token string">&apos; &gt;Rat =&gt; (I *Int J&apos;</span><span class="token punctuation">)</span> <span class="token operator">/</span>Rat J
  <span class="token keyword keyword-rule">rule</span> &lt; I <span class="token punctuation">,</span> I<span class="token string">&apos; &gt;Rat /Rat J:Int         =&gt; I /Rat (I&apos;</span> <span class="token operator">*</span><span class="token keyword keyword-Int">Int</span> J<span class="token punctuation">)</span> <span class="token keyword keyword-requires">requires</span> J <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span><span class="token keyword keyword-Int">Int</span> <span class="token number">0</span>
  <span class="token keyword keyword-rule">rule</span> I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span>         <span class="token operator">/</span>Rat J<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span>         <span class="token operator">=&gt;</span> makeRat<span class="token punctuation">(</span>I<span class="token punctuation">,</span> J<span class="token punctuation">)</span>      <span class="token keyword keyword-requires">requires</span> J <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span><span class="token keyword keyword-Int">Int</span> <span class="token number">0</span>

  <span class="token comment">// derived</span>

  <span class="token keyword keyword-rule">rule</span> R <span class="token operator">-</span>Rat S <span class="token operator">=&gt;</span> R <span class="token operator">+</span>Rat <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">*</span>Rat S<span class="token punctuation">)</span>

  <span class="token comment">// normalize</span>

  <span class="token keyword keyword-syntax">syntax</span> Rat <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> makeRat<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span>      <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
               <span class="token operator">|</span> makeRat<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> makeRat<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> J<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token number">0</span> <span class="token keyword keyword-requires">requires</span> J <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span><span class="token keyword keyword-Int">Int</span> <span class="token number">0</span>

  <span class="token keyword keyword-rule">rule</span> makeRat<span class="token punctuation">(</span>I<span class="token punctuation">,</span> J<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> makeRat<span class="token punctuation">(</span>I<span class="token punctuation">,</span> J<span class="token punctuation">,</span> gcdInt<span class="token punctuation">(</span>I<span class="token punctuation">,</span>J<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword keyword-requires">requires</span> I <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span><span class="token keyword keyword-Int">Int</span> <span class="token number">0</span> andBool J <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span><span class="token keyword keyword-Int">Int</span> <span class="token number">0</span>

  <span class="token comment">// makeRat(I, J, D) is defined when I =/= 0, J =/= 0, D &gt; 0, and D = gcd(I,J)</span>
  <span class="token keyword keyword-rule">rule</span> makeRat<span class="token punctuation">(</span>I<span class="token punctuation">,</span> J<span class="token punctuation">,</span> D<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> I <span class="token operator">/</span><span class="token keyword keyword-Int">Int</span> D                       <span class="token keyword keyword-requires">requires</span> J <span class="token operator">==</span><span class="token keyword keyword-Int">Int</span> D <span class="token comment">// implies J &gt; 0 since D &gt; 0</span>
  <span class="token keyword keyword-rule">rule</span> makeRat<span class="token punctuation">(</span>I<span class="token punctuation">,</span> J<span class="token punctuation">,</span> D<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> &lt; I <span class="token operator">/</span><span class="token keyword keyword-Int">Int</span> D <span class="token punctuation">,</span> J <span class="token operator">/</span><span class="token keyword keyword-Int">Int</span> D &gt;Rat     <span class="token keyword keyword-requires">requires</span> J &gt;<span class="token keyword keyword-Int">Int</span> <span class="token number">0</span> andBool J <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span><span class="token keyword keyword-Int">Int</span> D
  <span class="token keyword keyword-rule">rule</span> makeRat<span class="token punctuation">(</span>I<span class="token punctuation">,</span> J<span class="token punctuation">,</span> D<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> makeRat<span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> I<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> J<span class="token punctuation">,</span> D<span class="token punctuation">)</span> <span class="token keyword keyword-requires">requires</span> J &lt;<span class="token keyword keyword-Int">Int</span> <span class="token number">0</span>

  <span class="token comment">// gcdInt(a,b) computes the gcd of |a| and |b|, which is positive.</span>
  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> gcdInt<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> public<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> gcdInt<span class="token punctuation">(</span>A<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> A        <span class="token keyword keyword-requires">requires</span> A &gt;<span class="token keyword keyword-Int">Int</span> <span class="token number">0</span>
  <span class="token keyword keyword-rule">rule</span> gcdInt<span class="token punctuation">(</span>A<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token number">0</span> <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> A <span class="token keyword keyword-requires">requires</span> A &lt;<span class="token keyword keyword-Int">Int</span> <span class="token number">0</span>
  <span class="token keyword keyword-rule">rule</span> gcdInt<span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> gcdInt<span class="token punctuation">(</span>B<span class="token punctuation">,</span> A <span class="token operator">%</span><span class="token keyword keyword-Int">Int</span> B<span class="token punctuation">)</span> <span class="token keyword keyword-requires">requires</span> B <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span><span class="token keyword keyword-Int">Int</span> <span class="token number">0</span> <span class="token comment">// since |A %Int B| = |A| %Int |B|</span>

  <span class="token comment">/*
   * exponentiation
   */</span>

  <span class="token keyword keyword-rule">rule</span> _ <span class="token operator">^</span>Rat <span class="token number">0</span> <span class="token operator">=&gt;</span> <span class="token number">1</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token number">0</span> <span class="token operator">^</span>Rat N <span class="token operator">=&gt;</span> <span class="token number">0</span> <span class="token keyword keyword-requires">requires</span> N <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span><span class="token keyword keyword-Int">Int</span> <span class="token number">0</span>

  <span class="token keyword keyword-rule">rule</span> &lt; I <span class="token punctuation">,</span> J &gt;Rat <span class="token operator">^</span>Rat N <span class="token operator">=&gt;</span> powRat<span class="token punctuation">(</span>&lt; I <span class="token punctuation">,</span> J &gt;Rat<span class="token punctuation">,</span> N<span class="token punctuation">)</span> <span class="token keyword keyword-requires">requires</span> N &gt;<span class="token keyword keyword-Int">Int</span> <span class="token number">0</span>
  <span class="token keyword keyword-rule">rule</span> X<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span>        <span class="token operator">^</span>Rat N <span class="token operator">=&gt;</span> X <span class="token operator">^</span><span class="token keyword keyword-Int">Int</span> N                <span class="token keyword keyword-requires">requires</span> N &gt;<span class="token keyword keyword-Int">Int</span> <span class="token number">0</span>

  <span class="token keyword keyword-rule">rule</span> X <span class="token operator">^</span>Rat N <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">/</span>Rat X<span class="token punctuation">)</span> <span class="token operator">^</span>Rat <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> N<span class="token punctuation">)</span> <span class="token keyword keyword-requires">requires</span> X <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>Rat <span class="token number">0</span> andBool N &lt;<span class="token keyword keyword-Int">Int</span> <span class="token number">0</span>

  <span class="token comment">// exponentiation by squaring</span>

  <span class="token keyword keyword-syntax">syntax</span> Rat <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> powRat<span class="token punctuation">(</span>Rat<span class="token punctuation">,</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>

  <span class="token comment">// powRat(X, N) is defined when X =/= 0 and N &gt; 0</span>
  <span class="token keyword keyword-rule">rule</span> powRat<span class="token punctuation">(</span>X<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> X
  <span class="token keyword keyword-rule">rule</span> powRat<span class="token punctuation">(</span>X<span class="token punctuation">,</span> N<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> powRat<span class="token punctuation">(</span>X <span class="token operator">*</span>Rat X<span class="token punctuation">,</span> N <span class="token operator">/</span><span class="token keyword keyword-Int">Int</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword keyword-requires">requires</span> N &gt;<span class="token keyword keyword-Int">Int</span> <span class="token number">1</span> andBool N <span class="token operator">%</span><span class="token keyword keyword-Int">Int</span> <span class="token number">2</span>  <span class="token operator">==</span><span class="token keyword keyword-Int">Int</span> <span class="token number">0</span>
  <span class="token keyword keyword-rule">rule</span> powRat<span class="token punctuation">(</span>X<span class="token punctuation">,</span> N<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> powRat<span class="token punctuation">(</span>X<span class="token punctuation">,</span> N <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span>Rat X <span class="token keyword keyword-requires">requires</span> N &gt;<span class="token keyword keyword-Int">Int</span> <span class="token number">1</span> andBool N <span class="token operator">%</span><span class="token keyword keyword-Int">Int</span> <span class="token number">2</span> <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span><span class="token keyword keyword-Int">Int</span> <span class="token number">0</span>

  <span class="token comment">/*
   * inequalities
   */</span>

  <span class="token keyword keyword-rule">rule</span> R &gt;Rat S <span class="token operator">=&gt;</span> R <span class="token operator">-</span>Rat S &gt;Rat <span class="token number">0</span> <span class="token keyword keyword-requires">requires</span> S <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>Rat <span class="token number">0</span>

  <span class="token keyword keyword-rule">rule</span> &lt; I <span class="token punctuation">,</span> _ &gt;Rat &gt;Rat <span class="token number">0</span> <span class="token operator">=&gt;</span> I &gt;<span class="token keyword keyword-Int">Int</span> <span class="token number">0</span>
  <span class="token keyword keyword-rule">rule</span> I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span>        &gt;Rat <span class="token number">0</span> <span class="token operator">=&gt;</span> I &gt;<span class="token keyword keyword-Int">Int</span> <span class="token number">0</span>

  <span class="token comment">// derived</span>

  <span class="token keyword keyword-rule">rule</span> R <span class="token operator">&gt;=</span>Rat S <span class="token operator">=&gt;</span> notBool R &lt;Rat S

  <span class="token keyword keyword-rule">rule</span> R &lt;Rat S <span class="token operator">=&gt;</span> S &gt;Rat R

  <span class="token keyword keyword-rule">rule</span> R <span class="token operator">&lt;=</span>Rat S <span class="token operator">=&gt;</span> S <span class="token operator">&gt;=</span>Rat R

  <span class="token keyword keyword-rule">rule</span> minRat<span class="token punctuation">(</span>R<span class="token punctuation">,</span> S<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> R <span class="token keyword keyword-requires">requires</span> R <span class="token operator">&lt;=</span>Rat S
  <span class="token keyword keyword-rule">rule</span> minRat<span class="token punctuation">(</span>R<span class="token punctuation">,</span> S<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> S <span class="token keyword keyword-requires">requires</span> S <span class="token operator">&lt;=</span>Rat R

  <span class="token keyword keyword-rule">rule</span> maxRat<span class="token punctuation">(</span>R<span class="token punctuation">,</span> S<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> R <span class="token keyword keyword-requires">requires</span> R <span class="token operator">&gt;=</span>Rat S
  <span class="token keyword keyword-rule">rule</span> maxRat<span class="token punctuation">(</span>R<span class="token punctuation">,</span> S<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> S <span class="token keyword keyword-requires">requires</span> S <span class="token operator">&gt;=</span>Rat R

  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Float">Float</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> #Rat2Float<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> <span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>FLOAT<span class="token punctuation">.</span>rat2float<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> Rat2Float<span class="token punctuation">(</span>Num<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> Prec<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> Exp<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> #Rat2Float<span class="token punctuation">(</span>Num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> Prec<span class="token punctuation">,</span> Exp<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> Rat2Float<span class="token punctuation">(</span>&lt; Num<span class="token punctuation">,</span> Dem &gt;Rat<span class="token punctuation">,</span> Prec<span class="token punctuation">,</span> Exp<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> #Rat2Float<span class="token punctuation">(</span>Num<span class="token punctuation">,</span> Dem<span class="token punctuation">,</span> Prec<span class="token punctuation">,</span> Exp<span class="token punctuation">)</span>

<span class="token keyword keyword-endmodule">endmodule</span>
</pre></div></div><div id="ebook-heading-substitution" ebook-toc-level-2 heading="substitution"><div><h1>Capture-Aware Substitution in K</h1>
<p>One of the traditional ways in which functional languages are given operational<br>
semantics is via substitution. In particular, you can view a function as<br>
declaring a particular bound variable, the parameter of the function, as well<br>
as the body of the function, within which both bound and free variables can<br>
occur, and implement the process of beta-reduction (one of the axioms of the<br>
lambda calculus) by means of a substitution operator which is aware of the<br>
difference between free variables and bound variables and prevents variable<br>
capture.</p>
<p>In K this is implemented using two mechanisms: The <code>KVar</code> sort, and the<br>
<code>binder</code> attribute.</p>
<h2>The <code>KVar</code> Sort</h2>
<p>K introduces a new hooked sort, <code>KVar</code>, which the substitution operator<br>
(defined below) understands in a particular way. The syntax of <code>KVar</code> is the<br>
same as for sort <code>Id</code> in <code>DOMAINS</code>, but with a different sort name. Similarly,<br>
some of the same operators are defined over <code>KVar</code> which are defined for <code>Id</code>,<br>
such as conversion from <code>String</code> to <code>KVar</code> and support for the <code>!Var:KVar</code><br>
syntax.</p>
<p>A <code>KVar</code> is simply an identifier with special meaning during substitution.<br>
<code>KVar</code>s must begin with a letter or underscore,<br>
and can be followed by zero or more letters, numbers, or underscores.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> KVAR<span class="token operator">-</span>SYNTAX<span class="token operator">-</span>PROGRAM<span class="token operator">-</span>PARSING
  <span class="token keyword keyword-imports">imports</span> BUILTIN<span class="token operator">-</span>ID<span class="token operator">-</span>TOKENS

  <span class="token keyword keyword-syntax">syntax</span> KVar <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> r<span class="token string">&quot;[A-Za-z\\_][A-Za-z0-9\\_]*&quot;</span>     <span class="token punctuation">[</span>prec<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">token</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> #LowerId                                             <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> #UpperId                                             <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> KVAR<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-syntax">syntax</span> KVar <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">,</span> hook<span class="token punctuation">(</span>KVAR<span class="token punctuation">.</span>KVar<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> KVAR<span class="token operator">-</span>COMMON
  <span class="token keyword keyword-imports">imports</span> KVAR<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> private STRING

  <span class="token keyword keyword-syntax">syntax</span> KVar <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> String2KVar <span class="token punctuation">(</span><span class="token keyword keyword-String">String</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>STRING<span class="token punctuation">.</span>string2token<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> KVar <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> freshKVar<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span>    <span class="token punctuation">[</span>freshGenerator<span class="token punctuation">,</span> function<span class="token punctuation">,</span> total<span class="token punctuation">,</span> private<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> freshKVar<span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> String2KVar<span class="token punctuation">(</span><span class="token string">&quot;_&quot;</span> <span class="token operator">+</span><span class="token keyword keyword-String">String</span> Int2String<span class="token punctuation">(</span>I<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> KVAR
  <span class="token keyword keyword-imports">imports</span> KVAR<span class="token operator">-</span>COMMON
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><h2>The <code>binder</code> Attribute</h2>
<p>A production can be given the attribute <code>binder</code>. Such a production must have<br>
at least two nonterminals. The first nonterminal from left to right must be of<br>
sort <code>KVar</code>, and contains the bound variable. The last nonterminal from left<br>
to right contains the term that is bound. For example, I could describe lambdas<br>
in the lambda calculus with the production<br>
<code>syntax Val ::= &quot;lambda&quot; KVar &quot;.&quot; Exp [binder]</code>.</p>
<h2>Substitution</h2>
<p>K provides a hooked implementation of substitution, currently only implemented<br>
on the Java and LLVM backends. Two variants exist: the first substitutes<br>
a single <code>KVar</code> for a single <code>KItem</code>. The second takes a <code>Map</code> with <code>KVar</code><br>
keys and <code>KItem</code> values, and substitutes each element in the map atomically.</p>
<p>Internally, this is implemented in the LLVM backend by a combination of<br>
<code>de Bruijn</code> indices for bound variables and names for free variables. Free<br>
variables are also sometimes given a unique numeric identifier in order to<br>
prevent capture, and the rewriter will automatically assign unique names to<br>
such identifiers when rewriting finishes. The names assigned will always begin<br>
with the original name of the variable and be followed by a unique integer<br>
suffix. However, the names assigned after rewriting finishes might be different<br>
from the names that would be assigned if rewriting were to halt prematurely,<br>
for example due to <code>krun --depth</code>.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> SUBSTITUTION
  <span class="token keyword keyword-imports">imports</span> private MAP
  <span class="token keyword keyword-imports">imports</span> KVAR

  <span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>Sort<span class="token punctuation">}</span> Sort <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Sort <span class="token string">&quot;[&quot;</span> KItem <span class="token string">&quot;/&quot;</span> KItem <span class="token string">&quot;]&quot;</span>  <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>SUBSTITUTION<span class="token punctuation">.</span>substOne<span class="token punctuation">)</span><span class="token punctuation">,</span> impure<span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> <span class="token punctuation">{</span>Sort<span class="token punctuation">}</span> Sort <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Sort <span class="token string">&quot;[&quot;</span> Map <span class="token string">&quot;]&quot;</span>      <span class="token punctuation">[</span>function<span class="token punctuation">,</span> hook<span class="token punctuation">(</span>SUBSTITUTION<span class="token punctuation">.</span>substMany<span class="token punctuation">)</span><span class="token punctuation">,</span> impure<span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre></div></div><div id="ebook-heading-unification" ebook-toc-level-2 heading="unification"><div></div></div><div id="ebook-heading-k-pl-tutorial" ebook-toc-level-1 heading="K PL Tutorial"><div><h1 class="mume-header" id="k-pl-tutorial">K PL Tutorial</h1>

<p>Here you will learn how to use the K tool to define languages by means of a series of screencast movies. It is recommended to do these in the indicated order, because K features already discussed in a previous language definition will likely not be rediscussed in latter definitions. The screencasts follow quite closely the structure of the files under the <a href="https://github.com/runtimeverification/k/tree/master/k-distribution/pl-tutorial">tutorial folder</a> in the K tool distribution. If you&apos;d rather follow the instructions there and do the tutorial exercises yourself, then go back to <a href="https://kframework.org">https://kframework.org</a> and download the K tool, if you have not done it already. Or, you can first watch the screencasts below and then do the exercises, or do them in parallel.</p>
<h2 class="mume-header" id="k-overview">K Overview</h2>

<p>Make sure you watch the K overview video before you do the K tutorial:</p>
<ul>
<li>[9&apos;59&quot;] <a href="file:///home/runner/work/k/k/gh-pages/overview.md">K Overview</a></li>
</ul>
<h2 class="mume-header" id="learning-k">Learning K</h2>

<h3 class="mume-header" id="3446-part-1-defining-lambda">[34&apos;46&quot;]   Part 1: Defining LAMBDA</h3>

<p>Here you will learn how to define a very simple functional language in K and the basics of how to use the K tool. The language is a call-by-value variant of lambda calculus with builtins and mu, and its definition is based on substitution.</p>
<ul>
<li>[04&apos;07&quot;]   <a href="#ebook-heading-lesson-1-lambda-syntax-modules-and-basic-k-commands">Lesson 1, LAMBDA: Syntax Modules and Basic K Commands</a></li>
<li>[04&apos;03&quot;]   <a href="#ebook-heading-lesson-2-lambda-module-importing-rules-variables">Lesson 2, LAMBDA: Module Importing, Rules, Variables</a></li>
<li>[02&apos;20&quot;]   <a href="#ebook-heading-lesson-3-lambda-evaluation-strategies-using-strictness">Lesson 3, LAMBDA: Evaluation Strategies using Strictness</a></li>
<li>[03&apos;13&quot;]   <a href="#ebook-heading-lesson-4-lambda-generating-documentation-latex-attributes">Lesson 4, LAMBDA: Generating Documentation; Latex Attributes</a></li>
<li>[04&apos;52&quot;]   <a href="#ebook-heading-lesson-5-lambda-adding-builtins-side-conditions">Lesson 5, LAMBDA: Adding Builtins; Side Conditions</a></li>
<li>[02&apos;14&quot;]   <a href="#ebook-heading-lesson-6-lambda-selective-strictness-anonymous-variables">Lesson 6, LAMBDA: Selective Strictness; Anonymous Variables</a></li>
<li>[05&apos;10&quot;]   <a href="#ebook-heading-lesson-7-lambda-derived-constructs-extending-predefined-syntax">Lesson 7, LAMBDA: Derived Constructs; Extending Predefined Syntax</a></li>
<li>[02&apos;40&quot;]   <a href="#ebook-heading-lesson-8-lambda-multiple-binding-constructs">Lesson 8, LAMBDA: Multiple Binding Constructs</a> (uncommented)</li>
<li>[06&apos;07&quot;]   <a href="#ebook-heading-lesson-9-lambda-a-complete-and-commented-definition">Lesson 9, LAMBDA: A Complete and Commented Definition</a> (commented)</li>
</ul>
<h3 class="mume-header" id="3707-part-2-defining-imp">[37&apos;07&quot;]   Part 2: Defining IMP</h3>

<p>Here you will learn how to define a very simple, prototypical textbook C-like imperative language, called IMP, and several new features of the K tool.</p>
<ul>
<li>[09&apos;15&quot;]   <a href="#ebook-heading-lesson-1-imp-defining-a-more-complex-syntax">Lesson 1, IMP: Defining a More Complex Syntax</a></li>
<li>[04&apos;21&quot;]   <a href="#ebook-heading-lesson-2-imp-defining-a-configuration">Lesson 2, IMP: Defining a Configuration</a></li>
<li>[10&apos;30&quot;]   <a href="#ebook-heading-lesson-3-imp-computations-results-strictness-rules-involving-cells">Lesson 3, IMP: Computations, Results, Strictness; Rules Involving Cells</a></li>
<li>[09&apos;16&quot;]   <a href="#ebook-heading-lesson-4-imp-configuration-abstraction-part-1-types-of-rules">Lesson 4, IMP: Configuration Abstraction, Part 1; Types of Rules</a></li>
<li>[03&apos;45&quot;]   <a href="#ebook-heading-lesson-5-imp-completing-and-documenting-imp">Lesson 5, IMP: Completing and Documenting IMP</a></li>
</ul>
<h3 class="mume-header" id="3310-part-3-defining-lambda">[33&apos;10&quot;]   Part 3: Defining LAMBDA++</h3>

<p>Here you will learn how to define constructs which abruptly change the execution control, as well as how to define functional languages using environments and closures. LAMBDA++ extends the LAMBDA language above with a callcc construct.</p>
<ul>
<li>[06&apos;28&quot;]   <a href="#ebook-heading-lesson-1-lambda-abrupt-changes-of-control">Lesson 1, LAMBDA++: Abrupt Changes of Control</a> (substitution-based, uncommented)</li>
<li>[08&apos;02&quot;]   <a href="#ebook-heading-lesson-2-lambda-semantic-non-syntactic-computation-items">Lesson 2, LAMBDA++: Semantic (Non-Syntactic) Computation Items</a></li>
<li>[03&apos;21&quot;]   <a href="#ebook-heading-lesson-3-lambda-reusing-existing-semantics">Lesson 3, LAMBDA++: Reusing Existing Semantics</a></li>
<li>[03&apos;37&quot;]   <a href="#ebook-heading-lesson-4-lambda-do-not-reuse-blindly">Lesson 4, LAMBDA++: Do Not Reuse Blindly!</a></li>
<li>[05&apos;19&quot;]   <a href="#ebook-heading-lesson-5-lambda-more-semantic-computation-items">Lesson 5, LAMBDA++: More Semantic Computation Items</a></li>
<li>[06&apos;23&quot;]   <a href="#ebook-heading-lesson-6-lambda-wrapping-up-and-documenting-lambda-environment-based">Lesson 6, LAMBDA++: Wrapping Up and Documenting LAMBDA++ (environment-based)</a></li>
</ul>
<h3 class="mume-header" id="4646-part-4-defining-imp">[46&apos;46&quot;]   Part 4: Defining IMP++</h3>

<p>Here you will learn how to refine configurations, how to generate fresh elements, how to tag syntactic constructs and rules, how to exhaustively search the space of non-deterministic or concurrent program executions, etc. IMP++ extends the IMP language above with increment, blocks and locals, dynamic threads, input/output, and abrupt termination.</p>
<ul>
<li>[07&apos;47&quot;]   <a href="#ebook-heading-lesson-1-imp-extendingchanging-an-existing-language-syntax">Lesson 1, IMP++: Extending/Changing an Existing Language Syntax</a></li>
<li>[04&apos;06&quot;]   <a href="#ebook-heading-lesson-2-imp-configuration-refinement-freshness">Lesson 2, IMP++: Configuration Refinement; Freshness</a></li>
<li>[06&apos;56&quot;]   <a href="#ebook-heading-lesson-3-imp-tagging-superheatsupercool-kompilation-options">Lesson 3, IMP++: Tagging; Superheat/Supercool Kompilation Options</a></li>
<li>[05&apos;21&quot;]   <a href="#ebook-heading-lesson-4-imp-semantic-lists-inputoutput-streaming">Lesson 4, IMP++: Semantic Lists; Input/Output Streaming</a></li>
<li>[04&apos;30&quot;]   <a href="#ebook-heading-lesson-5-imp-deleting-saving-and-restoring-cell-contents">Lesson 5, IMP++: Deleting, Saving and Restoring Cell Contents</a></li>
<li>[11&apos;40&quot;]   <a href="#ebook-heading-lesson-6-imp-addingdeleting-cells-dynamically-configuration-abstraction-part-2">Lesson 6, IMP++: Adding/Deleting Cells Dynamically; Configuration Abstraction, Part 2</a></li>
<li>[??&apos;??&quot;]   <a href="#ebook-heading-lesson-7-imp-everything-changes-syntax-configuration-semantics">Lesson 7, IMP++: Everything Changes: Syntax, Configuration, Semantics</a></li>
<li>[06&apos;26&quot;]   <a href="#ebook-heading-lesson-8-imp-wrapping-up-larger-languages">Lesson 8, IMP++: Wrapping up Larger Languages</a></li>
</ul>
<h3 class="mume-header" id="1703-part-5-defining-type-systems">[17&apos;03&quot;]   Part 5: Defining Type Systems</h3>

<p>Here you will learn how to define various kinds of type systems following various approaches or styles using K.</p>
<ul>
<li>[10&apos;11&quot;]   <a href="#ebook-heading-lesson-1-type-systems-imperative-environment-based-type-systems">Lesson 1, Type Systems: Imperative, Environment-Based Type Systems</a> (IMP++ type checker)</li>
<li>[06&apos;52&quot;]   <a href="#ebook-heading-lesson-2-type-systems-substitution-based-higher-order-type-systems">Lesson 2, Type Systems: Substitution-Based Higher-Order Type Systems</a> (LAMBDA type checker, substitution, uncommented)</li>
<li>[??&apos;??&quot;]   <a href="#ebook-heading-lesson-3-type-systems-environment-based-higher-order-type-systems">Lesson 3, Type Systems: Environment-Based Higher-Order Type Systems</a> (LAMBDA type checker, environment, uncommented)</li>
<li>[??&apos;??&quot;]   <a href="#ebook-heading-lesson-4-type-systems-a-naive-substitution-based-type-inferencer">Lesson 4, Type Systems: A Naive Substitution-Based Type Inferencer</a> (for LAMBDA, uncommented)</li>
<li>[??&apos;??&quot;]   <a href="#ebook-heading-lesson-5-type-systems-a-naive-environment-based-type-inferencer">Lesson 5, Type Systems: A Naive Environment-Based Type Inferencer</a> (for LAMBDA, uncommented)</li>
<li>[??&apos;??&quot;]   <a href="#ebook-heading-lesson-6-type-systems-parallel-type-checkersinferencers">Lesson 6, Type Systems: Parallel Type Checkers/Inferencers</a> (for LAMBDA, uncommented)</li>
<li>[??&apos;??&quot;]   <a href="#ebook-heading-lesson-7-type-systems-a-naive-substitution-based-polymorphic-type-inferencer">Lesson 7, Type Systems: A Naive Substitution-based Polymorphic Type Inferencer</a> (for LAMBDA, uncommented)</li>
<li>[??&apos;??&quot;]   <a href="#ebook-heading-lesson-8-type-systems-a-naive-environment-based-polymorphic-type-inferencer">Lesson 8, Type Systems: A Naive Environment-based Polymorphic Type Inferencer</a> (for LAMBDA, uncommented)</li>
<li>[??&apos;??&quot;]   <a href="#ebook-heading-lesson-9-type-systems-let-polymorphic-type-inferencer-damas-hindley-milner">Lesson 9, Type Systems: Let-Polymorphic Type Inferencer (Damas-Hindley-Milner)</a> (for LAMBDA, uncommented)</li>
</ul>
<h3 class="mume-header" id="part-6-miscellaneous-other-k-features">[??&apos;??&quot;]   Part 6: Miscellaneous Other K Features</h3>

<p>Here you will learn a few other K features, and better understand how features that you have already seen work.</p>
<ul>
<li>[??&apos;??&quot;]   ...</li>
</ul>
<h2 class="mume-header" id="learning-language-design-and-semantics-using-k">Learning Language Design and Semantics using K</h2>

<h3 class="mume-header" id="part-7-simple-designing-imperative-programming-languages">[??&apos;??&quot;]   Part 7: SIMPLE: Designing Imperative Programming Languages</h3>

<p>Here you will learn how to design imperative programming languages using K. SIMPLE is an imperative language with functions, threads, pointers, exceptions, multi-dimensional arrays, etc. We first define an untyped version of SIMPLE, then a typed version. For the typed version, we define both a static and a dynamic semantics.</p>
<ul>
<li>[??&apos;??&quot;]   <a href="#ebook-heading-lesson-1-simple-untyped">Lesson 1, SIMPLE untyped</a></li>
<li>[??&apos;??&quot;]   <a href="#ebook-heading-lesson-2-simple-typed-static">Lesson 2, SIMPLE typed static</a></li>
<li>[??&apos;??&quot;]   <a href="#ebook-heading-lesson-3-simple-typed-dynamic">Lesson 3, SIMPLE typed dynamic</a></li>
</ul>
<h3 class="mume-header" id="part-8-kool-designing-object-oriented-programming-languages">[??&apos;??&quot;]   Part 8: KOOL: Designing Object-Oriented Programming Languages</h3>

<p>Here woul will learn how to design object-oriented programming languages using K. KOOL is an object-oriented language that extends SIMPLE with classes and objects. We first define an untyped version of KOOL, then a typed version, with both a dynamic and a static semantics.</p>
<ul>
<li>[??&apos;??&quot;]   <a href="#ebook-heading-lesson-1-kool-untyped">Lesson 1, KOOL untyped</a></li>
<li>[??&apos;??&quot;]   <a href="#ebook-heading-lesson-2-kool-typed-dynamic">Lesson 2, KOOL typed dynamic</a></li>
<li>[??&apos;??&quot;]   <a href="#ebook-heading-lesson-3-kool-typed-static">Lesson 3, KOOL typed static</a></li>
</ul>
<h3 class="mume-header" id="part-9-fun-designing-functional-programming-languages">[??&apos;??&quot;]   Part 9: FUN: Designing Functional Programming Languages</h3>

<p>H<br>
ere woul will learn how to design functional programming languages using K. FUN is a higher-order functional language with general let, letrec, pattern matching, references, lists, callcc, etc. We first define an untyped version of FUN, then a let-polymorphic type inferencer.</p>
<ul>
<li>[??&apos;??&quot;]   <a href="#ebook-heading-lesson-1-fun-untyped-environment-based">Lesson 1, FUN untyped, Environment-Based</a></li>
<li>[??&apos;??&quot;]   <a href="#ebook-heading-lesson-2-fun-untyped-substitution-based">Lesson 2, FUN untyped, Substitution-Based</a></li>
<li>[??&apos;??&quot;]   Lesson 3, FUN polymorphic type inferencer</li>
</ul>
<h3 class="mume-header" id="part-10-logik-designing-logic-programming-languages">[??&apos;??&quot;]   Part 10: LOGIK: Designing Logic Programming Languages</h3>

<p>Here you will learn how to design a logic programming language using K.</p>
<ul>
<li>[??&apos;??&quot;]   <a href="#ebook-heading-lesson-1-logik">Lesson 1, LOGIK</a></li>
</ul>
</div></div><div id="ebook-heading-k-overview" ebook-toc-level-2 heading="K Overview"><div><h1 class="mume-header" id="k-overview">K overview</h1>

<iframe width="560" height="315" src="https://www.youtube.com/embed/eSaIKHQOo4c" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p>Go to <a href="https://youtu.be/eSaIKHQOo4c">Youtube mirror</a>, if the above does not work.</p>
<p>Go back to <a href="https://kframework.org">https://kframework.org</a> for further links, the K tool and contact information.</p>
</div></div><div id="ebook-heading-learning-k" ebook-toc-level-2 heading="Learning K"><div><h1 class="mume-header" id="learning-k">Learning K</h1>

<p>We start by introducing the basic features of K by means of a series<br>
of very simple languages.  The objective here is neither to learn those<br>
languages nor to study their underlying paradigm, but simply to learn K.</p>
<ul>
<li><a href="#ebook-heading-part-1-defining-lambda">LAMBDA</a>: Lambda calculus defined.</li>
<li><a href="#ebook-heading-part-2-defining-imp">IMP</a>: A simple imperative language.</li>
<li><a href="#ebook-heading-part-3-defining-lambda">LAMBDA++</a>: LAMBDA extended with control flow.</li>
<li><a href="#ebook-heading-part-4-defining-imp">IMP++</a>: IMP extended with threads and IO.</li>
<li><a href="#ebook-heading-part-5-defining-type-systems">TYPES</a>: LAMBDA type system.</li>
</ul>
</div></div><div id="ebook-heading-part-1-defining-lambda" ebook-toc-level-3 heading="Part 1: Defining LAMBDA"><div><h2 class="mume-header" id="part-1-defining-lambda">Part 1: Defining LAMBDA</h2>

<p>Here you will learn how to define a very simple language in K and the basics<br>
of how to use the K tool.  The language is a variant of call-by-value lambda<br>
calculus and its definition is based on substitution.  Specifically, you will<br>
learn the following:</p>
<ul>
<li>How to define a module.</li>
<li>How to define a language syntax.</li>
<li>How to use the defined syntax to parse programs.</li>
<li>How to import predefined modules.</li>
<li>How to define evaluation strategies using strictness attributes.</li>
<li>How to define semantic rules.</li>
<li>How the predefined generic substitution works.</li>
<li>How to generate PDF and HTML documentation from ASCII definitions.</li>
<li>How to include builtins (integers and Booleans) into your language.</li>
<li>How to define derived language constructs.</li>
</ul>
<p>This folder contains several lessons, each adding new features to LAMBDA.</p>
</div></div><div id="ebook-heading-lesson-1-lambda-syntax-modules-and-basic-k-commands" ebook-toc-level-4 heading="Lesson 1, LAMBDA: Syntax Modules and Basic K Commands"><div><h1 class="mume-header" id="syntax-modules-and-basic-k-commands">Syntax Modules and Basic K Commands</h1>

<p>Here we define our first K module, which contains the initial syntax of the<br>
LAMBDA language, and learn how to use the basic K commands.</p>
<p>Let us create an empty working folder, and open a terminal window<br>
(to the left) and an editor window (to the right). We will edit our K<br>
definition in the right window in a file called <code>lambda.k</code>, and will call<br>
the K tool commands in the left window.</p>
<p>Let us start by defining a K module, containing the syntax of LAMBDA.</p>
<p>K modules are introduced with the keywords <code>module</code> ... <code>endmodule</code>.</p>
<p>The keyword <code>syntax</code> adds new productions to the syntax grammar, using a<br>
BNF-like notation.</p>
<p>Terminals are enclosed in double-quotes, like strings.</p>
<p>You can define multiple productions for the same non-terminal in the same<br>
syntax declaration using the <code>|</code> separator.</p>
<p>Productions can have attributes, which are enclosed in square brackets.</p>
<p>The attribute <code>left</code> tells the parser that we want the lambda application to be<br>
left associative. For example, <code>a b c d</code> will then parse as <code>(((a b) c) d)</code>.</p>
<p>The attribute <code>bracket</code> tells the parser to not generate a node for the<br>
parenthesis production in the abstract syntax trees associated to programs.<br>
In other words, we want to allow parentheses to be used for grouping, but we<br>
do not want to bother to give them their obvious (ignore) semantics.</p>
<p>In our variant of lambda calculus defined here, identifiers and lambda<br>
abstractions are meant to be irreducible, that is, are meant to be values.<br>
However, so far <code>Val</code> is just another non-terminal, just like <code>Exp</code>,<br>
without any semantic meaning. It will get a semantic meaning later.</p>
<p>After we are done typing our definition in the file <code>lambda.k</code>, we can kompile<br>
it with the command:</p>
<pre class="language-text">kompile lambda.k
</pre>
<p>If we get no errors then a parser has been generated. This parser will be<br>
called from now on by default by the krun tool. To see whether and how the<br>
parser works, we are going to write some LAMBDA programs and store them in<br>
files with the extension <code>.lambda</code>.</p>
<p>Let us create a file <code>identity.lambda</code>, which contains the identity lambda<br>
abstraction:</p>
<pre class="language-text">lambda x . x
</pre>
<p>Now let us call <code>krun</code> on <code>identity.lambda</code>:</p>
<pre class="language-text">krun identity.lambda
</pre>
<p>Make sure you call the <code>krun</code> command from the folder containing your language<br>
definition (otherwise type <code>krun --help</code> to learn how to pass a language<br>
definition as a parameter to <code>krun</code>). The krun command produces the output:</p>
<pre class="language-text">&lt;k&gt;
  lambda x . x
&lt;/k&gt;
</pre>
<p>If you see such an output it means that your program has been parsed (and then<br>
pretty printed) correctly. If you want to see the internal abstract syntax<br>
tree (AST) representation of the parsed program, which we call the K AST, then<br>
type <code>kast</code> in the command instead of <code>krun</code>:</p>
<pre class="language-text">kast identity.lambda
</pre>
<p>You should normally never need to see this internal representation in your<br>
K definitions, so do not get scared (yes, it is ugly for humans, but it is<br>
very convenient for tools).</p>
<p>Note that <code>krun</code> placed the program in a <code>&lt;k&gt; ... &lt;/k&gt;</code> cell. In K, computations<br>
happen only in cells. If you do not define a configuration in your definition,<br>
like we did here, then a configuration will be created automatically for you<br>
which contains only one cell, the default <code>k</code> cell, which holds the program.</p>
<p>Next, let us create a file <code>free-variable-capture.lambda</code>, which contains an<br>
expression which, in order to execute correctly in a substitution-based<br>
semantics of LAMBDA, the substitution operation needs to avoid<br>
variable-capture:</p>
<pre class="language-text">a (((lambda x.lambda y.x) y) z)
</pre>
<p>Next, file <code>closed-variable-capture.lambda</code> shows an expression which also<br>
requires a capture-free substitution, but this expression is closed (that is,<br>
it has no free variables) and all its bound variables are distinct (I believe<br>
this is the smallest such expression):</p>
<pre class="language-text">(lambda z.(z z)) (lambda x.lambda y.(x y))
</pre>
<p>Finally, the file <code>omega.lambda</code> contains the classic omega combinator<br>
(or closed expression), which is the smallest expression which loops forever<br>
(not now, but after we define the semantics of LAMBDA):</p>
<pre class="language-text">(lambda x.(x x)) (lambda x.(x x))
</pre>
<p>Feel free to define and parse several other LAMBDA programs to get a feel for<br>
how the parser works. Parse also some incorrect programs, to see how the<br>
parser generates error messages.</p>
<p>In the next lesson we will see how to define semantic rules that iteratively<br>
rewrite expressions over the defined syntax until they evaluate to a result.<br>
This way, we obtain our first programming language defined using K.</p>
<p>Go to <a href="#ebook-heading-lesson-2-lambda-module-importing-rules-variables">Lesson 2, LAMBDA: Module Importing, Rules, Variables</a></p>
<p><a href="https://youtu.be/y5Tf1EZVj8E">MOVIE (out of date) [4&apos;07&quot;]</a></p>
</div></div><div id="ebook-heading-lesson-2-lambda-module-importing-rules-variables" ebook-toc-level-4 heading="Lesson 2, LAMBDA: Module Importing, Rules, Variables"><div><h1 class="mume-header" id="module-importing-rules-variables">Module Importing, Rules, Variables</h1>

<p>We here learn how to include a predefined module (SUBSTITUTION), how to<br>
use it to define a K rule (the characteristic rule of lambda calculus),<br>
and how to make proper use of variables in rules.</p>
<p>Let us continue our <code>lambda.k</code> definition started in the previous lesson.</p>
<p>The <code>requires</code> keyword takes a <code>.k</code> file containing language features that<br>
are needed for the current definition, which can be found in the<br>
<a href="file:///home/runner/work/k/k/gh-pages/k-distribution/include/kframework/builtin/README.md">k-distribution/include/kframework/builtin</a> folder.  Thus, the command</p>
<pre class="language-text">requires &quot;substitution.k&quot;
</pre>
<p>says that the subsequent definition of LAMBDA needs the generic substitution,<br>
which is predefined in file <code>substitution.k</code> under the folder<br>
<a href="file:///home/runner/work/k/k/gh-pages/k-distribution/include/kframework/builtin/README.md">k-distribution/include/kframework/builtin</a>.  Note that substitution can be defined itself in K,<br>
although it uses advanced features that we have not discussed yet in this<br>
tutorial, so it may not be easy to understand now.</p>
<p>Using the <code>imports</code> keyword, we can now modify LAMBDA to import the module<br>
SUBSTITUTION, which is defined in the required <code>substitution.k</code> file.</p>
<p>Now we have all the substitution machinery available for our definition.<br>
However, since our substitution is generic, it cannot know which language<br>
constructs bind variables, and what counts as a variable; however, this<br>
information is critical in order to correctly solve the variable capture<br>
problem.  Thus, you have to tell the substitution that your lambda construct<br>
is meant to be a binder, and that your <code>Id</code> terms should be treated as variables<br>
for substitution.  The former is done using the attribute <code>binder</code>.<br>
By default, <code>binder</code> binds all the variables occurring anywhere in the first<br>
argument of the corresponding syntactic construct within its other arguments;<br>
you can configure which arguments are bound where, but that will be discussed<br>
in subsequent lectures.  To tell K which terms are meant to act as variables<br>
for binding and substitution, we have to explicitly subsort the desired syntactic<br>
categories to the builtin <code>KVariable</code> sort.</p>
<p>Now we are ready to define our first K rule.  Rules are introduced with the<br>
keyword <code>rule</code> and make use of the rewrite symbol, <code>=&gt;</code>.  In our case,<br>
the rule defines the so-called lambda calculus <em>beta-reduction</em>, which<br>
makes use of substitution in its right-hand side, as shown in <code>lambda.k</code>.</p>
<p>By convention, variables that appear in rules start with a capital letter<br>
(the current implementation of the K tool may even enforce that).</p>
<p>Variables may be explicitly tagged with their syntactic category (also called<br>
<em>sort</em>).  If tagged, the matching term will be checked at run-time for<br>
membership to the claimed sort.  If not tagged, then no check will be made.<br>
The former is safer, but involves the generation of a side condition to the<br>
rule, so the resulting definition may execute slightly slower overall.</p>
<p>In our rule in <code>lambda.k</code> we tagged all variables with their sorts, so we chose<br>
the safest path.  Only the <code>V</code> variable really needs to be tagged there,<br>
because we can prove (using other means, not the K tool, as the K tool is not<br>
yet concerned with proving) that the first two variables will always have the<br>
claimed sorts whenever we execute any expression that parses within our<br>
original grammar.</p>
<p>Let us compile the definition and then run some programs.  For example,</p>
<pre class="language-text">krun closed-variable-capture.lambda
</pre>
<p>yields the output</p>
<pre class="language-text">&lt;k&gt;
  lambda y . ((lambda x . (lambda y . (x  y))) y)
&lt;/k&gt; 
</pre>
<p>Notice that only certain programs reduce (some even yield non-termination,<br>
such as <code>omega.lambda</code>), while others do not.  For example,<br>
<code>free-variable-capture.lambda</code> does not reduce its second argument expression<br>
to <code>y</code>, as we would expect.  This is because the K rewrite rules between syntactic<br>
terms do not apply anywhere they match.  They only apply where they have been<br>
given permission to apply by means of appropriate evaluation strategies of language<br>
constructs, which is done using strictness attributes, evaluation contexts,<br>
heating/cooling rules, etc., as discussed in the next lessons.</p>
<p>The next lesson will show how to add LAMBDA the desired evaluation strategies<br>
using strictness attributes.</p>
<p>Go to <a href="#ebook-heading-lesson-3-lambda-evaluation-strategies-using-strictness">Lesson 3, LAMBDA: Evaluation Strategies using Strictness</a></p>
<p><a href="https://youtu.be/NDXgYfHG6R4">MOVIE (out of date) [4&apos;03&quot;]</a></p>
</div></div><div id="ebook-heading-lesson-3-lambda-evaluation-strategies-using-strictness" ebook-toc-level-4 heading="Lesson 3, LAMBDA: Evaluation Strategies using Strictness"><div><h1 class="mume-header" id="evaluation-strategies-using-strictness">Evaluation Strategies using Strictness</h1>

<p>Here we learn how to use the K <code>strict</code> attribute to define desired evaluation<br>
strategies.  We will also learn how to tell K which terms are already<br>
evaluated, so it does not attempt to evaluate them anymore and treats them<br>
internally as results of computations.</p>
<p>Recall from the previous lecture that the LAMBDA program<br>
<code>free-variable-capture.lambda</code> was stuck, because K was not given permission<br>
to evaluate the arguments of the lambda application construct.</p>
<p>You can use the attribute <code>strict</code> to tell K that the corresponding construct<br>
has a strict evaluation strategy, that is, that its arguments need to be<br>
evaluated before the semantics of the construct applies.  The order of<br>
argument evaluation is purposely unspecified when using <code>strict</code>, and indeed<br>
the K tool allows us to detect all possible non-deterministic behaviors that<br>
result from such intended underspecification of evaluation strategies.  We will<br>
learn how to do that when we define the IMP language later in this tutorial;<br>
we will also learn how to enforce a particular order of evaluation.</p>
<p>In order for the above strictness declaration to work effectively and<br>
efficiently, we need to tell the K tool which expressions are meant to be<br>
results of computations, so that it will not attempt to evaluate them anymore.<br>
One way to do it is to make <code>Val</code> a syntactic subcategory of the builtin<br>
<code>KResult</code> syntactic category.  Since we use the same K parser to also parse<br>
the semantics, we use the same <code>syntax</code> keyword to define additional syntax<br>
needed exclusively for the semantics (like <code>KResult</code>s).  See <code>lambda.k</code>.</p>
<p>Compile again and then run some programs.  They should all work as expected.<br>
In particular, <code>free-variable-capture.lambda</code> now evaluates to <code>a y</code>.</p>
<p>We now got a complete and working semantic definition of call-by-value<br>
lambda-calculus.  While theoretically correct, our definition is not<br>
easy to use and disseminate.  In the next lessons we will learn how to<br>
generate formatted documentation for LAMBDA and how to extend LAMBDA<br>
in order to write human readable and interesting programs.</p>
<p>Go to <a href="#ebook-heading-lesson-4-lambda-generating-documentation-latex-attributes">Lesson 4, LAMBDA: Generating Documentation; Latex Attributes</a>.</p>
<p><a href="https://youtu.be/aul1x6bd1YM">MOVIE (out of date) [2&apos;20&quot;]</a></p>
</div></div><div id="ebook-heading-lesson-4-lambda-generating-documentation-latex-attributes" ebook-toc-level-4 heading="Lesson 4, LAMBDA: Generating Documentation; Latex Attributes"><div><h1 class="mume-header" id="generating-documentation-latex-attributes">Generating Documentation; Latex Attributes</h1>

<p>In this lesson we learn how to generate formatted documentation from K<br>
language definitions.  We also learn how to use Latex attributes to control<br>
the formatting of language constructs, particularly of ones which have a<br>
mathematical flavor and we want to display accordingly.</p>
<p>To enhance readability, we may want to replace the keyword <code>lambda</code> by the<br>
mathematical lambda symbol in the generated documentation.  We can control<br>
the way we display language constructs in the generated documentation<br>
by associating them Latex attributes.</p>
<p>This is actually quite easy.  All we have to do is to associate a <code>latex</code><br>
attribute to the production defining the construct in question, following<br>
the Latex syntax for defining new commands (or macros).</p>
<p>In our case, we associate the attribute <code>latex(\lambda{#1}.{#2})</code> to the<br>
production declaring the lambda abstraction (recall that in Latex, <code>#n</code> refers<br>
to the n-th argument of the defined new command).</p>
<p>We will later see, in Lesson 9, that we can add arbitrarily complex Latex<br>
comments and headers to our language definitions, which give us maximum<br>
flexibility in formatting our language definitions.</p>
<p>Now we have a simple programming language, with a nice documentation.  However,<br>
it is not easy to write interesting programs in this language.  Almost all<br>
programming languages build upon existing data-types and libraries.  The K<br>
tool provides a few of these (and you can add more).</p>
<p>In the next lesson we show how we can add builtin integers and Booleans to<br>
LAMBDA, so we can start to evaluate meaningful expressions.</p>
<p>Go to <a href="#ebook-heading-lesson-5-lambda-adding-builtins-side-conditions">Lesson 5, LAMBDA: Adding Builtins; Side Conditions</a>.</p>
<p><a href="https://youtu.be/ULXA4e_6-DY">MOVIE (out of date) [3&apos;13&quot;]</a></p>
</div></div><div id="ebook-heading-lesson-5-lambda-adding-builtins-side-conditions" ebook-toc-level-4 heading="Lesson 5, LAMBDA: Adding Builtins; Side Conditions"><div><h1 class="mume-header" id="adding-builtins-side-conditions">Adding Builtins; Side Conditions</h1>

<p>We have already added the builtin identifiers (sort <code>Id</code>) to LAMBDA expressions,<br>
but those had no operations on them.  In this lesson we add integers and<br>
Booleans to LAMBDA, and extend the builtin operations on them into<br>
corresponding operations on LAMBDA expressions.  We will also learn how to add<br>
side conditions to rules, to limit the number of instances where they can<br>
apply.</p>
<p>The K tool provides several builtins, which are automatically included in all<br>
definitions.  These can be used in the languages that we define, typically by<br>
including them in the desired syntactic categories.  You can also define your<br>
own builtins in case the provided ones are not suitable for your language<br>
(e.g., the provided builtin integers and operations on them are arbitrary<br>
precision).</p>
<p>For example, to add integers and Booleans as values to our LAMBDA, we have to<br>
add the productions</p>
<pre class="language-text">syntax Val ::= Int | Bool
</pre>
<p><code>Int</code> and <code>Bool</code> are the nonterminals that correspond to these builtins.</p>
<p>To make use of these builtins, we have to add some arithmetic operation<br>
constructs to our language.  We prefer to use the conventional infix notation<br>
for these, and the usual precedences (i.e., multiplication and division bind<br>
tighter than addition, which binds tighter than relational operators).<br>
Inspired from <a href="http://www.syntax-definition.org/">SDF</a>, we use <code>&gt;</code> instead of<br>
<code>|</code> to state that all the previous constructs bind tighter than all the<br>
subsequent ones.  See <code>lambda.k</code>.</p>
<p>The only thing left is to link the LAMBDA arithmetic operations to the<br>
corresponding builtin operations, when their arguments are evaluated.<br>
This can be easily done using trivial rewrite rules, as shown in <code>lambda.k</code>.<br>
In general, the K tool attempts to uniformly add the corresponding builtin<br>
name as a suffix to all the operations over builtins.  For example, the<br>
addition over integers is an infix operation named <code>+Int</code>.</p>
<p>Compile the new <code>lambda.k</code> definition and evaluate some simple arithmetic<br>
expressions.  For example, if <code>arithmetic.lambda</code> is <code>(1+2*3)/4 &lt;= 1</code>, then</p>
<pre class="language-text">krun arithmetic.lambda
</pre>
<p>yields, as expected, <code>true</code>.  Note that the parser took the desired operation<br>
precedence into account.</p>
<p>Let us now try to evaluate an expression which performs a wrong computation,<br>
namely a division by zero.  Consider the expression <code>arithmetic-div-zero.lambda</code><br>
which is <code>1/(2/3)</code>.  Since division is strict and <code>2/3</code> evaluates to <code>0</code>, this<br>
expression reduces to <code>1/0</code>, which further reduces to <code>1 /Int 0</code> by the rule for<br>
division, which is now stuck (with the current back-end to the K tool).</p>
<p>In fact, depending upon the back-end that we use to execute K definitions and<br>
in particular to evaluate expressions over builtins, <code>1 /Int 0</code> can evaluate to<br>
anything.  It just happens that the current back-end keeps it as an<br>
irreducible term.  Other K back-ends may reduce it to an explicit error<br>
element, or issue a segmentation fault followed by a core dump, or throw an<br>
exception, etc.</p>
<p>To avoid requesting the back-end to perform an illegal operation, we may use a<br>
side condition in the rule of division, to make sure it only applies when the<br>
denominator is non-zero.</p>
<p>Like in other operational formalisms, the role of the K side<br>
conditions is to filter the number of instances of the rule.  The notion<br>
of a <em>side condition</em> comes from logics, where a sharp distinction is made<br>
between a side condition (cheap) and a <em>premise</em> (expensive).  Premises are<br>
usually resolved using further (expensive) logical derivations, while side<br>
conditions are simple (cheap) conditions over the rule meta-variables within<br>
the underlying mathematical domains (which in K can be extended by the user,<br>
as we will see in future lessons).  Regarded as a logic, K derives rewrite<br>
rules from other rewrite rules; therefore, the K side conditions cannot<br>
contain other rewrites in them (using <code>=&gt;</code>).  This contrasts other rewrite<br>
engines, for example <a href="http://maude.cs.illinois.edu/">Maude</a>, which<br>
allow conditional rules with rewrites in conditions.<br>
The rationale behind this deliberate restriction in K is twofold:</p>
<ul>
<li>On the one hand, general conditional rules require a complex, and thus slower<br>
rewrite engine, which starts recursive (sometimes exhaustive) rewrite sessions<br>
to resolve the rewrites in conditions.  In contrast, the side conditions in K<br>
can be evaluated efficiently by back-ends, for example by evaluating builtin<br>
expressions and/or by calling builtin functions.</li>
<li>On the other hand, the semantic definitional philosophy of K is that rule<br>
premises are unnecessary, so there is no need to provide support for them.</li>
</ul>
<p>Having builtin arithmetic is useful, but writing programs with just lambda<br>
and arithmetic constructs is still a pain.  In the next two lessons we will<br>
add conditional (<code>if_then_else</code>) and binding (<code>let</code> and <code>letrec</code>) constructs,<br>
which will allow us to write nicer programs.</p>
<p>Go to <a href="#ebook-heading-lesson-6-lambda-selective-strictness-anonymous-variables">Lesson 6, LAMBDA: Selective Strictness; Anonymous Variables</a>.</p>
<p><a href="https://youtu.be/T1aI04q3l9U">MOVIE (out of date) [4&apos;52&quot;]</a></p>
</div></div><div id="ebook-heading-lesson-6-lambda-selective-strictness-anonymous-variables" ebook-toc-level-4 heading="Lesson 6, LAMBDA: Selective Strictness; Anonymous Variables"><div><h1 class="mume-header" id="selective-strictness-anonymous-variables">Selective Strictness; Anonymous Variables</h1>

<p>We here show how to define selective strictness of language constructs,<br>
that is, how to state that certain language constructs are strict only<br>
in some arguments.  We also show how to use anonymous variables.</p>
<p>We next define a conditional <code>if</code> construct, which takes three arguments,<br>
evaluates only the first one, and then reduces to either the second or the<br>
third, depending on whether the first one evaluated to true or to false.</p>
<p>K allows to define selective strictness using the same <code>strict</code> attribute,<br>
but passing it a list of numbers.  The numbers correspond to the arguments<br>
in which we want the defined construct to be strict.  In our case,</p>
<pre class="language-text">syntax Exp ::= &quot;if&quot; Exp &quot;then&quot; Exp &quot;else&quot; Exp   [strict(1)]
</pre>
<p>states that the conditional construct is strict in the first argument.</p>
<p>We can now assume that its first argument will eventually reduce to a value, so<br>
we only write the following two semantic rules:</p>
<pre class="language-text">rule if true  then E else _ =&gt; E
rule if false then _ else E =&gt; E
</pre>
<p>Thus, we assume that the first argument evaluates to either <code>true</code> or <code>false</code>.</p>
<p>Note the use of the anonymous variable <code>_</code>.  We use such variables purely for<br>
structural reasons, to state that something is there but we don&apos;t care what.<br>
An anonymous variable is therefore completely equivalent to a normal variable<br>
which is unsorted and different from all the other variables in the rule.  If<br>
you use <code>_</code> multiple times in a rule, they will all be considered distinct.</p>
<p>Compile <code>lambda.k</code> and write and execute some interesting expressions making<br>
use of the conditional construct.  For example, the expression</p>
<pre class="language-text">if 2&lt;=1 then 3/0 else 10
</pre>
<p>evaluates to <code>10</code> and will never evaluate <code>3/0</code>, thus avoiding an unwanted<br>
division-by-zero.</p>
<p>In the next lesson we will introduce two new language constructs, called<br>
<code>let</code> and <code>letrec</code> and conventionally found in functional programming<br>
languages, which will allow us to already write interesting LAMBDA programs.</p>
<p>Go to <a href="#ebook-heading-lesson-7-lambda-derived-constructs-extending-predefined-syntax">Lesson 7, LAMBDA: Derived Constructs; Extending Predefined Syntax</a>.</p>
<p><a href="https://youtu.be/IreP6DFPWdk">MOVIE (out of date) [2&apos;14&quot;]</a></p>
</div></div><div id="ebook-heading-lesson-7-lambda-derived-constructs-extending-predefined-syntax" ebook-toc-level-4 heading="Lesson 7, LAMBDA: Derived Constructs; Extending Predefined Syntax"><div><h1 class="mume-header" id="derived-constructs-extending-predefined-syntax">Derived Constructs, Extending Predefined Syntax</h1>

<p>In this lesson we will learn how to define derived language constructs, that<br>
is, ones whose semantics is defined completely in terms of other language<br>
constructs.  We will also learn how to add new constructs to predefined<br>
syntactic categories.</p>
<p>When defining a language, we often want certain language constructs to be<br>
defined in terms of other constructs.  For example, a let-binding construct<br>
of the form</p>
<pre class="language-text">let x = e in e&apos;
</pre>
<p>is nothing but syntactic sugar for</p>
<pre class="language-text">(lambda x . e&apos;) e
</pre>
<p>This can be easily achieved with a rule, as shown in <code>lambda.k</code>.</p>
<p>Compile <code>lambda.k</code> and write some programs using <code>let</code> binders.</p>
<p>For example, consider a <code>lets.lambda</code> program which takes <code>arithmetic.lambda</code><br>
and replaces each integer by a let-bound variable.  It should evaluate to<br>
<code>true</code>, just like the original <code>arithmetic.lambda</code>.</p>
<p>Let us now consider a more interesting program, namely one that calculates the<br>
factorial of 10:</p>
<pre class="language-text">let f = lambda x . (
        (lambda t . lambda x . (t t x))
        (lambda f . lambda x . (if x &lt;= 1 then 1 else (x * (f f (x + -1)))))
        x
      )
in (f 10)
</pre>
<p>This program follows a common technique to define fixed points in untyped<br>
lambda calculus, based on passing a function to itself.</p>
<p>We may not like to define fixed-points following the approach above, because<br>
it requires global changes in the body of the function meant to be recursive,<br>
basically to pass it to itself (<code>f f</code> in our case above).  The approach below<br>
isolates the fixed-point aspect of the function in a so-called <em>fixed-point<br>
combinator</em>, which we call <code>fix</code> below, and then apply it to the function<br>
defining the body of the factorial, without any changes to it:</p>
<pre class="language-text">let fix = lambda f . (
          (lambda x . (f (lambda y . (x x y))))
          (lambda x . (f (lambda y . (x x y))))
        )
in let f = fix (lambda f . lambda x .
                (if x &lt;= 1 then 1 else (x * (f (x + -1)))))
   in (f 10)
</pre>
<p>Although the above techniques are interesting and powerful (indeed, untyped<br>
lambda calculus is in fact Turing complete), programmers will probably not<br>
like to write programs this way.</p>
<p>We can easily define a more complex derived construct, called <code>letrec</code> and<br>
conventionally encountered in functional programming languages, whose semantics<br>
captures the fixed-point idea above.  In order to keep its definition simple<br>
and intuitive, we define a simplified variant of <code>letrec</code>, namely one which only<br>
allows to define one recursive one-argument function.  See <code>lambda.k</code>.</p>
<p>There are two interesting observations here.</p>
<p>First, note that we have already in-lined the definition of the <code>fix</code><br>
combinator in the definition of the factorial, to save one application of the<br>
beta reduction rule (and the involved substitution steps).  We could have<br>
in-lined the definition of the remaining <code>let</code>, too, but we believe that the<br>
current definition is easier to read.</p>
<p>Second, note that we extended the predefined <code>Id</code> syntactic category with two<br>
new constants, <code>$x</code> and <code>$y</code>.  The predefined identifiers cannot start with<br>
<code>$</code>, so programs that will be executed with this semantics cannot possibly<br>
contain the identifiers <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>a</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">x and</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">x</span><span class="mord mathnormal">an</span><span class="mord mathnormal">d</span></span></span></span>y.  In other words, by adding them to Id they<br>
become indirectly reserved for the semantics.  This is indeed desirable,<br>
because any possible uses of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>i</mi><mi>n</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>b</mi><mi>o</mi><mi>d</mi><mi>y</mi><mi>o</mi><mi>f</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>f</mi><mi>u</mi><mi>n</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>f</mi><mi>i</mi><mi>n</mi><mi>e</mi><mi>d</mi><mi>u</mi><mi>s</mi><mi>i</mi><mi>n</mi><mi>g</mi><mi mathvariant="normal">&#x2018;</mi><mi>l</mi><mi>e</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi mathvariant="normal">&#x2018;</mi><mi>w</mi><mi>o</mi><mi>u</mi><mi>l</mi><mi>d</mi><mi>b</mi><mi>e</mi><mi>c</mi><mi>a</mi><mi>p</mi><mi>t</mi><mi>u</mi><mi>r</mi><mi>e</mi><mi>d</mi><mi>b</mi><mi>y</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi mathvariant="normal">&#x2018;</mi><mi>l</mi><mi>a</mi><mi>m</mi><mi>b</mi><mi>d</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">x in the body of the function defined
using `letrec` would be captured by the `lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mord mathnormal">in</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">b</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">yo</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">in</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mord mathnormal">u</span><span class="mord mathnormal">s</span><span class="mord mathnormal">in</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">&#x2018;</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mord mathnormal">rec</span><span class="mord">&#x2018;</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">d</span><span class="mord mathnormal">b</span><span class="mord mathnormal">ec</span><span class="mord mathnormal">a</span><span class="mord mathnormal">pt</span><span class="mord mathnormal">u</span><span class="mord mathnormal">re</span><span class="mord mathnormal">d</span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord">&#x2018;</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">amb</span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span></span></span></span>x<code>declaration in the definition of</code>letrec`.</p>
<p>Using <code>letrec</code>, we can now write the factorial program as elegantly as it can<br>
be written in a functional language:</p>
<pre class="language-text">letrec f x = if x &lt;= 1 then 1 else (x * (f (x + -1)))
in (f 10)
</pre>
<p>In the next lesson we will discuss an alternative definition of <code>letrec</code>, based<br>
on another binder, <code>mu</code>, specifically designed to define fixed points.</p>
<p>Go to <a href="#ebook-heading-lesson-8-lambda-multiple-binding-constructs">Lesson 8, LAMBDA: Multiple Binding Constructs</a>.</p>
<p><a href="https://youtu.be/qZWiBaN7zrw">MOVIE (out of date) [5&apos;10&quot;]</a></p>
</div></div><div id="ebook-heading-lesson-8-lambda-multiple-binding-constructs" ebook-toc-level-4 heading="Lesson 8, LAMBDA: Multiple Binding Constructs"><div><h1 class="mume-header" id="multiple-binding-constructs">Multiple Binding Constructs</h1>

<p>Here we learn how multiple language constructs that bind variables can<br>
coexist. We will also learn about or recall another famous binder besides<br>
<code>lambda</code>, namely <code>mu</code>, which can be used to elegantly define all kinds of<br>
interesting fixed-point constructs.</p>
<p>The <code>mu</code> binder has the same syntax as lambda, except that it replaces<br>
<code>lambda</code> with <code>mu</code>.</p>
<p>Since <code>mu</code> is a binder, in order for substitution to know how to deal with<br>
variable capture in the presence of <code>mu</code>, we have to tell it that <code>mu</code> is a<br>
binding construct, same like lambda.  We take advantage of being there and<br>
also add <code>mu</code> its desired latex attribute.</p>
<p>The intuition for</p>
<pre class="language-text">mu x . e
</pre>
<p>is that it reduces to <code>e</code>, but each free occurrence of <code>x</code> in <code>e</code> behaves<br>
like a pointer that points back to <code>mu x . e</code>.</p>
<p>With that in mind, let us postpone the definition of <code>mu</code> and instead redefine<br>
<code>letrec F X = E in E&apos;</code> as a derived construct, assuming <code>mu</code> available.  The<br>
idea is to simply regard <code>F</code> as a fixed-point of the function</p>
<pre class="language-text">lambda X . E
</pre>
<p>that is, to first calculate</p>
<pre class="language-text">mu F . lambda X . E
</pre>
<p>and then to evaluate <code>E&apos;</code> where <code>F</code> is bound to this fixed-point:</p>
<pre class="language-text">let F = mu F . lambda X . E in E&apos;
</pre>
<p>This new definition of <code>letrec</code> may still look a bit tricky, particularly<br>
because <code>F</code> is bound twice, but it is much simpler and cleaner than our<br>
previous definition.  Moreover, now it is done in a type-safe manner<br>
(this aspect goes beyond our objective in this tutorial).</p>
<p>Let us now define the semantic rule of <code>mu</code>.</p>
<p>The semantics of <code>mu</code> is actually disarmingly simple.  We just have to<br>
substitute <code>mu X . E</code> for each free occurrence of <code>X</code> in <code>E</code>:</p>
<pre class="language-text">mu X . E =&gt; E[(mu X . E) / X]
</pre>
<p>Compile <code>lambda.k</code> and execute some recursive programs.  They should be now<br>
several times faster.  Write a few more recursive programs, for example ones<br>
for calculating the Ackermann function, for calculating the number of moves<br>
needed to solve the Hanoi tower problem, etc.</p>
<p>We have defined our first programming language in K, which allows us to<br>
write interesting functional programs.  In the next lesson we will learn how<br>
to fully document our language definition, in order to disseminate it, to ship<br>
it to colleagues or friends, to publish it, to teach it, and so on.</p>
<p>Go to <a href="#ebook-heading-lesson-9-lambda-a-complete-and-commented-definition">Lesson 9, LAMBDA: A Complete and Commented Definition</a>.</p>
<p><a href="https://youtu.be/Ox4uXDpcY64">MOVIE (out of date) [2&apos;40&quot;]</a></p>
</div></div><div id="ebook-heading-lesson-9-lambda-a-complete-and-commented-definition" ebook-toc-level-4 heading="Lesson 9, LAMBDA: A Complete and Commented Definition"><div><h1 class="mume-header" id="a-complete-and-documented-k-definition">A Complete and Documented K Definition</h1>

<p>In this lesson you will learn how to add formal comments to your K definition,<br>
in order to nicely document it.  The generated document can be then used for<br>
various purposes: to ease understanding the K definition, to publish it,<br>
to send it to others, etc.</p>
<p>The K tool allows a literate programming style, where the executable<br>
language definition can be documented by means of annotations. One such<br>
annotation is the <code>latex(_)</code> annotation, where you can specify how to format<br>
the given production when producing Latex output via the <code>--output latex</code><br>
option to <code>krun</code>, <code>kast</code>, and <code>kprove</code>.</p>
<p>There are three types of comments, which we discuss next.</p>
<h2 class="mume-header" id="ordinary-comments">Ordinary comments</h2>

<p>These use <code>//</code> or <code>/* ... */</code>, like in various programming languages.  These<br>
comments are completely ignored.</p>
<h2 class="mume-header" id="document-annotations">Document annotations</h2>

<p>Use the <code>@</code> symbol right after <code>//</code> or <code>/*</code> in order for the comment to be<br>
considered an annotation and thus be processed by the K tool when it<br>
generates documentation.</p>
<p>As an example, we can go ahead and add such an annotation at the beginning<br>
of the LAMBDA module, explaining how we define the syntax of this language.</p>
<h2 class="mume-header" id="header-annotations">Header annotations</h2>

<p>Use the <code>!</code> symbol right after <code>//</code> or <code>/*</code> if you want the comment to be<br>
considered a header annotation, that is, one which goes before<br>
<code>\begin{document}</code> in the generated Latex.  You typically need header<br>
annotations to include macros, or to define a title, etc.</p>
<p>As an example, let us set a Latex length and then add a title and an<br>
author to this K definition.</p>
<p>Compile the documentation and take a look at the results.  Notice the title.</p>
<p>Feel free to now add lots of annotations to <code>lambda.k</code>.</p>
<p>Then compile and check the result.  Depending on your PDF viewer, you<br>
may also see a nice click-able table of contents, with all the sections<br>
of your document.  This could be quite convenient when you define large<br>
languages, because it helps you jump to any part of the semantics.</p>
<p>Tutorial 1 is now complete.  The next tutorial will take us through the<br>
definition of a simple imperative language and will expose us to more<br>
feature of the K framework and the K tool.</p>
<p><a href="https://youtu.be/-pHgLqNMKac">MOVIE (out of date) [6&apos;07&quot;]</a></p>
</div></div><div id="ebook-heading-part-2-defining-imp" ebook-toc-level-3 heading="Part 2: Defining IMP"><div><h2 class="mume-header" id="part-2-defining-imp">Part 2: Defining IMP</h2>

<p>Here you will learn how to define a very simple imperative language in K<br>
and the basics of how to work with configurations, cells, and computations.<br>
Specifically, you will learn the following:</p>
<ul>
<li>How to define languages using multiple modules.</li>
<li>How to define sequentially strict syntactic constructs.</li>
<li>How to use K&apos;s syntactic lists.</li>
<li>How to define, initialize and configure configurations.</li>
<li>How the language syntax is swallowed by the builtin K syntactic category.</li>
<li>The additional syntax of the K syntactic category.</li>
<li>How the strictness annotations are automatically desugared into rules.</li>
<li>The first steps of the configuration abstraction mechanism.</li>
</ul>
<p>Like in the previous tutorial, this folder contains several lessons, each<br>
adding new features to IMP.  Do them in order.  Also, make sure you completed<br>
and understood the previous tutorial.</p>
</div></div><div id="ebook-heading-lesson-1-imp-defining-a-more-complex-syntax" ebook-toc-level-4 heading="Lesson 1, IMP: Defining a More Complex Syntax"><div><h1 class="mume-header" id="defining-a-more-complex-syntax">Defining a More Complex Syntax</h1>

<p>Here we learn how to define a more complex language syntax than LAMBDA&apos;s,<br>
namely the C-like syntax of IMP. Also, we will learn how to define languages<br>
using multiple modules, because we are going to separate IMP&apos;s syntax from<br>
its semantics using modules. Finally, we will also learn how to use K&apos;s<br>
builtin support for syntactic lists.</p>
<p>The K tool provides modules for grouping language features. In general, we<br>
can organize our languages in arbitrarily complex module structures.<br>
While there are no rigid requirements or even guidelines for how to group<br>
language features in modules, we often separate the language syntax from the<br>
language semantics in different modules.</p>
<p>In our case here, we start by defining two modules, IMP-SYNTAX and IMP, and<br>
import the first in the second, using the keyword <code>imports</code>. As their names<br>
suggest, we will place all IMP&apos;s syntax definition in IMP-SYNTAX and all its<br>
semantics in IMP.</p>
<p>Note, however, that K does no more than simply includes all the<br>
contents of the imported module in the one which imports it (making sure<br>
that everything is only kept once, even if you import it multiple times).<br>
In other words, there is currently nothing fancy in K tool&apos;s module system.</p>
<p>IMP has six syntactic categories, as shown in <code>imp.k</code>: <code>AExp</code> for arithmetic<br>
expressions, <code>BExp</code> for Boolean expressions, <code>Block</code> for blocks, <code>Stmt</code> for<br>
statements, <code>Pgm</code> for programs and <code>Ids</code> for comma-separated lists of<br>
identifiers. Blocks are special statements, whose role is to syntactically<br>
constrain the conditional statement and the while loop statement to only<br>
take blocks as branches and body, respectively.</p>
<p>There is nothing special about arithmetic and Boolean expressions. They<br>
are given the expected strictness attributes, except for <code>&lt;=</code> and <code>&amp;&amp;</code>,<br>
for demonstration purposes.</p>
<p>The <code>&lt;=</code> is defined to be <code>seqstrict</code>, which means that it evaluates its<br>
arguments in order, from left-to-right (recall that the <code>strict</code> operators<br>
can evaluate their arguments in any, fully interleaved, orders). Like<br>
<code>strict</code>, the <code>seqstrict</code> annotation can also be configured; for example, one<br>
can specify in which arguments and in what order. By default, <code>seqstrict</code><br>
refers to all the arguments, in their left-to-right order. In our case here,<br>
it is equivalent with <code>seqstrict(1 2)</code>.</p>
<p>The <code>&amp;&amp;</code> is only strict in its first argument, because we will give it a<br>
short-circuited semantics (its second argument will only be evaluated when<br>
the first evaluates to true). Recall the K tool also allows us to associate<br>
LaTex attributes to constructs, telling the document generator how to display<br>
them. For example, we associate <code>&lt;=</code> the attribute <code>latex({#1}\leq{#2})</code>,<br>
which makes it be displayed <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&#x2264;</mo></mrow><annotation encoding="application/x-tex">\leq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">&#x2264;</span></span></span></span> everywhere in the generated LaTex<br>
documentation.</p>
<p>In this tutorial we take the freedom to associate the various constructs<br>
parsing precedences that we have already tested and we know work well, so that<br>
we can focus on the semantics here instead of syntax. In practice, though,<br>
you typically need to experiment with precedences until you obtain the desired<br>
parser.</p>
<p>Blocks are defined using curly brackets, and they can either be empty or<br>
hold a statement.</p>
<p>Nothing special about the IMP statements. Note that <code>;</code> is an assignment<br>
statement terminator, not a statement separator. Note also that blocks are<br>
special statements.</p>
<p>An IMP program declares a comma-separated list of variables using the keyword<br>
<code>int</code> like in C, followed by a semicolon <code>;</code>, followed by a statement.<br>
Syntactically, the idea here is that we can wrap any IMP program within a<br>
<code>main(){...}</code> function and get a valid C program. IMP does not allow variable<br>
declarations anywhere else except through this construct, at the top-level of<br>
the program. Other languages provided with the K distribution (see, e.g., the<br>
IMP++ language also discussed in this tutorial) remove this top-level program<br>
construct of IMP and add instead variable declaration as a statement construct,<br>
which can be used anywhere in the program, not only at the top level.</p>
<p>Note how we defined the comma-separated list of identifiers using<br>
<code>List{Id,&quot;,&quot;}</code>. The K tool provides builtin support for generic syntactic<br>
lists. In general,</p>
<pre class="language-text">syntax B ::= List{A,T}
</pre>
<p>declares a new non-terminal, <code>B</code>, corresponding to <code>T</code>-separated sequences of<br>
elements of <code>A</code>, where <code>A</code> is a non-terminal and <code>T</code> is a terminal. These<br>
lists can also be empty, that is, IMP programs declaring no variable are also<br>
allowed (e.g., <code>int; {}</code> is a valid IMP program). To instantiate and use<br>
the K builtin lists, you should alias each instance with a (typically fresh)<br>
non-terminal in your syntax, like we do with the <code>Ids</code> nonterminal.</p>
<p>Like with other K features, there are ways to configure the syntactic lists,<br>
but we do not discuss them here.</p>
<p>Recall from Tutorial 1 (LAMBDA) that in order for strictness to work well<br>
we also need to tell K which computations are meant to be results. We do<br>
this as well now, in the module IMP: integers and Booleans are K results.</p>
<p>Kompile <code>imp.k</code> and test the generated parser by running some programs.<br>
Since IMP is a fragment of C, you may want to select the C mode in your<br>
editor when writing these programs. This will also give your the feel that<br>
you are writing programs in a real programming language.</p>
<p>For example, here is <code>sum.imp</code>, which sums in <code>sum</code> all numbers up to <code>n</code>:</p>
<pre class="language-text">int n, sum;
n = 100;
sum=0;
while (!(n &lt;= 0)) {
  sum = sum + n;
  n = n + -1;
}
</pre>
<p>Now krun it and see how it looks parsed in the default <code>k</code> cell.</p>
<p>The program <code>collatz.imp</code> tests the Collatz conjecture for all numbers up to<br>
<code>m</code> and accumulates the total number of steps in <code>s</code>:</p>
<pre class="language-text">int m, n, q, r, s;
m = 10;
while (!(m&lt;=2)) {
  n = m;
  m = m + -1;
  while (!(n&lt;=1)) {
    s = s+1;
    q = n/2;
    r = q+q+1;
    if (r&lt;=n) {
      n = n+n+n+1;         // n becomes 3*n+1 if odd
    } else {n=q;}          //        of   n/2 if even
  }
}
</pre>
<p>Finally, program <code>primes.imp</code> counts in <code>s</code> all the prime numbers up to <code>m</code>:</p>
<pre class="language-text">int i, m, n, q, r, s, t, x, y, z;
m = 10;  n = 2;
while (n &lt;= m) {
  // checking primality of n and writing t to 1 or 0
  i = 2;  q = n/i;  t = 1;
  while (i&lt;=q &amp;&amp; 1&lt;=t) {
    x = i;
    y = q;
    // fast multiplication (base 2) algorithm
    z = 0;
    while (!(x &lt;= 0)) {
      q = x/2;
      r = q+q+1;
      if (r &lt;= x) { z = z+y; } else {}
      x = q;
      y = y+y;
    } // end fast multiplication
    if (n &lt;= z) { t = 0; } else { i = i+1;  q = n/i; }
  } // end checking primality
  if (1 &lt;= t) { s = s+1; } else {}
  n = n+1;
}
</pre>
<p>All the programs above will run once we define the semantics of IMP. If you<br>
want to execute them now, wrap them in a <code>main(){...}</code> function and compile<br>
them and run them with your favorite C compiler.</p>
<p>Before we move to the K semantics of IMP, we would like to make some<br>
clarifications regarding the K builtin parser, <code>kast</code>. Although it is quite<br>
powerful, you should not expect magic from it! While the K parser can parse<br>
many non-trivial languages (see, for example, the KOOL language in<br>
<a href="file:///home/runner/work/k/k/gh-pages/pl-tutorial/2_languages">pl-tutorial/2_languages</a>) in the K distribution), it was<br>
never meant to be a substitute for real parsers. We often call the syntax<br>
defined in K <em>the syntax of the semantics</em>, to highlight the fact that its<br>
role is to serve as a convenient notation when writing the semantics, not<br>
necessarily as a means to define concrete syntax of arbitrarily complex<br>
programming languages. See the KERNELC language for an example on how to connect an external parser for concrete syntax to<br>
the K tool.</p>
<p>The above being said, we strongly encourage you to strive to make the<br>
builtin parser work with your desired language syntax! Do not give up<br>
simply because you don&apos;t want to deal with syntactic problems. On the<br>
contrary, fight for your syntax! If you really cannot define your desired<br>
syntax because of tool limitations, we would like to know. Please tell us.</p>
<p>Until now we have only seen default configurations. In the next lesson we<br>
will learn how to define a K custom configuration.</p>
<p>Go to <a href="#ebook-heading-lesson-2-imp-defining-a-configuration">Lesson 2, IMP: Defining a Configuration</a>.</p>
<p><a href="https://youtu.be/F39Ta1stiCM">MOVIE (out of date) [09&apos;15&quot;]</a></p>
</div></div><div id="ebook-heading-lesson-2-imp-defining-a-configuration" ebook-toc-level-4 heading="Lesson 2, IMP: Defining a Configuration"><div><h1 class="mume-header" id="defining-a-configuration">Defining a Configuration</h1>

<p>Here we learn how to define a configuration in K. We also learn how to<br>
initialize and how to display it.</p>
<p>As explained in the overview presentation on K, configurations are quite<br>
important, because all semantic rules match and apply on them.<br>
Moreover, they are the backbone of <em>configuration abstraction</em>, which allows<br>
you to only mention the relevant cells in each semantic rule, the rest of<br>
the configuration context being inferred automatically. The importance of<br>
configuration abstraction will become clear when we define more complex<br>
languages (even in IMP++). IMP does not really need it. K configurations<br>
are constructed making use of cells, which are labeled and can be arbitrarily<br>
nested.</p>
<p>Configurations are defined with the keyword <code>configuration</code>. Cells are<br>
defined using an XML-ish notation stating clearly where the cell starts<br>
and where it ends.</p>
<p>While not enforced by the tool, we typically like to put the entire<br>
configuration in a top-level cell, called <code>T</code>. So let&apos;s define it:</p>
<pre class="language-text">configuration &lt;T&gt;...&lt;/T&gt;
</pre>
<p>Cells can have other cells inside. In our case of IMP, we need a cell to<br>
hold the remaining program, cell which we typically call <code>k</code>, and a cell to<br>
hold the program state. Let us add them:</p>
<pre class="language-text">configuration &lt;T&gt; &lt;k&gt;...&lt;/k&gt; &lt;state&gt;...&lt;/state&gt; &lt;/T&gt;
</pre>
<p>K allows us to also specify how to initialize a configuration at the same<br>
time with declaring the configuration. All we have to do is to fill in<br>
the contents of the cells with some terms. The syntactic categories of<br>
those terms will also indirectly define the types of the corresponding<br>
cells.</p>
<p>For example, we want the <code>k</code> cell to initially hold the program that is passed<br>
to <code>krun</code>. K provides a builtin configuration variable, called <code>$PGM</code>, which<br>
is specifically designed for this purpose: <code>krun</code> will place its program there<br>
(after it parses it, or course). The K tool allows users to define their own<br>
configuration variables, too, which can be used to develop custom<br>
initializations of program configurations with the help of <code>krun</code>; this can be<br>
quite useful when defining complex languages, but we do not discuss it in<br>
this tutorial.</p>
<pre class="language-text">configuration &lt;T&gt; &lt;k&gt; $PGM &lt;/k&gt; &lt;state&gt;...&lt;/state&gt;  &lt;/T&gt;
</pre>
<p>Moreover, we want the program to be a proper <code>Pgm</code> term (because we do not<br>
want to allow <code>krun</code> to take fragments of programs, for example, statements).<br>
Therefore, we tag <code>$PGM</code> with the desired syntactic category, <code>Pgm</code>:</p>
<pre class="language-text">configuration &lt;T&gt; &lt;k&gt; $PGM:Pgm &lt;/k&gt; &lt;state&gt;...&lt;/state&gt;  &lt;/T&gt;
</pre>
<p>Like for other variable tags in K, a run-time check will be performed and the<br>
semantics will get stuck if the passed term is not a well-formed program.</p>
<p>We next tell K that the state cell should be initialized with the empty map:</p>
<pre class="language-text">configuration &lt;T&gt; &lt;k&gt; $PGM:Pgm &lt;/k&gt; &lt;state&gt; .Map &lt;/state&gt;  &lt;/T&gt;
</pre>
<p>Recall that in K <code>.</code> stands for <em>nothing</em>. However, since there are various<br>
types of nothing, to avoid confusion we can suffix the <code>.</code> with its desired<br>
type. K has several builtin data-types, including lists, sets, bags, and<br>
maps. <code>.Map</code> is the empty map.</p>
<p>Kompile <code>imp.k</code> and run several programs to see how the configuration is<br>
initialized as desired.</p>
<p>When configurations get large, and they do when defining large programming<br>
languages, you may want to color the cells in order to more easily distinguish<br>
them. This can be easily achieved using the <code>color</code> cell attribute, following<br>
again an XML-ish style:</p>
<pre class="language-text">configuration &lt;T color=&quot;yellow&quot;&gt;
                &lt;k color=&quot;green&quot;&gt; $PGM:Pgm &lt;/k&gt;
                &lt;state color=&quot;red&quot;&gt; .Map &lt;/state&gt;
              &lt;/T&gt;
</pre>
<p>In the next lesson we will learn how to write rules that involve cells.</p>
<p>Go to <a href="#ebook-heading-lesson-3-imp-computations-results-strictness-rules-involving-cells">Lesson 3, IMP: Computations, Results, Strictness; Rules Involving Cells</a>.</p>
<p><a href="https://youtu.be/jkwLyGdt70U">MOVIE (out of date) [04&apos;21&quot;]</a></p>
</div></div><div id="ebook-heading-lesson-3-imp-computations-results-strictness-rules-involving-cells" ebook-toc-level-4 heading="Lesson 3, IMP: Computations, Results, Strictness; Rules Involving Cells"><div><h1 class="mume-header" id="computations-results-strictness-rules-involving-cells">Computations, Results, Strictness; Rules Involving Cells</h1>

<p>In this lesson we will learn about the syntactic category <code>K</code> of computations,<br>
about how strictness attributes are in fact syntactic sugar for rewrite rules<br>
over computations, and why it is important to tell the tool which<br>
computations are results. We will also see a K rule that involves cells.</p>
<h2 class="mume-header" id="k-computations">K Computations</h2>

<p>Computation structures, or more simply <em>computations</em>, extend the abstract<br>
syntax of your language with a list structure using <code>~&gt;</code> (read <em>followed<br>
by</em> or <em>and then</em>, and written <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&#x21B7;</mo></mrow><annotation encoding="application/x-tex">\curvearrowright</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mrel amsrm">&#x21B7;</span></span></span></span> in Latex) as a separator.<br>
K provides a distinguished sort, <code>K</code>, for computations. The extension of the<br>
abstract syntax of your language into computations is done automatically by<br>
the K tool when you declare constructs using the <code>syntax</code> keyword, so the K<br>
semantic rules can uniformly operate only on terms of sort <code>K</code>. The intuition<br>
for computation structures of the form</p>
<pre class="language-text">t1 ~&gt; t2 ~&gt; ... ~&gt; tn
</pre>
<p>is that the listed tasks are to be processed in order. The initial<br>
computation typically contains the original program as its sole task, but<br>
rules can then modify it into task sequences, as seen shortly.</p>
<h2 class="mume-header" id="strictness-in-theory">Strictness in Theory</h2>

<p>The strictness attributes, used as annotations to language constructs,<br>
actually correspond to rules over computations. For example, the<br>
<code>strict(2)</code> attribute of the assignment statement corresponds to the<br>
following two opposite rules (<code>X</code> ranges over <code>Id</code> and <code>A</code> over <code>AExp</code>):</p>
<pre class="language-text">X=A; =&gt; A ~&gt; X=[];
A ~&gt; X=[]; =&gt; X=A;
</pre>
<p>The first rule pulls <code>A</code> from the syntactic context <code>X=A;</code> and schedules it<br>
for processing. The second rule plugs <code>A</code> back into its context.<br>
Inspired from the chemical abstract machine, we call rules of the first<br>
type above <em>heating</em> rules and rules of the second type <em>cooling</em> rules.<br>
Similar rules are generated for other arguments in which operations are<br>
strict. Iterative applications of heating rules eventually bring to the<br>
top of the computation atomic tasks, such as a variable lookup, or a<br>
builtin operation, which then make computational progress by means of other<br>
rules. Once progress is made, cooling rules can iteratively plug the result<br>
back into context, so that heating rules can pick another candidate for<br>
reduction, and so on and so forth.</p>
<p>When operations are strict only in some of their arguments, the corresponding<br>
positions of the arguments in which they are strict are explicitly enumerated<br>
in the argument of the <code>strict</code> attribute, e.g., <code>strict(2)</code> like above, or<br>
<code>strict(2 3)</code> for an operation strict in its second and third arguments, etc.<br>
If an operation is simply declared <code>strict</code> then it means that it is strict<br>
in all its arguments. For example, the strictness of addition yields:</p>
<pre class="language-text">A1+A2 =&gt; A1 ~&gt; []+A2
A1 ~&gt; []+A2 =&gt; A1+A2
A1+A2 =&gt; A2 ~&gt; A1+[]
A2 ~&gt; A1+[] =&gt; A1+A2
</pre>
<p>It can be seen that such heating/cooling rules can easily lead to<br>
non-determinism, since the same term may be heated many different ways;<br>
these different evaluation orders may lead to different behaviors in some<br>
languages (not in IMP, because its expressions do not have side effects,<br>
but we will experiment with non-determinism in its successor, IMP++).</p>
<p>A similar desugaring applies to sequential strictness, declared with the<br>
keyword <code>seqstrict</code>. While the order of arguments of <code>strict</code> is irrelevant,<br>
it matters in the case of <code>seqstrict</code>: they are to be evaluated in the<br>
specified order; if no arguments are given, then they are assumed by default<br>
to be evaluated from left-to-right. For example, the default heating/cooling<br>
rules associated to the sequentially strict <code>&lt;=</code> construct above are<br>
(<code>A1</code>, <code>A2</code> range over <code>AExp</code> and <code>I1</code> over <code>Int</code>):</p>
<pre class="language-text">A1&lt;=A2 =&gt; A1 ~&gt; []&lt;=A2
A1 ~&gt; []&lt;=A2 =&gt; A1&lt;=A2
I1&lt;=A2 =&gt; A2 ~&gt; I1&lt;=[]
A2 ~&gt; I1&lt;=[] =&gt; I1&lt;=A2
</pre>
<p>In other words, <code>A2</code> is only heated/cooled after <code>A1</code> is already evaluated.</p>
<p>While the heating/cooling rules give us a nice and uniform means to define<br>
all the various allowable ways in which a program can evaluate, all based<br>
on rewriting, the fact that they are reversible comes with a serious practical<br>
problem: they make the K definitions unexecutable, because they lead to<br>
non-termination.</p>
<h2 class="mume-header" id="strictness-in-practice-k-results">Strictness in Practice; K Results</h2>

<p>To break the reversibility of the theoretical heating/cooling rules, and,<br>
moreover, to efficiently execute K definitions, the current implementation of<br>
the K tool relies on users giving explicit definitions of their languages&apos;<br>
results.</p>
<p>The K tool provides a predicate <code>isKResult</code>, which is automatically defined<br>
as we add syntactic constructs to <code>KResult</code> (in fact the K tool defines such<br>
predicates for all syntactic categories, which are used, for example, as<br>
rule side conditions to check user-declared variable memberships, such as<br>
<code>V:Val</code> stating that <code>V</code> belongs to <code>Val</code>).</p>
<p>The <code>kompile</code> tool, depending upon what it is requested to do, changes the<br>
reversible heating/cooling rules corresponding to evaluation strategy<br>
definitions (e.g., those corresponding to strictness attributes) to avoid<br>
non-termination. For example, when one is interested in obtaining an<br>
executable model of the language (which is the default compilation mode of<br>
<code>kompile</code>), then heating is performed only when the to-be-pulled syntactic<br>
fragment is not a result, and the corresponding cooling only when the<br>
to-be-plugged fragment is a result. In this case, e.g., the heating/cooling<br>
rules for assignment are modified as follows:</p>
<pre class="language-text">X=A; =&gt; A ~&gt; X=[];  requires notBool isKResult(A)
A ~&gt; X=[]; =&gt; X=A;  requires isKResult(A)
</pre>
<p>Note that non-termination of heating/cooling is avoided now. The only thing<br>
lost is the number of possible behaviors that a program can manifest, but<br>
this is irrelevant when all we want is one behavior.</p>
<p>As will be discussed in the IMP++ tutorial, the heating/cooling rules are<br>
modified differently by <code>kompile</code> when we are interested in other aspects<br>
of the language definition, such us, for example, in a search-able model that<br>
comprises all program behaviors. This latter model is obviously more general<br>
from a theoretical perspective, but, in practice, it is also slower to execute.<br>
The <code>kompile</code> tool strives to give you the best model of the language for the<br>
task you are interested in.</p>
<h2 class="mume-header" id="cant-results-be-inferred-automatically">Can&apos;t Results be Inferred Automatically?</h2>

<p>This is a long story, but the short answer is: <em>No!</em>. Maybe in some cases<br>
it is possible, but we prefer to not attempt it in the K tool. For example,<br>
you most likely do not want any stuck computation to count as a result,<br>
since some of them can happen simply because you forgot a semantic rule that<br>
could have further reduce it! Besides, in our experience with defining large<br>
languages, it is quite useful to take your time and think of what the results<br>
of your language&apos;s computations are. This fact in itself may help you improve<br>
your overall language design. We typically do it at the same time with<br>
defining the evaluation strategies of our languages. Although in theory K<br>
could infer the results of your language as the stuck computations, based on<br>
the above we have deliberately decided to not provide this feature, in spite<br>
of requests from some users. So you currently do have to explicitly define<br>
your K results if you want to effectively use the K tool. Note, however, that<br>
theoretical definitions, not meant to be executed, need not worry about<br>
defining results (that&apos;s because in theory semantic rules apply <em>modulo</em> the<br>
reversible heating/cooling rules, so results are not necessary).</p>
<h2 class="mume-header" id="a-k-rule-involving-cells">A K Rule Involving Cells</h2>

<p>All our K rules so far in the tutorial were of the form</p>
<pre class="language-text">rule left =&gt; right requires condition
</pre>
<p>where <code>left</code> and <code>right</code> were syntactic, or more generally computation, terms.</p>
<p>Here is our first K rule explicitly involving cells:</p>
<pre class="language-text">rule &lt;k&gt; X:Id =&gt; I ...&lt;/k&gt; &lt;state&gt;... X |-&gt; I ...&lt;/state&gt;
</pre>
<p>Recall that the <code>k</code> cell holds computations, which are sequences of tasks<br>
separated by <code>~&gt;</code>. Also, the <code>state</code> cell holds a map, which is a set of<br>
bindings, each binding being a pair of computations (currently, the<br>
K builtin data-structures, like maps, are untyped; or, said differently,<br>
they are all over the type of computations, <code>K</code>).</p>
<p>Therefore, the two cells mentioned in the rule above hold collections<br>
of things, ordered or not. The <code>...</code>s, which we also call cell <em>frames</em>,<br>
stand for <em>more stuff there, which we do not care about</em>.</p>
<p>The rewrite relation <code>=&gt;</code> is allowed in K to appear anywhere in a term, its<br>
meaning being that the corresponding subterm is rewritten as indicated in the<br>
shown context. We say that K&apos;s rewriting is <em>local</em>.</p>
<p>The rule above says that if the identifier <code>X</code> is the first task in the <code>k</code><br>
cell, and if <code>X</code> is bound to <code>I</code> somewhere in the <code>state</code>, then <code>X</code> rewrites<br>
to <code>I</code> <em>locally</em> in the <code>k</code> cell. Therefore, IMP variables need to be already<br>
declared when looked up.</p>
<p>Of course, the K rule above can be translated into an ordinary rewrite rule<br>
of the form</p>
<pre class="language-text">rule &lt;k&gt; X ~&gt; Rest &lt;/k&gt; &lt;state&gt; Before (X |-&gt; I) After &lt;/state&gt;
  =&gt; &lt;k&gt; I ~&gt; Rest &lt;/k&gt; &lt;state&gt; Before (X |-&gt; I) After &lt;/state&gt;
</pre>
<p>Besides being more verbose and thus tedious to write, this ordinary rule<br>
is also more error-prone; for example, we may forget the <code>Rest</code> variable<br>
in the right-hand-side, etc. Moreover, the concurrent semantics of K<br>
allows for its rules to be interpreted as <em>concurrent transactions</em>, where<br>
the context is the read-only component of the transaction, while the<br>
subterms which are rewritten are read/write component of the transaction;<br>
thus, K rule instances can apply concurrently if they only overlap<br>
on read-only parts, while they cannot if regarded as ordinary rewrite logic<br>
rules. Note: our current implementation of the K tool is not concurrent,<br>
so K rules are in fact desugared as normal rewrite rules in the K tool.</p>
<p>Kompile <code>imp.k</code> using a documentation option and check out how the K rule<br>
looks in the generated document. The <code>...</code> frames are displayed as cell<br>
tears, metaphorically implying that those parts of the cells that we<br>
do not care about are <em>torn away</em>. The rewrite relation is replaced by a<br>
horizontal line: specifically, the subterm which rewrites, <code>X</code>, is<br>
underlined, and its replacement is written underneath the line.</p>
<p>In the next lesson we define the complete K semantics of IMP and<br>
run the programs we parsed in the first lesson.</p>
<p>Go to <a href="#ebook-heading-lesson-4-imp-configuration-abstraction-part-1-types-of-rules">Lesson 4, IMP: Configuration Abstraction, Part 1; Types of Rules</a>.</p>
<p><a href="https://youtu.be/gYPkhiT2SxA">MOVIE (out of date) [10&apos;30&quot;]</a></p>
</div></div><div id="ebook-heading-lesson-4-imp-configuration-abstraction-part-1-types-of-rules" ebook-toc-level-4 heading="Lesson 4, IMP: Configuration Abstraction, Part 1; Types of Rules"><div><h1 class="mume-header" id="configuration-abstraction-part-1-types-of-rules">Configuration Abstraction, Part 1; Types of Rules</h1>

<p>Here we will complete the K definition of IMP and, while doing so, we will<br>
learn the very first step of what we call <em>configuration abstraction</em>.</p>
<h2 class="mume-header" id="the-imp-semantic-rules">The IMP Semantic Rules</h2>

<p>Let us add the remaining rules, in the order in which the language constructs<br>
were defined in IMP-SYNTAX.</p>
<p>The rules for the arithmetic and Boolean constructs are self-explanatory.<br>
Note, however, that K will infer the correct sorts of all the variables in<br>
these rules, because they appear as arguments of the builtin operations<br>
(<code>_+Int_</code>, etc.). Moreover, the inferred sorts will be enforced dynamically.<br>
Indeed, we do not want to apply the rule for addition, for example, when the<br>
two arguments are not integers. In the rules for <code>&amp;&amp;</code>, although we prefer to<br>
not do it here for simplicity, we could have eliminated the dynamic check by<br>
replacing <code>B</code> (and similarly for <code>_</code>) with <code>B:K</code>. Indeed, it can be shown<br>
that whenever any of these rules apply, <code>B</code> (or <code>_</code>) is a <code>BExp</code> anyway.<br>
That&apos;s because there is no rule that can touch such a <code>B</code> (or <code>_</code>); this<br>
will become clearer shortly, when we discuss the first step of configuration<br>
abstraction. Therefore, since we know that <code>B</code> will be a <code>BExp</code> anyway, we<br>
could save the time it takes to check its sort; such times may look minor,<br>
but they accumulate, so some designers may prefer to avoid run-time checks<br>
whenever possible.</p>
<p>The block rules are trivial. However, the rule for non-empty blocks is<br>
semantically correct only because we do not have local variable declarations<br>
in IMP. We will have to change this rule in IMP++.</p>
<p>The assignment rule has two <code>=&gt;</code>: one in the <code>k</code> cell dissolving the<br>
assignment statement, and the other in the <code>state</code> cell updating the value of<br>
the assigned variable. Note that the one in the <code>state</code> is surrounded by<br>
parentheses: <code>(_ =&gt; I)</code>. That is because <code>=&gt;</code> is greedy: it matches as much<br>
as it can to the left and to the right, until it reaches the cell boundaries<br>
(closed or open). If you want to limit its scope, or for clarity, you can use<br>
parentheses like here.</p>
<p>The rule for sequential composition simply desugars <code>S1 S2</code> into <code>S1 ~&gt; S2</code>.<br>
Indeed, the two have exactly the same semantics. Note that statements<br>
<em>evaluate</em> to nothing (<code>.</code>), so once <code>S1</code> is processed in <code>S1 ~&gt; S2</code>, then the<br>
next task is automatically <code>S2</code>, without wasting any step for the transition.</p>
<p>The rules for the conditional and while statements are clear. One thing to<br>
keep in mind now is that the <code>while</code> unrolling rule will not apply<br>
indefinitely in the positive branch of the resulting conditional, because<br>
of K&apos;s configuration abstraction, which will be discussed shortly.</p>
<p>An IMP program declares a set of variables and then executes a<br>
statement in the state obtained after initializing all those variables<br>
to <code>0</code>. The rules for programs initialize the declared variables one by one,<br>
checking also that there are no duplicates. We check for duplicates only for<br>
demonstration purposes, to illustrate the <code>keys</code> predefined operation that<br>
returns the set of keys of a map, and the set membership operation <code>in</code>.<br>
In practice, we typically define a static type checker for our language,<br>
which we execute before the semantics and reject inappropriate programs.</p>
<p>The use of the <code>.Ids</code> in the second rule is not necessary. We could have<br>
written <code>int; S</code> instead of <code>int .Ids; S</code> and the K tool would parse it and<br>
kompile the definition correctly, because it uses the same parser used for<br>
parsing programs also to parse the semantics. However, we typically prefer to<br>
explicitly write the <em>nothing</em> values in the semantics, for clarity;<br>
the parser has been extended to accept these. Note that the first rule<br>
matches the entire <code>k</code> cell, because <code>int_;_</code> is the top-level program<br>
construct in IMP, so there is nothing following it in the computation cell.<br>
The anonymous variable stands for the second argument of this top-level program<br>
construct, not for the rest of the computation. The second rule could have<br>
also been put in a complete <code>k</code> cell, but we preferred not to, for simplicity.</p>
<p>Our IMP semantics is now complete, but there are a few more things that we<br>
need to understand and do.</p>
<h2 class="mume-header" id="configuration-abstraction-part-1">Configuration Abstraction, Part 1</h2>

<p>First, let us briefly discuss the very first step of configuration abstraction.<br>
In K, all semantic rules are in fact rules between configurations. As soon<br>
explained in the IMP++ tutorial, the declared configuration cell structure is<br>
used to automatically complete the missing configuration parts in rules.<br>
However, many rules do not involve any cells, being rules between syntactic<br>
terms (of sort <code>K</code>); for example, we had only three rules involving cells in our<br>
IMP semantics. In this case, the <code>k</code> cell will be added automatically and the<br>
actual rewrite will happen on top of the enclosed computation. For example,<br>
the rule for the <code>while</code> loop is automatically translated into the following:</p>
<pre class="language-text">rule &lt;k&gt; while (B) S =&gt; if (B) {S while (B) S} else {} ...&lt;/k&gt;
</pre>
<p>Since the first task in computations is what needs to be done next, the<br>
intuition for this rule completion is that the syntactic transition<br>
only happens when the term to rewrite is ready for processing. This explains,<br>
for example, why the while loop unrolling does not indefinitely apply in the<br>
positive branch of the conditional: the inner while loop is not ready for<br>
evaluation yet. We call this rule completion process, as well as other<br>
similar ones, <em>configuration abstraction</em>. That is because the incomplete<br>
rule abstracts away the configuration structure, thus being easier to read.<br>
As seen soon when we define IMP++, configuration abstraction is not only a<br>
user convenience; it actually significantly increases the modularity of our<br>
definitions. The k-cell-completion is only the very first step, though.</p>
<p>If you really want certain rewrites over syntactic terms to apply<br>
anywhere they match, then you should tag the rule with the attribute<br>
<code>anywhere</code>, which was discussed in Tutorial 1, Lesson 2.5.</p>
<p>Kompile and then krun the programs that you only parsed in Lesson 1. They<br>
should all execute as expected. The state cell shows the final state<br>
of the program. The <code>k</code> cell shows the final code contents, which should be<br>
empty whenever the IMP program executes correctly.</p>
<p>Kompile also with the documentation option and take a look at the generated<br>
documentation. The assignment rule should particularly be of interest,<br>
because it contains two local rewrites.</p>
<p>In the next lesson we comment the IMP definition and conclude this tutorial.</p>
<p>Go to <a href="#ebook-heading-lesson-5-imp-completing-and-documenting-imp">Lesson 5, IMP: Completing and Documenting IMP</a>.</p>
<p><a href="https://youtu.be/fR2VEfGHtho">MOVIE (out of date) [09&apos;16&quot;]</a></p>
</div></div><div id="ebook-heading-lesson-5-imp-completing-and-documenting-imp" ebook-toc-level-4 heading="Lesson 5, IMP: Completing and Documenting IMP"><div><h1 class="mume-header" id="completing-and-documenting-imp">Completing and Documenting IMP</h1>

<p>We here learn no new concepts, but it is a good moment to take a break<br>
and contemplate what we learned so far.</p>
<p>Let us add lots of formal annotations to <code>imp.k</code>.</p>
<p>Once we are done with the annotations, we kompile with the documentation<br>
option and then take a look at the produced document. We often call these<br>
documents <em>language posters</em>. Depending on how much information you add to<br>
these language posters, they can serve as standalone, formal presentations<br>
of your languages. For example, you can print them as large posters and<br>
post them on the wall, or in poster sessions at conferences.</p>
<p>This completes our second tutorial. The next tutorials will teach us more<br>
features of the K framework, such as how to define languages with complex<br>
control constructs (like <code>callcc</code>), languages which are concurrent, and so on.</p>
<p><a href="https://youtu.be/w2t_Yx2VGVQ">MOVIE (out of date) [03&apos;45&quot;]</a></p>
</div></div><div id="ebook-heading-part-3-defining-lambda" ebook-toc-level-3 heading="Part 3: Defining LAMBDA++"><div><h1 class="mume-header" id="part-3-defining-lambda">Part 3: Defining LAMBDA++</h1>

<p>Here you will learn how to define language constructs which abruptly change<br>
the execution control flow, and how to define language semantics following<br>
and environment/store style.  Specifically, you will learn the following:</p>
<ul>
<li>How to define constructs like <code>callcc</code>, which allow you to take snapshots of<br>
program executions and to go <em>back in time</em> at any moment.</li>
<li>How to define languages in an environment/store style.</li>
<li>Some basic notions about the use of closures and closure-like semantic<br>
structures to save and restore execution environments.</li>
<li>Some basic intuitions about reusing existing semantics in new languages,<br>
as well as some of the pitfalls in doing so.</li>
</ul>
</div></div><div id="ebook-heading-lesson-1-lambda-abrupt-changes-of-control" ebook-toc-level-4 heading="Lesson 1, LAMBDA++: Abrupt Changes of Control"><div><h1 class="mume-header" id="abrupt-changes-of-control">Abrupt Changes of Control</h1>

<p>Here we add <em>call-with-current-continuation</em> (<code>callcc</code>) to the definition of<br>
LAMBDA completed in Tutorial 1, and call the resulting language LAMBDA++.<br>
While doing so, we will learn how to define language constructs that<br>
abruptly change the execution control flow.</p>
<p>Take over the <code>lambda.k</code> definition from Lesson 8 in Part 1 of this Tutorial,<br>
which is the complete definition of the LAMBDA language, but without the<br>
comments.</p>
<p><code>callcc</code> is a good example for studying the capabilities of a framework to<br>
support abrupt changes of control, because it is one of the most<br>
control-intensive language constructs known.  Scheme is probably the first<br>
programming language that incorporated the <code>callcc</code> construct, although<br>
similar constructs have been recently included in many other languages in<br>
one form or another.</p>
<p>Here is a quick description: <code>callcc e</code> passes the remaining computation<br>
context, packaged as a function <code>k</code>, to <code>e</code> (which is expected to be a function);<br>
if during its evaluation <code>e</code> passes any value to <code>k</code>, then the current<br>
execution context is discarded and replaced by the one encoded by <code>k</code> and<br>
the value is passed to it; if <code>e</code> evaluates normally to some value <code>v</code> and<br>
passes nothing to <code>k</code> in the process, then <code>v</code> is returned as a result of<br>
<code>callcc e</code> and the execution continues normally.  For example, we want the<br>
program <code>callcc-jump.lambda</code>:</p>
<pre class="language-text">(callcc (lambda k . ((k 5) + 2))) + 10
</pre>
<p>to evaluate to <code>15</code>, not <code>17</code>!  Indeed, the computation context <code>[] + 10</code> is<br>
passed to <code>callcc</code>&apos;s argument, which then sends it a <code>5</code>, so the computation<br>
resumes to <code>5 + 10</code>.  On the other hand, the program <code>callcc-not-jump.lambda</code></p>
<pre class="language-text">(callcc (lambda k . (5 + 2))) + 10
</pre>
<p>evaluates to <code>17</code>.</p>
<p>If you like playing games, you can metaphorically think of <code>callcc e</code> as<br>
<em>saving your game state in a file and passing it to your friend <code>e</code></em>.<br>
Then <code>e</code> can decide at some moment to drop everything she was doing, load<br>
your game and continue to play it from where you were.</p>
<p>The behavior of many popular control-changing constructs can be obtained<br>
using <code>callcc</code>.  The program <code>callcc-return.lambda</code> shows, for example, how to<br>
obtain the behavior of a <code>return</code> statement, which exits the current execution<br>
context inside a function and returns a value to the caller&apos;s context:</p>
<pre class="language-text">letrec f x = callcc (lambda return . (
  f (if (x &lt;= 0) then ((return 1) / 0) else 2)
))
in (f -3)
</pre>
<p>This should evaluate to <code>1</code>, in spite of the recursive call to <code>f</code><br>
and of the division by zero!  Note that <code>return</code> is nothing but a variable<br>
name, but one which is bound to the current continuation at the beginning of<br>
the function execution.  As soon as <code>1</code> is passed to <code>return</code>, the computation<br>
jumps <em>back in time</em> to where <code>callcc</code> was defined! Change <code>-3</code> to <code>3</code> and the<br>
program will loop forever.</p>
<p><code>callcc</code> is quite a powerful and beautiful language construct, although one<br>
which is admittedly hard to give semantics to in some frameworks.<br>
But not in K &#x1F603;  Here is the entire K syntax and semantics of <code>callcc</code>:</p>
<pre class="language-text">syntax Exp ::= &quot;callcc&quot; Exp  [strict]
syntax Val ::= cc(K)
rule &lt;k&gt; (callcc V:Val =&gt; V cc(K)) ~&gt; K &lt;/k&gt;
rule &lt;k&gt; cc(K) V ~&gt; _ =&gt;  V ~&gt; K &lt;/k&gt;
</pre>
<p>Let us first discuss the annotated syntax.  We declared <code>callcc</code> strict,<br>
because its argument may not necessarily be a function yet, so it may need<br>
to be evaluated.  As explained above, we need to encode the remaining<br>
computation somehow and pass it to <code>callcc</code>&apos;s argument.  More specifically,<br>
since LAMBDA is call-by-value, we have to encode the remaining computation as<br>
a value.  We do not want to simply subsort computations to <code>Val</code>, because there<br>
are computations which we do not want to be values.  A simple solution to<br>
achieve our goal here is to introduce a new value construct, say <code>cc</code> (from<br>
<em>current-continuation</em>), which holds any computation.</p>
<p>Note that, inspired from <a href="http://www.program-transformation.org/Sdf/">SDF</a>,<br>
K allows you to define the syntax of helping semantic operations, like <code>cc</code>,<br>
more compactly.  Typically, we do not need a fancy syntax for such operators;<br>
all we need is a name, followed by open parenthesis, followed by a<br>
comma-separated list of arguments, followed by closed parenthesis.  If this<br>
is the syntax that you want for a particular construct, then K allows you to<br>
drop all the quotes surrounding the terminals, as we did above for <code>cc</code>.</p>
<p>The semantic rules do exactly what the English semantics of <code>callcc</code> says.<br>
Note that here, unlike in our definition of LAMBDA in Tutorial 1, we had<br>
to mention the cell <code>&lt;k/&gt;</code> in our rules.  This is because we need to make sure<br>
that we match the entire remaining computation, not only a fragment of it!<br>
For example, if we replace the two rules above with</p>
<pre class="language-text">rule (callcc V:Val =&gt; V cc(K)) ~&gt; K
rule cc(K) V ~&gt; _ =&gt;  V ~&gt; K
</pre>
<p>then we get a <code>callcc</code> which is allowed to non-deterministically pick a<br>
prefix of the remaining computation and pass it to its argument, and then<br>
when invoked within its argument, a non-deterministic prefix of the new<br>
computation is discarded and replaced by the saved one.  Wow, that would<br>
be quite a language!  Would you like to write programs in it?  &#x1F603;</p>
<p>Consequently, in K we can abruptly change the execution control flow of a<br>
program by simply changing the contents of the <code>&lt;k/&gt;</code> cell.  This is one of<br>
the advantages of having an explicit representation of the execution context,<br>
like in K or in reduction semantics with evaluation contexts.  Constructs like<br>
<code>callcc</code> are very hard and non-elegant to define in frameworks such as SOS,<br>
because those implicitly represent the execution context as proof context,<br>
and the latter cannot be easily changed.</p>
<p>Now that we know how to handle cells in configurations and use them in rules,<br>
in the next lesson we take a fresh look at LAMBDA and define it using<br>
an environment-based style, which avoids the complexity of substitution<br>
(e.g., having to deal with variable capture) and is closer in spirit to how<br>
functional languages are implemented.</p>
<p>Go to <a href="#ebook-heading-lesson-2-lambda-semantic-non-syntactic-computation-items">Lesson 2, LAMBDA++: Semantic (Non-Syntactic) Computation Items</a>.</p>
<p><a href="https://youtu.be/UZ9iaus024g">MOVIE (out of date) [6&apos;28&quot;]</a></p>
</div></div><div id="ebook-heading-lesson-2-lambda-semantic-non-syntactic-computation-items" ebook-toc-level-4 heading="Lesson 2, LAMBDA++: Semantic (Non-Syntactic) Computation Items"><div><h1 class="mume-header" id="semantic-non-syntactic-computation-items">Semantic (Non-Syntactic) Computation Items</h1>

<p>In this lesson we start another semantic definition of LAMBDA++, which<br>
follows a style based on environments instead of substitution.  In terms of<br>
K, we will learn how easy it is to add new items to the syntactic category<br>
of computations <code>K</code>, even ones which do not have a syntactic nature.</p>
<p>An environment binds variable names of interest to locations where their<br>
values are stored.  The idea of environment-based definitions is to maintain<br>
a global <em>store</em> mapping locations to values, and then have environments<br>
available when we evaluate expressions telling where the variables are<br>
located in the store.  Since LAMBDA++ is a relatively simple language, we<br>
only need to maintain one global environment.  Following a similar style<br>
like in IMP, we place all cells into a top cell <code>T</code>:</p>
<pre class="language-text">configuration &lt;T&gt;
                &lt;k&gt; $PGM:Exp &lt;/k&gt;
                &lt;env&gt; .Map &lt;/env&gt;
                &lt;store&gt; .Map &lt;/store&gt;
              &lt;/T&gt;
</pre>
<p>Recall that <code>$PGM</code> is where the program is placed by <code>krun</code> after parsing.  So<br>
the program execution starts with an empty environment and an empty store.</p>
<p>In environment-based definitions of lambda-calculi, lambda abstractions<br>
evaluate to so-called <em>closures</em>:</p>
<pre class="language-text">rule &lt;k&gt; lambda X:Id . E =&gt; closure(Rho,X,E) ...&lt;/k&gt;
     &lt;env&gt; Rho &lt;/env&gt;
</pre>
<p>A closure is like a lambda abstraction, but it also holds the environment<br>
in which it was declared.  This way, when invoked, a closure knows where to<br>
find in the store the values of all the variables that its body expression<br>
refers to.  We will define the lookup rule shortly.</p>
<p>Therefore, unlike in the substitution-based definitions of LAMBDA and<br>
LAMBDA++, neither the lambda abstractions nor the identifiers are values<br>
anymore here, because they both evaluate further: lambda abstractions to<br>
closures and identifiers to their values in the store.  In fact, the only<br>
values at this moment are the closures, and they are purely semantic entities,<br>
which cannot be used explicitly in programs.  That&apos;s why we modified the<br>
original syntax of the language to include no <code>Val</code> syntactic category<br>
anymore, and that&apos;s why we need to add closures as values now; same like<br>
before, we add a <code>Val</code> syntactic category which is subsorted<br>
to <code>KResult</code>.  In general, whenever you have any strictness attributes,<br>
your should also define some K results.</p>
<p>Invoking a closure is a bit more involved than the substitution-based<br>
beta-reduction: we need to switch to the closure&apos;s environment, then create a<br>
new, or fresh, binding for the closure&apos;s parameter to the value passed to the<br>
closure, then evaluate the closure&apos;s body, and then switch back to the<br>
caller&apos;s environment, which needs to be stored somewhere in the meanwhile.<br>
We can do all these with one rule:</p>
<pre class="language-text">rule &lt;k&gt; closure(Rho,X,E) V:Val =&gt; E ~&gt; Rho&apos; ...&lt;/k&gt;
     &lt;env&gt; Rho&apos; =&gt; Rho[X &lt;- !N] &lt;/env&gt;
     &lt;store&gt;... .Map =&gt; (!N:Int |-&gt; V) ...&lt;/store&gt;
</pre>
<p>Therefore, we atomically do all the following:</p>
<ul>
<li>switch the computation to the closure&apos;s body, <code>E</code>, followed by a<br>
caller-environment-recovery task <code>Rho&apos;</code> (note that <code>Rho&apos;</code> is the<br>
current environment),</li>
<li>generate a fresh location <code>!N</code> (the <code>!</code> is important, we discuss it below),<br>
bind <code>X</code> to <code>!N</code> in closure&apos;s environment and switch the current environment<br>
<code>Rho&apos;</code> to that one,</li>
<li>write the value passed to the closure, <code>V</code>, at location <code>!N</code>.</li>
</ul>
<p>This was the most complex K rule we&apos;ve seen so far in the tutorial.  Note,<br>
however, that this one rule achieves a lot.  It is, in fact, quite compact<br>
considering how much it does.  Note also that everything that this K rule<br>
mentions is needed also conceptually in order to achieve this task, so it<br>
is minimal from that point of view.  That would not be the case if we<br>
used, instead, a conventional rewrite rule, because we would have had to<br>
mention the remaining store, say <code>Sigma</code>, in both sides of the rule, to say<br>
it stays unchanged.  Here we just use <code>...</code>.</p>
<p>The declaration of the <em>fresh</em> variable above, <code>!N</code>, is new and needs<br>
some explanation.  First, note that <code>!N</code> appears only in the right-hand-side<br>
terms in the rule, that is, it is not matched when the rule is applied.<br>
Instead, a fresh <code>Nat</code> element is generated each time the rule is applied.<br>
In K, we can define syntactic categories which have the capability to<br>
generate fresh elements like above, using unbound variables whose name starts<br>
with a <code>!</code>.  The details of how to do that are beyond the scope of this<br>
tutorial (see Tutorial 6).  All we need to know here is that an arbitrary<br>
fresh element of that syntactic category is generated each time the rule<br>
is applied.  We cannot rely on the particular name or value of the generated<br>
element, because that can change with the next version of the K tool, or<br>
even from execution to execution with the same version.  All you can rely<br>
on is that each newly generated element is distinct from the previously<br>
generated elements for the same syntactic category.</p>
<p>Unlike in the substitution-based definition, we now also need a lookup rule:</p>
<pre class="language-text">rule &lt;k&gt; X =&gt; V ...&lt;/k&gt;
     &lt;env&gt;... X |-&gt; N ...&lt;/env&gt;
     &lt;store&gt;... N |-&gt; V ...&lt;/store&gt;
</pre>
<p>This rule speaks for itself: replace <code>X</code> by the value <code>V</code> located in the store<br>
at <code>X</code>&apos;s location <code>N</code> in the current environment.</p>
<p>The only thing left to define is the auxiliary environment-recovery operation:</p>
<p>rule <k> _:Val ~&gt; (Rho =&gt; .) ...</k> <env> _ =&gt; Rho </env></p>
<p>When the item preceding the environment recovery task <code>Rho</code> in the<br>
computation becomes a value, replace the current environment with <code>Rho</code><br>
and dissolve <code>Rho</code> from the computation.</p>
<p>Let us kompile and ... fail:</p>
<pre class="language-text">kompile lambda
</pre>
<p>gives a parsing error saying that <code>V:Val</code> does not fit there in the closure<br>
invocation rule.  That&apos;s because <code>Val</code> and <code>Exp</code> are currently completely<br>
disconnected, so K rightfully complains that we want to apply a value to<br>
another one, because application was defined to work with expressions, not<br>
values.  What we forgot here was to state that <code>Exp</code> includes <code>Val</code>:</p>
<pre class="language-text">syntax Exp ::= Val
</pre>
<p>Now everything works, but it is a good time to reflect a bit.</p>
<p>So we added closures, which are inherently semantic entities, to the syntax<br>
of expressions.  Does that mean that we can now write LAMBDA programs with<br>
closures in them?  Interestingly, with our current definition of LAMBDA,<br>
which purposely did not follow the nice organization of IMP into syntax and<br>
semantic modules, and with K&apos;s default parser, <code>kast</code>, you can.  But you are<br>
not supposed to speculate this!  In fact, if you use an external parser, that<br>
parser will reject programs with explicit closures.  Also, if we split the<br>
LAMBDA definition into two modules, one called LAMBDA-SYNTAX containing<br>
exclusively the desired program syntax and one called LAMBDA importing the<br>
former and defining the syntax of the auxiliary operations and the semantics,<br>
then even K&apos;s default parser will reject programs using auxiliary syntactic<br>
constructs.</p>
<p>Indeed, when you kompile a language, say <code>lang.k</code>, the tool will by default<br>
attempt to find a module LANG-SYNTAX and generate the program parser from<br>
that.  If it cannot find it, then it will use the module LANG instead.  There<br>
are also ways to tell kompile precisely which syntax module you want to use<br>
for the program parser if you don&apos;t like the default convention.<br>
See <code>kompile --help</code>.</p>
<p>Another insightful thought to reflect upon, is the relationship between your<br>
language&apos;s values and other syntactic categories.  It is often the case that<br>
values form a subset of the original language syntax, like in IMP (Part 2 of<br>
the tutorial), but sometimes that is not true, like in our case here.  When<br>
that happens, in order for the semantics to be given smoothly and uniformly<br>
using the original syntax, you need to extend your language&apos;s original<br>
syntactic categories with the new values.  The same holds true in other<br>
semantic approaches, not only in K, even in ones which are considered purely<br>
syntactic.  As it should be clear by now, K does not enforce you to use a<br>
purely syntactic style in your definitions; nevertheless, K does allow you to<br>
develop purely syntactic definitions, like LAMBDA in Part 1 of the tutorial,<br>
if you prefer those.</p>
<p><code>krun</code> some programs, such as those provided in Lesson 1 of the LAMBDA<br>
tutorial (Part 1).  Note the closures, both as results in the <code>&lt;k/&gt;</code> cell,<br>
and as values in the store.  Also, since variables are not values anymore,<br>
expressions that contain free variables may get stuck with one of those on<br>
top of their computation.  See, for example, <code>free-variable-capture.lambda</code>,<br>
which gets stuck on <code>z</code>, because <code>z</code> is free, so it cannot evaluate it.<br>
If you want, you can go ahead and manually provide a configuration with<br>
<code>z</code> mapped to some location in the environment and that location mapped to<br>
some value in the store, and then you can also execute this program.  The<br>
program <code>omega.lambda</code> should still loop.</p>
<p>Although we completely changed the definitional style of LAMBDA, the semantics<br>
of the other constructs do not need to change, as seen in the next lesson.</p>
<p>Go to <a href="#ebook-heading-lesson-3-lambda-reusing-existing-semantics">Lesson 3, LAMBDA++: Reusing Existing Semantics</a>.</p>
<p><a href="https://youtu.be/BYhQQW6swfc">MOVIE (out of date) [8&apos;02&quot;]</a></p>
</div></div><div id="ebook-heading-lesson-3-lambda-reusing-existing-semantics" ebook-toc-level-4 heading="Lesson 3, LAMBDA++: Reusing Existing Semantics"><div><h1 class="mume-header" id="reusing-existing-semantics">Reusing Existing Semantics</h1>

<p>In this lesson we will learn that, in some cases, we can reuse existing<br>
semantics of language features without having to make any change!</p>
<p>Although the definitional style of the basic LAMBDA language changed quite<br>
radically in our previous lesson, compared to its original definition in<br>
Part 1 of the tutorial, we fortunately can reuse a large portion of the<br>
previous definition.  For example, let us just cut-and-paste the rest of the<br>
definition from Lesson 7 in Part 1 of the tutorial.</p>
<p>Let us <code>kompile</code> and <code>krun</code> all the remaining programs from Part 1 of the<br>
tutorial.  Everything should work fine, although the store contains lots of<br>
garbage.  Garbage collection is an interesting topic, but we do not do it<br>
here.  Nevertheless, much of this garbage is caused by the intricate use of<br>
the fixed-point combinator to define recursion.  In a future lesson in this<br>
tutorial we will see that a different, environment-based definition of<br>
fixed-points will allocate much less memory.</p>
<p>One interesting question at this stage is: how do we know when we can reuse<br>
an existing semantics of a language feature?  Well, I&apos;m afraid the answer is:<br>
we don&apos;t.  In the next lesson we will learn how reuse can fail for quite subtle<br>
reasons, which are impossible to detect statically (and some non-experts may<br>
fail to even detect them at all).</p>
<p>Go to <a href="#ebook-heading-lesson-4-lambda-do-not-reuse-blindly">Lesson 4, LAMBDA++: Do Not Reuse Blindly!</a>.</p>
<p><a href="https://youtu.be/tW4KRdgBIGo">MOVIE (out of date) [3&apos;21&quot;]</a></p>
</div></div><div id="ebook-heading-lesson-4-lambda-do-not-reuse-blindly" ebook-toc-level-4 heading="Lesson 4, LAMBDA++: Do Not Reuse Blindly!"><div><h1 class="mume-header" id="do-not-reuse-blindly">Do Not Reuse Blindly!</h1>

<p>It may be tempting to base your decision to reuse an existing semantics of<br>
a language feature solely on syntactic considerations; for example, to reuse<br>
whenever the parser does not complain.  As seen in this lesson, this could<br>
be quite risky.</p>
<p>Let&apos;s try (and fail) to reuse the definition of <code>callcc</code> from Lesson 1:</p>
<pre class="language-text">syntax Exp ::= &quot;callcc&quot; Exp  [strict]
syntax Val ::= cc(K)
rule &lt;k&gt; (callcc V:Val =&gt; V cc(K)) ~&gt; K &lt;/k&gt;
rule &lt;k&gt; cc(K) V ~&gt; _ =&gt;  V ~&gt; K &lt;/k&gt;
</pre>
<p>The <code>callcc</code> examples that we tried in Lesson 1 work, so it may look it works.</p>
<p>However, the problem is that <code>cc(K)</code> should also include an environment,<br>
and that environment should also be restored when <code>cc(K)</code> is invoked.<br>
Let&apos;s try to illustrate this bug with <code>callcc-env1.lambda</code></p>
<pre class="language-text">let x = 1 in
  ((callcc lambda k . (let x = 2 in (k x))) + x)
</pre>
<p>where the second argument of <code>+</code>, <code>x</code>, should be bound to the top <code>x</code>, which<br>
is 1.  However, since <code>callcc</code> does not restore the environment, that <code>x</code><br>
should be looked up in the wrong, callcc-inner environment, so we should see<br>
the overall result 4.</p>
<p>Hm, we get the right result, 3 ... (Note: you may get 4, depending on<br>
your version of K and platform; but both 3 and 4 are possible results, as<br>
explained below and seen in the tests).  How can we get 3?  Well, recall that<br>
<code>+</code> is strict, which means that it can evaluate its arguments in any order.<br>
It just happened that in the execution that took place above its second<br>
argument was evaluated first, to 1, and then the <code>callcc</code> was evaluated, but<br>
its <code>cc</code> value K had already included the 1 instead of <code>x</code> ...  In Part 4 of<br>
the tutorial we will see how to explore all the non-deterministic behaviors of<br>
a program; we could use that feature of K to debug semantics, too.<br>
For example, in this case, we could search for all behaviors of this program<br>
and we would indeed get two possible value results: 3 and 4.</p>
<p>One may think that the problem is the non-deterministic evaluation order<br>
of <code>+</code>, and thus that all we need to do is to enforce a deterministic order<br>
in which the arguments of + are evaluated.  Let us follow this path to<br>
see what happens.  There are two simple ways to make the evaluation order<br>
of <code>+</code>&apos;s arguments deterministic.  One is to make <code>+</code> <code>seqstrict</code> in the<br>
semantics, to enforce its evaluation from left-to-right.  Do it and then<br>
run the program above again; you should get only one behavior for the<br>
program above, 4, which therefore shows that copying-and-pasting our old<br>
definition of <code>callcc</code> was incorrect.  However, as seen shortly, that only<br>
fixed the problem for the particular example above, but not in general.<br>
Another conventional approach to enforce the desired evaluation order is to<br>
modify the program to enforce the left-to-right evaluation order using let<br>
binders, as we do in <code>callcc-env2.lambda</code>:</p>
<pre class="language-text">let x = 1 in
  let a = callcc lambda k . (let x = 2 in (k x)) in
    let b = x in
      (a + b)
</pre>
<p>With your installation of K you may get the &quot;expected&quot; result 4 when you<br>
execute this program, so it may look like our non-deterministic problem is<br>
fixed.  Unfortunately, it is not.  Using the K tool to search for all the<br>
behaviors in the program above reveals that the final result 3 is still<br>
possible.  Moreover, both the 3 and the 4 behaviors are possible regardless<br>
of whether <code>+</code> is declared to be <code>seqstrict</code> or just <code>strict</code>.  How is that<br>
possible?  The problem is now the non-deterministic evaluation strategy of<br>
the function application construct.  Indeed, recall that the semantics of<br>
the let-in construct is defined by desugaring to lambda application:</p>
<pre class="language-text">rule let X = E in E&apos; =&gt; (lambda X . E&apos;) E
</pre>
<p>With this, the program above eventually reduces to</p>
<pre class="language-text">(lambda a . ((lambda b . a + b) x))
(callcc lambda k . (let x = 2 in (k x)))
</pre>
<p>in an environment where <code>x</code> is 1.  If the first expression evaluates first,<br>
then it does so to a closure in which <code>x</code> is bound to a location holding 1,<br>
so when applied later on to the <code>x</code> inside the argument of <code>callcc</code> (which is<br>
2), it will correctly lookup <code>x</code> in its enclosed environment and thus the<br>
program will evaluate to 3.  On the other hand, if the second expression<br>
evaluates first, then the <code>cc</code> value will freeze the first expression as is,<br>
breaking the relationship between its <code>x</code> and the current environment in which<br>
it is bound to 1, being inadvertently captured by the environment of the<br>
let-in construct inside the <code>callcc</code> and thus making the entire expression<br>
evaluate to 4.</p>
<p>So the morale is: Do not reuse blindly.  <em>Think!</em></p>
<p>In the next lesson we fix the environment-based semantics of <code>callcc</code> by having<br>
<code>cc</code> also wrap an environment, besides a computation.  We will also give a more<br>
direct semantics to recursion, based on environments instead of fixed-point<br>
combinators.</p>
<p>Go to <a href="#ebook-heading-lesson-5-lambda-more-semantic-computation-items">Lesson 5, LAMBDA++: More Semantic Computation Items</a>.</p>
<p><a href="https://youtu.be/OXvtklaSaSQ">MOVIE (out of date) [3&apos;37&quot;]</a></p>
</div></div><div id="ebook-heading-lesson-5-lambda-more-semantic-computation-items" ebook-toc-level-4 heading="Lesson 5, LAMBDA++: More Semantic Computation Items"><div><h1 class="mume-header" id="more-semantic-computation-items">More Semantic Computation Items</h1>

<p>In this lesson we see more examples of semantic (i.e., non-syntactic)<br>
computational items, and how useful they can be.  Specifically, we fix the<br>
environment-based definition of <code>callcc</code> and give an environment-based<br>
definition of the <code>mu</code> construct for recursion.</p>
<p>Let us first fix <code>callcc</code>.  As discussed in Lesson 4, the problem that we<br>
noticed there was that we only recovered the computation, but not the<br>
environment, when a value was passed to the current continuation.  This is<br>
quite easy to fix: we modify <code>cc</code> to take both an environment and a<br>
computation, and its rules to take a snapshot of the current environment with<br>
it, and to recover it at invocation time:</p>
<pre class="language-text">syntax Val ::= cc(Map,K)
rule &lt;k&gt; (callcc V:Val =&gt; V cc(Rho,K)) ~&gt; K &lt;/k&gt; &lt;env&gt; Rho &lt;/env&gt;
rule &lt;k&gt; cc(Rho,K) V:Val ~&gt; _ =&gt;  V ~&gt; K &lt;/k&gt; &lt;env&gt; _ =&gt; Rho &lt;/env&gt;
</pre>
<p>Let us kompile and make sure it works with the <code>callcc-env2.lambda</code> program,<br>
which should evaluate to 3, not to 4.</p>
<p>Note that the <code>cc</code> value, which can be used as a computation item in the <code>&lt;k/&gt;</code><br>
cell, is now quite semantic in nature, pretty much the same as the closures.</p>
<p>Let us next add one more closure-like semantic computational item, for <code>mu</code>.<br>
But before that, let us reuse the semantics of <code>letrec</code> in terms of <code>mu</code> that<br>
was defined in Lesson 8 of Part 1 of the tutorial on LAMBDA:</p>
<pre class="language-text">syntax Exp ::= &quot;letrec&quot; Id Id &quot;=&quot; Exp &quot;in&quot; Exp [macro]
             | &quot;mu&quot; Id &quot;.&quot; Exp                 [latex(\mu{#1}.{#2})]
rule letrec F:Id X = E in E&apos; =&gt; let F = mu F . lambda X . E in E&apos;
</pre>
<p>We removed the <code>binder</code> annotation of <code>mu</code>, because it is not necessary<br>
anymore (since we do not work with substitutions anymore).</p>
<p>To save the number of locations needed to evaluate <code>mu X . E</code>, let us replace<br>
it with a special closure which already binds <code>X</code> to a fresh location holding<br>
the closure itself:</p>
<pre class="language-text">syntax Exp ::= muclosure(Map,Exp)

rule &lt;k&gt; mu X . E =&gt; muclosure(Rho[X &lt;- !N], E) ...&lt;/k&gt;
     &lt;env&gt; Rho &lt;/env&gt;
     &lt;store&gt;... .Map =&gt; (!N:Int |-&gt; muclosure(Rho[X &lt;- !N], E)) ...&lt;/store&gt;
</pre>
<p>Since each time <code>mu X . E</code> is encountered during the evaluation it needs to<br>
evaluate <code>E</code>, we conclude that <code>muclosure</code> cannot be a value.  We can declare<br>
it as either an expression or as a computation.  Let&apos;s go with the former.</p>
<p>Finally, here is the rule unrolling the <code>muclosure</code>:</p>
<p>rule <k> muclosure(Rho,E) =&gt; E ~&gt; Rho&apos; ...</k><br>
<env> Rho&apos; =&gt; Rho </env></p>
<p>Note that the current environment <code>Rho&apos;</code> needs to be saved before and<br>
restored after <code>E</code> is executed, because the fixed point may be invoked<br>
from a context with a completely different environment from the one<br>
in which <code>mu X . E</code> was declared.</p>
<p>We are done.  Let us now <code>kompile</code> and <code>krun</code> <code>factorial-letrec.lambda</code> from<br>
Lesson 7 in Part 1 of the tutorial on LAMBDA.  Recall that in the previous<br>
lesson this program generated a lot of garbage into the store, due to the<br>
need to allocate space for the arguments of all those lambda abstractions<br>
needed to run the fixed-point combinator.  Now we need much fewer locations,<br>
essentially only locations for the argument of the factorial function, one at<br>
each recursive call.  Anyway, much better than before.</p>
<p>In the next lesson we wrap up the environment definition of LAMBDA++ and<br>
generate its documentation.</p>
<p>Go to <a href="#ebook-heading-lesson-6-lambda-wrapping-up-and-documenting-lambda-environment-based">Lesson 6, LAMBDA++: Wrapping Up and Documenting LAMBDA++</a>.</p>
<p><a href="https://youtu.be/dP3FW0kZN6k">MOVIE (out of date) [5&apos;19&quot;]</a></p>
</div></div><div id="ebook-heading-lesson-6-lambda-wrapping-up-and-documenting-lambda-environment-based" ebook-toc-level-4 heading="Lesson 6, LAMBDA++: Wrapping Up and Documenting LAMBDA++ (environment-based)"><div><h1 class="mume-header" id="wrapping-up-and-documenting-lambda">Wrapping Up and Documenting LAMBDA++</h1>

<p>In this lesson we wrap up and nicely document LAMBDA++.  In doing so, we also<br>
take the freedom to reorganize the semantics a bit, to make it look better.</p>
<p>See the <code>lambda.k</code> file, which is self-explanatory.</p>
<p>Part 3 of the tutorial is now complete.  Part 4 will teach you more features<br>
of the K framework, in particular how to exhaustively explore the behaviors<br>
of non-deterministic or concurrent programs.</p>
<p><a href="https://youtu.be/xfvx6Ss5PcA">MOVIE (out of date) [6&apos;23&quot;]</a></p>
</div></div><div id="ebook-heading-part-4-defining-imp" ebook-toc-level-3 heading="Part 4: Defining IMP++"><div><h1 class="mume-header" id="part-4-defining-imp">Part 4: Defining IMP++</h1>

<p>IMP++ extends IMP, which was discussed in Part 2 of this tutorial, with several<br>
new syntactic constructs.  Also, some existing syntax is generalized, which<br>
requires non-modular changes of the existing IMP semantics.  For example,<br>
global variable declarations become local declarations and can occur<br>
anywhere a statement can occur.  In this tutorial we will learn the following:</p>
<ul>
<li>That (and how) existing syntax/semantics may change as a language evolves.</li>
<li>How to refine configurations as a language evolves.</li>
<li>How to define and use fresh elements of desired sorts.</li>
<li>How to tag syntactic constructs and rules, and how to use such tags<br>
with the <code>superheat</code>/<code>supercool</code> options of <code>kompile</code>.</li>
<li>How the <code>search</code> option of <code>krun</code> works.</li>
<li>How to stream cells holding semantic lists to the standard input/output,<br>
and thus obtain interactive interpreters for the defined languages.</li>
<li>How to delete, save and restore cell contents.</li>
<li>How to add/delete cells dynamically.</li>
<li>More details on how the configuration abstraction mechanism works.</li>
</ul>
<p>Like in the previous tutorials, this folder contains several lessons, each<br>
adding new features to IMP++.  Do them in order and make sure you completed<br>
and understood the previous tutorials.</p>
</div></div><div id="ebook-heading-lesson-1-imp-extendingchanging-an-existing-language-syntax" ebook-toc-level-4 heading="Lesson 1, IMP++: Extending/Changing an Existing Language Syntax"><div><h1 class="mume-header" id="extendingchanging-an-existing-language-syntax">Extending/Changing an Existing Language Syntax</h1>

<p>Here we learn how to extend the syntax of an existing language, both with<br>
new syntactic constructs and with more general uses of existing constructs.<br>
The latter, in particular, requires changes of the existing semantics.</p>
<p>Consider the IMP language, as defined in Lesson 4 of Part 2 of the tutorial.</p>
<p>Let us first add the new syntactic constructs, with their precedences:</p>
<ul>
<li>variable increment, <code>++</code>, which increments an integer variable and<br>
evaluates to the new value;</li>
<li><code>read</code>, which reads and evaluates to a new integer from the input buffer;</li>
<li><code>print</code>, which takes a comma-separated list of arithmetic expressions and<br>
evaluates and prints each of them in order, from left to right, to the<br>
output buffer; we therefore define a new list syntactic category, <code>AExps</code>,<br>
which we pass as an argument to <code>print</code>; note we do not want to declare<br>
<code>print</code> to be <code>strict</code>, because we do not want to first evaluate the<br>
arguments and then print them (for example, if the second argument performs<br>
an illegal operation, say division by zero, we still want to print the first<br>
argument); we also go ahead and add strings as arithmetic expressions,<br>
because we intend print to also take strings, in order to print nice<br>
messages to the user;</li>
<li><code>halt</code>, which abruptly terminates the program; and</li>
<li><code>spawn</code>, which takes a statement and creates a new concurrent thread<br>
executing it and sharing its environment with the parent thread.</li>
</ul>
<p>Also, we want to allow local variable declarations, which can appear anywhere<br>
a statement can appear. Their scope ranges from the place they are defined<br>
until the end of the current block, and they can shadow previous declarations,<br>
both inside and outside the current block. The simplest way to define the<br>
syntax of the new variable declarations is as ordinary statements, at the same<br>
time removing the previous <code>Pgm</code> syntactic category and its construct.<br>
Programs are now just statements.</p>
<p>We are now done with adding the new syntax and modifying the old one.<br>
Note that the old syntax was modified in a way which makes the previous IMP<br>
programs still parse, but this time as statements. Let us then modify<br>
the configuration variable <code>$PGM</code> to have the sort <code>Stmt</code> instead of <code>Pgm</code>,<br>
and let us try to run the old IMP programs, for example <code>sum.imp</code>.</p>
<p>Note that they actually get stuck with the <em>global</em> declaration on the top<br>
of their computations. This is because variable declarations are now treated<br>
like any statements, in particular, the sequential composition rule applies.<br>
This makes the old IMP rule for global variable declarations not match anymore.<br>
We can easily fix it by replacing the anonymous variable <code>_</code>, which matched<br>
the program&apos;s statement that now turned into the remaining computation in<br>
the <code>&lt;k/&gt;</code> cell, with the cell frame variable <code>...</code>, which matches the<br>
remaining computation. Similarly, we have to change the rule for the case<br>
where there are no variables left to declare into one that dissolves itself.</p>
<p>We can now run all the previous IMP programs, in spite of the fact that<br>
our IMP++ semantics is incomplete and, more interestingly, in spite of the<br>
fact that our current semantics of blocks is incorrect in what regards the<br>
semantics of local variable declarations (note that the old IMP programs do<br>
not declare block-local variables, which is why they still run correctly).</p>
<p>Let us also write some proper IMP++ programs, which we would like to execute<br>
once we give semantics to the new constructs.</p>
<p><code>div.imp</code> is a program manifesting non-deterministic behaviors due to the<br>
desired non-deterministic evaluation strategy of division and the fact that<br>
expressions will have side effects once we add variable increment. We will<br>
be able to see all the different behaviors of this program. Challenge: can<br>
you identify the behavior where the program performs a division-by-zero?</p>
<p>If we run <code>div.imp</code> now, it will get stuck with the variable increment<br>
construct on top of the computation cell. Once we give it a semantics,<br>
<code>div.imp</code> will execute completely (all the other constructs in <code>div.imp</code><br>
already have their semantics defined as part of IMP).</p>
<p>Note that some people prefer to define all their semantics in a <em>by need</em><br>
style, that is, they first write and parse lots of programs, and then they<br>
add semantics to each language construct on which any of the programs gets<br>
stuck, and so on and so forth until they can run all the programs.</p>
<p><code>io.imp</code> is a program which exercises the input/output capabilities of the<br>
language: reads two integers and prints three strings and an integer.<br>
Note that the variable declaration is not the first statement anymore.</p>
<p><code>sum-io.imp</code> is an interactive variant of the sum program.</p>
<p><code>spawn.imp</code> is a program which dynamically creates two threads that interact<br>
with the main thread via the shared variable x. Lots of behaviors will be<br>
seen here once we give spawn the right semantics.</p>
<p>Finally, <code>locals.imp</code> tests whether variable shadowing/unshadowing works well.</p>
<p>In the next lesson we will prepare the configuration for the new constructs,<br>
and will see what it takes to adapt the semantics to the new configuration.<br>
Specifically, we will split the state cell into an environment cell and a<br>
store cell, like in LAMBDA++ in Part 3 of the tutorial.</p>
<p>Go to <a href="#ebook-heading-lesson-2-imp-configuration-refinement-freshness">Lesson 2, IMP++: Configuration Refinement; Freshness</a>.</p>
<p><a href="https://youtu.be/hWqJ8k9NNp8">MOVIE (out of date) [07&apos;47&quot;]</a></p>
</div></div><div id="ebook-heading-lesson-2-imp-configuration-refinement-freshness" ebook-toc-level-4 heading="Lesson 2, IMP++: Configuration Refinement; Freshness"><div><h1 class="mume-header" id="configuration-refinement-freshness">Configuration Refinement; Freshness</h1>

<p>To prepare for the semantics of threads and local variables, in this lesson we<br>
split the state cell into an environment and a store. The environment and<br>
the store will be similar to those in the definition of LAMBDA++ in Part<br>
3 of the Tutorial. This configuration refinement will require us to change<br>
some of IMP&apos;s rules, namely those that used the state.</p>
<p>To split the state map, which binds program variables to values, into an<br>
environment mapping program variables to locations and a store mapping<br>
locations to values, we replace in the configuration declaration the cell</p>
<pre class="language-text">&lt;state color=&quot;red&quot;&gt; .Map &lt;/state&gt;
</pre>
<p>with two cells</p>
<pre class="language-text">&lt;env color=&quot;LightSkyBlue&quot;&gt; .Map &lt;/env&gt;
&lt;store color=&quot;red&quot;&gt; .Map &lt;/store&gt;
</pre>
<p>Structurally speaking, this split of a cell into other cells is a major<br>
semantic change, which, unfortunately, requires us to revisit the existing<br>
rules that used the state cell. One could, of course, argue that we could<br>
have avoided this problem if we had followed from the very beginning the<br>
good-practice style to work with an environment and a store, instead of a<br>
monolithic state. While that is a valid argument, highlighting the fact that<br>
modularity is not only a feature of the framework alone, but one should also<br>
follow good practices to achieve it, it is also true that if all we wanted<br>
in Part 2 of the tutorial was to define IMP as is, then the split of the state<br>
in an environment and a store is unnecessary and not really justified.</p>
<p>The first rule which used a state cell is the lookup rule:</p>
<pre class="language-text">rule &lt;k&gt; X:Id =&gt; I ...&lt;/k&gt; &lt;state&gt;... X |-&gt; I ...&lt;/state&gt;
</pre>
<p>We modify it as follows:</p>
<pre class="language-text">rule &lt;k&gt; X:Id =&gt; I ...&lt;/k&gt;
     &lt;env&gt;... X |-&gt; N ...&lt;/env&gt;
     &lt;store&gt;... N |-&gt; I ...&lt;/store&gt;
</pre>
<p>So we first match the location <code>N</code> of <code>X</code> in the environment, then the value<br>
<code>I</code> at location <code>N</code> in the store, and finally we rewrite <code>X</code> to <code>I</code> into the<br>
computation. This rule also shows an instance of a more complex<br>
multiset matching, where two variables (<code>X</code> and <code>N</code>) are matched each twice.</p>
<p>The assignment rule is modified quite similarly.</p>
<p>The variable declaration rule is trickier, though, because we need to allocate<br>
a fresh location in the store and bind the newly declared variable to it.<br>
This is quite similar to the way we allocated space for variables in<br>
the environment-based definition of LAMBDA++ in Part 3 of the tutorial.</p>
<pre class="language-text">rule &lt;k&gt; int (X,Xs =&gt; Xs); ...&lt;/k&gt;
     &lt;env&gt; Rho =&gt; Rho[X &lt;- !N:Int] &lt;/env&gt;
     &lt;store&gt;... .Map =&gt; !N |-&gt; 0 ...&lt;/store&gt;
</pre>
<p>Note the use of the fresh (<code>!N</code>) variable notation above. Recall from<br>
the LAMBDA++ tutorial that each time the rule with fresh (<code>!</code>) variables is<br>
applied, fresh elements of corresponding sorts are generated for the fresh<br>
variables, distinct from all the previously generated elements; also, we<br>
cannot and should not assume anything about the particular element that is<br>
being generated, except that it is different from the previous ones.</p>
<p><code>kompile</code> and <code>krun</code> <code>sum.imp</code> to see how the fresh locations have been<br>
generated and used. There were two fresh locations needed, for the two<br>
variables. Note also that a cell holding the counter has been added to the<br>
configuration.</p>
<p>In the next lesson we will add the semantics of variable increment, and see<br>
how that yields non-deterministic behaviors in programs and how to explore<br>
those behaviors using the K tool.</p>
<p>Go to <a href="#ebook-heading-lesson-3-imp-tagging-superheatsupercool-kompilation-options">Lesson 3, IMP++: Tagging; Superheat/Supercool Kompilation Options</a>.</p>
<p><a href="https://youtu.be/f-qrqs8cMcU">MOVIE (out of date) [04&apos;06&quot;]</a></p>
</div></div><div id="ebook-heading-lesson-3-imp-tagging-superheatsupercool-kompilation-options" ebook-toc-level-4 heading="Lesson 3, IMP++: Tagging; Superheat/Supercool Kompilation Options"><div><h1 class="mume-header" id="variable-increment-search">Variable increment; Search</h1>

<p>In this lesson we add the semantics of variable increment. We also learn<br>
how to instruct the <code>kompile</code> tool to instrument the language model for<br>
exhaustive analysis.</p>
<p>The variable increment rule is self-explanatory:</p>
<pre class="language-text">rule &lt;k&gt; ++X =&gt; I +Int 1 ...&lt;/k&gt;
     &lt;env&gt;... X |-&gt; N ...&lt;/env&gt;
     &lt;store&gt;... N |-&gt; (I =&gt; I +Int 1) ...&lt;/store&gt;
</pre>
<p>We can now run programs like our <code>div.imp</code> program introduced in Lesson 1.<br>
Do it.</p>
<p>The addition of increment makes the evaluation of expressions have side<br>
effects. That, in combination with the non-determinism allowed by the<br>
strictness attributes in how expression constructs evaluate their<br>
arguments, makes expressions in particular and programs in general have<br>
non-deterministic behaviors. One possible execution of the <code>div.imp</code> program<br>
assigns <code>1</code> to <code>y</code>&apos;s location, for example, but this program manifests several<br>
other behaviors, too.</p>
<p>To see all the (final-state) behaviors that a program can have, you can kompile<br>
the semantics with <code>--enable-search</code> and call the <code>krun</code> tool with the option<br>
<code>--search</code>. For example:</p>
<pre class="language-text">krun div.imp --search
</pre>
<p>In the next lesson we add input/output to our language and learn how to<br>
generate a model of it which behaves like an interactive interpreter!</p>
<p>Go to <a href="#ebook-heading-lesson-4-imp-semantic-lists-inputoutput-streaming">Lesson 4, IMP++: Semantic Lists; Input/Output Streaming</a>.</p>
<p><a href="https://youtu.be/uwCUfWt7n-o">MOVIE (out of date) [06&apos;56&quot;]</a></p>
</div></div><div id="ebook-heading-lesson-4-imp-semantic-lists-inputoutput-streaming" ebook-toc-level-4 heading="Lesson 4, IMP++: Semantic Lists; Input/Output Streaming"><div><h1 class="mume-header" id="semantic-lists-inputoutput-streaming">Semantic Lists; Input/Output Streaming</h1>

<p>In this lesson we add semantics to the <code>read</code> and <code>print</code> IMP++ constructs.<br>
In doing so, we also learn how to use semantic lists and how to connect<br>
cells holding semantic lists to the standard input and standard output.<br>
This allows us to turn the K semantics into an interactive interpreter.</p>
<p>We start by adding two new cells to the configuration,</p>
<pre class="language-text">&lt;in color=&quot;magenta&quot;&gt; .List &lt;/in&gt;
&lt;out color=&quot;Orchid&quot;&gt; .List &lt;/out&gt;
</pre>
<p>each holding a semantic list, initially empty. Semantic lists are<br>
space-separated sequences of items, each item being a term of the form<br>
<code>ListItem(t)</code>, where <code>t</code> is a term of sort <code>K</code>. Recall that the semantic maps,<br>
which we use for states, environments, stores, etc., are sets of pairs<br>
<code>t1 |-&gt; t2</code>, where <code>t1</code> and <code>t2</code> are terms of sort K. The <code>ListItem</code> wrapper<br>
is currently needed, to avoid parsing ambiguities.</p>
<p>Since we want the <code>print</code> statement to also print strings, we need to tell<br>
K that strings are results. To make it more interesting, let us also overload<br>
the <code>+</code> symbol on arithmetic expressions to also take strings and, as a<br>
result, to concatenate them. Since <code>+</code> is already strict, we only need to add<br>
a rule reducing the IMP addition of strings to the builtin operation <code>+String</code><br>
which concatenates two strings.</p>
<p>The semantics of <code>read</code> is immediate: read and consumes the first integer item<br>
from the <code>&lt;in/&gt;</code> cell; note that our read only reads integer values (it gets<br>
stuck if the first item in the <code>&lt;in/&gt;</code> cell is not an integer).</p>
<p>The semantics of <code>print</code> is a bit trickier. Recall that <code>print</code> takes an<br>
arbitrary number of arithmetic expression arguments, and evaluates and outputs<br>
each of them in order, from left to right. For example,<br>
<code>print(&quot;Hello&quot;, 3/0, &quot;Bye&quot;);</code> outputs &quot;Hello&quot; and then gets stuck on the<br>
illegal division by zero operation. In other words, we do not want it to<br>
first evaluate all its arguments and then print them, because that would miss<br>
outputting potentially valuable information. So the first step is to evaluate<br>
the first argument of <code>print</code>. In some sense, what we&apos;d like to say is that<br>
<code>print</code> has the evaluation strategy <code>strict(1)</code>. However, strictness<br>
attributes only work with individual language constructs, while what we need<br>
is an evaluation strategy that involves <em>two</em> constructs: <code>print</code> and the list<br>
(comma) construct of <code>AExps</code>. If we naively associate <code>print</code> the <code>strict(1)</code><br>
evaluation strategy then its first and unique argument, an <code>AExps</code> list, will<br>
be scheduled for evaluation and the execution will get stuck because we have<br>
no rules for evaluating <code>AExps</code> terms. If we make the list construct of<br>
<code>AExps</code> <code>strict</code> then we get the wrong semantics for <code>print</code> which first<br>
evaluates all its arguments and then outputs them. The correct way to<br>
tell K that <code>print</code> should evaluate only its first argument is by using a<br>
context declaration:</p>
<pre class="language-text">context print(HOLE:AExp, _);
</pre>
<p>Note the <code>HOLE</code> of sort <code>AExp</code> above. Contexts allow us to define finer-grain<br>
evaluation strategies than the strictness attributes, involving potentially<br>
more than one language construct, like above. The <code>HOLE</code> indicates the<br>
argument which is requested to be evaluated. For example, the <code>strict</code><br>
attribute of division corresponds to two contexts:</p>
<pre class="language-text">context HOLE / _
context _ / HOLE
</pre>
<p>In their full generality, contexts can be any terms with precisely one<br>
occurrence of a <code>HOLE</code>, and with arbitrary side conditions on any variables<br>
occurring in the context term as well as on the <code>HOLE</code>. See Part 6 of the<br>
tutorial for more examples.</p>
<p>Once evaluated, the first argument of <code>print</code> is expected to become either an<br>
integer or a string. Since we want to print both integers and string values,<br>
to avoid writing two rules, one for each type of value, we instead add a new<br>
syntactic category, <code>Printable</code>, which is the union of integers and strings.</p>
<p>Let us <code>kompile</code> and <code>krun</code> the <code>io.imp</code> program discussed in Lesson 1. As<br>
expected, it gets stuck with a read construct on top of the computation and<br>
with an empty <code>&lt;in/&gt;</code> cell. To run it, we need to provide some items in the<br>
<code>&lt;in/&gt;</code> cell, so that the rule of read can match. Let us add</p>
<pre class="language-text">&lt;in&gt; ListItem(3) ListItem(5) ListItem(7) &lt;/in&gt;
</pre>
<p>Now, if we <code>krun</code> <code>io.imp</code>, we can see that its execution completes normally<br>
(the <code>&lt;k/&gt;</code> cell is empty), that the first two items have been removed by the<br>
two read constructs from the <code>&lt;in/&gt;</code> cell, and that the desired strings and<br>
numbers have been placed into the <code>&lt;out/&gt;</code> cell.</p>
<p>Cells holding semantic lists can be connected to the standard input and<br>
standard output buffers, and <code>krun</code> knows how to handle these appropriately.<br>
Let us connect the <code>&lt;in/&gt;</code> cell to the standard input using the cell attribute<br>
<code>stream=&quot;stdin&quot;</code> and the <code>&lt;out/&gt;</code> cell to the standard output with the<br>
attribute <code>stream=&quot;sdtout&quot;</code>. A cell connected to the standard input will<br>
take its items from the standard input and block the rewriting process when<br>
an input is needed until an item is available in the standard input buffer.<br>
A cell connected to the standard output buffer will send all its items, in<br>
order, to the standard output.</p>
<p>Let us <code>kompile</code> and <code>krun</code> <code>io.imp</code> again. It prints the message and then<br>
waits for your input numbers. Type in two numbers, then press <code>&lt;Enter&gt;</code>.<br>
A message with their sum is then printed, followed by the final configuration.<br>
If you do not want to see the final configuration, and thus obtain a realistic<br>
interpreter for our language, then call <code>krun</code> with the option <code>--output none</code>:</p>
<pre class="language-text">krun io.imp --output none
</pre>
<p>Let us now <code>krun</code> our interactive sum program, which continuously reads numbers<br>
from the console and prints the sum of numbers up to them:</p>
<pre class="language-text">krun sum-io.imp
</pre>
<p>Try a few numbers, then <code>0</code>. Note that the program terminated, but with junk<br>
in the <code>&lt;k/&gt;</code> cell, essentially with a <code>halt</code> statement on its top. Of course,<br>
because <code>halt</code> has been reached and it has no semantics yet.</p>
<p>In the next lesson we give the semantics of <code>halt</code> and also fix the semantics<br>
of blocks with local variable declarations.</p>
<p>Go to <a href="#ebook-heading-lesson-5-imp-deleting-saving-and-restoring-cell-contents">Lesson 5, IMP++: Deleting, Saving and Restoring Cell Contents</a>.</p>
<p><a href="https://youtu.be/a0qxV1GFR5s">MOVIE (out of date) [05&apos;21&quot;]</a></p>
</div></div><div id="ebook-heading-lesson-5-imp-deleting-saving-and-restoring-cell-contents" ebook-toc-level-4 heading="Lesson 5, IMP++: Deleting, Saving and Restoring Cell Contents"><div><h1 class="mume-header" id="deleting-saving-and-restoring-cell-contents">Deleting, Saving and Restoring Cell Contents</h1>

<p>In this lesson we will see how easily we can delete, save and/or restore<br>
contents of cells in order to achieve the desired semantics of language<br>
constructs that involve abrupt changes of control or environments. We have<br>
seen similar or related K features in the LAMBDA++ language in Part 3 of the<br>
tutorial.</p>
<p>Let us start by adding semantics to the <code>halt</code> statement. As its name says,<br>
what we want is to abruptly terminate the execution of the program. Moreover,<br>
we want the program configuration to look as if the program terminated<br>
normally, with an empty computation cell. The simplest way to achieve that is<br>
to simply empty the computation cell when <code>halt</code> is encountered:</p>
<pre class="language-text">rule &lt;k&gt; halt; ~&gt; _ =&gt; . &lt;/k&gt;
</pre>
<p>It is important to mention the entire <code>&lt;k/&gt;</code> cell here, with both its membranes<br>
closed, to make sure that its entire contents is discarded. Note the<br>
anonymous variable, which matches the rest of the computation.</p>
<p><code>kompile</code> and <code>krun</code> <code>sum-io.imp</code>. Note that unlike in Lesson 4, the program<br>
terminates with an empty computation cell now.</p>
<p>As mentioned earlier, the semantics of blocks that was inherited from IMP is<br>
wrong. Program <code>locals.imp</code> shows it very clearly: the environments are not<br>
correctly restored at block exits. One way to fix the problem is to take<br>
a snapshot of the current environment when a block is entered and save it<br>
somewhere, and then to restore it when the block is left. There are many<br>
ways to do this, which you can explore on your own: for example you can add<br>
a new list cell for this task where to push/pop the environment snapshots in<br>
a stack style; or you can use the existing environment cell for this purpose,<br>
but then you need to change the variable access rules to search through the<br>
stacked environments for the variable.</p>
<p>My preferred solution is to follow a style similar to how we saved/restored<br>
LAMBDA++ environments in Part 3 of the Tutorial, namely to use the already<br>
existing <code>&lt;k/&gt;</code> cell for such operations. More specifically, we place a<br>
<em>reminder</em> item in the computation whenever we need to take a snapshot of<br>
some cell contents; the item simply consists of the entire contents of the cell.<br>
Then, when the reminder item is reached, we restore the contents of the cell:</p>
<pre class="language-text">rule &lt;k&gt; {S} =&gt; S ~&gt; Rho ...&lt;/k&gt; &lt;env&gt; Rho &lt;/env&gt;
</pre>
<p>The only thing left now is to give the definition of environment restore:</p>
<pre class="language-text">rule &lt;k&gt; Rho =&gt; . ...&lt;/k&gt; &lt;env&gt; _ =&gt; Rho &lt;/env&gt;
</pre>
<p>Done. <code>kompile</code> and <code>krun</code> <code>locals.imp</code>. Everything should work correctly now.<br>
Note that the rule above is different from the one we had for LAMBDA++ in<br>
Part 3 of the tutorial, in that here there is no value preceding the environment<br>
restoration item in the computation; that&apos;s because IMP++ statements,<br>
unlike LAMBDA++&apos;s expressions, evaluate to nothing (<code>.</code>).</p>
<p>In the next lesson we will give semantics to the <code>spawn S</code> construct, which<br>
dynamically creates a concurrent shared-memory thread executing statement <code>S</code>.</p>
<p>Go to <a href="#ebook-heading-lesson-6-imp-addingdeleting-cells-dynamically-configuration-abstraction-part-2">Lesson 6, IMP++: Adding/Deleting Cells Dynamically; Configuration Abstraction, Part 2</a>.</p>
<p><a href="https://youtu.be/Hr1yfcnee_c">MOVIE (out of date) [04&apos;30&quot;]</a></p>
</div></div><div id="ebook-heading-lesson-6-imp-addingdeleting-cells-dynamically-configuration-abstraction-part-2" ebook-toc-level-4 heading="Lesson 6, IMP++: Adding/Deleting Cells Dynamically; Configuration Abstraction, Part 2"><div><h1 class="mume-header" id="addingdeleting-cells-dynamically-configuration-abstraction-part-2">Adding/Deleting Cells Dynamically; Configuration Abstraction, Part 2</h1>

<p>In this lesson we add dynamic thread creation and termination to IMP, and<br>
while doing so we learn how to define and use configurations whose structure<br>
can evolve dynamically.</p>
<p>Recall that the intended semantics of <code>spawn S</code> is to spawn a new concurrent<br>
thread that executes <code>S</code>. The new thread is being passed at creation time<br>
its parent&apos;s environment, so it can share with its parent the memory<br>
locations that its parent had access to at creation time. No other locations<br>
can be shared, and no other memory sharing mechanism is available.<br>
The parent and the child threads can evolve unrestricted, in particular they<br>
can change their environments by declaring new variables or shadowing existing<br>
ones, can create other threads, and so on.</p>
<p>The above suggests that each thread should have its own computation and its<br>
own environment. This can be elegantly achieved if we group the <code>&lt;k/&gt;</code> and<br>
<code>&lt;env/&gt;</code> cells in a <code>&lt;thread/&gt;</code> cell in the configuration. Since at any given<br>
moment during the execution of a program there could be zero, one or more<br>
instances of such a <code>&lt;thread/&gt;</code> cell in the configuration, it is a good idea<br>
to declare the <code>&lt;thread/&gt;</code> cell with multiplicity <code>*</code> (i.e., zero, one or more):</p>
<pre class="language-text">&lt;thread multiplicity=&quot;*&quot; color=&quot;blue&quot;&gt;
  &lt;k color=&quot;green&quot;&gt; $PGM:Stmt &lt;/k&gt;
  &lt;env color=&quot;LightSkyBlue&quot;&gt; .Map &lt;/env&gt;
&lt;/thread&gt;
</pre>
<p>This multiplicity declaration is not necessary, but it is a good idea to do<br>
it for several reasons:</p>
<ol>
<li>it may help the configuration abstraction process,<br>
which may in turn significantly increase the compactness and modularity of<br>
your subsequent rules;</li>
<li>it may help various analysis and execution tools,<br>
for example static analyzers to give you error messages when you create cells<br>
where you should not, or K compilers to improve performance by starting<br>
actual concurrent hardware threads or processes corresponding to each cell<br>
instance; and</li>
<li>it may help you better understand and control the dynamics<br>
of your configuration, and thus your overall semantics.</li>
</ol>
<p>For good encapsulation, I also prefer to put all thread cells into one cell,<br>
<code>&lt;threads/&gt;</code>. This is technically unnecessary, though; to convince yourself<br>
that this is indeed the case, you can remove this cell once we are done with<br>
the semantics and everything will work without having to make any changes.</p>
<p>Before we continue, let us <code>kompile</code> an <code>krun</code> some programs that used to<br>
work, say <code>sum-io.imp</code>. In spite of the relatively radical configuration<br>
reorganization, those programs execute just fine! How is that possible?<br>
In particular, why do rules like the lookup and assignment still work,<br>
unchanged, in spite of the fact that the <code>&lt;k/&gt;</code> and <code>&lt;env/&gt;</code> cells are not at<br>
the same level with the <code>&lt;store/&gt;</code> cell in the configuration anymore?</p>
<p>Welcome to configuration abstraction, part 2. Recall that the role of<br>
configuration abstraction is to allow you to only write the relevant<br>
information in each rule, and have the compiler fill-in the obvious and boring<br>
details. According to the configuration that we declared for our new<br>
language, there is only one reasonable way to complete rules like the lookup,<br>
namely to place the <code>&lt;k/&gt;</code> and <code>&lt;/env&gt;</code> cells inside a <code>&lt;thread/&gt;</code> cell,<br>
inside a <code>&lt;threads/&gt;</code> cell:</p>
<pre class="language-text">rule &lt;threads&gt;...
       &lt;thread&gt;...
         &lt;k&gt; X:Id =&gt; I ...&lt;/k&gt;
         &lt;env&gt;... X |-&gt; N ...&lt;/env&gt;
       ...&lt;/thread&gt;
     ...&lt;threads/&gt;
     &lt;store&gt;... N |-&gt; I ...&lt;/store&gt;  [lookup]
</pre>
<p>This is the most direct, compact and local way to complete the configuration<br>
context of the lookup rule. If for some reason you wanted here to match the<br>
<code>&lt;k/&gt;</code> cell of one thread and the <code>&lt;env/&gt;</code> cell of another thread, then you<br>
would need to explicitly tell K so, by mentioning the two thread cells,<br>
for example:</p>
<pre class="language-text">rule &lt;thread&gt;...
         &lt;k&gt; X:Id =&gt; I ...&lt;/k&gt;
     ...&lt;/thread&gt;
     &lt;thread&gt;...
         &lt;env&gt;... X |-&gt; N ...&lt;/env&gt;
     ...&lt;/thread&gt;
     &lt;store&gt;... N |-&gt; I ...&lt;/store&gt;  [lookup]
</pre>
<p>By default, K completes rules in a greedy style. Think this way: what is the<br>
minimal number of changes to my rule to make it fit the declared<br>
configuration? That&apos;s what the K tool will do.</p>
<p>Configuration abstraction is technically unnecessary, but once you start<br>
using it and get a feel for how it works, it will become your best friend.<br>
It allows you to focus on the essentials of your semantics, and at the same<br>
time gives you flexibility in changing the configuration later on without<br>
having to touch the rules. For example, it allows you to remove the<br>
<code>&lt;threads/&gt;</code> cell from the configuration, if you don&apos;t like it, without<br>
having to touch any rule.</p>
<p>We are now ready to give the semantics of <code>spawn</code>:</p>
<pre class="language-text">rule &lt;k&gt; spawn S =&gt; . ...&lt;/k&gt; &lt;env&gt; Rho &lt;/env&gt;
     (. =&gt; &lt;thread&gt;... &lt;k&gt; S &lt;/k&gt; &lt;env&gt; Rho &lt;/env&gt; ...&lt;/thread&gt;)
</pre>
<p>Note configuration abstraction at work, again. Taking into account<br>
the declared configuration, and in particular the multiplicity information<br>
<code>*</code> in the <code>&lt;thread/&gt;</code> cell, the only reasonable way to complete the rule<br>
above is to wrap the <code>&lt;k/&gt;</code> and <code>&lt;env/&gt;</code> cells on the first line within a<br>
<code>&lt;thread/&gt;</code> cell, and to fill-in the <code>...</code>s in the child thread with the<br>
default contents of the other subcells in <code>&lt;thread/&gt;</code>. In this case there<br>
are no other cells, so we can get rid of those <code>...</code>s, but that would<br>
decrease the modularity of this rule: indeed, we may later on add other<br>
cells within <code>&lt;thread/&gt;</code> as the language evolves, for example a function<br>
or an exception stack, etc.</p>
<p>In theory, we should be able to write the rule above even more compactly<br>
and modularly, namely as</p>
<pre class="language-text">rule &lt;k&gt; spawn S =&gt; . ...&lt;/k&gt; &lt;env&gt; Rho &lt;/env&gt;
     (. =&gt; &lt;k&gt; S &lt;/k&gt; &lt;env&gt; Rho &lt;/env&gt;)
</pre>
<p>Unfortunately, this currently does not work in the K tool, due to some<br>
known limitations of our current configuration abstraction algorithm.<br>
This latter rule would be more modular, because it would not even depend<br>
on the cell name <code>thread</code>. For example, we may later decide to change<br>
<code>thread</code> into <code>agent</code>, and we would not have to touch this rule.<br>
We hope this current limitation will be eliminated soon.</p>
<p>Once a thread terminates, its computation cell becomes empty. When that<br>
happens, we can go ahead and remove the useless <code>thread</code> cell:</p>
<pre class="language-text">rule &lt;thread&gt;... &lt;k&gt; . &lt;/k&gt; ...&lt;/thread&gt; =&gt; .
</pre>
<p>Let&apos;s see what we&apos;ve got. <code>kompile</code> and <code>krun</code> <code>spawn.imp</code>.<br>
Note the following:</p>
<ul>
<li>The <code>&lt;threads/&gt;</code> cell is empty, so all threads terminated normally;</li>
<li>The value printed is different from the value in the store; the store value<br>
is not even the one obtained if the threads executed sequentially.</li>
</ul>
<p>Therefore, interesting behaviors may happen; we would like to see them all!</p>
<pre class="language-text">krun spawn.imp --search
</pre>
<p>However, the above does not work.</p>
<p><code>spawn.imp</code> is an interactive program, which reads a number from the<br>
standard input. When analyzing programs exhaustively using the search option,<br>
<code>krun</code> has to disable the streaming capabilities (just think about it and you<br>
will realize why). The best you can do in terms of interactivity with search<br>
is to pipe some input to <code>krun</code>: <code>krun</code> will flush the standard input buffer<br>
into the cells connected to it when creating the initial configuration (will<br>
do that no matter whether you run it with or without the <code>--search</code> option).<br>
For example:</p>
<pre class="language-text">echo 23 | krun spawn.imp --search
</pre>
<p>puts <code>23</code> in the standard input buffer, which is then transferred in the<br>
<code>&lt;in/&gt;</code> cell as a list item, and then the exhaustive search procedure is<br>
invoked.</p>
<p>However, even after piping some input, the <code>spawn.imp</code> program outputs<br>
an error:</p>
<pre class="language-text">[Error] krun: You must pass --enable-search to kompile to be able to use krun --search with the LLVM backend
</pre>
<p>As explained in Lesson 3, by default <code>kompile</code> optimizes the generated<br>
language model for execution. In particular, it does not insert any<br>
backtracking markers where transition attempts should be made, so <code>krun</code><br>
lacks the information it needs to exhaustively search the generated language<br>
model.</p>
<p><code>kompile</code> with the search feature enabled:</p>
<pre class="language-text">kompile imp --enable-search
</pre>
<p>Now <code>echo 23 | krun spawn.imp --search</code> gives us all 12 behaviors of the<br>
<code>spawn.imp</code> program.</p>
<p>We currently have no mechanism for thread synchronization. In the next lesson<br>
we add a <code>join</code> statement, which allows a thread to wait until another completes.</p>
<p>Go to <a href="#ebook-heading-lesson-7-imp-everything-changes-syntax-configuration-semantics">Lesson 7, IMP++: Everything Changes: Syntax, Configuration, Semantics</a>.</p>
<p><a href="https://youtu.be/DpJPP3Qtqno">MOVIE (out of date) [11&apos;40&quot;]</a></p>
</div></div><div id="ebook-heading-lesson-7-imp-everything-changes-syntax-configuration-semantics" ebook-toc-level-4 heading="Lesson 7, IMP++: Everything Changes: Syntax, Configuration, Semantics"><div><h1 class="mume-header" id="everything-changes-syntax-configuration-semantics">Everything Changes: Syntax, Configuration, Semantics</h1>

<p>In this lesson we add thread joining, one of the simplest thread<br>
synchronization mechanisms. In doing so, we need to add unique ids<br>
to threads in the configuration, and to modify the syntax to allow <code>spawn</code><br>
to return the id of the newly created thread. This gives us an opportunity<br>
to make several other small syntactic and semantics changes to the language,<br>
which make it more powerful or more compact at a rather low cost.</p>
<p>Before we start, let us first copy and modify the previous <code>spawn.imp</code> program<br>
from Lesson 1 to make use of thread joining. Recall from Lesson 6 that in some<br>
runs of this program the main thread completed before the child threads,<br>
printing a possibly undesired value of <code>x</code>. What we want now is to assign<br>
unique ids to the two spawned threads, and then to modify the main thread to<br>
join the two child threads before printing. To avoid adding a new type to<br>
the language, let&apos;s assume that thread ids are integer numbers. So we declare<br>
two integers, <code>t1</code> and <code>t2</code>, and assign them the two spawn commands. In order<br>
for this to parse, we will have to change the syntax of <code>spawn</code> to be an<br>
arithmetic expression construct instead of a statement. Once we do that,<br>
we have a slight syntactic annoyance: we need to put two consecutive <code>;</code><br>
after the spawn assignment, one for the assignment statement inside the spawn,<br>
and another for the outer assignment. To avoid the two consecutive semicolons,<br>
we can syntactically enforce spawn to take a block as argument, instead of a<br>
statement. Now it looks better. The new <code>spawn.imp</code> program is still<br>
non-deterministic, because the two threads can execute in any order and even<br>
continue to have a data-race on the shared variable <code>x</code>, but we should see fewer<br>
behaviors when we use the <code>join</code> statements. If we want to fully synchronize<br>
this program, we can have the second thread start with a <code>join(t1)</code> statement.<br>
Then we should only see one behavior for this program.</p>
<p>Let us now modify the language semantics. First, we move the <code>spawn</code><br>
construct from statements to expressions, and make it take a block.<br>
Second, we add one more sub-cell to the thread cell in the configuration,<br>
<code>&lt;id/&gt;</code>, to hold the unique identifier of the thread. We want the main<br>
thread to have id <code>0</code>, so we initialize this cell with <code>0</code>. Third, we modify<br>
the spawn rule to generate a fresh integer identifier, which is put in the<br>
<code>&lt;id/&gt;</code> cell of the child thread and returned as a result of <code>spawn</code> in the<br>
parent thread. Fourth, let us add the <code>join</code> statement to the language,<br>
both syntactically and semantically. So in order for the <code>join(T)</code> statement<br>
to execute, thread <code>T</code> must have its computation empty. However, in order<br>
for this to work we have to get rid of the thread termination cleanup rule.<br>
Indeed, we need to store somewhere the information that thread <code>T</code> terminated;<br>
the simplest way to do it is to not remove the terminated threads. Feel free<br>
to experiment with other possibilities, too, here. For example, you may add<br>
another cell, <code>&lt;done/&gt;</code>, in which you can store all the thread ids of the<br>
terminated and garbage-collected threads.</p>
<p>Let us now <code>kompile imp.k</code> and convince ourselves that the new <code>spawn.imp</code><br>
with <code>join</code> statements indeed has fewer behaviors than its variant without<br>
<code>join</code> statements. Also, let us convince ourselves that the fully synchronized<br>
variant of it indeed has only one behavior.</p>
<p>Note that now spawn, like variable increment, makes the evaluation of<br>
expressions to have side effects. Many programming languages in fact allow<br>
expressions to be evaluated only for their side effects, and not for their<br>
value. This is typically done by simply adding a <code>;</code> after the expression<br>
and thus turning it into a statement. For example, <code>++x;</code>. Let as also<br>
allow arithmetic expressions in our language to be used as statements, by<br>
simply adding the production <code>AExp &quot;;&quot;</code> to <code>Stmt</code>, with evaluation strategy<br>
<code>strict</code> and with the expected semantics discarding the value of the <code>AExp</code>.</p>
<p>Another simple change in syntax and semantics which gives our language more<br>
power, is to remove the <code>;</code> from the syntax of variable assignments and to make<br>
them expression instead of statement constructs. This change, combined with<br>
the previous one, will still allow us to parse all the programs that we could<br>
parse before, but will also allow us to parse more programs. For example, we<br>
can now do sequence assignments like in C: <code>x = y = z = 0</code>. The semantics<br>
of assignment now has to return the assigned value also to the computation,<br>
because we want the assignment expression to evaluate to the assigned value.</p>
<p>Let us also make another change, but this time one which only makes the<br>
definition more compact. Instead of defining statement sequential<br>
composition as a binary construct for statements, let us define a new<br>
syntactic construct, <code>Stmts</code>, as whitespace-separated lists of <code>Stmt</code>. This<br>
allows us to get rid of the empty blocks, because we can change the syntax of<br>
blocks to <code>{Stmts}</code> and <code>Stmts</code> also allows the empty sequence of statements.<br>
However, we do have to make sure that <code>.Stmts</code> dissolves.</p>
<p>In general, unless you are defining a well-established programming language,<br>
it is quite likely that your definitions will suffer lots of changes like the<br>
ones seen in this lecture. You add a new construct, which suggests changes<br>
in the existing syntax making in fact your language parse more programs,<br>
which then requires corresponding changes in the semantics, and so on.<br>
Also, compact definitions are desirable in general, because they are easier<br>
to read and easier to change if needed later.</p>
<p>In the next lesson we wrap up and document the definition of IMP++.</p>
<p>Go to <a href="#ebook-heading-lesson-8-imp-wrapping-up-larger-languages">Lesson 8, IMP++: Wrapping up Larger Languages</a>.</p>
</div></div><div id="ebook-heading-lesson-8-imp-wrapping-up-larger-languages" ebook-toc-level-4 heading="Lesson 8, IMP++: Wrapping up Larger Languages"><div><h1 class="mume-header" id="wrapping-up-larger-languages">Wrapping up Larger Languages</h1>

<p>In this lesson we wrap up IMP++&apos;s semantics and also generate its poster.<br>
While doing so, we also learn how to display larger configurations in order<br>
to make them easier to read and print.</p>
<p>Note that we rearrange a bit the semantics, to group the semantics of old<br>
IMP&apos;s constructs together, and separate it from the new IMP++&apos;s semantics.</p>
<p>You can go even further and manually edit the generated Latex document.<br>
You typically want to do that when you want to publish your language<br>
definition, or parts of it, and you need to finely tune it to fit the<br>
editing requirements. For example, you may want to insert some negative<br>
spaces, etc.</p>
<p>Part 4 of the tutorial is now complete. At this moment you should know most<br>
of K framework&apos;s features and how to use the K tool. You can now define or<br>
design your own programming languages, and then execute and analyze programs.</p>
<p><a href="https://youtu.be/QV1AGagktzk">MOVIE (out of date) [06&apos;26&quot;]</a></p>
</div></div><div id="ebook-heading-part-5-defining-type-systems" ebook-toc-level-3 heading="Part 5: Defining Type Systems"><div><h1 class="mume-header" id="part-5-defining-type-systems">Part 5: Defining Type Systems</h1>

<p>In this part of the tutorial we will show that defining type systems for<br>
languages is essentially no different from defining semantics.  The major<br>
difference is that programs and fragments of programs now rewrite to their<br>
types, instead of to concrete values.  In terms of K, we will learn how<br>
to use it for a certain particular but important kind of applications.</p>
</div></div><div id="ebook-heading-lesson-1-type-systems-imperative-environment-based-type-systems" ebook-toc-level-4 heading="Lesson 1, Type Systems: Imperative, Environment-Based Type Systems"><div><h1 class="mume-header" id="imperative-environment-based-type-systems">Imperative, Environment-Based Type Systems</h1>

<p>In this lesson you learn how to define a type system for an imperative<br>
language (the IMP++ language defined in Part 4 of the tutorial), using a style<br>
based on type  environments.</p>
<p>Let us copy the <code>imp.k</code> file from Part 4 of the tutorial, Lesson 7, which holds<br>
the semantics of IMP++, and modify it into a type system.  The resulting type<br>
system, when executed, yields a type checker.</p>
<p>We start by defining the new strictness attributes of the IMP++ syntax.<br>
While doing so, remember that programs and fragments of programs now reduce<br>
to their types.  So types will be the new results of our new (type) semantics.<br>
We also clean up the semantics by removing the unnecessary tags, and also<br>
use <code>strict</code> instead of <code>seqstrict</code> wherever possible, because <code>strict</code> gives<br>
implementations more freedom.  Interestingly, note that <code>spawn</code> is strict now,<br>
because the code of the child thread should type in the current parent&apos;s type<br>
environment.  Note that this is not always the case for threads, see for example<br>
SIMPLE in the languages tutorial, but it works here for our simpler IMP++.</p>
<p>From a typing perspective, the <code>&amp;&amp;</code> construct is strict in both its arguments;<br>
its short-circuit (concrete) semantics is irrelevant for its (static) type<br>
system.  Similarly, both the conditional and the while loop are strict<br>
constructs when regarded through the typing lenses.</p>
<p>Finally, the sequential composition is now sequentially strict!  Indeed,<br>
statements are now going to reduce to their type, <code>stmt</code>, and it is critical<br>
for sequential composition to type its argument statements left-to-right;<br>
for example, imagine that the second argument is a variable declaration (whose<br>
type semantics will modify the type environment).</p>
<p>We continue by defining the new results of computations, that is, the actual<br>
types.  In this simple imperative language, we only have a few constant types:<br>
<code>int</code>, <code>bool</code>, <code>string</code>, <code>block</code> and <code>stmt</code>.</p>
<p>We next define the new configuration, which is actually quite simple.  Besides<br>
the <code>&lt;k/&gt;</code> cell, all we need is a type environment cell, <code>&lt;tenv/&gt;</code>, which will<br>
hold a map from identifiers to their types.  A type environment is therefore<br>
like a state in the abstract domain of type values.</p>
<p>Let us next modify the semantic rules, turning them into a type system.  In<br>
short, the idea is to reduce the basic values to their types, and then have a<br>
rule for each language construct reducing it to its result type whenever its<br>
arguments have the expected types.</p>
<p>We write the rules in the order given by the syntax declarations, to make<br>
sure we do not forget any construct.</p>
<p>Integers reduce to their type, <code>int</code>.</p>
<p>So do the strings.</p>
<p>Variables are now looked up in the type environment and reduced to their type<br>
there.  Since we only declare integer variables in IMP++, their type in <code>tenv</code><br>
will always be <code>int</code>.  Nevertheless, we write the rule generically, so that we<br>
would not have to change it later if we add other type declarations to IMP++.<br>
Note that we reject programs which lookup undeclared variables.  Rejection,<br>
in this case, means <em>rewriting getting stuck</em>.</p>
<p>Variable increment types to <code>int</code>, provided the variable has type <code>int</code>.</p>
<p>Read types to <code>int</code>, because we only allow integer input.</p>
<p>Division is only allowed on integers, so it rewrites to <code>int</code> provided that its<br>
arguments rewrite to <code>int</code>.  Note, however, that in order to write <code>int / int</code>,<br>
we have to explicitly add <code>int</code> to the syntax of arithmetic expressions.<br>
Otherwise, the K parser rightfully complains, because <code>/</code> was declared on<br>
arithmetic expressions, not on types.  One simple and generic way to allow<br>
types to appear anywhere, is to define <code>Type</code> as a syntactic subcategory of all<br>
the other syntactic categories.  Let&apos;s do it on a by-need basis, though.</p>
<p>Addition is overloaded, so we add two typing rules for it: one for integers<br>
and another for strings.</p>
<p>As discussed, <code>spawn</code> types to <code>stmt</code> provided that its argument types to<br>
<code>block</code>.</p>
<p>The assignment construct was <code>strict(2)</code>; its typing policy is that the declared<br>
type of <code>X</code> should be identical to the type of the assigned value.  Like for<br>
lookup, we define this rule more generically than needed for IMP++, for any<br>
type, not only for <code>int</code>.</p>
<p>The typing rules for Boolean expression constructs are in the same spirit.<br>
Note that we need only one rule for <code>&amp;&amp;</code>.</p>
<p>The typing of blocks is a bit trickier.  First, note that we still need to<br>
recover the environment after the block is typed, because we do not want the<br>
block-local variables to be visible in the outer type environment.  We recover<br>
the type environment only after the block-enclosed statements type; moreover,<br>
we also opportunistically yield a <code>block</code> type on the computation when we<br>
discard the type environment recovery item.  To account for the fact that the<br>
block-enclosed statement can itself be a block (e.g., <code>{{S}}</code>), we would need an<br>
additional rule.  Since we do not like repetition, we instead group the types<br>
<code>block</code> and <code>stmt</code> into one syntactic category, <code>BlockOrStmtType</code>, and now we<br>
can have only one rule.  We also include <code>BlockOrStmtType</code> in <code>Type</code>, as a<br>
replacement for the two basic types.</p>
<p>The expression statement types as expected.  Recall that we only allow<br>
arithmetic expressions, which type to <code>int</code>, to be used as statements in IMP++.</p>
<p>The conditional was declared <code>strict</code> in all its arguments.  Its typing policy<br>
is that its first argument types to <code>bool</code> and its two branches to <code>block</code>.<br>
If that is the case, then it yields a <code>stmt</code> type.</p>
<p>For <code>while</code>, its first argument should type to <code>bool</code> and its second to <code>block</code>.</p>
<p>Variable declarations add new bindings to the type environment.  Recall that<br>
we can only declare variables of integer type in IMP++.</p>
<p>The typing policy of <code>print</code> is that it can only print integer or string values,<br>
and in that case it types to <code>stmt</code>.  Like for <code>BlockOrStmtType</code>, to avoid<br>
having two similar rules, one for <code>int</code> and another for <code>string</code>, we prefer to<br>
introduce an additional syntactic category, <code>PrintableType</code>, which includes both<br>
<code>int</code> and <code>string</code> types.</p>
<p><code>halt</code> types to <code>stmt</code>; so its subsequent code is also typed.</p>
<p><code>join</code> types to <code>stmt</code>, provided that its argument types to <code>int</code>.</p>
<p>Sequential composition was declared as a whitespace-separated sequentially<br>
strict list.  Its typing policy is that all the statements in the list should<br>
type to <code>stmt</code> or <code>block</code> in order for the list to type to <code>stmt</code>.  Since<br>
lists are maintained internally as cons-lists, this is probably the simplest<br>
way to do it:</p>
<pre class="language-text">rule .Stmts =&gt; stmt
rule _:BlockOrStmtType Ss =&gt; Ss
</pre>
<p>Note that the first rule, which types the empty sequence of statements to <code>stmt</code>,<br>
is needed anyway, to type empty blocks <code>{}</code> (together with the block rule).</p>
<p><code>kompile</code> <code>imp.k</code> and <code>krun</code> all the programs in Part 4 of the tutorial.  They<br>
should all type to <code>stmt</code>.</p>
<p>In the next lesson we will define a substitution-based type system for LAMBDA.</p>
<p>Go to <a href="#ebook-heading-lesson-2-type-systems-substitution-based-higher-order-type-systems">Lesson 2, Type Systems: Substitution-Based Higher-Order Type Systems</a>.</p>
<p><a href="https://youtu.be/WyUxdo7GhtE">MOVIE (out of date) [10&apos;11&quot;]</a></p>
</div></div><div id="ebook-heading-lesson-2-type-systems-substitution-based-higher-order-type-systems" ebook-toc-level-4 heading="Lesson 2, Type Systems: Substitution-Based Higher-Order Type Systems"><div><h1 class="mume-header" id="substitution-based-higher-order-type-systems">Substitution-Based Higher-Order Type Systems</h1>

<p>In this lesson you learn how to define a substitution-based type system for<br>
a higher-order language, namely the LAMBDA language defined in Part 1 of the<br>
tutorial.</p>
<p>Let us copy the definition of LAMBDA from Part 1 of the tutorial, Lesson 8.<br>
We are going to modify it into a type systems for LAMBDA.</p>
<p>Before we start, it is important to clarify an important detail, namely that<br>
our type system will yield a type checker when executed, not a type<br>
inferencer.  In particular, we are going to change the LAMBDA syntax<br>
to allow us to associate a type to each declared variable.  The<br>
constructs which declare variables are <code>lambda</code>, <code>let</code>, <code>letrec</code> and <code>mu</code>.<br>
The syntax of all these will therefore change.</p>
<p>Since here we are not interested in a LAMBDA semantics anymore, we take the<br>
freedom to eliminate the <code>Val</code> syntactic category, our previous results.<br>
Our new results are going to be the types, because programs will now reduce<br>
to their types.</p>
<p>As explained, the syntax of the <code>lambda</code> construct needs to change, to also<br>
declare the type of the variable that it binds.  We add the new syntactic<br>
category <code>Type</code>, with the following constructs: <code>int</code>, <code>bool</code>, the function<br>
type (which gives it its higher-order status), and parentheses as bracket.<br>
Also, we make types our K results.</p>
<p>We are now ready to define the typing rules.</p>
<p>Let us start with the typing rule for lambda abstraction: <code>lambda X : T . E</code><br>
types to the function type <code>T -&gt; T&apos;</code>, where <code>T&apos;</code> is the type obtained by further<br>
typing <code>E[T/X]</code>.  This can be elegantly achieved by reducing the lambda<br>
abstraction to <code>T -&gt; E[T/X]</code>, provided that we extend the function type construct<br>
to take expressions, not only types, as arguments, and to be strict.<br>
This can be easily achieved by redeclaring it as a strict expression construct<br>
(strictness in the second argument would suffice in this example, but it is<br>
more uniform to define it strict overall).</p>
<p>The typing rule for application is as simple as it can get: <code>(T1-&gt;T2) T1 =&gt; T2</code>.</p>
<p>Let us now give the typing rules of arithmetic and Boolean expression<br>
constructs.  First, let us get rid of <code>Val</code>.  Second, rewrite each value to its<br>
type, similarly to the type system for IMP++ in the previous lesson.  Third,<br>
replace each semantic rule by its typing rule.  Fourth, make sure you<br>
do not forget to subsort <code>Type</code> to <code>Exp</code>, so your rules above will parse.</p>
<p>The typing policy of the conditional statement is that its first argument<br>
should type to <code>bool</code> and its other two arguments should type to the same type<br>
<code>T</code>, which will also be the result type of the conditional.  So we make the<br>
conditional construct <code>strict</code> in all its three arguments and we write the<br>
obvious rule: <code>if bool then T:Type else T =&gt; T</code>.  We want a runtime check that<br>
the latter arguments are actually typed, so we write <code>T:Type</code>.</p>
<p>There is nothing special about <code>let</code>, except that we have to make sure we<br>
change its syntax to account for the type of the variable that it binds.<br>
This rule is a macro, so the <code>let</code> is desugared statically.</p>
<p>Similarly, the syntax of <code>letrec</code> and <code>mu</code> needs to change to account for the<br>
type of the variable that they bind.  The typing of <code>letrec</code> remains based on<br>
its desugaring to <code>mu</code>; we have to make sure the types are also included now.</p>
<p>The typing policy of <code>mu</code> is that its body should type to the same type <code>T</code> of<br>
its variable, which is also the type of the entire <code>mu</code> expression.  This can<br>
be elegantly achieved by rewriting it to <code>(T -&gt; T) E[T/X]</code>.  Recall that<br>
application is strict, so <code>E[T/X]</code> will be eventually reduced to its type.<br>
Then the application types correctly only if that type is also <code>T</code>, and in<br>
that case the result type will also be <code>T</code>.</p>
<p><code>kompile</code> and <code>krun</code> some programs.  You can, for example, take the LAMBDA<br>
programs from the first tutorial, modify them by adding types to their<br>
variable declarations, and then type check them using <code>krun</code>.</p>
<p>In the next lesson we will discuss an environment-based type system<br>
for LAMBDA.</p>
<p>Go to <a href="#ebook-heading-lesson-3-type-systems-environment-based-higher-order-type-systems">Lesson 3, Type Systems: Environment-Based Higher-Order Type Systems</a>.</p>
<p><a href="https://youtu.be/7P2QtR9jM2o">MOVIE (out of date) [6&apos;52&quot;]</a></p>
</div></div><div id="ebook-heading-lesson-3-type-systems-environment-based-higher-order-type-systems" ebook-toc-level-4 heading="Lesson 3, Type Systems: Environment-Based Higher-Order Type Systems"><div><h1 class="mume-header" id="environment-based-higher-order-type-systems">Environment-Based Higher-Order Type Systems</h1>

<p>In this lesson you learn how to define an environment-based type system for<br>
a higher-order language, namely the LAMBDA language defined in Part 1 of the<br>
tutorial.</p>
<p>The simplest and fastest way to proceed is to copy the substitution-based<br>
type system of LAMBDA from the previous lesson and modify it into an<br>
environment-based one. A large portion of the substitution-based definition<br>
will remain unchanged. We only have to modify the rules that use<br>
substitution.</p>
<p>We do not need the substitution anymore, so we can remove the require and<br>
import statements. The syntax of types and expressions stays unchanged, but<br>
we can now remove the <code>binder</code> tag of lambda.</p>
<p>Like in the type system of IMP++ in Lesson 1, we need a configuration that<br>
contains, besides the <code>&lt;k/&gt;</code> cell, a <code>&lt;tenv/&gt;</code> cell that will hold the type<br>
environment.</p>
<p>In an environment-based definition, unlike in a substitution-based one, we<br>
need to lookup variables in the environment. So let us start with the<br>
type lookup rule:</p>
<pre class="language-text">rule &lt;k&gt; X:Id =&gt; T ...&lt;/k&gt; &lt;tenv&gt;... X |-&gt; T ...&lt;/k&gt;
</pre>
<p>The type environment is populated by the semantic rule of <code>lambda</code>:</p>
<pre class="language-text">rule &lt;k&gt; lambda X : T . E =&gt; (T -&gt; E) ~&gt; Rho ...&lt;/k&gt;
     &lt;tenv&gt; Rho =&gt; Rho[X &lt;- T] &lt;/tenv&gt;
</pre>
<p>So <code>X</code> is bound to its type <code>T</code> in the type environment, and then <code>T -&gt; E</code><br>
is scheduled for processing. Recall that the arrow type construct has been<br>
extended into a strict expression construct, so <code>E</code> will be eventually reduced<br>
to its type. Like in other environment-based definitions, we need to make<br>
sure that we recover the type environment after the computation in the scope<br>
of the declared variable terminates.</p>
<p>The typing rule of application does not change, so it stays as elegant as it<br>
was in the substitution-based definition:</p>
<pre class="language-text">rule (T1 -&gt; T2) T1 =&gt; T2
</pre>
<p>So do the rules for arithmetic and Boolean constructs, and those for the<br>
<code>if</code>, and <code>let</code>, and <code>letrec</code>.</p>
<p>The <code>mu</code> rule needs to change, because it was previously defined using<br>
substitution. We modify it in the same spirit as we modified the <code>lambda</code><br>
rule: bind <code>X</code> to its type in the environment, schedule its body for typing<br>
in its right context, and then recover the type environment.</p>
<p>Finally, we give the semantics of environment recovery, making sure<br>
the environment is recovered only after the preceding computation is<br>
reduced to a type:</p>
<p>rule <k> _:Type ~&gt; (Rho =&gt; .) ...</k> <tenv> _ =&gt; Rho </tenv></p>
<p>The changes that we applied to the substitution-based definition were<br>
therefore quite systematic: each substitution invocation was replaced with<br>
an appropriate type environment update/recovery.</p>
<p>Go to <a href="#ebook-heading-lesson-4-type-systems-a-naive-substitution-based-type-inferencer">Lesson 4, Type Systems: A Naive Substitution-Based Type Inferencer</a>.</p>
</div></div><div id="ebook-heading-lesson-4-type-systems-a-naive-substitution-based-type-inferencer" ebook-toc-level-4 heading="Lesson 4, Type Systems: A Naive Substitution-Based Type Inferencer"><div><h1 class="mume-header" id="a-naive-substitution-based-type-inferencer">A Naive Substitution-Based Type Inferencer</h1>

<p>In this lesson you learn how to define a naive substitution-based type<br>
inferencer for a higher-order language, namely the LAMBDA language<br>
defined in Part 1 of the tutorial.</p>
<p>Unlike in the type checker defined in Lessons 2 and 3, where we had to<br>
associate a type with each declared variable, a type inferencer<br>
attempts to infer the types of all the variables from the way those<br>
variables are used. Let us take a look at this program, say <code>plus.lambda</code>:</p>
<pre class="language-text">lambda x . lambda y . x + y
</pre>
<p>Since <code>x</code> and <code>y</code> are used in an integer addition context, we can infer<br>
that they must have the type <code>int</code> and the result of the addition is<br>
also an <code>int</code>, so the type of the entire expression is <code>int -&gt; int -&gt; int</code>.<br>
Similarly, the program <code>if.lambda</code></p>
<pre class="language-text">lambda x . lambda y . lambda z .
  if x then y else z
</pre>
<p>can only make sense when <code>x</code> has type <code>bool</code> and <code>y</code> and <code>z</code> have the same<br>
type, say <code>t</code>, in which case the type of the entire expression is<br>
<code>bool -&gt; t -&gt; t -&gt; t</code>. Since the type <code>t</code> can be anything, we say that<br>
the type of this expression is <em>polymorphic</em>. That means that the code<br>
above can be used in different contexts, where <code>t</code> can be an <code>int</code>, a<br>
<code>bool</code>, a function type <code>int -&gt; int</code>, and so on.</p>
<p>In the <code>identity.lambda</code> program</p>
<pre class="language-text">let f = lambda x . x
in f 1
</pre>
<p><code>f</code> has such a polymorphic type, which is then applied to an integer,<br>
so this program is type-safe and its type is <code>int</code>.</p>
<p>A typical polymorphic expression is the composition</p>
<pre class="language-text">lambda f . lambda g . lambda x .
  g (f x)
</pre>
<p>which has the type <code>(t1 -&gt; t2) -&gt; (t2 -&gt; t3) -&gt; (t1 -&gt; t3)</code>, polymorphic<br>
in 3 types.</p>
<p>Let us now define our naive type inferencer and then we discuss more<br>
examples. The idea is quite simple: we conceptually do the same<br>
operations like we did within the type checker defined in Lesson 2,<br>
with two important differences:</p>
<ol>
<li>instead of declaring a type with each declared variable, we assume<br>
a fresh type for that variable; and</li>
<li>instead of checking that the types of expressions satisfy the<br>
type properties of the context in which they are used, we impose<br>
those properties as type equality constraints. A general-purpose<br>
unification-based constraint solving mechanism is then used to solve<br>
the generated type constraints.</li>
</ol>
<p>Let us start with the syntax, which is essentially identical to that<br>
of the type checker in Lesson 2, except that bound variables are not<br>
declared a type anymore. Also, to keep things more compact, we put<br>
all the <code>Exp</code> syntax declarations in one syntax declaration this time.</p>
<p>Before we modify the rules, let us first define our machinery for<br>
adding and solving constraints. First, we require and import the<br>
unification procedure. We do not discuss unification here, but if you<br>
are interested you can consult the <code>unification.k</code> files under<br>
<a href="file:///home/runner/work/k/k/gh-pages/k-distribution/include/kframework/builtin/README.md">k-distribution/include/kframework/builtin</a>, which contains our current generic<br>
definition of unification, which is written also in K. The generic unification<br>
provides a sort, <code>Mgu</code>, for <em>most-general-unifier</em>, an operation<br>
<code>updateMgu(Mgu,T1,T2)</code> which updates <code>Mgu</code> with additional constraints<br>
generated by forcing the terms <code>T1</code> and <code>T2</code> to be equal, and an operation<br>
<code>applyMgu(Mgu,T)</code> which applies <code>Mgu</code> to term <code>T</code>. For our use<br>
of unification here, we do not even need to know how <code>Mgu</code> terms are<br>
represented internally.</p>
<p>We define a K item construct, <code>=</code>, which takes two <code>Type</code> terms and<br>
enforces them to be equal by means of updating the current <code>Mgu</code>.<br>
Once the constraints are added to the <code>Mgu</code>, the equality dissolves<br>
itself. With this semantics of <code>=</code> in mind, we can now go ahead and<br>
modify the rules of the type checker systematically into rules<br>
for a type inferencer. The changes are self-explanatory and<br>
mechanical: for example, the rule</p>
<pre class="language-text">rule int * int =&gt; int
</pre>
<p>changes into rule</p>
<pre class="language-text">rule T1:Type  * T2:Type =&gt; T1 = int ~&gt; T2 = int ~&gt; int
</pre>
<p>generating the constraints that the two arguments of multiplication<br>
have the type <code>int</code>, and the result type is <code>int</code>. Recall that each type<br>
equality on the <code>&lt;k/&gt;</code> cell updates the current <code>Mgu</code> appropriately and<br>
then dissolves itself; thus, the above says that after imposing the<br>
constraints <code>T1=int</code> and <code>T2=int</code>, multiplication yields a type <code>int</code>.</p>
<p>As mentioned above, since types of variables are not declared anymore,<br>
but inferred, we have to generate a fresh type for each variable at its<br>
declaration time, and then generate appropriately constraints for it.<br>
For example, the type semantics of <code>lambda</code> and <code>mu</code> become:</p>
<pre class="language-text">rule lambda X . E =&gt; T -&gt; E[T/X]  when fresh(T:Type)
rule mu X . E =&gt; (T -&gt; T) E[T/X]  when fresh(T:Type)
</pre>
<p>that is, we add a condition stating that the previously declared type<br>
is now a fresh one. This type will be further constrained by how the<br>
variable <code>X</code> is being used within <code>E</code>.</p>
<p>Interestingly, the previous typing rule for lambda application is not<br>
powerful enough anymore. Indeed, since types are not given anymore,<br>
it may very well be the case that the inferred type of the first<br>
argument of the application construct is not yet a function type<br>
(remember, for example, the program composition.lambda above). What<br>
we have to do is to enforce it to be a function type, by means of<br>
fresh types and constraints. We can introduce a fresh type for the<br>
result of the application, and then write the expected rule as<br>
follows:</p>
<pre class="language-text">rule T1:Type T2:Type =&gt; T1 = (T2 -&gt; T) ~&gt; T  when fresh(T:Type)
</pre>
<p>The conditional requires that its first argument is a <code>bool</code> and its<br>
second and third arguments have the same type, which is also the<br>
result type.</p>
<p>The macros do not change, in particular <code>let</code> is desugared into lambda<br>
application. We will next see that this is a significant restriction,<br>
because it limits the polymorphism of our type system.</p>
<p>We are done. We have a working type inferencer for LAMBDA.</p>
<p>Let&apos;s <code>kompile</code> it and <code>krun</code> the programs above. They all work as<br>
expected. Let us also try some additional programs, to push it to its<br>
limits.</p>
<p>First, let us test <code>mu</code> by means of a <code>letrec</code> example:</p>
<pre class="language-text">letrec f x = 3
in f
</pre>
<p>We can also try all the programs that we had in our first tutorial, on<br>
lambda, for example the <code>factorial.imp</code> program:</p>
<pre class="language-text">letrec f x = if x &lt;= 1 then 1 else (x * (f (x + -1)))
in (f 10)
</pre>
<p>Those programs are simple enough that they should all work as<br>
expected with our naive type inferencer here.</p>
<p>Let us next try to type some tricky programs, which involve more<br>
complex and indirect type constraints.</p>
<p><code>tricky-1.lambda</code>:</p>
<pre class="language-text">lambda f . lambda x . lambda y . (
  (f x y) + x + (let x = y in x)
)
</pre>
<p><code>tricky-2.lambda</code>:</p>
<pre class="language-text">lambda x .
  let f = lambda y . if true then y else x
  in (lambda x . f 0)
</pre>
<p><code>tricky-3.lambda</code>:</p>
<pre class="language-text">lambda x . let f = lambda y . if true then x 7 else x y
           in f
</pre>
<p><code>tricky-4.lambda</code>:</p>
<pre class="language-text">lambda x . let f = lambda x . x
           in let d = (f x) + 1
              in x
</pre>
<p><code>tricky-5.lambda</code>:</p>
<pre class="language-text">lambda x . let f = lambda y . x y
           in let z = x 0 in f
</pre>
<p>It is now time to see the limitations of this naive type inferencer.<br>
Consider the program</p>
<pre class="language-text">let id = lambda x . x
in if (id true) then (id 1) else (id 2)
</pre>
<p>Our type inferencer fails graciously with a clash in the <code>&lt;mgu/&gt;</code> cell<br>
between <code>int</code> and <code>bool</code>. Indeed, the desugaring macro of <code>let</code> turns it<br>
into a <code>lambda</code> and an application, which further enforce <code>id</code> to have a<br>
type of the form <code>t -&gt; t</code> for some fresh type <code>t</code>. The first use of <code>id</code><br>
in the condition of <code>if</code> will then constrain <code>t</code> to be <code>bool</code>, while the<br>
other uses in the two branches will enforce <code>t</code> to be <code>int</code>. Thus the<br>
clash in the <code>&lt;mgu/&gt;</code> cell.</p>
<p>Similarly, the program</p>
<pre class="language-text">let id = lambda x . x
in id id
</pre>
<p>yields a different kind of conflict: if <code>id</code> has type <code>t -&gt; t</code>, in order<br>
to apply <code>id</code> to itself it must be the case that its argument, <code>t</code>, equals<br>
<code>t -&gt; t</code>. These two type terms cannot be unified because there is a<br>
circular dependence on <code>t</code>, so we get a cycle in the <code>&lt;mgu/&gt;</code> cell.</p>
<p>Both limitations above will be solved when we change the semantics of<br>
<code>let</code> later on, to account for the desired polymorphism.</p>
<p>Before we conclude this lesson, let us see one more interesting<br>
example, where the lack of let-polymorphism leads not to a type error,<br>
but to a less generic type:</p>
<pre class="language-text">let f1 = lambda x . x in
  let f2 = f1 in
    let f3 = f2 in
      let f4 = f3 in
        let f5 = f4 in
          if (f5 true) then f2 else f3
</pre>
<p>Our current type inferencer will infer the type <code>bool -&gt; bool</code> for the<br>
program above. Nevertheless, since all functions <code>f1</code>, <code>f2</code>, <code>f3</code>, <code>f4</code>, <code>f5</code><br>
are the identity function, which is polymorphic, we would expect the<br>
entire program to type to the same polymorphic identity function type.</p>
<p>This limitation will be also addressed when we define our<br>
let-polymorphic type inferencer.</p>
<p>Before that, in the next lesson we will show how easily we can turn<br>
the naive substitution-based type inferencer discussed in this lesson<br>
into a similarly naive, but environment-based type inferencer.</p>
<p>Go to <a href="#ebook-heading-lesson-5-type-systems-a-naive-environment-based-type-inferencer">Lesson 5, Type Systems: A Naive Environment-Based Type Inferencer</a>.</p>
</div></div><div id="ebook-heading-lesson-5-type-systems-a-naive-environment-based-type-inferencer" ebook-toc-level-4 heading="Lesson 5, Type Systems: A Naive Environment-Based Type Inferencer"><div><h1 class="mume-header" id="a-naive-environment-based-type-inferencer">A Naive Environment-Based Type Inferencer</h1>

<p>In this lesson you learn how to define a naive environment-based type<br>
inferencer for a higher-order language. Specifically, we take the<br>
substitution-based type inferencer for LAMBDA defined in Lesson 4 and<br>
turn it into an environment-based one.</p>
<p>Recall from Lesson 3, where we defined an environment-based type<br>
checker for LAMBDA based on the substitution-based one in Lesson 2,<br>
that the transition from a substitution-based definition to an<br>
environment-based one was quite systematic and mechanical: each<br>
substitution occurrence <code>E[T/X]</code> is replaced by <code>E</code>, but at the same time<br>
the variable <code>X</code> is bound to type <code>T</code> in the type environment. One benefit<br>
of using type environments instead of substitution is that we replace<br>
a linear complexity operation (the substitution) with a constant<br>
complexity one (the variable lookup).</p>
<p>There is not much left to say which has not been already said in<br>
Lesson 3: we remove the unnecessary binder annotations for the<br>
variable binding operations, then add a <code>&lt;tenv/&gt;</code> cell to the<br>
configuration to hold the type environment, then add a new rule for<br>
variable lookup, and finally apply the transformation of substitutions<br>
<code>E[T/X]</code> into <code>E</code> as explained above.</p>
<p>The resulting type inferencer should now work exactly the same way as<br>
the substitution-based one, except, of course, that the resulting<br>
configurations will contain a <code>&lt;tenv/&gt;</code> cell now.</p>
<p>As sanity check, let us consider two more LAMBDA programs that test<br>
the static scoping nature of the inferencer. We do that because<br>
faulty environment-based definitions often have this problem. The<br>
program</p>
<pre class="language-text">let x = 1
in let f = lambda a . x
   in let x = true
      in f 3
</pre>
<p>should type to <code>int</code>, not to <code>bool</code>, and so it does. Similarly, the<br>
program</p>
<pre class="language-text">let y = 0
in letrec f x = if x &lt;= 0
                then y
                else let y = true
                     in f (x + 1)
   in f 1
</pre>
<p>should also type to <code>int</code>, not <code>bool</code>, and so it does, too.</p>
<p>The type inferencer defined in this lesson has the same limitations,<br>
in terms of polymorphism, as the one in Lesson 4. In the next<br>
lesson we will see how it can be parallelized, and in further lessons<br>
how to make it polymorphic.</p>
<p>Go to <a href="#ebook-heading-lesson-6-type-systems-parallel-type-checkersinferencers">Lesson 6, Type Systems: Parallel Type Checkers/Inferencers</a>.</p>
</div></div><div id="ebook-heading-lesson-6-type-systems-parallel-type-checkersinferencers" ebook-toc-level-4 heading="Lesson 6, Type Systems: Parallel Type Checkers/Inferencers"><div><h1 class="mume-header" id="parallel-type-checkersinferencers">Parallel Type Checkers/Inferencers</h1>

<p>In this lesson you learn how to define parallel type checkers or<br>
inferencers. For the sake of a choice, we will parallelize the one in<br>
the previous lesson, but the ideas are general. We are using the same<br>
idea to define type checkers for other languages in the K tool<br>
distribution, such as SIMPLE and KOOL.</p>
<p>The idea is in fact quite simple. Instead of one monolithic typing<br>
task, we generate many smaller tasks, which can be processed in<br>
parallel. We use the same approach to define parallel semantics as we<br>
used for threads in IMP++ in Part 4 of the tutorial, that is, we add a<br>
cell holding all the parallel tasks, making sure we declare the cell<br>
holding a task with multiplicity <code>*</code>. For the particular type<br>
inferencer that we chose here, the one in Lesson 5, each task will<br>
hold an expression to type together with a type environment (so it<br>
knows where to lookup its free variables). We have the following<br>
configuration then:</p>
<pre class="language-text">configuration &lt;tasks color=&quot;yellow&quot;&gt;
                &lt;task color=&quot;orange&quot; multiplicity=&quot;*&quot;&gt;
                  &lt;k color=&quot;green&quot;&gt; $PGM:Exp &lt;/k&gt;
                  &lt;tenv color=&quot;red&quot;&gt; .Map &lt;/tenv&gt;
                &lt;/task&gt;
              &lt;/tasks&gt;
              &lt;mgu color=&quot;blue&quot;&gt; .Mgu &lt;/mgu&gt;
</pre>
<p>Now we have to take each typing rule we had before and change it to<br>
yield parallel typing. For example, our rule for typing<br>
multiplication was the following in Lesson 5:</p>
<pre class="language-text">rule T1:Type * T2:Type =&gt; T1 = int ~&gt; T2 = int ~&gt; int
</pre>
<p>Since <code>*</code> was strict, its two arguments eventually type, and once that<br>
happens the rule above fires. Unfortunately, the strictness of<br>
multiplication makes the typing of the two expressions sequential in<br>
our previous definition. To avoid typing the two expressions<br>
sequentially and instead generating two parallel tasks, we remove the<br>
<code>strict</code> attribute of multiplication and replace the rule above with the<br>
following:</p>
<pre class="language-text">rule &lt;k&gt; E1 * E2 =&gt; int ...&lt;/k&gt; &lt;tenv&gt; Rho &lt;/tenv&gt;
     (. =&gt; &lt;task&gt; &lt;k&gt; E1 = int &lt;/k&gt; &lt;tenv&gt; Rho &lt;/tenv&gt; &lt;/task&gt;
           &lt;task&gt; &lt;k&gt; E2 = int &lt;/k&gt; &lt;tenv&gt; Rho &lt;/tenv&gt; &lt;/task&gt;)
</pre>
<p>Therefore, we generate two tasks for typing <code>E1</code> and <code>E2</code> in the same type<br>
environment as the current task, and let the current task continue by<br>
simply optimistically reducing <code>E1*E2</code> to its expected result type, <code>int</code>.<br>
If <code>E1</code> or <code>E2</code> will not type to <code>int</code>, then either their corresponding<br>
tasks will get stuck or the <code>&lt;mgu/&gt;</code> cell will result into a clash or cycle,<br>
so the program will not type overall in spite of the fact that we<br>
allowed the task containing the multiplication to continue. This is<br>
how we get maximum of parallelism in this case.</p>
<p>Before we continue, note that the new tasks hold equalities in them,<br>
where one of its arguments is an expression, while previously the<br>
equality construct was declared to take types. What we want now is<br>
for the equality construct to possibly take any expressions, and first<br>
type them and then generate the type constraint like before. This can<br>
be done very easily by just extending the equality construct to<br>
expressions and declaring it <code>strict</code>:</p>
<pre class="language-text">syntax KItem ::= Exp &quot;=&quot; Exp  [strict]
</pre>
<p>Unlike before, where we only passed types to the equality construct,<br>
we now need a runtime check that its arguments are indeed types before<br>
we can generate the <code>updateMgu</code> command:</p>
<pre class="language-text">rule &lt;k&gt; T:Type = T&apos;:Type =&gt; . ...&lt;/k&gt;
     &lt;mgu&gt; Theta:Mgu =&gt; updateMgu(Theta,T,T&apos;) &lt;/mgu&gt;
</pre>
<p>Like before, an equality will therefore update the <code>&lt;mgu/&gt;</code> cell and then<br>
it dissolves itself, letting the <code>&lt;k/&gt;</code> cell in the corresponding task<br>
empty. Such empty tasks are unnecessary, so they can be erased:</p>
<pre class="language-text">rule &lt;task&gt;... &lt;k&gt; . &lt;/k&gt; ...&lt;/task&gt; =&gt; .
</pre>
<p>We can now follow the same style as for multiplication to write the<br>
parallel typing rules of the other arithmetic constructs, and even for<br>
the conditional.</p>
<p>To parallelize the typing of lambda we generate two fresh types, one<br>
for the variable and one for the body, and make sure that we generate<br>
the correct type constraint and environment in the body task:</p>
<pre class="language-text">rule &lt;k&gt; lambda X . E =&gt; Tx -&gt; Te ...&lt;/k&gt; &lt;tenv&gt; TEnv &lt;/tenv&gt;
     (. =&gt; &lt;task&gt; &lt;k&gt; E = Te &lt;/k&gt; &lt;tenv&gt; TEnv[Tx/X] &lt;/tenv&gt; &lt;/task&gt;)
  when fresh(Tx:Type) andBool fresh(Te:Type)
</pre>
<p>Note that the above also allows us to not need to change and then<br>
recover the environment of the current cell.</p>
<p>For function application we also need to generate two fresh types:</p>
<pre class="language-text">rule &lt;k&gt; E1 E2 =&gt; T ...&lt;/k&gt; &lt;tenv&gt; Rho &lt;/tenv&gt;
     (. =&gt; &lt;task&gt; &lt;k&gt; E1 = T2 -&gt; T &lt;/k&gt; &lt;tenv&gt; Rho &lt;/tenv&gt; &lt;/task&gt;
           &lt;task&gt; &lt;k&gt; E2 = T2 &lt;/k&gt; &lt;tenv&gt; Rho &lt;/tenv&gt; &lt;/task&gt;)
  when fresh(T2:Type) andBool fresh(T:Type)
</pre>
<p>The only rule left is that of <code>mu X . E</code>. In this case we only need one<br>
fresh type, because <code>X</code>, <code>E</code> and <code>mu X . E</code> have all the same type:</p>
<pre class="language-text">rule &lt;k&gt; mu X . E =&gt; T ...&lt;/k&gt;  &lt;tenv&gt; TEnv &lt;/tenv&gt;
     (. =&gt; &lt;task&gt; &lt;k&gt; E = T &lt;/k&gt; &lt;tenv&gt; TEnv[T/X] &lt;/tenv&gt; &lt;/task&gt;)
  when fresh(T:Type)
</pre>
<p>We do not need the type environment recovery operation, so we delete it.</p>
<p>We can now <code>kompile</code> and <code>krun</code> all the programs that we typed in Lesson 5.<br>
Everything should work.</p>
<p>In this lesson we only aimed at parallelizing the type inferencer in<br>
Lesson 5, not to improve its expressiveness; it still has the same<br>
limitations in terms of polymorphism. The next lessons are dedicated<br>
to polymorphic type inferencers.</p>
<p>Go to <a href="#ebook-heading-lesson-7-type-systems-a-naive-substitution-based-polymorphic-type-inferencer">Lesson 7, Type Systems: A Naive Substitution-based Polymorphic Type Inferencer</a>.</p>
</div></div><div id="ebook-heading-lesson-7-type-systems-a-naive-substitution-based-polymorphic-type-inferencer" ebook-toc-level-4 heading="Lesson 7, Type Systems: A Naive Substitution-based Polymorphic Type Inferencer"><div><h1 class="mume-header" id="a-naive-substitution-based-polymorphic-type-inferencer">A Naive Substitution-based Polymorphic Type Inferencer</h1>

<p>In this lesson you learn how little it takes to turn a naive monomorphic<br>
type inferencer into a naive polymorphic one, basically only changing<br>
a few characters. In terms of the K framework, you will learn that<br>
you can have complex combinations of substitutions in K, both over<br>
expressions and over types.</p>
<p>Let us start directly with the change. All we have to do is to take<br>
the LAMBDA type inferencer in Lesson 4 and only change the macro</p>
<pre class="language-text">rule let X = E in E&apos; =&gt; (lambda X . E&apos;) E  [macro]
</pre>
<p>as follows:</p>
<pre class="language-text">rule let X = E in E&apos; =&gt; E&apos;[E/X]  [macro]
</pre>
<p>In other words, we are inlining the beta-reduction rule of<br>
lambda-calculus within the original rule. In terms of typing,<br>
the above forces the type inferencer to type <code>E</code> in place for each<br>
occurrence of <code>X</code> in <code>E&apos;</code>. Unlike in the first rule, where <code>X</code> had to get<br>
one type only which satisfied the constrains of all <code>X</code>&apos;s occurrences in<br>
<code>E&apos;</code>, we now never associate any type to <code>X</code> anymore.</p>
<p>Let us <code>kompile</code> and <code>krun</code> some examples. Everything that worked with<br>
the type inferencer in Lesson 4 should still work here, although the<br>
types of some programs can now be more general. For example, reconsider<br>
the <code>nested-lets.lambda</code> program</p>
<pre class="language-text">let f1 = lambda x . x in
  let f2 = f1 in
    let f3 = f2 in
      let f4 = f3 in
        let f5 = f4 in
          if (f5 true) then f2 else f3
</pre>
<p>which was previously typed to <code>bool -&gt; bool</code>. With the new rule above,<br>
the sequence of lets is iteratively eliminated and we end up with the<br>
program</p>
<pre class="language-text">if (lambda x . x) true then (lambda x . x) else (lambda x . x)
</pre>
<p>which now types (with both type inferencers) to a type of the form<br>
<code>t -&gt; t</code>, for some type variable <code>t</code>, which is more general than the<br>
previous <code>bool -&gt; bool</code> type that the program typed to in Lesson 4.</p>
<p>We can also now type programs that were not typable before, such as</p>
<pre class="language-text">let id = lambda x . x
in if (id true) then (id 1) else (id 2)
</pre>
<p>and</p>
<pre class="language-text">let id = lambda x . x
in id id
</pre>
<p>Let us also test it on some trickier programs, also not typable<br>
before, such as</p>
<pre class="language-text">let f = lambda x . x
in let g = lambda y . f y
   in g g
</pre>
<p>which gives us a type of the form <code>t -&gt; t</code> for some type variable <code>t</code>,<br>
and as</p>
<pre class="language-text">let f = let g = lambda x . x
        in let h = lambda x . lambda x . (g g g g)
           in h
in f
</pre>
<p>which types to <code>t1 -&gt; t2 -&gt; t3 -&gt; t3</code> for some type variables <code>t1</code>, <code>t2</code>, <code>t3</code>.</p>
<p>Here is another program which was not typable before, which is<br>
trickier than the others above in that a lambda-bound variable appears<br>
free in a let-bound expression:</p>
<pre class="language-text">lambda x . (
  let y = lambda z . x
  in if (y true) then (y 1) else (y (lambda x . x))
)
</pre>
<p>The above presents no problem now, because once <code>lambda z . x</code> gets<br>
substituted for <code>y</code> we get a well-typed expression which yields that <code>x</code><br>
has the type <code>bool</code>, so the entire expression types to <code>bool -&gt; bool</code>.</p>
<p>The cheap type inferencer that we obtained above therefore works as<br>
expected. However, it has two problems which justify a more advanced<br>
solution. First, substitution is typically considered an elegant<br>
mathematical instrument which is not too practical in implementations,<br>
so an implementation of this type inferencer will likely be based on<br>
type environments anyway. Additionally, we mix two kinds of<br>
substitutions in this definition, one where we substitute types and<br>
another where we substitute expressions, which can only make things<br>
harder to implement efficiently. Second, our naive substitution of <code>E</code><br>
for <code>X</code> in <code>E&apos;</code> can yield an exponential explosion in size of the original<br>
program. Consider, for example, the following classic example which<br>
is known to generate a type whose size is exponential in the size of<br>
the program (and is thus used as an argument for why let-polymorphic<br>
type inference is exponential in the worst-case):</p>
<pre class="language-text">let f00 = lambda x . lambda y . x in
  let f01 = lambda x . f00 (f00 x) in
    let f02 = lambda x . f01 (f01 x) in
      let f03 = lambda x . f02 (f02 x) in
        let f04 = lambda x . f03 (f03 x) in
          // ... you can add more nested lets here
          f04
</pre>
<p>The particular instance of the pattern above generates a type which<br>
has 17 type variables! The desugaring of each <code>let</code> doubles the size of<br>
the program and of its resulting type. While such programs are little<br>
likely to appear in practice, it is often the case that functions can<br>
be quite complex and large while their type can be quite simple in the<br>
end, so we should simply avoid retyping each function each time it is<br>
used.</p>
<p>This is precisely what we will do next. Before we present the classic<br>
let-polymorphic type inferencer in Lesson 9, which is based on<br>
environments, we first quickly discuss in Lesson 8 an intermediate<br>
step, namely a naive environment-based variant of the inferencer<br>
defined here.</p>
<p>Go to <a href="#ebook-heading-lesson-8-type-systems-a-naive-environment-based-polymorphic-type-inferencer">Lesson 8, Type Systems: A Naive Environment-based Polymorphic Type Inferencer</a>.</p>
</div></div><div id="ebook-heading-lesson-8-type-systems-a-naive-environment-based-polymorphic-type-inferencer" ebook-toc-level-4 heading="Lesson 8, Type Systems: A Naive Environment-based Polymorphic Type Inferencer"><div><h1 class="mume-header" id="a-naive-environment-based-polymorphic-type-inferencer">A Naive Environment-based Polymorphic Type Inferencer</h1>

<p>In this short lesson we discuss how to quickly turn a naive<br>
environment-based monomorphic type inferencer into a naive let-polymorphic<br>
one. Like in the previous lesson, we only need to change a few<br>
characters. In terms of the K framework, you will learn how to have<br>
both environments and substitution in the same definition.</p>
<p>Like in the previous lesson, all we have to do is to take the LAMBDA<br>
type inferencer in Lesson 5 and only change the rule</p>
<pre class="language-text">rule let X = E in E&apos; =&gt; (lambda X . E&apos;) E
</pre>
<p>as follows:</p>
<pre class="language-text">rule let X = E in E&apos; =&gt; E&apos;[E/X]
</pre>
<p>The reasons why this works have already been explained in the previous<br>
lesson, so we do not repeat them here.</p>
<p>Since our new let rule uses substitution, we have to require the<br>
substitution module at the top and also import SUBSTITUTION in the<br>
current module, besides the already existing UNIFICATION.</p>
<p>Everything which worked with the type inferencer in Lesson 7 should<br>
also work now. Let us only try the exponential type example,</p>
<pre class="language-text">let f00 = lambda x . lambda y . x in
  let f01 = lambda x . f00 (f00 x) in
    let f02 = lambda x . f01 (f01 x) in
      let f03 = lambda x . f02 (f02 x) in
        let f04 = lambda x . f03 (f03 x) in
          f04
</pre>
<p>As expected, this gives us precisely the same type as in Lesson 7.</p>
<p>So the only difference between this type inferencer and the one in<br>
Lesson 7 is that substitution is only used for LAMBDA-to-LAMBDA<br>
transformations, but not for infusing types within LAMBDA programs.<br>
Thus, the syntax of LAMBDA programs is preserved intact, which some<br>
may prefer. Nevertheless, this type inferencer is still expensive and<br>
wasteful, because the let-bound expression is typed over and over<br>
again in each place where the let-bound variable occurs.</p>
<p>In the next lesson we will discuss a type inferencer based on the<br>
classic Damas-Hindley-Milner type system, which maximizes the reuse of<br>
typing work by means of parametric types.</p>
<p>Go to <a href="#ebook-heading-lesson-9-type-systems-let-polymorphic-type-inferencer-damas-hindley-milner">Lesson 9, Type Systems: Let-Polymorphic Type Inferencer (Damas-Hindley-Milner)</a>.</p>
</div></div><div id="ebook-heading-lesson-9-type-systems-let-polymorphic-type-inferencer-damas-hindley-milner" ebook-toc-level-4 heading="Lesson 9, Type Systems: Let-Polymorphic Type Inferencer (Damas-Hindley-Milner)"><div><h1 class="mume-header" id="let-polymorphic-type-inferencer-damas-hindley-milner">Let-Polymorphic Type Inferencer (Damas-Hindley-Milner)</h1>

<p>In this lesson we discuss a type inferencer based on what we call today<br>
<em>the Damas-Hindley-Milner type system</em>, which is at the core of many<br>
modern functional programming languages. The first variant of it was<br>
proposed by Hindley in 1969, then, interestingly, Milner rediscovered<br>
it in 1978 in the context of the ML language. Damas formalized it as<br>
a type system in his PhD thesis in 1985. More specifically, our type<br>
inferencer here, like many others as well as many implementations of<br>
it, follows more closely the syntax-driven variant proposed by Clement<br>
in 1987.</p>
<p>In terms of K, we will see how easily we can turn one definition which<br>
is considered naive (our previous type inferencer in Lesson 8) into a<br>
definition which is considered advanced. All we have to do is to<br>
change one existing rule (the rule of the let binder) and to add a new<br>
one. We will also learn some new predefined features of K, which make<br>
the above possible.</p>
<p>The main idea is to replace the rule</p>
<pre class="language-text">rule let X = E in E&apos; =&gt; E&apos;[E/X]
</pre>
<p>which creates potentially many copies of <code>E</code> within <code>E&apos;</code> with a rule<br>
which types <code>E</code> once and then reuses that type in each place where <code>X</code><br>
occurs free in <code>E&apos;</code>. The simplest K way to type <code>E</code> is to declare the<br>
let construct <code>strict(2)</code>. Now we cannot simply bind <code>X</code> to the type<br>
of <code>E</code>, because we would obtain a variant of the naive type inferencer<br>
we already discussed, together with its limitations, in Lesson 5 of this<br>
tutorial. The trick here is to parameterize the type of <code>E</code> in all its<br>
unconstrained fresh types, and then create fresh copies of those<br>
parameters in each free occurrence of <code>X</code> in <code>E&apos;</code>.</p>
<p>Let us discuss some examples, before we go into the technical details.<br>
Consider the first let-polymorphic example which failed to be typed<br>
with our first naive type-inferencer:</p>
<pre class="language-text">let id = lambda x . x
in if (id true) then (id 1) else (id 2)
</pre>
<p>When typing <code>lambda x . x</code>, we get a type of the form <code>t -&gt; t</code>, for some<br>
fresh type <code>t</code>. Instead of assigning this type to <code>id</code> as we did in the<br>
naive type inferencers, we now first parametrize this type in its<br>
fresh variable <code>t</code>, written</p>
<pre class="language-text">(forall t) t -&gt; t
</pre>
<p>and then bind <code>id</code> to this parametric type. The intuition for the<br>
parameter is that it can be instantiated with any other type, so this<br>
parametric type stands, in fact, for infinitely many non-parametric<br>
types. This is similar to what happens in formal logic proof systems,<br>
where <em>rule schemas</em> stand for infinitely many concrete instances of<br>
them. For this reason, parametric types are also called <em>type schemas</em>.</p>
<p>Now each time <code>id</code> is looked up within the let-body, we create a fresh<br>
copy of the parameter <code>t</code>, which can this way be independently<br>
constrained by each local context. Let&apos;s suppose that the three <code>id</code><br>
lookups yield the types <code>t1 -&gt; t1</code>, <code>t2 -&gt; t2</code>, and respectively <code>t3 -&gt; t3</code>.<br>
Then <code>t1</code> will be constrained to be <code>bool</code>, and <code>t2</code> and <code>t3</code> to be <code>int</code>,<br>
so we can now safely type the program above to <code>int</code>.</p>
<p>Therefore, a type schema comprises a summary of all the typing work<br>
that has been done for typing the corresponding expression, and an<br>
instantiation of its parameters with fresh copies represents an<br>
elegant way to reuse all that typing work.</p>
<p>There are some subtleties regarding what fresh types can be made<br>
parameters. Let us consider another example, discussed as part of<br>
Lesson 7 on naive let-polymorphism:</p>
<pre class="language-text">lambda x . (
  let y = lambda z . x
  in if (y true) then (y 1) else (y (lambda x . x))
)
</pre>
<p>This program should type to <code>bool -&gt; bool</code>, as explained in Lesson 7.<br>
The <code>lambda</code> construct will bind <code>x</code> to some fresh type <code>tx</code>. Then the<br>
let-bound expression <code>lambda z . x</code> types to <code>tz -&gt; tx</code> for some<br>
additional fresh type <code>tz</code>. The question now is what should the<br>
parameters of this type be when we generate the type schema? If we<br>
naively parameterize in all fresh variables, that is in both <code>tz</code> and<br>
<code>tx</code> obtaining the type schema <code>(forall tz,tx) tz -&gt; tx</code>, then there will<br>
be no way to infer that the type of <code>x</code>, <code>tx</code>, must be a <code>bool</code>! The<br>
inferred type of this expression would then wrongly be <code>tx -&gt; t</code> for<br>
some fresh types <code>tx</code> and <code>t</code>. That&apos;s because the parameters are replaced<br>
with fresh copies in each occurrence of <code>y</code>, and thus their relationship<br>
to the original <code>x</code> is completely lost. This tells us that we cannot<br>
parameterize in all fresh types that appear in the type of the<br>
let-bound expression. In particular, we cannot parameterize in those<br>
which some variables are already bound to in the current type<br>
environment (like <code>x</code> is bound to <code>tx</code> in our example above).<br>
In our example, the correct type schema is <code>(forall tz) tz -&gt; tx</code>,<br>
which now allows us to correctly infer that <code>tx</code> is <code>bool</code>.</p>
<p>Let us now discuss another example, which should fail to type:</p>
<pre class="language-text">lambda x .
  let f = lambda y . x y
  in if (f true) then (f 1) else (f 2)
</pre>
<p>This should fail to type because <code>lambda y . x y</code> is equivalent to <code>x</code>,<br>
so the conditional imposes the conflicting constraints that <code>x</code> should be<br>
a function whose argument is either a <code>bool</code> or an <code>int</code>. Let us try to<br>
type it using our currently informal procedure. Like in the previous<br>
example, <code>x</code> will be bound to a fresh type <code>tx</code>. Then the let-bound<br>
expression types to <code>ty -&gt; tz</code> with <code>ty</code> and <code>tz</code> fresh types, adding also<br>
the constraint <code>tx = ty -&gt; tz</code>. What should the parameters of this type<br>
be? If we ignore the type constraint and simply make both <code>ty</code> and <code>tz</code><br>
parameters because no variable is bound to them in the type<br>
environment (indeed, the only variable <code>x</code> in the type environment is<br>
bound to <code>tx</code>), then we can wrongly type this program to <code>tx -&gt; tz</code><br>
following a reasoning similar to the one in the example above.<br>
In fact, in this example, none of <code>ty</code> and <code>tz</code> can be parameters, because<br>
they are constrained by <code>tx</code>.</p>
<p>The examples above tell us two things: first, that we have to take the<br>
type constraints into account when deciding the parameters of the<br>
schema; second, that after applying the most-general-unifier solution<br>
given by the type constraints everywhere, the remaining fresh types<br>
appearing anywhere in the type environment are consequently constrained<br>
and cannot be turned into parameters. Since the type environment can in<br>
fact also hold type schemas, which already bind some types, we only need<br>
to ensure that none of the fresh types appearing free anywhere in the<br>
type environment are turned into parameters of type schemas.</p>
<p>Thanks to generic support offered by the K tool, we can easily achieve<br>
all the above as follows.</p>
<p>First, add syntax for type schemas:</p>
<pre class="language-text">syntax TypeSchema ::= &quot;(&quot; &quot;forall&quot; Set &quot;)&quot; Type  [binder]
</pre>
<p>The definition below will be given in such a way that the <code>Set</code> argument<br>
of a type schema will always be a set of fresh types. We also declare<br>
this construct to be a <code>binder</code>, so that we can make use of the generic<br>
free variable function provided by the K tool.</p>
<p>We now replace the old rule for <code>let</code></p>
<pre class="language-text">rule let X = E in E&apos; =&gt; E&apos;[E/X]
</pre>
<p>with the following rule:</p>
<pre class="language-text">rule &lt;k&gt; let X = T:Type in E =&gt; E ~&gt; tenv(TEnv) ...&lt;/k&gt;
     &lt;mgu&gt; Theta:Mgu &lt;/mgu&gt;
     &lt;tenv&gt; TEnv
      =&gt; TEnv[(forall freeVariables(applyMgu(Theta, T)) -Set
                      freeVariables(applyMgu(Theta, values TEnv))
              ) applyMgu(Theta, T) / X]
     &lt;/tenv&gt;
</pre>
<p>So the type <code>T</code> of <code>E</code> is being parameterized and then bound to <code>X</code> in the<br>
type environment. The current mgu <code>Theta</code>, which comprises all the type<br>
constraints accumulated so far, is applied to both <code>T</code> and the types in<br>
the type environment. The remaining fresh types in <code>T</code> which do not<br>
appear free in the type environment are then turned into type parameters.<br>
The function <code>freeVariables</code> returns, as expected, the free variables of<br>
its argument as a <code>Set</code>; this is why we declared the type schema to be a<br>
binder above.</p>
<p>Now a LAMBDA variable in the type environment can be bound to either a<br>
type or a type schema. In the first case, the previous rule we had<br>
for variable lookup can be reused, but we have to make sure we check<br>
that <code>T</code> there is of sort <code>Type</code> (adding a sort membership, for example).<br>
In the second case, as explained above, we have to create fresh copies<br>
of the parameters. This can be easily achieved with another<br>
predefined K function, as follows:</p>
<pre class="language-text">rule &lt;k&gt; X:Id =&gt; freshVariables(Tvs,T) ...&lt;/k&gt;
     &lt;tenv&gt;... X |-&gt; (forall Tvs) T ...&lt;/tenv&gt;
</pre>
<p>Indeed, <code>freshVariables</code> takes a set of variables and a term, and returns the<br>
same term but with each of the given variables replaced by a fresh copy.</p>
<p>The operations <code>freeVariables</code> and <code>freshVariables</code> are useful in many K<br>
definitions, so they are predefined in module <code>substitution.k</code>.</p>
<p>Our definition of this let-polymorphic type inferencer is now<br>
complete. To test it, <code>kompile</code> it and then <code>krun</code> all the LAMBDA<br>
programs discussed since Lesson 4. They should all work as expected.</p>
</div></div><div id="ebook-heading-learning-language-design-and-semantics-using-k" ebook-toc-level-2 heading="Learning Language Design and Semantics using K"><div><h1 class="mume-header" id="k-languages">K Languages</h1>

<p>Here we present several &quot;real-world&quot; language examples. These languages<br>
demonstrate many of the features you would expect to find in a full-fledged<br>
programming language.</p>
<ul>
<li>SIMPLE: Imperative programming language with threads.</li>
<li>KOOL: SIMPLE extended with object-oriented features.</li>
<li>FUN: A functional language with algebraic data-types and pattern-matching.</li>
<li>LOGIK: A logical programming language based on clause unification.</li>
</ul>
</div></div><div id="ebook-heading-part-7-simple-designing-imperative-programming-languages" ebook-toc-level-3 heading="Part 7: SIMPLE: Designing Imperative Programming Languages"><div><h1 class="mume-header" id="simple-untyped">SIMPLE &#x2014; Untyped</h1>

<p>Author: Grigore Ro&#x219;u (<a href="mailto:grosu@illinois.edu">grosu@illinois.edu</a>)<br>
Organization: University of Illinois at Urbana-Champaign</p>
<p>Author: Traian Florin &#x218;erb&#x103;nu&#x21B;&#x103; (<a href="mailto:traian.serbanuta@unibuc.ro">traian.serbanuta@unibuc.ro</a>)<br>
Organization: University of Bucharest</p>
<h2 class="mume-header" id="abstract">Abstract</h2>

<p>This is the <strong>K</strong> semantic definition of the untyped SIMPLE language.<br>
SIMPLE is intended to be a pedagogical and research language that captures<br>
the essence of the imperative programming paradigm, extended with several<br>
features often encountered in imperative programming languages.<br>
A program consists of a set of global variable declarations and<br>
function definitions.  Like in C, function definitions cannot be<br>
nested and each program must have one function called <code>main</code>,<br>
which is invoked when the program is executed.  To make it more<br>
interesting and to highlight some of <strong>K</strong>&apos;s strengths, SIMPLE includes<br>
the following features in addition to the conventional imperative<br>
expression and statement constructs:</p>
<ul>
<li>
<p>Multidimensional arrays and array references.  An array evaluates<br>
to an array reference, which is a special value holding a location (where<br>
the elements of the array start) together with the size of the array;<br>
the elements of the array can be array references themselves (particularly<br>
when the array is multi-dimensional).  Array references are ordinary values,<br>
so they can be assigned to variables and passed/received by functions.</p>
</li>
<li>
<p>Functions and function values.  Functions can have zero or<br>
more parameters and can return abruptly using a <code>return</code> statement.<br>
SIMPLE follows a call-by-value parameter passing style, with static scoping.<br>
Function names evaluate to function abstractions, which hereby become ordinary<br>
values in the language, same like the array references.</p>
</li>
<li>
<p>Blocks with locals.  SIMPLE variables can be declared<br>
anywhere, their scope being from the place where they are declared<br>
until the end of the most nested enclosing block.</p>
</li>
<li>
<p>Input/Output.  The expression <code>read()</code> evaluates to the<br>
next value in the input buffer, and the statement <code>write(e)</code><br>
evaluates <code>e</code> and outputs its value to the output buffer.  The<br>
input and output buffers are lists of values.</p>
</li>
<li>
<p>Exceptions.  SIMPLE has parametric exceptions (the value thrown as<br>
an exception can be caught and bound).</p>
</li>
<li>
<p>Concurrency via dynamic thread creation/termination and<br>
synchronization.  One can spawn a thread to execute any statement.<br>
The spawned thread shares with its parent its environment at creation time.<br>
Threads can be synchronized via a join command which blocks the current thread<br>
until the joined thread completes, via re-entrant locks which can be acquired<br>
and released, as well as through rendezvous commands.</p>
</li>
</ul>
<p>Like in many other languages, some of SIMPLE&apos;s constructs can be<br>
desugared into a smaller set of basic constructs.  We do that at the end<br>
of the syntax module, and then we only give semantics to the core constructs.</p>
<p><strong>Note</strong>: This definition is commented slightly more than others, because it is<br>
intended to be one of the first non-trivial definitions that the new<br>
user of <strong>K</strong> sees.  We recommend the beginner user to first check the<br>
language definitions discussed in the <strong>K</strong> tutorial.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> SIMPLE<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> DOMAINS<span class="token operator">-</span>SYNTAX
</pre><h2 class="mume-header" id="syntax">Syntax</h2>

<p>We start by defining the SIMPLE syntax.  The language constructs discussed<br>
above have the expected syntax and evaluation strategies.  Recall that in <strong>K</strong><br>
we annotate the syntax with appropriate strictness attributes, thus giving<br>
each language construct the desired evaluation strategy.</p>
<h2 class="mume-header" id="identifiers">Identifiers</h2>

<p>Recall from the <strong>K</strong> tutorial that identifiers are builtin and come under the<br>
syntactic category <code>Id</code>.  The special identifier for the function<br>
<code>main</code> belongs to all programs, and plays a special role in the semantics,<br>
so we declare it explicitly.  This would not be necessary if the identifiers<br>
were all included automatically in semantic definitions, but that is not<br>
possible because of parsing reasons (e.g., <strong>K</strong> variables used to match<br>
concrete identifiers would then be ambiguously parsed as identifiers).  They<br>
are only included in the parser generated to parse programs (and used by the<br>
<code>kast</code> tool).  Consequently, we have to explicitly declare all the<br>
concrete identifiers that play a special role in the semantics, like<br>
<code>main</code> below.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Id">Id</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;main&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
</pre><h2 class="mume-header" id="declarations">Declarations</h2>

<p>There are two types of declarations: for variables (including arrays) and<br>
for functions.  We are going to allow declarations of the form<br>
<code>var x=10, a[10,10], y=23;</code>, which is why we allow the <code>var</code><br>
keyword to take a list of expressions.  The non-terminals used in the two<br>
productions below are defined shortly.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;var&quot;</span> Exps <span class="token string">&quot;;&quot;</span>
                <span class="token operator">|</span> <span class="token string">&quot;function&quot;</span> <span class="token keyword keyword-Id">Id</span> <span class="token string">&quot;(&quot;</span> Ids <span class="token string">&quot;)&quot;</span> Block
</pre><h2 class="mume-header" id="expressions">Expressions</h2>

<p>The expression constructs below are standard.  Increment (<code>++</code>) takes<br>
an expression rather than a variable because it can also increment an array<br>
element.  Recall that the syntax we define in <strong>K</strong> is what we call <em>the syntax<br>
of the semantics</em>: while powerful enough to define non-trivial syntaxes<br>
(thanks to the underlying SDF technology that we use), we typically refrain<br>
from defining precise syntaxes, that is, ones which accept precisely the<br>
well-formed programs (that would not be possible anyway in general).  That job<br>
is deferred to type systems, which can also be defined in <strong>K</strong>.  In other words,<br>
we are not making any effort to guarantee syntactically that only variables<br>
or array elements are passed to the increment construct, we allow any<br>
expression.  Nevertheless, we will only give semantics to those, so expressions<br>
of the form <code>++5</code>, which parse (but which will be rejected by our type<br>
system in the typed version of SIMPLE later), will get stuck when executed.<br>
Arrays can be multidimensional and can hold other arrays, so their<br>
lookup operation takes a list of expressions as argument and applies to an<br>
expression (which can in particular be another array lookup), respectively.<br>
The construct <code>sizeOf</code> gives the size of an array in number of elements<br>
of its first dimension.  Note that almost all constructs are strict.  The only<br>
constructs which are not strict are the increment (since its first argument<br>
gets updated, so it cannot be evaluated), the input read which takes no<br>
arguments so strictness is irrelevant for it, the logical and and or constructs<br>
which are short-circuited, the thread spawning construct which creates a new<br>
thread executing the argument expression and return its unique identifier to<br>
the creating thread (so it cannot just evaluate its argument in place), and the<br>
assignment which is only strict in its second argument (for the same reason as<br>
the increment).</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span> <span class="token operator">|</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token operator">|</span> <span class="token keyword keyword-String">String</span> <span class="token operator">|</span> <span class="token keyword keyword-Id">Id</span>
               <span class="token operator">|</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span>             <span class="token punctuation">[</span><span class="token class-name">bracket</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;++&quot;</span> Exp
               &gt; Exp <span class="token string">&quot;[&quot;</span> Exps <span class="token string">&quot;]&quot;</span>        <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               &gt; Exp <span class="token string">&quot;(&quot;</span> Exps <span class="token string">&quot;)&quot;</span>        <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;-&quot;</span> Exp                 <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;sizeOf&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span>    <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;read&quot;</span> <span class="token string">&quot;(&quot;</span> <span class="token string">&quot;)&quot;</span>
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;*&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;/&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;%&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;+&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;-&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               &gt; <span class="token class-name">non-assoc</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;&lt;&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;&lt;=&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;&gt;&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;&gt;=&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;==&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;!=&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               &gt; <span class="token string">&quot;!&quot;</span> Exp                 <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;&amp;&amp;&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;||&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               &gt; <span class="token string">&quot;spawn&quot;</span> Block
               &gt; Exp <span class="token string">&quot;=&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">right</span><span class="token punctuation">]</span>
</pre><p>We also need comma-separated lists of identifiers and of expressions.<br>
Moreover, we want them to be strict, that is, to evaluate to lists of results<br>
whenever requested (e.g., when they appear as strict arguments of<br>
the constructs above).</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Ids  <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>           <span class="token punctuation">[</span>overload<span class="token punctuation">(</span>Exps<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Exps <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Exp<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>          <span class="token punctuation">[</span>overload<span class="token punctuation">(</span>Exps<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">strict</span><span class="token punctuation">]</span>  <span class="token comment">// automatically hybrid now</span>
  <span class="token keyword keyword-syntax">syntax</span> Exps <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Ids
  <span class="token keyword keyword-syntax">syntax</span> Val
  <span class="token keyword keyword-syntax">syntax</span> Vals <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Val<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>          <span class="token punctuation">[</span>overload<span class="token punctuation">(</span>Exps<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Bottom
  <span class="token keyword keyword-syntax">syntax</span> Bottoms <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Bottom<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>    <span class="token punctuation">[</span>overload<span class="token punctuation">(</span>Exps<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Ids <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Bottoms
</pre><h2 class="mume-header" id="statements">Statements</h2>

<p>Most of the statement constructs are standard for imperative languages.<br>
We syntactically distinguish between empty and non-empty blocks, because we<br>
chose <code>Stmts</code> not to be a (<code>;</code>-separated) list of<br>
<code>Stmt</code>.  Variables can be declared anywhere inside a block, their scope<br>
ending with the block.  Expressions are allowed to be used for their side<br>
effects only (followed by a semicolon <code>;</code>).  Functions are allowed<br>
to abruptly return.  The exceptions are parametric, i.e., one can throw a value<br>
which is bound to the variable declared by <code>catch</code>.  Threads can be<br>
dynamically created and terminated, and can synchronize with <code>join</code>,<br>
<code>acquire</code>, <code>release</code> and <code>rendezvous</code>.  Note that the<br>
strictness attributes obey the intended evaluation strategy of the various<br>
constructs.  In particular, the if-then-else construct is strict only in its<br>
first argument (the if-then construct will be desugared into if-then-else),<br>
while the loop constructs are not strict in any arguments.  The <code>print</code><br>
statement construct is variadic, that is, it takes an arbitrary number of<br>
arguments.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Block <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;{&quot;</span> <span class="token string">&quot;}&quot;</span>
                <span class="token operator">|</span> <span class="token string">&quot;{&quot;</span> Stmt <span class="token string">&quot;}&quot;</span>

  <span class="token keyword keyword-syntax">syntax</span> Stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Block
                <span class="token operator">|</span> Exp <span class="token string">&quot;;&quot;</span>                               <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;if&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Block <span class="token string">&quot;else&quot;</span> Block   <span class="token punctuation">[</span><span class="token class-name">avoid</span><span class="token punctuation">,</span> <span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;if&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Block                <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;while&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Block
                <span class="token operator">|</span> <span class="token string">&quot;for&quot;</span> <span class="token string">&quot;(&quot;</span> Stmt Exp <span class="token string">&quot;;&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Block  <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;return&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                      <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;return&quot;</span> <span class="token string">&quot;;&quot;</span>                          <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;print&quot;</span> <span class="token string">&quot;(&quot;</span> Exps <span class="token string">&quot;)&quot;</span> <span class="token string">&quot;;&quot;</span>              <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
<span class="token comment">// NOTE: print strict allows non-deterministic evaluation of its arguments</span>
<span class="token comment">// Either keep like this but document, or otherwise make Exps seqstrict.</span>
<span class="token comment">// Of define and use a different expression list here, which is seqstrict.</span>
                <span class="token operator">|</span> <span class="token string">&quot;try&quot;</span> Block <span class="token string">&quot;catch&quot;</span> <span class="token string">&quot;(&quot;</span> <span class="token keyword keyword-Id">Id</span> <span class="token string">&quot;)&quot;</span> Block
                <span class="token operator">|</span> <span class="token string">&quot;throw&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                       <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;join&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                        <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;acquire&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                     <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;release&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                     <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;rendezvous&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                  <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
</pre><p>The reason we allow <code>Stmts</code> as the first argument of <code>for</code><br>
instead of <code>Stmt</code> is because we want to allow more than one statement<br>
to be executed when the loop is initialized.  Also, as seens shorly, macros<br>
may expand one statement into more statements; for example, an initialized<br>
variable declaration statement <code>var x=0;</code> desugars into two statements,<br>
namely <code>var x; x=0;</code>, so if we use <code>Stmt</code> instead of <code>Stmts</code><br>
in the production of <code>for</code> above then we risk that the macro expansion<br>
of statement <code>var x=0;</code> happens before the macro expansion of <code>for</code>,<br>
also shown below, in which case the latter would not apply anymore because<br>
of syntactic mismatch.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Stmt Stmt                          <span class="token punctuation">[</span><span class="token class-name">right</span><span class="token punctuation">]</span>

<span class="token comment">// I wish I were able to write the following instead, but confuses the parser.</span>
<span class="token comment">//</span>
<span class="token comment">// syntax Stmts ::= List{Stmt,&quot;&quot;}</span>
<span class="token comment">// syntax Top ::= Stmt | &quot;function&quot; Id &quot;(&quot; Ids &quot;)&quot; Block</span>
<span class="token comment">// syntax Pgm ::= List{Top,&quot;&quot;}</span>
<span class="token comment">//</span>
<span class="token comment">// With that, I could have also eliminated the empty block</span>
</pre><h2 class="mume-header" id="desugared-syntax">Desugared Syntax</h2>

<p>This part desugars some of SIMPLE&apos;s language constructs into core ones.<br>
We only want to give semantics to core constructs, so we get rid of the<br>
derived ones before we start the semantics.  All desugaring macros below are<br>
straightforward.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> if <span class="token punctuation">(</span>E<span class="token punctuation">)</span> S <span class="token operator">=&gt;</span> if <span class="token punctuation">(</span>E<span class="token punctuation">)</span> S else <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword keyword-rule">rule</span> for<span class="token punctuation">(</span>Start Cond<span class="token punctuation">;</span> Step<span class="token punctuation">)</span> <span class="token punctuation">{</span>S<span class="token punctuation">}</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>Start while <span class="token punctuation">(</span>Cond<span class="token punctuation">)</span> <span class="token punctuation">{</span>S Step<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span>
  <span class="token keyword keyword-rule">rule</span> for<span class="token punctuation">(</span>Start Cond<span class="token punctuation">;</span> Step<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>Start while <span class="token punctuation">(</span>Cond<span class="token punctuation">)</span> <span class="token punctuation">{</span>Step<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span>
  <span class="token keyword keyword-rule">rule</span> var E1<span class="token punctuation">:</span>Exp<span class="token punctuation">,</span> E2<span class="token punctuation">:</span>Exp<span class="token punctuation">,</span> Es<span class="token punctuation">:</span>Exps<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> var E1<span class="token punctuation">;</span> var E2<span class="token punctuation">,</span> Es<span class="token punctuation">;</span>
  <span class="token keyword keyword-rule">rule</span> var X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=</span> E<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> var X<span class="token punctuation">;</span> X <span class="token operator">=</span> E<span class="token punctuation">;</span>
</pre><p>For the semantics, we can therefore assume from now on that each<br>
conditional has both branches, that there are only <code>while</code> loops, and<br>
that each variable is declared alone and without any initialization as part of<br>
the declaration.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-endmodule">endmodule</span>


<span class="token keyword keyword-module">module</span> SIMPLE<span class="token operator">-</span>UNTYPED
  <span class="token keyword keyword-imports">imports</span> SIMPLE<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> DOMAINS
</pre><h2 class="mume-header" id="basic-semantic-infrastructure">Basic Semantic Infrastructure</h2>

<p>Before one starts adding semantic rules to a <strong>K</strong> definition, one needs to<br>
define the basic semantic infrastructure consisting of definitions for<br>
<code>values</code> and <code>configuration</code>.  As discussed in the definitions<br>
in the <strong>K</strong> tutorial, the values are needed to know when to stop applying<br>
the heating rules and when to start applying the cooling rules corresponding<br>
to strictness or context declarations.  The configuration serves as a backbone<br>
for the process of configuration abstraction which allows users to only<br>
mention the relevant cells in each semantic rule, the rest of the configuration<br>
context being inferred automatically.  Although in some cases the configuration<br>
could be automatically inferred from the rules, we believe that it is very<br>
useful for language designers/semanticists to actually think of and design<br>
their configuration explicitly, so the current implementation of <strong>K</strong> requires<br>
one to define it.</p>
<h2 class="mume-header" id="values">Values</h2>

<p>We here define the values of the language that the various fragments of<br>
programs evaluate to.  First, integers and Booleans are values.  As discussed,<br>
arrays evaluate to special array reference values holding (1) a location from<br>
where the array&apos;s elements are contiguously allocated in the store, and<br>
(2) the size of the array.  Functions evaluate to function values as<br>
&#x3BB;-abstractions (we do not need to evaluate functions to closures<br>
because each function is executed in the fixed global environment and<br>
function definitions cannot be nested).  Like in IMP and other<br>
languages, we finally tell the tool that values are <strong>K</strong> results.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span> <span class="token operator">|</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token operator">|</span> <span class="token keyword keyword-String">String</span>
               <span class="token operator">|</span> array<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span>
               <span class="token operator">|</span> lambda<span class="token punctuation">(</span>Ids<span class="token punctuation">,</span>Stmt<span class="token punctuation">)</span>
  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Val
  <span class="token keyword keyword-syntax">syntax</span> Exps <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Vals
  <span class="token keyword keyword-syntax">syntax</span> Vals <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Bottoms
  <span class="token keyword keyword-syntax">syntax</span> KResult <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Val
                   <span class="token operator">|</span> Vals  <span class="token comment">// TODO: should not need this</span>
</pre><p>The inclusion of values in expressions follows the methodology of<br>
syntactic definitions (like, e.g., in SOS): extend the syntax of the language<br>
to encompass all values and additional constructs needed to give semantics.<br>
In addition to that, it allows us to write the semantic rules using the<br>
original syntax of the language, and to parse them with the same (now extended<br>
with additional values) parser.  If writing the semantics directly on the <strong>K</strong><br>
AST, using the associated labels instead of the syntactic constructs, then one<br>
would not need to include values in expressions.</p>
<h2 class="mume-header" id="configuration">Configuration</h2>

<p>The <strong>K</strong> configuration of SIMPLE consists of a top level cell, <code>T</code>,<br>
holding a <code>threads</code> cell, a global environment map cell <code>genv</code><br>
mapping the global variables and function names to their locations, a shared<br>
store map cell <code>store</code> mapping each location to some value, a set cell<br>
<code>busy</code> holding the locks which have been acquired but not yet released<br>
by threads, a set cell <code>terminated</code> holding the unique identifiers of<br>
the threads which already terminated (needed for <code>join</code>), <code>input</code><br>
and <code>output</code> list cells, and a <code>nextLoc</code> cell holding a natural<br>
number indicating the next available location.  Unlike in the small languages<br>
in the <strong>K</strong> tutorial, where we used the fresh predicate to generate fresh<br>
locations, in larger languages, like SIMPLE, we prefer to explicitly manage<br>
memory.  The location counter in <code>nextLoc</code> models an actual physical<br>
location in the store; for simplicity, we assume arbitrarily large memory and<br>
no garbage collection.  The <code>threads</code> cell contains one <code>thread</code><br>
cell for each existing thread in the program.  Note that the thread cell has<br>
multiplicity <code>*</code>, which means that at any given moment there could be zero,<br>
one or more <code>thread</code> cells.  Each <code>thread</code> cell contains a<br>
computation cell <code>k</code>, a <code>control</code> cell holding the various<br>
control structures needed to jump to certain points of interest in the program<br>
execution, a local environment map cell <code>env</code> mapping the thread local<br>
variables to locations in the store, and finally a <code>holds</code> map cell<br>
indicating what locks have been acquired by the thread and not released so far<br>
and how many times (SIMPLE&apos;s locks are re-entrant).  The <code>control</code> cell<br>
currently contains only two subcells, a function stack <code>fstack</code> which<br>
is a list and an exception stack <code>xstack</code> which is also a list.<br>
One can add more control structures in the <code>control</code> cell, such as a<br>
stack for break/continue of loops, etc., if the language is extended with more<br>
control-changing constructs.  Note that all cells except for <code>k</code> are<br>
also initialized, in that they contain a ground term of their corresponding<br>
sort.  The <code>k</code> cell is initialized with the program that will be passed<br>
to the <strong>K</strong> tool, as indicated by the <code>$PGM</code> variable, followed by the<br>
<code>execute</code> task (defined shortly).</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token comment">// the syntax declarations below are required because the sorts are</span>
  <span class="token comment">// referenced directly by a production and, because of the way KIL to KORE</span>
  <span class="token comment">// is implemented, the configuration syntax is not available yet</span>
  <span class="token comment">// should simply work once KIL is removed completely</span>
  <span class="token comment">// check other definitions for this hack as well</span>

  <span class="token keyword keyword-syntax">syntax</span> ControlCell
  <span class="token keyword keyword-syntax">syntax</span> ControlCellFragment

  <span class="token keyword keyword-configuration">configuration</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>T</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>red<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>threads</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>orange<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>thread</span> <span class="token attr-name">multiplicity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>*<span class="token punctuation">&quot;</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Map<span class="token punctuation">&quot;</span></span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>yellow<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>pink<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token operator">-</span><span class="token number">1</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">&gt;</span></span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>green<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> $PGM<span class="token punctuation">:</span>Stmt <span class="token operator">~&gt;</span> execute <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
                    <span class="token comment">//&lt;br/&gt; // TODO(KORE): support latex annotations #1799</span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>control</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>cyan<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fstack</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>blue<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fstack</span><span class="token punctuation">&gt;</span></span>
                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>xstack</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>purple<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>xstack</span><span class="token punctuation">&gt;</span></span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>control</span><span class="token punctuation">&gt;</span></span>
                    <span class="token comment">//&lt;br/&gt; // TODO(KORE): support latex annotations #1799</span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>violet<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>holds</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>black<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>holds</span><span class="token punctuation">&gt;</span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>thread</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>threads</span><span class="token punctuation">&gt;</span></span>
                <span class="token comment">//&lt;br/&gt; // TODO(KORE): support latex annotations #1799</span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>genv</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>pink<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>genv</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>white<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>busy</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>cyan<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Set <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>busy</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>terminated</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>red<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Set <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>terminated</span><span class="token punctuation">&gt;</span></span>
                <span class="token comment">//&lt;br/&gt; // TODO(KORE): support latex annotations #1799</span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>magenta<span class="token punctuation">&quot;</span></span> <span class="token attr-name">stream</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>stdin<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>input</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>output</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>brown<span class="token punctuation">&quot;</span></span> <span class="token attr-name">stream</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>stdout<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>output</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nextLoc</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>gray<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token number">0</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>nextLoc</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>T</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="declarations-and-initialization">Declarations and Initialization</h2>

<p>We start by defining the semantics of declarations (for variables,<br>
arrays and functions).</p>
<h2 class="mume-header" id="variable-declaration">Variable Declaration</h2>

<p>The SIMPLE syntax was desugared above so that each variable is<br>
declared alone and its initialization is done as a separate statement.<br>
The semantic rule below matches resulting variable declarations of the<br>
form <code>var X;</code> on top of the <code>k</code> cell<br>
(indeed, note that the <code>k</code> cell is complete, or round, to the<br>
left, and is torn, or ruptured, to the right), allocates a fresh<br>
location <code>L</code> in the store which is initialized with a special value<br>
<code>&#x22A5;</code> (indeed, the unit <code>.</code>, or nothing, is matched anywhere<br>
in the map &#x2012;note the tears at both sides&#x2012; and replaced with the<br>
mapping <code>L &#x21A6; &#x22A5;</code>), and binds <code>X</code> to <code>L</code> in the local<br>
environment shadowing previous declarations of <code>X</code>, if any.<br>
This possible shadowing of <code>X</code> requires us to therefore update the<br>
entire environment map, which is expensive and can significantly slow<br>
down the execution of larger programs.  On the other hand, since we know<br>
that <code>L</code> is not already bound in the store, we simply add the binding<br>
<code>L &#x21A6; &#x22A5;</code> to the store, thus avoiding a potentially complete<br>
traversal of the the store map in order to update it.  We prefer the approach<br>
used for updating the store whenever possible, because, in addition to being<br>
faster, it offers more true concurrency than the latter; indeed, according<br>
to the concurrent semantics of <code>K</code>, the store is not frozen while<br>
<code>L &#x21A6; &#x22A5;</code> is added to it, while the environment is frozen during the<br>
update operation <code>Env[L/X]</code>.  The variable declaration command is<br>
also removed from the top of the computation cell and the fresh location<br>
counter is incremented.  The undefined symbol <code>&#x22A5;</code> added in the store<br>
is of sort <code>KItem</code>, instead of <code>Val</code>, on purpose; this way, the<br>
store lookup rules will get stuck when one attempts to lookup an<br>
uninitialized location.  All the above happen in one transactional step,<br>
with the rule below.  Note also how configuration abstraction allows us to<br>
only mention the needed cells; indeed, as the configuration above states,<br>
the <code>k</code> and <code>env</code> cells are actually located within a<br>
<code>thread</code> cell within the <code>threads</code> cell, but one needs<br>
not mention these: the configuration context of the rule is<br>
automatically transformed to match the declared configuration<br>
structure.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;undefined&quot;</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> var X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token operator">=&gt;</span> Env<span class="token punctuation">[</span>X &lt;<span class="token operator">-</span> L<span class="token punctuation">]</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Map <span class="token operator">=&gt;</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; undefined <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nextLoc</span><span class="token punctuation">&gt;</span></span> L <span class="token operator">=&gt;</span> L <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>nextLoc</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="array-declaration">Array Declaration</h2>

<p>The <strong>K</strong> semantics of the uni-dimensional array declaration is somehow similar<br>
to the above declaration of ordinary variables.  First, note the<br>
context declaration below, which requests the evaluation of the array<br>
dimension.  Once evaluated, say to a natural number <code>N</code>, then<br>
<code>N +Int 1</code> locations are allocated in the store for<br>
an array of size <code>N</code>, the additional location (chosen to be the first<br>
one allocated) holding the array reference value.  The array reference<br>
value <code>array(L,N)</code> states that the array has size <code>N</code> and its<br>
elements are located contiguously in the store starting with location<br>
<code>L</code>.  The operation <code>L &#x2026; L&apos; &#x21A6; V</code>, defined at the end of this<br>
file in the auxiliary operation section, initializes each location in<br>
the list <code>L &#x2026; L&apos;</code> to <code>V</code>.  Note that, since the dimensions of<br>
array declarations can be arbitrary expressions, this virtually means<br>
that we can dynamically allocate memory in SIMPLE by means of array<br>
declarations.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-context">context</span> var _<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">[</span>HOLE<span class="token punctuation">]</span><span class="token punctuation">;</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> var X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">[</span>N<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token operator">=&gt;</span> Env<span class="token punctuation">[</span>X &lt;<span class="token operator">-</span> L<span class="token punctuation">]</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Map <span class="token operator">=&gt;</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; array<span class="token punctuation">(</span>L <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">,</span> N<span class="token punctuation">)</span>
                          <span class="token punctuation">(</span>L <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">(</span>L <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> N<span class="token punctuation">)</span> <span class="token operator">|</span><span class="token operator">-</span>&gt; undefined <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nextLoc</span><span class="token punctuation">&gt;</span></span> L <span class="token operator">=&gt;</span> L <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span> <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> N <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>nextLoc</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> N <span class="token operator">&gt;=</span><span class="token keyword keyword-Int">Int</span> <span class="token number">0</span>
</pre><p>SIMPLE allows multi-dimensional arrays.  For semantic simplicity, we<br>
desugar them all into uni-dimensional arrays by code transformation.<br>
This way, we only need to give semantics to uni-dimensional arrays.<br>
First, note that the context rule above actually evaluates all the array<br>
dimensions (that&apos;s why we defined the expression lists strict!):<br>
Upon evaluating the array dimensions, the code generation rule below<br>
desugars multi-dimensional array declaration to uni-dimensional declarations.<br>
To this aim, we introduce two special unique variable identifiers,<br>
<code>$1</code> and <code>$2</code>.  The first variable, <code>$1</code>, iterates<br>
through and initializes each element of the first dimension with an array<br>
of the remaining dimensions, declared as variable <code>$2</code>:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Id">Id</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;$1&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token string">&quot;$2&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> var X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">[</span>N1<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> N2<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token operator">=&gt;</span> var X<span class="token punctuation">[</span>N1<span class="token punctuation">]</span><span class="token punctuation">;</span>
       <span class="token punctuation">{</span>
         for<span class="token punctuation">(</span>var $<span class="token number">1</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> $<span class="token number">1</span> <span class="token operator">&lt;=</span> N1 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>$<span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           var $<span class="token number">2</span><span class="token punctuation">[</span>N2<span class="token punctuation">,</span> Vs<span class="token punctuation">]</span><span class="token punctuation">;</span>
           X<span class="token punctuation">[</span>$<span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> $<span class="token number">2</span><span class="token punctuation">;</span>
         <span class="token punctuation">}</span>
       <span class="token punctuation">}</span>
</pre><p>Ideally, one would like to perform syntactic desugarings like the one<br>
above before the actual semantics.  Unfortunately, that was not possible in<br>
this case because the dimension expressions of the multi-dimensional array need<br>
to be evaluated first.  Indeed, the desugaring rule above does not work if the<br>
dimensions of the declared array are arbitrary expressions, because they can<br>
have side effects (e.g., <code>a[++x,++x]</code>) and those side effects would be<br>
propagated each time the expression is evaluated in the desugaring code (note<br>
that both the loop condition and the nested multi-dimensional declaration<br>
would need to evaluate the expressions given as array dimensions).</p>
<h2 class="mume-header" id="function-declaration">Function declaration</h2>

<p>Functions are evaluated to &#x3BB;-abstractions and stored like any other<br>
values in the store.  A binding is added into the environment for the function<br>
name to the location holding its body.  Similarly to the C language, SIMPLE<br>
only allows function declarations at the top level of the program.  More<br>
precisely, the subsequent semantics of SIMPLE only works well when one<br>
respects this requirement.  Indeed, the simplistic context-free parser<br>
generated by the grammar above is more generous than we may want, in that it<br>
allows function declarations anywhere any declaration is allowed, including<br>
inside arbitrary blocks.  However, as the rule below shows, we are <code>not</code><br>
storing the declaration environment with the &#x3BB;-abstraction value as<br>
closures do.  Instead, as seen shortly, we switch to the global environment<br>
whenever functions are invoked, which is consistent with our requirement that<br>
functions should only be declared at the top.  Thus, if one declares local<br>
functions, then one may see unexpected behaviors (e.g., when one shadows a<br>
global variable before declaring a local function).  The type checker of<br>
SIMPLE, also defined in <strong>K</strong> (see <code>examples/simple/typed/static</code>),<br>
discards programs which do not respect this requirement.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> function F<span class="token punctuation">(</span>Xs<span class="token punctuation">)</span> S <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token operator">=&gt;</span> Env<span class="token punctuation">[</span>F &lt;<span class="token operator">-</span> L<span class="token punctuation">]</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Map <span class="token operator">=&gt;</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; lambda<span class="token punctuation">(</span>Xs<span class="token punctuation">,</span> S<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nextLoc</span><span class="token punctuation">&gt;</span></span> L <span class="token operator">=&gt;</span> L <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>nextLoc</span><span class="token punctuation">&gt;</span></span>
</pre><p>When we are done with the first pass (pre-processing), the computation<br>
cell <code>k</code> contains only the token <code>execute</code> (see the configuration<br>
declaration above, where the computation item <code>execute</code> was placed<br>
right after the program in the <code>k</code> cell of the initial configuration)<br>
and the cell <code>genv</code> is empty.  In this case, we have to call<br>
<code>main()</code> and to initialize the global environment by transferring the<br>
contents of the local environment into it.  We prefer to do it this way, as<br>
opposed to processing all the top level declarations directly within the global<br>
environment, because we want to avoid duplication of semantics: the syntax of<br>
the global declarations is identical to that of their corresponding local<br>
declarations, so the semantics of the latter suffices provided that we copy<br>
the local environment into the global one once we are done with the<br>
pre-processing.  We want this separate pre-processing step precisely because<br>
we want to create the global environment.  All (top-level) functions end up<br>
having their names bound in the global environment and, as seen below, they<br>
are executed in that same global environment; all these mean, in particular,<br>
that the functions &quot;see&quot; each other, allowing for mutual recursion, etc.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;execute&quot;</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> execute <span class="token operator">=&gt;</span> main<span class="token punctuation">(</span><span class="token punctuation">.</span>Exps<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>genv</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token operator">=&gt;</span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>genv</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="expressions-1">Expressions</h2>

<p>We next define the <strong>K</strong> semantics of all the expression constructs.</p>
<h2 class="mume-header" id="variable-lookup">Variable lookup</h2>

<p>When a variable <code>X</code> is the first computational task, and <code>X</code> is bound to some<br>
location <code>L</code> in the environment, and <code>L</code> is mapped to some value <code>V</code> in the<br>
store, then we rewrite <code>X</code> into <code>V</code>:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=&gt;</span> V <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> X <span class="token operator">|</span><span class="token operator">-</span>&gt; L <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; V<span class="token punctuation">:</span>Val <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
</pre><p>Note that the rule above excludes reading <code>&#x22A5;</code>, because <code>&#x22A5;</code> is not<br>
a value and <code>V</code> is checked at runtime to be a value.</p>
<h2 class="mume-header" id="variablearray-increment">Variable/Array increment</h2>

<p>This is tricky, because we want to allow both <code>++x</code> and <code>++a[5]</code>.<br>
Therefore, we need to extract the lvalue of the expression to increment.<br>
To do that, we state that the expression to increment should be wrapped<br>
by the auxiliary <code>lvalue</code> operation and then evaluated.  The semantics<br>
of this auxiliary operation is defined at the end of this file.  For now, all<br>
we need to know is that it takes an expression and evaluates to a location<br>
value.  Location values, also defined at the end of the file, are integers<br>
wrapped with the operation <code>loc</code>, to distinguish them from ordinary<br>
integers.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-context">context</span> <span class="token operator">++</span><span class="token punctuation">(</span>HOLE <span class="token operator">=&gt;</span> lvalue<span class="token punctuation">(</span>HOLE<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token operator">++</span>loc<span class="token punctuation">(</span>L<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> I <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; <span class="token punctuation">(</span>I <span class="token operator">=&gt;</span> I <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="arithmetic-operators">Arithmetic operators</h2>

<p>There is nothing special about the following rules.  They rewrite the<br>
language constructs to their library counterparts when their arguments<br>
become values of expected sorts:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">+</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> Str1 <span class="token operator">+</span> Str2 <span class="token operator">=&gt;</span> Str1 <span class="token operator">+</span><span class="token keyword keyword-String">String</span> Str2
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">-</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">*</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">*</span><span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">/</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">/</span><span class="token keyword keyword-Int">Int</span> I2 <span class="token keyword keyword-requires">requires</span> I2 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K <span class="token number">0</span>
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">%</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">%</span><span class="token keyword keyword-Int">Int</span> I2 <span class="token keyword keyword-requires">requires</span> I2 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K <span class="token number">0</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token operator">-</span> I <span class="token operator">=&gt;</span> <span class="token number">0</span> <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> I
  <span class="token keyword keyword-rule">rule</span> I1 &lt; I2 <span class="token operator">=&gt;</span> I1 &lt;<span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">&lt;=</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">&lt;=</span><span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> I1 &gt; I2 <span class="token operator">=&gt;</span> I1 &gt;<span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">&gt;=</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">&gt;=</span><span class="token keyword keyword-Int">Int</span> I2
</pre><p>The equality and inequality constructs reduce to syntactic comparison<br>
of the two argument values (which is what the equality on <code>K</code> terms does).</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> V1<span class="token punctuation">:</span>Val <span class="token operator">==</span> V2<span class="token punctuation">:</span>Val <span class="token operator">=&gt;</span> V1 <span class="token operator">==</span>K V2
  <span class="token keyword keyword-rule">rule</span> V1<span class="token punctuation">:</span>Val <span class="token operator">!=</span> V2<span class="token punctuation">:</span>Val <span class="token operator">=&gt;</span> V1 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K V2
</pre><p>The logical negation is clear, but the logical conjunction and disjunction<br>
are short-circuited:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token operator">!</span> T <span class="token operator">=&gt;</span> notBool<span class="token punctuation">(</span>T<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">true</span>  <span class="token operator">&amp;&amp;</span> E <span class="token operator">=&gt;</span> E
  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">false</span> <span class="token operator">&amp;&amp;</span> _ <span class="token operator">=&gt;</span> <span class="token boolean">false</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">true</span>  <span class="token operator">||</span> _ <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">false</span> <span class="token operator">||</span> E <span class="token operator">=&gt;</span> E
</pre><h2 class="mume-header" id="array-lookup">Array lookup</h2>

<p>Untyped SIMPLE does not check array bounds (the dynamically typed version of<br>
it, in <code>examples/simple/typed/dynamic</code>, does check for array out of<br>
bounds).  The first rule below desugars the multi-dimensional array access to<br>
uni-dimensional array access; recall that the array access operation was<br>
declared strict, so all sub-expressions involved are already values at this<br>
stage.  The second rule rewrites the array access to a lookup operation at a<br>
precise location; we prefer to do it this way to avoid locking the store.<br>
The semantics of the auxiliary <code>lookup</code> operation is straightforward,<br>
and is defined at the end of the file.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token comment">// The [anywhere] feature is underused, because it would only be used</span>
<span class="token comment">// at the top of the computation or inside the lvalue wrapper. So it</span>
<span class="token comment">// may not be worth, or we may need to come up with a special notation</span>
<span class="token comment">// allowing us to enumerate contexts for [anywhere] rules.</span>
  <span class="token keyword keyword-rule">rule</span> V<span class="token punctuation">:</span>Val<span class="token punctuation">[</span>N1<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> N2<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">]</span> <span class="token operator">=&gt;</span> V<span class="token punctuation">[</span>N1<span class="token punctuation">]</span><span class="token punctuation">[</span>N2<span class="token punctuation">,</span> Vs<span class="token punctuation">]</span>
    <span class="token punctuation">[</span>anywhere<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> array<span class="token punctuation">(</span>L<span class="token punctuation">,</span>_<span class="token punctuation">)</span><span class="token punctuation">[</span>N<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">]</span> <span class="token operator">=&gt;</span> lookup<span class="token punctuation">(</span>L <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> N<span class="token punctuation">)</span>
    <span class="token punctuation">[</span>anywhere<span class="token punctuation">]</span>
</pre><h2 class="mume-header" id="size-of-an-array">Size of an array</h2>

<p>The size of the array is stored in the array reference value, and the<br>
<code>sizeOf</code> construct was declared strict, so:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> sizeOf<span class="token punctuation">(</span>array<span class="token punctuation">(</span>_<span class="token punctuation">,</span>N<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> N
</pre><h2 class="mume-header" id="function-call">Function call</h2>

<p>Function application was strict in both its arguments, so we can<br>
assume that both the function and its arguments are evaluated to<br>
values (the former expected to be a &#x3BB;-abstraction).  The first<br>
rule below matches a well-formed function application on top of the<br>
computation and performs the following steps atomically: it switches<br>
to the function body followed by <code>return;</code> (for the case in<br>
which the function does not use an explicit return statement); it<br>
pushes the remaining computation, the current environment, and the<br>
current control data onto the function stack (the remaining<br>
computation can thus also be discarded from the computation cell,<br>
because an unavoidable subsequent <code>return</code> statement &#x2012;see<br>
above&#x2012; will always recover it from the stack); it switches the<br>
current environment (which is being pushed on the function stack) to<br>
the global environment, which is where the free variables in the<br>
function body should be looked up; it binds the formal parameters to<br>
fresh locations in the new environment, and stores the actual<br>
arguments to those locations in the store (this latter step is easily<br>
done by reducing the problem to variable declarations, whose semantics<br>
we have already defined; the auxiliary operation <code>mkDecls</code> is<br>
defined at the end of the file).  The second rule pops the<br>
computation, the environment and the control data from the function<br>
stack when a <code>return</code> statement is encountered as the next<br>
computational task, passing the returned value to the popped<br>
computation (the popped computation was the context in which the<br>
returning function was called).  Note that the pushing/popping of the<br>
control data is crucial.  Without it, one may have a function that<br>
contains an exception block with a return statement inside, which<br>
would put the <code>xstack</code> cell in an inconsistent state (since the<br>
exception block modifies it, but that modification should be<br>
irrelevant once the function returns).  We add an artificial<br>
<code>nothing</code> value to the language, which is returned by the<br>
nulary <code>return;</code> statements.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span>  <span class="token punctuation">(</span>Map<span class="token punctuation">,</span>K<span class="token punctuation">,</span>ControlCellFragment<span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> lambda<span class="token punctuation">(</span>Xs<span class="token punctuation">,</span>S<span class="token punctuation">)</span><span class="token punctuation">(</span>Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> K <span class="token operator">=&gt;</span> mkDecls<span class="token punctuation">(</span>Xs<span class="token punctuation">,</span>Vs<span class="token punctuation">)</span> S return<span class="token punctuation">;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>control</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fstack</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token operator">=&gt;</span> ListItem<span class="token punctuation">(</span><span class="token punctuation">(</span>Env<span class="token punctuation">,</span>K<span class="token punctuation">,</span>C<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fstack</span><span class="token punctuation">&gt;</span></span>
         C
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>control</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token operator">=&gt;</span> GEnv <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>genv</span><span class="token punctuation">&gt;</span></span> GEnv <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>genv</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> return<span class="token punctuation">(</span>V<span class="token punctuation">:</span>Val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">~&gt;</span> _ <span class="token operator">=&gt;</span> V <span class="token operator">~&gt;</span> K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>control</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fstack</span><span class="token punctuation">&gt;</span></span> ListItem<span class="token punctuation">(</span><span class="token punctuation">(</span>Env<span class="token punctuation">,</span>K<span class="token punctuation">,</span>C<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>List <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fstack</span><span class="token punctuation">&gt;</span></span>
         <span class="token punctuation">(</span>_ <span class="token operator">=&gt;</span> C<span class="token punctuation">)</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>control</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> _ <span class="token operator">=&gt;</span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;nothing&quot;</span>
  <span class="token keyword keyword-rule">rule</span> return<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> return nothing<span class="token punctuation">;</span>
</pre><p>Like for division-by-zero, it is left unspecified what happens<br>
when the <code>nothing</code> value is used in domain calculations.  For<br>
example, from the the perspective of the language semantics,<br>
<code>7 +Int nothing</code> can evaluate to anything, or<br>
may not evaluate at all (be undefined).  If one wants to make sure that<br>
such artificial values are never misused, then one needs to define a static<br>
checker (also using <strong>K</strong>, like our the type checker in<br>
<code>examples/simple/typed/static</code>) and reject programs that do.<br>
Note that, unlike the undefined symbol <code>&#x22A5;</code> which had the sort <code>K</code><br>
instead of <code>Val</code>, we defined <code>nothing</code> to be a value.  That<br>
is because, as explained above, we do not want the program to get<br>
stuck when nothing is returned by a function.  Instead, we want the<br>
behavior to be unspecified; in particular, if one is careful to never<br>
use the returned value in domain computation, like it happens when we<br>
call a function for its side effects (e.g., with a statement of the<br>
form <code>f(x);</code>), then the program does not get stuck.</p>
<h2 class="mume-header" id="read">Read</h2>

<p>The <code>read()</code> expression construct simply evaluates to the next<br>
input value, at the same time discarding the input value from the<br>
<code>in</code> cell.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> read<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> I <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span><span class="token punctuation">&gt;</span></span> ListItem<span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>List <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>input</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="assignment">Assignment</h2>

<p>In SIMPLE, like in C, assignments are expression constructs and not statement<br>
constructs.  To make it a statement all one needs to do is to follow it by a<br>
semi-colon <code>;</code> (see the semantics for expression statements below).<br>
Like for the increment, we want to allow assignments not only to variables but<br>
also to array elements, e.g., <code>e1[e2] = e3</code> where <code>e1</code> evaluates<br>
to an array reference, <code>e2</code> to a natural number, and <code>e3</code> to any<br>
value.  Thus, we first compute the lvalue of the left-hand-side expression<br>
that appears in an assignment, and then we do the actual assignment to the<br>
resulting location:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-context">context</span> <span class="token punctuation">(</span>HOLE <span class="token operator">=&gt;</span> lvalue<span class="token punctuation">(</span>HOLE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> _

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> loc<span class="token punctuation">(</span>L<span class="token punctuation">)</span> <span class="token operator">=</span> V<span class="token punctuation">:</span>Val <span class="token operator">=&gt;</span> V <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; <span class="token punctuation">(</span>_ <span class="token operator">=&gt;</span> V<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="statements-1">Statements</h2>

<p>We next define the <strong>K</strong> semantics of statements.</p>
<h2 class="mume-header" id="blocks">Blocks</h2>

<p>Empty blocks are simply discarded, as shown in the first rule below.<br>
For non-empty blocks, we schedule the enclosed statement but we have to<br>
make sure the environment is recovered after the enclosed statement executes.<br>
Recall that we allow local variable declarations, whose scope is the block<br>
enclosing them.  That is the reason for which we have to recover the<br>
environment after the block.  This allows us to have a very simple semantics<br>
for variable declarations, as we did above.  One can make the two rules below<br>
computational if one wants them to count as computational steps.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span> S <span class="token punctuation">}</span> <span class="token operator">=&gt;</span> S <span class="token operator">~&gt;</span> setEnv<span class="token punctuation">(</span>Env<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
</pre><p>The basic definition of environment recovery is straightforward and<br>
given in the section on auxiliary constructs at the end of the file.</p>
<p>There are two common alternatives to the above semantics of blocks.<br>
One is to keep track of the variables which are declared in the block and only<br>
recover those at the end of the block.  This way one does more work for<br>
variable declarations but conceptually less work for environment recovery; we<br>
say <code>conceptually</code> because it is not clear that it is indeed the case that<br>
one does less work when AC matching is involved.  The other alternative is to<br>
work with a stack of environments instead of a flat environment, and push the<br>
current environment when entering a block and pop it when exiting it.  This<br>
way, one does more work when accessing variables (since one has to search the<br>
variable in the environment stack in a top-down manner), but on the other hand<br>
uses smaller environments and the definition gets closer to an implementation.<br>
Based on experience with dozens of language semantics and other <strong>K</strong> definitions,<br>
we have found that our approach above is the best trade-off between elegance<br>
and efficiency (especially since rewrite engines have built-in techniques to<br>
lazily copy terms, by need, thus not creating unnecessary copies),<br>
so it is the one that we follow in general.</p>
<h2 class="mume-header" id="sequential-composition">Sequential composition</h2>

<p>Sequential composition is desugared into <strong>K</strong>&apos;s builtin sequentialization<br>
operation (recall that, like in C, the semi-colon <code>;</code> is not a<br>
statement separator in SIMPLE &#x2014; it is either a statement terminator or a<br>
construct for a statement from an expression).  Note that <strong>K</strong> allows<br>
to define the semantics of SIMPLE in such a way that statements eventually<br>
dissolve from the top of the computation when they are completed; this is in<br>
sharp contrast to (artificially) <code>evaluating</code> them to a special<br>
<code>skip</code> statement value and then getting rid of that special value, as<br>
it is the case in other semantic approaches (where everything must evaluate<br>
to something).  This means that once <code>S&#x2081;</code> completes in the rule below, <code>S&#x2082;</code><br>
becomes automatically the next computation item without any additional<br>
(explicit or implicit) rules.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> S1<span class="token punctuation">:</span>Stmt S2<span class="token punctuation">:</span>Stmt <span class="token operator">=&gt;</span> S1 <span class="token operator">~&gt;</span> S2
</pre><p>A subtle aspect of the rule above is that <code>S&#x2081;</code> is declared to have sort<br>
<code>Stmts</code> and not <code>Stmt</code>.  That is because desugaring macros can indeed<br>
produce left associative sequential composition of statements.  For example,<br>
the code <code>var x=0; x=1;</code> is desugared to<br>
<code>(var x; x=0;) x=1;</code>, so although originally the first term of<br>
the sequential composition had sort <code>Stmt</code>, after desugaring it became<br>
of sort <code>Stmts</code>.  Note that the attribute <code>[right]</code> associated<br>
to the sequential compositon production is an attribute of the syntax, and not<br>
of the semantics: e.g., it tells the parser to parse<br>
<code>var x; x=0; x=1;</code> as <code>var x; (x=0; x=1;)</code>, but it<br>
does not tell the rewrite engine to rewrite <code>(var x; x=0;) x=1;</code> to<br>
<code>var x; (x=0; x=1;)</code>.</p>
<h2 class="mume-header" id="expression-statements">Expression statements</h2>

<p>Expression statements are only used for their side effects, so their result<br>
value is simply discarded.  Common examples of expression statements are ones<br>
of the form <code>++x;</code>, <code>x=e;</code>, <code>e1[e2]=e3;</code>, etc.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> _<span class="token punctuation">:</span>Val<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K
</pre><h2 class="mume-header" id="conditional">Conditional</h2>

<p>Since the conditional was declared with the <code>strict(1)</code> attribute, we<br>
can assume that its first argument will eventually be evaluated.  The rules<br>
below cover the only two possibilities in which the conditional is allowed to<br>
proceed (otherwise the rewriting process gets stuck).</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> if <span class="token punctuation">(</span> <span class="token boolean">true</span><span class="token punctuation">)</span> S else _ <span class="token operator">=&gt;</span> S
  <span class="token keyword keyword-rule">rule</span> if <span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> _ else S <span class="token operator">=&gt;</span> S
</pre><h2 class="mume-header" id="while-loop">While loop</h2>

<p>The simplest way to give the semantics of the while loop is by unrolling.<br>
Note, however, that its unrolling is only allowed when the while loop reaches<br>
the top of the computation (to avoid non-termination of unrolling).  The<br>
simple while loop semantics below works because our while loops in SIMPLE are<br>
indeed very basic.  If we allowed break/continue of loops then we would need<br>
a completely different semantics, which would also involve the <code>control</code> cell.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> while <span class="token punctuation">(</span>E<span class="token punctuation">)</span> S <span class="token operator">=&gt;</span> if <span class="token punctuation">(</span>E<span class="token punctuation">)</span> <span class="token punctuation">{</span>S while<span class="token punctuation">(</span>E<span class="token punctuation">)</span>S<span class="token punctuation">}</span>
</pre><h2 class="mume-header" id="print">Print</h2>

<p>The <code>print</code> statement was strict, so all its arguments are now<br>
evaluated (recall that <code>print</code> is variadic).  We append each of<br>
its evaluated arguments to the output buffer, and discard the residual<br>
<code>print</code> statement with an empty list of arguments.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> print<span class="token punctuation">(</span>V<span class="token punctuation">:</span>Val<span class="token punctuation">,</span> Es <span class="token operator">=&gt;</span> Es<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>output</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>List <span class="token operator">=&gt;</span> ListItem<span class="token punctuation">(</span>V<span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>output</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> print<span class="token punctuation">(</span><span class="token punctuation">.</span>Vals<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K
</pre><h2 class="mume-header" id="exceptions">Exceptions</h2>

<p>SIMPLE allows parametric exceptions, in that one can throw and catch a<br>
particular value.  The statement <code>try S&#x2081; catch(X) S&#x2082;</code><br>
proceeds with the evaluation of <code>S&#x2081;</code>.  If <code>S&#x2081;</code> evaluates normally, i.e.,<br>
without any exception thrown, then <code>S&#x2082;</code> is discarded and the execution<br>
continues normally.  If <code>S&#x2081;</code> throws an exception with a statement of the<br>
form <code>throw E</code>, then <code>E</code> is first evaluated to some value <code>V</code><br>
(<code>throw</code> was declared to be strict), then <code>V</code> is bound to <code>X</code>, then<br>
<code>S&#x2082;</code> is evaluated in the new environment while the reminder of <code>S&#x2081;</code> is<br>
discarded, then the environment is recovered and the execution continues<br>
normally with the statement following the <code>try S&#x2081; catch(X) S&#x2082;</code> statement.<br>
Exceptions can be nested and the statements in the<br>
<code>catch</code> part (<code>S&#x2082;</code> in our case) can throw exceptions to the<br>
upper level.  One should be careful with how one handles the control data<br>
structures here, so that the abrupt changes of control due to exception<br>
throwing and to function returns interact correctly with each other.<br>
For example, we want to allow function calls inside the statement <code>S&#x2081;</code> in<br>
a <code>try S&#x2081; catch(X) S&#x2082;</code> block which can throw an exception<br>
that is not caught by the function but instead is propagated to the<br>
<code>try S&#x2081; catch(X) S&#x2082;</code> block that called the function.<br>
Therefore, we have to make sure that the function stack as well as other<br>
potential control structures are also properly modified when the exception<br>
is thrown to correctly recover the execution context.  This can be easily<br>
achieved by pushing/popping the entire current control context onto the<br>
exception stack.  The three rules below modularly do precisely the above.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span>Stmt<span class="token punctuation">,</span>K<span class="token punctuation">,</span>Map<span class="token punctuation">,</span>ControlCellFragment<span class="token punctuation">)</span>

  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;popx&quot;</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span>try S1 catch<span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token punctuation">{</span>S2<span class="token punctuation">}</span> <span class="token operator">=&gt;</span> S1 <span class="token operator">~&gt;</span> popx<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>control</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>xstack</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token operator">=&gt;</span> ListItem<span class="token punctuation">(</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> S2<span class="token punctuation">,</span> K<span class="token punctuation">,</span> Env<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>xstack</span><span class="token punctuation">&gt;</span></span>
         C
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>control</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> popx <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>xstack</span><span class="token punctuation">&gt;</span></span> ListItem<span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>List <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>xstack</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> throw V<span class="token punctuation">:</span>Val<span class="token punctuation">;</span> <span class="token operator">~&gt;</span> _ <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> var X <span class="token operator">=</span> V<span class="token punctuation">;</span> S2 <span class="token punctuation">}</span> <span class="token operator">~&gt;</span> K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>control</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>xstack</span><span class="token punctuation">&gt;</span></span> ListItem<span class="token punctuation">(</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> S2<span class="token punctuation">,</span> K<span class="token punctuation">,</span> Env<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>List <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>xstack</span><span class="token punctuation">&gt;</span></span>
         <span class="token punctuation">(</span>_ <span class="token operator">=&gt;</span> C<span class="token punctuation">)</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>control</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> _ <span class="token operator">=&gt;</span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
</pre><p>The catch statement <code>S&#x2082;</code> needs to be executed in the original environment,<br>
but where the thrown value <code>V</code> is bound to the catch variable <code>X</code>.  We here<br>
chose to rely on two previously defined constructs when giving semantics to<br>
the catch part of the statement: (1) the variable declaration with<br>
initialization, for binding <code>X</code> to <code>V</code>; and (2) the block construct for<br>
preventing <code>X</code> from shadowing variables in the original environment upon the<br>
completion of <code>S&#x2082;</code>.</p>
<h2 class="mume-header" id="threads">Threads</h2>

<p>SIMPLE&apos;s threads can be created and terminated dynamically, and can<br>
synchronize by acquiring and releasing re-entrant locks and by rendezvous.<br>
We discuss the seven rules giving the semantics of these operations below.</p>
<h2 class="mume-header" id="thread-creation">Thread creation</h2>

<p>Threads can be created by any other threads using the <code>spawn S</code><br>
construct.  The spawn expression construct evaluates to the unique identifier<br>
of the newly created thread and, at the same time, a new thread cell is added<br>
into the configuration, initialized with the <code>S</code> statement and sharing the<br>
same environment with the parent thread.  Note that the newly created<br>
<code>thread</code> cell is torn.  That means that the remaining cells are added<br>
and initialized automatically as described in the definition of SIMPLE&apos;s<br>
configuration.  This is part of <strong>K</strong>&apos;s configuration abstraction mechanism.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>thread</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> spawn S <span class="token operator">=&gt;</span> <span class="token operator">!</span>T<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>thread</span><span class="token punctuation">&gt;</span></span>
       <span class="token punctuation">(</span><span class="token punctuation">.</span>Bag <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>thread</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
               <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> S <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
               <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
               <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">&gt;</span></span> <span class="token operator">!</span>T <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">&gt;</span></span>
             <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>thread</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>
</pre><h2 class="mume-header" id="thread-termination">Thread termination</h2>

<p>Dually to the above, when a thread terminates its assigned computation (the<br>
contents of its <code>k</code> cell) is empty, so the thread can be dissolved.<br>
However, since no discipline is imposed on how locks are acquired and released,<br>
it can be the case that a terminating thread still holds locks.  Those locks<br>
must be released, so other threads attempting to acquire them do not deadlock.<br>
We achieve that by removing all the locks held by the terminating thread in its<br>
<code>holds</code> cell from the set of busy locks in the <code>busy</code> cell<br>
(<code>keys(H)</code> returns the domain of the map <code>H</code> as a set, that is, only<br>
the locks themselves ignoring their multiplicity).  As seen below, a lock is<br>
added to the <code>busy</code> cell as soon as it is acquired for the first time<br>
by a thread.  The unique identifier of the terminated thread is also collected<br>
into the <code>terminated</code> cell, so the <code>join</code> construct knows which<br>
threads have terminated.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>thread</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span>K<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>holds</span><span class="token punctuation">&gt;</span></span>H<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>holds</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">&gt;</span></span>T<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>thread</span><span class="token punctuation">&gt;</span></span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Bag<span class="token punctuation">)</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>busy</span><span class="token punctuation">&gt;</span></span> Busy <span class="token operator">=&gt;</span> Busy <span class="token operator">-</span>Set keys<span class="token punctuation">(</span>H<span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>busy</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>terminated</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Set <span class="token operator">=&gt;</span> SetItem<span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>terminated</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="thread-joining">Thread joining</h2>

<p>Thread joining is now straightforward: all we need to do is to check whether<br>
the identifier of the thread to be joined is in the <code>terminated</code> cell.<br>
If yes, then the <code>join</code> statement dissolves and the joining thread<br>
continues normally; if not, then the joining thread gets stuck.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> join T<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>terminated</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> SetItem<span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>terminated</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="acquire-lock">Acquire lock</h2>

<p>There are two cases to distinguish when a thread attempts to acquire a lock<br>
(in SIMPLE any value can be used as a lock):<br>
(1) The thread does not currently have the lock, in which case it has to<br>
take it provided that the lock is not already taken by another thread (see<br>
the side condition of the first rule).<br>
(2) The thread already has the lock, in which case it just increments its<br>
counter for the lock (the locks are re-entrant).  These two cases are captured<br>
by the two rules below:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> acquire V<span class="token punctuation">:</span>Val<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>holds</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Map <span class="token operator">=&gt;</span> V <span class="token operator">|</span><span class="token operator">-</span>&gt; <span class="token number">0</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>holds</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>busy</span><span class="token punctuation">&gt;</span></span> Busy <span class="token punctuation">(</span><span class="token punctuation">.</span>Set <span class="token operator">=&gt;</span> SetItem<span class="token punctuation">(</span>V<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>busy</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> <span class="token punctuation">(</span>notBool<span class="token punctuation">(</span>V in Busy<span class="token punctuation">)</span><span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> acquire V<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>holds</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> V<span class="token punctuation">:</span>Val <span class="token operator">|</span><span class="token operator">-</span>&gt; <span class="token punctuation">(</span>N <span class="token operator">=&gt;</span> N <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>holds</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="release-lock">Release lock</h2>

<p>Similarly, there are two corresponding cases to distinguish when a thread<br>
releases a lock:<br>
(1) The thread holds the lock more than once, in which case all it needs to do<br>
is to decrement the lock counter.<br>
(2) The thread holds the lock only once, in which case it needs to remove it<br>
from its <code>holds</code> cell and also from the the shared <code>busy</code> cell,<br>
so other threads can acquire it if they need to.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> release V<span class="token punctuation">:</span>Val<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>holds</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> V <span class="token operator">|</span><span class="token operator">-</span>&gt; <span class="token punctuation">(</span>N <span class="token operator">=&gt;</span> N <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>holds</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> N &gt;<span class="token keyword keyword-Int">Int</span> <span class="token number">0</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> release V<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>holds</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> V<span class="token punctuation">:</span>Val <span class="token operator">|</span><span class="token operator">-</span>&gt; <span class="token number">0</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Map <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>holds</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>busy</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> SetItem<span class="token punctuation">(</span>V<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Set <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>busy</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="rendezvous-synchronization">Rendezvous synchronization</h2>

<p>In addition to synchronization through acquire and release of locks, SIMPLE<br>
also provides a construct for rendezvous synchronization.  A thread whose next<br>
statement to execute is <code>rendezvous(V)</code> gets stuck until another<br>
thread reaches an identical statement; when that happens, the two threads<br>
drop their rendezvous statements and continue their executions.  If three<br>
threads happen to have an identical rendezvous statement as their next<br>
statement, then precisely two of them will synchronize and the other will<br>
remain blocked until another thread reaches a similar rendezvous statement.<br>
The rule below is as simple as it can be.  Note, however, that, again, it is<br>
<strong>K</strong>&apos;s mechanism for configuration abstraction that makes it work as desired:<br>
since the only cell which can multiply containing a <code>k</code> cell inside is<br>
the <code>thread</code> cell, the only way to concretize the rule below to the<br>
actual configuration of SIMPLE is to include each <code>k</code> cell in a<br>
<code>thread</code> cell.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> rendezvous V<span class="token punctuation">:</span>Val<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> rendezvous V<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="auxiliary-declarations-and-operations">Auxiliary declarations and operations</h2>

<p>In this section we define all the auxiliary constructs used in the<br>
above semantics.</p>
<h2 class="mume-header" id="making-declarations">Making declarations</h2>

<p>The <code>mkDecls</code> auxiliary construct turns a list of identifiers<br>
and a list of values in a sequence of corresponding variable<br>
declarations.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> mkDecls<span class="token punctuation">(</span>Ids<span class="token punctuation">,</span>Vals<span class="token punctuation">)</span>  <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> mkDecls<span class="token punctuation">(</span><span class="token punctuation">(</span>X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span> Xs<span class="token punctuation">:</span>Ids<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>V<span class="token punctuation">:</span>Val<span class="token punctuation">,</span> Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> var X<span class="token operator">=</span>V<span class="token punctuation">;</span> mkDecls<span class="token punctuation">(</span>Xs<span class="token punctuation">,</span>Vs<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> mkDecls<span class="token punctuation">(</span><span class="token punctuation">.</span>Ids<span class="token punctuation">,</span><span class="token punctuation">.</span>Vals<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</pre><h2 class="mume-header" id="location-lookup">Location lookup</h2>

<p>The operation below is straightforward.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> lookup<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> lookup<span class="token punctuation">(</span>L<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> V <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; V<span class="token punctuation">:</span>Val <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="environment-recovery">Environment recovery</h2>

<p>We have already discussed the environment recovery auxiliary operation in the<br>
IMP++ tutorial:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token comment">// TODO: eliminate the env wrapper, like we did in IMP++</span>

  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> setEnv<span class="token punctuation">(</span>Map<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> setEnv<span class="token punctuation">(</span>Env<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> _ <span class="token operator">=&gt;</span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
</pre><p>While theoretically sufficient, the basic definition for environment<br>
recovery alone is suboptimal.  Consider a loop <code>while (E)S</code>,<br>
whose semantics (see above) was given by unrolling.  <code>S</code><br>
is a block.  Then the semantics of blocks above, together with the<br>
unrolling semantics of the while loop, will yield a computation<br>
structure in the <code>k</code> cell that increasingly grows, adding a new<br>
environment recovery task right in front of the already existing sequence of<br>
similar environment recovery tasks (this phenomenon is similar to the ``tail<br>
recursion&apos;&apos; problem).  Of course, when we have a sequence of environment<br>
recovery tasks, we only need to keep the last one.  The elegant rule below<br>
does precisely that, thus avoiding the unnecessary computation explosion<br>
problem:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>setEnv<span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> setEnv<span class="token punctuation">(</span>_<span class="token punctuation">)</span>
</pre><p>In fact, the above follows a common convention in <strong>K</strong> for recovery<br>
operations of cell contents: the meaning of a computation task of the form<br>
<code>cell(C)</code> that reaches the top of the computation is that the current<br>
contents of cell <code>cell</code> is discarded and gets replaced with <code>C</code>.  We<br>
did not add support for these special computation tasks in our current<br>
implementation of <strong>K</strong>, so we need to define them as above.</p>
<h2 class="mume-header" id="lvalue-and-loc">lvalue and loc</h2>

<p>For convenience in giving the semantics of constructs like the increment and<br>
the assignment, that we want to operate the same way on variables and on<br>
array elements, we used an auxiliary <code>lvalue(E)</code> construct which was<br>
expected to evaluate to the lvalue of the expression <code>E</code>.  This is only<br>
defined when <code>E</code> has an lvalue, that is, when <code>E</code> is either a variable or<br>
evaluates to an array element.  <code>lvalue(E)</code> evaluates to a value of<br>
the form <code>loc(L)</code>, where <code>L</code> is the location where the value of <code>E</code><br>
can be found; for clarity, we use <code>loc</code> to structurally distinguish<br>
natural numbers from location values.  In giving semantics to <code>lvalue</code><br>
there are two cases to consider.  (1) If <code>E</code> is a variable, then all we need<br>
to do is to grab its location from the environment.  (2) If <code>E</code> is an array<br>
element, then we first evaluate the array and its index in order to identify<br>
the exact location of the element of concern, and then return that location;<br>
the last rule below works because its preceding context declarations ensure<br>
that the array and its index are evaluated, and then the rule for array lookup<br>
(defined above) rewrites the evaluated array access construct to its<br>
corresponding store lookup operation.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token comment">// For parsing reasons, we prefer to allow lvalue to take a K</span>

  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> lvalue<span class="token punctuation">(</span>K<span class="token punctuation">)</span>
  <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> loc<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span>

<span class="token comment">// Local variable</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> lvalue<span class="token punctuation">(</span>X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=&gt;</span> loc<span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> X <span class="token operator">|</span><span class="token operator">-</span>&gt; L<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>

<span class="token comment">// Array element: evaluate the array and its index;</span>
<span class="token comment">// then the array lookup rule above applies.</span>

  <span class="token keyword keyword-context">context</span> lvalue<span class="token punctuation">(</span>_<span class="token punctuation">:</span><span class="token punctuation">:</span>Exp<span class="token punctuation">[</span>HOLE<span class="token punctuation">:</span><span class="token punctuation">:</span>Exps<span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-context">context</span> lvalue<span class="token punctuation">(</span>HOLE<span class="token punctuation">:</span><span class="token punctuation">:</span>Exp<span class="token punctuation">[</span>_<span class="token punctuation">:</span><span class="token punctuation">:</span>Exps<span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment">// Finally, return the address of the desired object member</span>

  <span class="token keyword keyword-rule">rule</span> lvalue<span class="token punctuation">(</span>lookup<span class="token punctuation">(</span>L<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> loc<span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">)</span>
</pre><h2 class="mume-header" id="initializing-multiple-locations">Initializing multiple locations</h2>

<p>The following operation initializes a sequence of locations with the same<br>
value:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Map <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;...&quot;</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;|-&gt;&quot;</span> K <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> N<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>M <span class="token operator">|</span><span class="token operator">-</span>&gt; _ <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Map  <span class="token keyword keyword-requires">requires</span> N &gt;<span class="token keyword keyword-Int">Int</span> M
  <span class="token keyword keyword-rule">rule</span> N<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>M <span class="token operator">|</span><span class="token operator">-</span>&gt; K <span class="token operator">=&gt;</span> N <span class="token operator">|</span><span class="token operator">-</span>&gt; K <span class="token punctuation">(</span>N <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>M <span class="token operator">|</span><span class="token operator">-</span>&gt; K  <span class="token keyword keyword-requires">requires</span> N <span class="token operator">&lt;=</span><span class="token keyword keyword-Int">Int</span> M
</pre><p>The semantics of SIMPLE is now complete.  Make sure you kompile the<br>
definition with the right options in order to generate the desired model.<br>
No kompile options are needed if you only only want to execute the definition<br>
(and thus get an interpreter), but if you want to search for a different<br>
program behaviors then you need to kompile with the --enable-search option</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>Go to <a href="#ebook-heading-lesson-2-simple-typed-static">Lesson 2, SIMPLE typed static</a></p>
</div></div><div id="ebook-heading-lesson-1-simple-untyped" ebook-toc-level-4 heading="Lesson 1, SIMPLE untyped"><div><h1 class="mume-header" id="simple-untyped">SIMPLE &#x2014; Untyped</h1>

<p>Author: Grigore Ro&#x219;u (<a href="mailto:grosu@illinois.edu">grosu@illinois.edu</a>)<br>
Organization: University of Illinois at Urbana-Champaign</p>
<p>Author: Traian Florin &#x218;erb&#x103;nu&#x21B;&#x103; (<a href="mailto:traian.serbanuta@unibuc.ro">traian.serbanuta@unibuc.ro</a>)<br>
Organization: University of Bucharest</p>
<h2 class="mume-header" id="abstract">Abstract</h2>

<p>This is the <strong>K</strong> semantic definition of the untyped SIMPLE language.<br>
SIMPLE is intended to be a pedagogical and research language that captures<br>
the essence of the imperative programming paradigm, extended with several<br>
features often encountered in imperative programming languages.<br>
A program consists of a set of global variable declarations and<br>
function definitions.  Like in C, function definitions cannot be<br>
nested and each program must have one function called <code>main</code>,<br>
which is invoked when the program is executed.  To make it more<br>
interesting and to highlight some of <strong>K</strong>&apos;s strengths, SIMPLE includes<br>
the following features in addition to the conventional imperative<br>
expression and statement constructs:</p>
<ul>
<li>
<p>Multidimensional arrays and array references.  An array evaluates<br>
to an array reference, which is a special value holding a location (where<br>
the elements of the array start) together with the size of the array;<br>
the elements of the array can be array references themselves (particularly<br>
when the array is multi-dimensional).  Array references are ordinary values,<br>
so they can be assigned to variables and passed/received by functions.</p>
</li>
<li>
<p>Functions and function values.  Functions can have zero or<br>
more parameters and can return abruptly using a <code>return</code> statement.<br>
SIMPLE follows a call-by-value parameter passing style, with static scoping.<br>
Function names evaluate to function abstractions, which hereby become ordinary<br>
values in the language, same like the array references.</p>
</li>
<li>
<p>Blocks with locals.  SIMPLE variables can be declared<br>
anywhere, their scope being from the place where they are declared<br>
until the end of the most nested enclosing block.</p>
</li>
<li>
<p>Input/Output.  The expression <code>read()</code> evaluates to the<br>
next value in the input buffer, and the statement <code>write(e)</code><br>
evaluates <code>e</code> and outputs its value to the output buffer.  The<br>
input and output buffers are lists of values.</p>
</li>
<li>
<p>Exceptions.  SIMPLE has parametric exceptions (the value thrown as<br>
an exception can be caught and bound).</p>
</li>
<li>
<p>Concurrency via dynamic thread creation/termination and<br>
synchronization.  One can spawn a thread to execute any statement.<br>
The spawned thread shares with its parent its environment at creation time.<br>
Threads can be synchronized via a join command which blocks the current thread<br>
until the joined thread completes, via re-entrant locks which can be acquired<br>
and released, as well as through rendezvous commands.</p>
</li>
</ul>
<p>Like in many other languages, some of SIMPLE&apos;s constructs can be<br>
desugared into a smaller set of basic constructs.  We do that at the end<br>
of the syntax module, and then we only give semantics to the core constructs.</p>
<p><strong>Note</strong>: This definition is commented slightly more than others, because it is<br>
intended to be one of the first non-trivial definitions that the new<br>
user of <strong>K</strong> sees.  We recommend the beginner user to first check the<br>
language definitions discussed in the <strong>K</strong> tutorial.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> SIMPLE<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> DOMAINS<span class="token operator">-</span>SYNTAX
</pre><h2 class="mume-header" id="syntax">Syntax</h2>

<p>We start by defining the SIMPLE syntax.  The language constructs discussed<br>
above have the expected syntax and evaluation strategies.  Recall that in <strong>K</strong><br>
we annotate the syntax with appropriate strictness attributes, thus giving<br>
each language construct the desired evaluation strategy.</p>
<h2 class="mume-header" id="identifiers">Identifiers</h2>

<p>Recall from the <strong>K</strong> tutorial that identifiers are builtin and come under the<br>
syntactic category <code>Id</code>.  The special identifier for the function<br>
<code>main</code> belongs to all programs, and plays a special role in the semantics,<br>
so we declare it explicitly.  This would not be necessary if the identifiers<br>
were all included automatically in semantic definitions, but that is not<br>
possible because of parsing reasons (e.g., <strong>K</strong> variables used to match<br>
concrete identifiers would then be ambiguously parsed as identifiers).  They<br>
are only included in the parser generated to parse programs (and used by the<br>
<code>kast</code> tool).  Consequently, we have to explicitly declare all the<br>
concrete identifiers that play a special role in the semantics, like<br>
<code>main</code> below.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Id">Id</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;main&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
</pre><h2 class="mume-header" id="declarations">Declarations</h2>

<p>There are two types of declarations: for variables (including arrays) and<br>
for functions.  We are going to allow declarations of the form<br>
<code>var x=10, a[10,10], y=23;</code>, which is why we allow the <code>var</code><br>
keyword to take a list of expressions.  The non-terminals used in the two<br>
productions below are defined shortly.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;var&quot;</span> Exps <span class="token string">&quot;;&quot;</span>
                <span class="token operator">|</span> <span class="token string">&quot;function&quot;</span> <span class="token keyword keyword-Id">Id</span> <span class="token string">&quot;(&quot;</span> Ids <span class="token string">&quot;)&quot;</span> Block
</pre><h2 class="mume-header" id="expressions">Expressions</h2>

<p>The expression constructs below are standard.  Increment (<code>++</code>) takes<br>
an expression rather than a variable because it can also increment an array<br>
element.  Recall that the syntax we define in <strong>K</strong> is what we call <em>the syntax<br>
of the semantics</em>: while powerful enough to define non-trivial syntaxes<br>
(thanks to the underlying SDF technology that we use), we typically refrain<br>
from defining precise syntaxes, that is, ones which accept precisely the<br>
well-formed programs (that would not be possible anyway in general).  That job<br>
is deferred to type systems, which can also be defined in <strong>K</strong>.  In other words,<br>
we are not making any effort to guarantee syntactically that only variables<br>
or array elements are passed to the increment construct, we allow any<br>
expression.  Nevertheless, we will only give semantics to those, so expressions<br>
of the form <code>++5</code>, which parse (but which will be rejected by our type<br>
system in the typed version of SIMPLE later), will get stuck when executed.<br>
Arrays can be multidimensional and can hold other arrays, so their<br>
lookup operation takes a list of expressions as argument and applies to an<br>
expression (which can in particular be another array lookup), respectively.<br>
The construct <code>sizeOf</code> gives the size of an array in number of elements<br>
of its first dimension.  Note that almost all constructs are strict.  The only<br>
constructs which are not strict are the increment (since its first argument<br>
gets updated, so it cannot be evaluated), the input read which takes no<br>
arguments so strictness is irrelevant for it, the logical and and or constructs<br>
which are short-circuited, the thread spawning construct which creates a new<br>
thread executing the argument expression and return its unique identifier to<br>
the creating thread (so it cannot just evaluate its argument in place), and the<br>
assignment which is only strict in its second argument (for the same reason as<br>
the increment).</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span> <span class="token operator">|</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token operator">|</span> <span class="token keyword keyword-String">String</span> <span class="token operator">|</span> <span class="token keyword keyword-Id">Id</span>
               <span class="token operator">|</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span>             <span class="token punctuation">[</span><span class="token class-name">bracket</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;++&quot;</span> Exp
               &gt; Exp <span class="token string">&quot;[&quot;</span> Exps <span class="token string">&quot;]&quot;</span>        <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               &gt; Exp <span class="token string">&quot;(&quot;</span> Exps <span class="token string">&quot;)&quot;</span>        <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;-&quot;</span> Exp                 <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;sizeOf&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span>    <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;read&quot;</span> <span class="token string">&quot;(&quot;</span> <span class="token string">&quot;)&quot;</span>
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;*&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;/&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;%&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;+&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;-&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               &gt; <span class="token class-name">non-assoc</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;&lt;&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;&lt;=&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;&gt;&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;&gt;=&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;==&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;!=&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               &gt; <span class="token string">&quot;!&quot;</span> Exp                 <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;&amp;&amp;&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;||&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               &gt; <span class="token string">&quot;spawn&quot;</span> Block
               &gt; Exp <span class="token string">&quot;=&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">right</span><span class="token punctuation">]</span>
</pre><p>We also need comma-separated lists of identifiers and of expressions.<br>
Moreover, we want them to be strict, that is, to evaluate to lists of results<br>
whenever requested (e.g., when they appear as strict arguments of<br>
the constructs above).</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Ids  <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>           <span class="token punctuation">[</span>overload<span class="token punctuation">(</span>Exps<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Exps <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Exp<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>          <span class="token punctuation">[</span>overload<span class="token punctuation">(</span>Exps<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">strict</span><span class="token punctuation">]</span>  <span class="token comment">// automatically hybrid now</span>
  <span class="token keyword keyword-syntax">syntax</span> Exps <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Ids
  <span class="token keyword keyword-syntax">syntax</span> Val
  <span class="token keyword keyword-syntax">syntax</span> Vals <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Val<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>          <span class="token punctuation">[</span>overload<span class="token punctuation">(</span>Exps<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Bottom
  <span class="token keyword keyword-syntax">syntax</span> Bottoms <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Bottom<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>    <span class="token punctuation">[</span>overload<span class="token punctuation">(</span>Exps<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Ids <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Bottoms
</pre><h2 class="mume-header" id="statements">Statements</h2>

<p>Most of the statement constructs are standard for imperative languages.<br>
We syntactically distinguish between empty and non-empty blocks, because we<br>
chose <code>Stmts</code> not to be a (<code>;</code>-separated) list of<br>
<code>Stmt</code>.  Variables can be declared anywhere inside a block, their scope<br>
ending with the block.  Expressions are allowed to be used for their side<br>
effects only (followed by a semicolon <code>;</code>).  Functions are allowed<br>
to abruptly return.  The exceptions are parametric, i.e., one can throw a value<br>
which is bound to the variable declared by <code>catch</code>.  Threads can be<br>
dynamically created and terminated, and can synchronize with <code>join</code>,<br>
<code>acquire</code>, <code>release</code> and <code>rendezvous</code>.  Note that the<br>
strictness attributes obey the intended evaluation strategy of the various<br>
constructs.  In particular, the if-then-else construct is strict only in its<br>
first argument (the if-then construct will be desugared into if-then-else),<br>
while the loop constructs are not strict in any arguments.  The <code>print</code><br>
statement construct is variadic, that is, it takes an arbitrary number of<br>
arguments.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Block <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;{&quot;</span> <span class="token string">&quot;}&quot;</span>
                <span class="token operator">|</span> <span class="token string">&quot;{&quot;</span> Stmt <span class="token string">&quot;}&quot;</span>

  <span class="token keyword keyword-syntax">syntax</span> Stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Block
                <span class="token operator">|</span> Exp <span class="token string">&quot;;&quot;</span>                               <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;if&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Block <span class="token string">&quot;else&quot;</span> Block   <span class="token punctuation">[</span><span class="token class-name">avoid</span><span class="token punctuation">,</span> <span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;if&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Block                <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;while&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Block
                <span class="token operator">|</span> <span class="token string">&quot;for&quot;</span> <span class="token string">&quot;(&quot;</span> Stmt Exp <span class="token string">&quot;;&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Block  <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;return&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                      <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;return&quot;</span> <span class="token string">&quot;;&quot;</span>                          <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;print&quot;</span> <span class="token string">&quot;(&quot;</span> Exps <span class="token string">&quot;)&quot;</span> <span class="token string">&quot;;&quot;</span>              <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
<span class="token comment">// NOTE: print strict allows non-deterministic evaluation of its arguments</span>
<span class="token comment">// Either keep like this but document, or otherwise make Exps seqstrict.</span>
<span class="token comment">// Of define and use a different expression list here, which is seqstrict.</span>
                <span class="token operator">|</span> <span class="token string">&quot;try&quot;</span> Block <span class="token string">&quot;catch&quot;</span> <span class="token string">&quot;(&quot;</span> <span class="token keyword keyword-Id">Id</span> <span class="token string">&quot;)&quot;</span> Block
                <span class="token operator">|</span> <span class="token string">&quot;throw&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                       <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;join&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                        <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;acquire&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                     <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;release&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                     <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;rendezvous&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                  <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
</pre><p>The reason we allow <code>Stmts</code> as the first argument of <code>for</code><br>
instead of <code>Stmt</code> is because we want to allow more than one statement<br>
to be executed when the loop is initialized.  Also, as seens shorly, macros<br>
may expand one statement into more statements; for example, an initialized<br>
variable declaration statement <code>var x=0;</code> desugars into two statements,<br>
namely <code>var x; x=0;</code>, so if we use <code>Stmt</code> instead of <code>Stmts</code><br>
in the production of <code>for</code> above then we risk that the macro expansion<br>
of statement <code>var x=0;</code> happens before the macro expansion of <code>for</code>,<br>
also shown below, in which case the latter would not apply anymore because<br>
of syntactic mismatch.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Stmt Stmt                          <span class="token punctuation">[</span><span class="token class-name">right</span><span class="token punctuation">]</span>

<span class="token comment">// I wish I were able to write the following instead, but confuses the parser.</span>
<span class="token comment">//</span>
<span class="token comment">// syntax Stmts ::= List{Stmt,&quot;&quot;}</span>
<span class="token comment">// syntax Top ::= Stmt | &quot;function&quot; Id &quot;(&quot; Ids &quot;)&quot; Block</span>
<span class="token comment">// syntax Pgm ::= List{Top,&quot;&quot;}</span>
<span class="token comment">//</span>
<span class="token comment">// With that, I could have also eliminated the empty block</span>
</pre><h2 class="mume-header" id="desugared-syntax">Desugared Syntax</h2>

<p>This part desugars some of SIMPLE&apos;s language constructs into core ones.<br>
We only want to give semantics to core constructs, so we get rid of the<br>
derived ones before we start the semantics.  All desugaring macros below are<br>
straightforward.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> if <span class="token punctuation">(</span>E<span class="token punctuation">)</span> S <span class="token operator">=&gt;</span> if <span class="token punctuation">(</span>E<span class="token punctuation">)</span> S else <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword keyword-rule">rule</span> for<span class="token punctuation">(</span>Start Cond<span class="token punctuation">;</span> Step<span class="token punctuation">)</span> <span class="token punctuation">{</span>S<span class="token punctuation">}</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>Start while <span class="token punctuation">(</span>Cond<span class="token punctuation">)</span> <span class="token punctuation">{</span>S Step<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span>
  <span class="token keyword keyword-rule">rule</span> for<span class="token punctuation">(</span>Start Cond<span class="token punctuation">;</span> Step<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>Start while <span class="token punctuation">(</span>Cond<span class="token punctuation">)</span> <span class="token punctuation">{</span>Step<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span>
  <span class="token keyword keyword-rule">rule</span> var E1<span class="token punctuation">:</span>Exp<span class="token punctuation">,</span> E2<span class="token punctuation">:</span>Exp<span class="token punctuation">,</span> Es<span class="token punctuation">:</span>Exps<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> var E1<span class="token punctuation">;</span> var E2<span class="token punctuation">,</span> Es<span class="token punctuation">;</span>
  <span class="token keyword keyword-rule">rule</span> var X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=</span> E<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> var X<span class="token punctuation">;</span> X <span class="token operator">=</span> E<span class="token punctuation">;</span>
</pre><p>For the semantics, we can therefore assume from now on that each<br>
conditional has both branches, that there are only <code>while</code> loops, and<br>
that each variable is declared alone and without any initialization as part of<br>
the declaration.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-endmodule">endmodule</span>


<span class="token keyword keyword-module">module</span> SIMPLE<span class="token operator">-</span>UNTYPED
  <span class="token keyword keyword-imports">imports</span> SIMPLE<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> DOMAINS
</pre><h2 class="mume-header" id="basic-semantic-infrastructure">Basic Semantic Infrastructure</h2>

<p>Before one starts adding semantic rules to a <strong>K</strong> definition, one needs to<br>
define the basic semantic infrastructure consisting of definitions for<br>
<code>values</code> and <code>configuration</code>.  As discussed in the definitions<br>
in the <strong>K</strong> tutorial, the values are needed to know when to stop applying<br>
the heating rules and when to start applying the cooling rules corresponding<br>
to strictness or context declarations.  The configuration serves as a backbone<br>
for the process of configuration abstraction which allows users to only<br>
mention the relevant cells in each semantic rule, the rest of the configuration<br>
context being inferred automatically.  Although in some cases the configuration<br>
could be automatically inferred from the rules, we believe that it is very<br>
useful for language designers/semanticists to actually think of and design<br>
their configuration explicitly, so the current implementation of <strong>K</strong> requires<br>
one to define it.</p>
<h2 class="mume-header" id="values">Values</h2>

<p>We here define the values of the language that the various fragments of<br>
programs evaluate to.  First, integers and Booleans are values.  As discussed,<br>
arrays evaluate to special array reference values holding (1) a location from<br>
where the array&apos;s elements are contiguously allocated in the store, and<br>
(2) the size of the array.  Functions evaluate to function values as<br>
&#x3BB;-abstractions (we do not need to evaluate functions to closures<br>
because each function is executed in the fixed global environment and<br>
function definitions cannot be nested).  Like in IMP and other<br>
languages, we finally tell the tool that values are <strong>K</strong> results.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span> <span class="token operator">|</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token operator">|</span> <span class="token keyword keyword-String">String</span>
               <span class="token operator">|</span> array<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span>
               <span class="token operator">|</span> lambda<span class="token punctuation">(</span>Ids<span class="token punctuation">,</span>Stmt<span class="token punctuation">)</span>
  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Val
  <span class="token keyword keyword-syntax">syntax</span> Exps <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Vals
  <span class="token keyword keyword-syntax">syntax</span> Vals <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Bottoms
  <span class="token keyword keyword-syntax">syntax</span> KResult <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Val
                   <span class="token operator">|</span> Vals  <span class="token comment">// TODO: should not need this</span>
</pre><p>The inclusion of values in expressions follows the methodology of<br>
syntactic definitions (like, e.g., in SOS): extend the syntax of the language<br>
to encompass all values and additional constructs needed to give semantics.<br>
In addition to that, it allows us to write the semantic rules using the<br>
original syntax of the language, and to parse them with the same (now extended<br>
with additional values) parser.  If writing the semantics directly on the <strong>K</strong><br>
AST, using the associated labels instead of the syntactic constructs, then one<br>
would not need to include values in expressions.</p>
<h2 class="mume-header" id="configuration">Configuration</h2>

<p>The <strong>K</strong> configuration of SIMPLE consists of a top level cell, <code>T</code>,<br>
holding a <code>threads</code> cell, a global environment map cell <code>genv</code><br>
mapping the global variables and function names to their locations, a shared<br>
store map cell <code>store</code> mapping each location to some value, a set cell<br>
<code>busy</code> holding the locks which have been acquired but not yet released<br>
by threads, a set cell <code>terminated</code> holding the unique identifiers of<br>
the threads which already terminated (needed for <code>join</code>), <code>input</code><br>
and <code>output</code> list cells, and a <code>nextLoc</code> cell holding a natural<br>
number indicating the next available location.  Unlike in the small languages<br>
in the <strong>K</strong> tutorial, where we used the fresh predicate to generate fresh<br>
locations, in larger languages, like SIMPLE, we prefer to explicitly manage<br>
memory.  The location counter in <code>nextLoc</code> models an actual physical<br>
location in the store; for simplicity, we assume arbitrarily large memory and<br>
no garbage collection.  The <code>threads</code> cell contains one <code>thread</code><br>
cell for each existing thread in the program.  Note that the thread cell has<br>
multiplicity <code>*</code>, which means that at any given moment there could be zero,<br>
one or more <code>thread</code> cells.  Each <code>thread</code> cell contains a<br>
computation cell <code>k</code>, a <code>control</code> cell holding the various<br>
control structures needed to jump to certain points of interest in the program<br>
execution, a local environment map cell <code>env</code> mapping the thread local<br>
variables to locations in the store, and finally a <code>holds</code> map cell<br>
indicating what locks have been acquired by the thread and not released so far<br>
and how many times (SIMPLE&apos;s locks are re-entrant).  The <code>control</code> cell<br>
currently contains only two subcells, a function stack <code>fstack</code> which<br>
is a list and an exception stack <code>xstack</code> which is also a list.<br>
One can add more control structures in the <code>control</code> cell, such as a<br>
stack for break/continue of loops, etc., if the language is extended with more<br>
control-changing constructs.  Note that all cells except for <code>k</code> are<br>
also initialized, in that they contain a ground term of their corresponding<br>
sort.  The <code>k</code> cell is initialized with the program that will be passed<br>
to the <strong>K</strong> tool, as indicated by the <code>$PGM</code> variable, followed by the<br>
<code>execute</code> task (defined shortly).</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token comment">// the syntax declarations below are required because the sorts are</span>
  <span class="token comment">// referenced directly by a production and, because of the way KIL to KORE</span>
  <span class="token comment">// is implemented, the configuration syntax is not available yet</span>
  <span class="token comment">// should simply work once KIL is removed completely</span>
  <span class="token comment">// check other definitions for this hack as well</span>

  <span class="token keyword keyword-syntax">syntax</span> ControlCell
  <span class="token keyword keyword-syntax">syntax</span> ControlCellFragment

  <span class="token keyword keyword-configuration">configuration</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>T</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>red<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>threads</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>orange<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>thread</span> <span class="token attr-name">multiplicity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>*<span class="token punctuation">&quot;</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Map<span class="token punctuation">&quot;</span></span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>yellow<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>pink<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token operator">-</span><span class="token number">1</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">&gt;</span></span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>green<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> $PGM<span class="token punctuation">:</span>Stmt <span class="token operator">~&gt;</span> execute <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
                    <span class="token comment">//&lt;br/&gt; // TODO(KORE): support latex annotations #1799</span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>control</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>cyan<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fstack</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>blue<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fstack</span><span class="token punctuation">&gt;</span></span>
                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>xstack</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>purple<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>xstack</span><span class="token punctuation">&gt;</span></span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>control</span><span class="token punctuation">&gt;</span></span>
                    <span class="token comment">//&lt;br/&gt; // TODO(KORE): support latex annotations #1799</span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>violet<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>holds</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>black<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>holds</span><span class="token punctuation">&gt;</span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>thread</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>threads</span><span class="token punctuation">&gt;</span></span>
                <span class="token comment">//&lt;br/&gt; // TODO(KORE): support latex annotations #1799</span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>genv</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>pink<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>genv</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>white<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>busy</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>cyan<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Set <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>busy</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>terminated</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>red<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Set <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>terminated</span><span class="token punctuation">&gt;</span></span>
                <span class="token comment">//&lt;br/&gt; // TODO(KORE): support latex annotations #1799</span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>magenta<span class="token punctuation">&quot;</span></span> <span class="token attr-name">stream</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>stdin<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>input</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>output</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>brown<span class="token punctuation">&quot;</span></span> <span class="token attr-name">stream</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>stdout<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>output</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nextLoc</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>gray<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token number">0</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>nextLoc</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>T</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="declarations-and-initialization">Declarations and Initialization</h2>

<p>We start by defining the semantics of declarations (for variables,<br>
arrays and functions).</p>
<h2 class="mume-header" id="variable-declaration">Variable Declaration</h2>

<p>The SIMPLE syntax was desugared above so that each variable is<br>
declared alone and its initialization is done as a separate statement.<br>
The semantic rule below matches resulting variable declarations of the<br>
form <code>var X;</code> on top of the <code>k</code> cell<br>
(indeed, note that the <code>k</code> cell is complete, or round, to the<br>
left, and is torn, or ruptured, to the right), allocates a fresh<br>
location <code>L</code> in the store which is initialized with a special value<br>
<code>&#x22A5;</code> (indeed, the unit <code>.</code>, or nothing, is matched anywhere<br>
in the map &#x2012;note the tears at both sides&#x2012; and replaced with the<br>
mapping <code>L &#x21A6; &#x22A5;</code>), and binds <code>X</code> to <code>L</code> in the local<br>
environment shadowing previous declarations of <code>X</code>, if any.<br>
This possible shadowing of <code>X</code> requires us to therefore update the<br>
entire environment map, which is expensive and can significantly slow<br>
down the execution of larger programs.  On the other hand, since we know<br>
that <code>L</code> is not already bound in the store, we simply add the binding<br>
<code>L &#x21A6; &#x22A5;</code> to the store, thus avoiding a potentially complete<br>
traversal of the the store map in order to update it.  We prefer the approach<br>
used for updating the store whenever possible, because, in addition to being<br>
faster, it offers more true concurrency than the latter; indeed, according<br>
to the concurrent semantics of <code>K</code>, the store is not frozen while<br>
<code>L &#x21A6; &#x22A5;</code> is added to it, while the environment is frozen during the<br>
update operation <code>Env[L/X]</code>.  The variable declaration command is<br>
also removed from the top of the computation cell and the fresh location<br>
counter is incremented.  The undefined symbol <code>&#x22A5;</code> added in the store<br>
is of sort <code>KItem</code>, instead of <code>Val</code>, on purpose; this way, the<br>
store lookup rules will get stuck when one attempts to lookup an<br>
uninitialized location.  All the above happen in one transactional step,<br>
with the rule below.  Note also how configuration abstraction allows us to<br>
only mention the needed cells; indeed, as the configuration above states,<br>
the <code>k</code> and <code>env</code> cells are actually located within a<br>
<code>thread</code> cell within the <code>threads</code> cell, but one needs<br>
not mention these: the configuration context of the rule is<br>
automatically transformed to match the declared configuration<br>
structure.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;undefined&quot;</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> var X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token operator">=&gt;</span> Env<span class="token punctuation">[</span>X &lt;<span class="token operator">-</span> L<span class="token punctuation">]</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Map <span class="token operator">=&gt;</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; undefined <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nextLoc</span><span class="token punctuation">&gt;</span></span> L <span class="token operator">=&gt;</span> L <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>nextLoc</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="array-declaration">Array Declaration</h2>

<p>The <strong>K</strong> semantics of the uni-dimensional array declaration is somehow similar<br>
to the above declaration of ordinary variables.  First, note the<br>
context declaration below, which requests the evaluation of the array<br>
dimension.  Once evaluated, say to a natural number <code>N</code>, then<br>
<code>N +Int 1</code> locations are allocated in the store for<br>
an array of size <code>N</code>, the additional location (chosen to be the first<br>
one allocated) holding the array reference value.  The array reference<br>
value <code>array(L,N)</code> states that the array has size <code>N</code> and its<br>
elements are located contiguously in the store starting with location<br>
<code>L</code>.  The operation <code>L &#x2026; L&apos; &#x21A6; V</code>, defined at the end of this<br>
file in the auxiliary operation section, initializes each location in<br>
the list <code>L &#x2026; L&apos;</code> to <code>V</code>.  Note that, since the dimensions of<br>
array declarations can be arbitrary expressions, this virtually means<br>
that we can dynamically allocate memory in SIMPLE by means of array<br>
declarations.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-context">context</span> var _<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">[</span>HOLE<span class="token punctuation">]</span><span class="token punctuation">;</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> var X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">[</span>N<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token operator">=&gt;</span> Env<span class="token punctuation">[</span>X &lt;<span class="token operator">-</span> L<span class="token punctuation">]</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Map <span class="token operator">=&gt;</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; array<span class="token punctuation">(</span>L <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">,</span> N<span class="token punctuation">)</span>
                          <span class="token punctuation">(</span>L <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">(</span>L <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> N<span class="token punctuation">)</span> <span class="token operator">|</span><span class="token operator">-</span>&gt; undefined <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nextLoc</span><span class="token punctuation">&gt;</span></span> L <span class="token operator">=&gt;</span> L <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span> <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> N <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>nextLoc</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> N <span class="token operator">&gt;=</span><span class="token keyword keyword-Int">Int</span> <span class="token number">0</span>
</pre><p>SIMPLE allows multi-dimensional arrays.  For semantic simplicity, we<br>
desugar them all into uni-dimensional arrays by code transformation.<br>
This way, we only need to give semantics to uni-dimensional arrays.<br>
First, note that the context rule above actually evaluates all the array<br>
dimensions (that&apos;s why we defined the expression lists strict!):<br>
Upon evaluating the array dimensions, the code generation rule below<br>
desugars multi-dimensional array declaration to uni-dimensional declarations.<br>
To this aim, we introduce two special unique variable identifiers,<br>
<code>$1</code> and <code>$2</code>.  The first variable, <code>$1</code>, iterates<br>
through and initializes each element of the first dimension with an array<br>
of the remaining dimensions, declared as variable <code>$2</code>:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Id">Id</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;$1&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token string">&quot;$2&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> var X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">[</span>N1<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> N2<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token operator">=&gt;</span> var X<span class="token punctuation">[</span>N1<span class="token punctuation">]</span><span class="token punctuation">;</span>
       <span class="token punctuation">{</span>
         for<span class="token punctuation">(</span>var $<span class="token number">1</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> $<span class="token number">1</span> <span class="token operator">&lt;=</span> N1 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>$<span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           var $<span class="token number">2</span><span class="token punctuation">[</span>N2<span class="token punctuation">,</span> Vs<span class="token punctuation">]</span><span class="token punctuation">;</span>
           X<span class="token punctuation">[</span>$<span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> $<span class="token number">2</span><span class="token punctuation">;</span>
         <span class="token punctuation">}</span>
       <span class="token punctuation">}</span>
</pre><p>Ideally, one would like to perform syntactic desugarings like the one<br>
above before the actual semantics.  Unfortunately, that was not possible in<br>
this case because the dimension expressions of the multi-dimensional array need<br>
to be evaluated first.  Indeed, the desugaring rule above does not work if the<br>
dimensions of the declared array are arbitrary expressions, because they can<br>
have side effects (e.g., <code>a[++x,++x]</code>) and those side effects would be<br>
propagated each time the expression is evaluated in the desugaring code (note<br>
that both the loop condition and the nested multi-dimensional declaration<br>
would need to evaluate the expressions given as array dimensions).</p>
<h2 class="mume-header" id="function-declaration">Function declaration</h2>

<p>Functions are evaluated to &#x3BB;-abstractions and stored like any other<br>
values in the store.  A binding is added into the environment for the function<br>
name to the location holding its body.  Similarly to the C language, SIMPLE<br>
only allows function declarations at the top level of the program.  More<br>
precisely, the subsequent semantics of SIMPLE only works well when one<br>
respects this requirement.  Indeed, the simplistic context-free parser<br>
generated by the grammar above is more generous than we may want, in that it<br>
allows function declarations anywhere any declaration is allowed, including<br>
inside arbitrary blocks.  However, as the rule below shows, we are <code>not</code><br>
storing the declaration environment with the &#x3BB;-abstraction value as<br>
closures do.  Instead, as seen shortly, we switch to the global environment<br>
whenever functions are invoked, which is consistent with our requirement that<br>
functions should only be declared at the top.  Thus, if one declares local<br>
functions, then one may see unexpected behaviors (e.g., when one shadows a<br>
global variable before declaring a local function).  The type checker of<br>
SIMPLE, also defined in <strong>K</strong> (see <code>examples/simple/typed/static</code>),<br>
discards programs which do not respect this requirement.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> function F<span class="token punctuation">(</span>Xs<span class="token punctuation">)</span> S <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token operator">=&gt;</span> Env<span class="token punctuation">[</span>F &lt;<span class="token operator">-</span> L<span class="token punctuation">]</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Map <span class="token operator">=&gt;</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; lambda<span class="token punctuation">(</span>Xs<span class="token punctuation">,</span> S<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nextLoc</span><span class="token punctuation">&gt;</span></span> L <span class="token operator">=&gt;</span> L <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>nextLoc</span><span class="token punctuation">&gt;</span></span>
</pre><p>When we are done with the first pass (pre-processing), the computation<br>
cell <code>k</code> contains only the token <code>execute</code> (see the configuration<br>
declaration above, where the computation item <code>execute</code> was placed<br>
right after the program in the <code>k</code> cell of the initial configuration)<br>
and the cell <code>genv</code> is empty.  In this case, we have to call<br>
<code>main()</code> and to initialize the global environment by transferring the<br>
contents of the local environment into it.  We prefer to do it this way, as<br>
opposed to processing all the top level declarations directly within the global<br>
environment, because we want to avoid duplication of semantics: the syntax of<br>
the global declarations is identical to that of their corresponding local<br>
declarations, so the semantics of the latter suffices provided that we copy<br>
the local environment into the global one once we are done with the<br>
pre-processing.  We want this separate pre-processing step precisely because<br>
we want to create the global environment.  All (top-level) functions end up<br>
having their names bound in the global environment and, as seen below, they<br>
are executed in that same global environment; all these mean, in particular,<br>
that the functions &quot;see&quot; each other, allowing for mutual recursion, etc.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;execute&quot;</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> execute <span class="token operator">=&gt;</span> main<span class="token punctuation">(</span><span class="token punctuation">.</span>Exps<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>genv</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token operator">=&gt;</span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>genv</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="expressions-1">Expressions</h2>

<p>We next define the <strong>K</strong> semantics of all the expression constructs.</p>
<h2 class="mume-header" id="variable-lookup">Variable lookup</h2>

<p>When a variable <code>X</code> is the first computational task, and <code>X</code> is bound to some<br>
location <code>L</code> in the environment, and <code>L</code> is mapped to some value <code>V</code> in the<br>
store, then we rewrite <code>X</code> into <code>V</code>:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=&gt;</span> V <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> X <span class="token operator">|</span><span class="token operator">-</span>&gt; L <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; V<span class="token punctuation">:</span>Val <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
</pre><p>Note that the rule above excludes reading <code>&#x22A5;</code>, because <code>&#x22A5;</code> is not<br>
a value and <code>V</code> is checked at runtime to be a value.</p>
<h2 class="mume-header" id="variablearray-increment">Variable/Array increment</h2>

<p>This is tricky, because we want to allow both <code>++x</code> and <code>++a[5]</code>.<br>
Therefore, we need to extract the lvalue of the expression to increment.<br>
To do that, we state that the expression to increment should be wrapped<br>
by the auxiliary <code>lvalue</code> operation and then evaluated.  The semantics<br>
of this auxiliary operation is defined at the end of this file.  For now, all<br>
we need to know is that it takes an expression and evaluates to a location<br>
value.  Location values, also defined at the end of the file, are integers<br>
wrapped with the operation <code>loc</code>, to distinguish them from ordinary<br>
integers.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-context">context</span> <span class="token operator">++</span><span class="token punctuation">(</span>HOLE <span class="token operator">=&gt;</span> lvalue<span class="token punctuation">(</span>HOLE<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token operator">++</span>loc<span class="token punctuation">(</span>L<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> I <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; <span class="token punctuation">(</span>I <span class="token operator">=&gt;</span> I <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="arithmetic-operators">Arithmetic operators</h2>

<p>There is nothing special about the following rules.  They rewrite the<br>
language constructs to their library counterparts when their arguments<br>
become values of expected sorts:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">+</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> Str1 <span class="token operator">+</span> Str2 <span class="token operator">=&gt;</span> Str1 <span class="token operator">+</span><span class="token keyword keyword-String">String</span> Str2
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">-</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">*</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">*</span><span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">/</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">/</span><span class="token keyword keyword-Int">Int</span> I2 <span class="token keyword keyword-requires">requires</span> I2 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K <span class="token number">0</span>
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">%</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">%</span><span class="token keyword keyword-Int">Int</span> I2 <span class="token keyword keyword-requires">requires</span> I2 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K <span class="token number">0</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token operator">-</span> I <span class="token operator">=&gt;</span> <span class="token number">0</span> <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> I
  <span class="token keyword keyword-rule">rule</span> I1 &lt; I2 <span class="token operator">=&gt;</span> I1 &lt;<span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">&lt;=</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">&lt;=</span><span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> I1 &gt; I2 <span class="token operator">=&gt;</span> I1 &gt;<span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">&gt;=</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">&gt;=</span><span class="token keyword keyword-Int">Int</span> I2
</pre><p>The equality and inequality constructs reduce to syntactic comparison<br>
of the two argument values (which is what the equality on <code>K</code> terms does).</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> V1<span class="token punctuation">:</span>Val <span class="token operator">==</span> V2<span class="token punctuation">:</span>Val <span class="token operator">=&gt;</span> V1 <span class="token operator">==</span>K V2
  <span class="token keyword keyword-rule">rule</span> V1<span class="token punctuation">:</span>Val <span class="token operator">!=</span> V2<span class="token punctuation">:</span>Val <span class="token operator">=&gt;</span> V1 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K V2
</pre><p>The logical negation is clear, but the logical conjunction and disjunction<br>
are short-circuited:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token operator">!</span> T <span class="token operator">=&gt;</span> notBool<span class="token punctuation">(</span>T<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">true</span>  <span class="token operator">&amp;&amp;</span> E <span class="token operator">=&gt;</span> E
  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">false</span> <span class="token operator">&amp;&amp;</span> _ <span class="token operator">=&gt;</span> <span class="token boolean">false</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">true</span>  <span class="token operator">||</span> _ <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">false</span> <span class="token operator">||</span> E <span class="token operator">=&gt;</span> E
</pre><h2 class="mume-header" id="array-lookup">Array lookup</h2>

<p>Untyped SIMPLE does not check array bounds (the dynamically typed version of<br>
it, in <code>examples/simple/typed/dynamic</code>, does check for array out of<br>
bounds).  The first rule below desugars the multi-dimensional array access to<br>
uni-dimensional array access; recall that the array access operation was<br>
declared strict, so all sub-expressions involved are already values at this<br>
stage.  The second rule rewrites the array access to a lookup operation at a<br>
precise location; we prefer to do it this way to avoid locking the store.<br>
The semantics of the auxiliary <code>lookup</code> operation is straightforward,<br>
and is defined at the end of the file.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token comment">// The [anywhere] feature is underused, because it would only be used</span>
<span class="token comment">// at the top of the computation or inside the lvalue wrapper. So it</span>
<span class="token comment">// may not be worth, or we may need to come up with a special notation</span>
<span class="token comment">// allowing us to enumerate contexts for [anywhere] rules.</span>
  <span class="token keyword keyword-rule">rule</span> V<span class="token punctuation">:</span>Val<span class="token punctuation">[</span>N1<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> N2<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">]</span> <span class="token operator">=&gt;</span> V<span class="token punctuation">[</span>N1<span class="token punctuation">]</span><span class="token punctuation">[</span>N2<span class="token punctuation">,</span> Vs<span class="token punctuation">]</span>
    <span class="token punctuation">[</span>anywhere<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> array<span class="token punctuation">(</span>L<span class="token punctuation">,</span>_<span class="token punctuation">)</span><span class="token punctuation">[</span>N<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">]</span> <span class="token operator">=&gt;</span> lookup<span class="token punctuation">(</span>L <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> N<span class="token punctuation">)</span>
    <span class="token punctuation">[</span>anywhere<span class="token punctuation">]</span>
</pre><h2 class="mume-header" id="size-of-an-array">Size of an array</h2>

<p>The size of the array is stored in the array reference value, and the<br>
<code>sizeOf</code> construct was declared strict, so:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> sizeOf<span class="token punctuation">(</span>array<span class="token punctuation">(</span>_<span class="token punctuation">,</span>N<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> N
</pre><h2 class="mume-header" id="function-call">Function call</h2>

<p>Function application was strict in both its arguments, so we can<br>
assume that both the function and its arguments are evaluated to<br>
values (the former expected to be a &#x3BB;-abstraction).  The first<br>
rule below matches a well-formed function application on top of the<br>
computation and performs the following steps atomically: it switches<br>
to the function body followed by <code>return;</code> (for the case in<br>
which the function does not use an explicit return statement); it<br>
pushes the remaining computation, the current environment, and the<br>
current control data onto the function stack (the remaining<br>
computation can thus also be discarded from the computation cell,<br>
because an unavoidable subsequent <code>return</code> statement &#x2012;see<br>
above&#x2012; will always recover it from the stack); it switches the<br>
current environment (which is being pushed on the function stack) to<br>
the global environment, which is where the free variables in the<br>
function body should be looked up; it binds the formal parameters to<br>
fresh locations in the new environment, and stores the actual<br>
arguments to those locations in the store (this latter step is easily<br>
done by reducing the problem to variable declarations, whose semantics<br>
we have already defined; the auxiliary operation <code>mkDecls</code> is<br>
defined at the end of the file).  The second rule pops the<br>
computation, the environment and the control data from the function<br>
stack when a <code>return</code> statement is encountered as the next<br>
computational task, passing the returned value to the popped<br>
computation (the popped computation was the context in which the<br>
returning function was called).  Note that the pushing/popping of the<br>
control data is crucial.  Without it, one may have a function that<br>
contains an exception block with a return statement inside, which<br>
would put the <code>xstack</code> cell in an inconsistent state (since the<br>
exception block modifies it, but that modification should be<br>
irrelevant once the function returns).  We add an artificial<br>
<code>nothing</code> value to the language, which is returned by the<br>
nulary <code>return;</code> statements.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span>  <span class="token punctuation">(</span>Map<span class="token punctuation">,</span>K<span class="token punctuation">,</span>ControlCellFragment<span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> lambda<span class="token punctuation">(</span>Xs<span class="token punctuation">,</span>S<span class="token punctuation">)</span><span class="token punctuation">(</span>Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> K <span class="token operator">=&gt;</span> mkDecls<span class="token punctuation">(</span>Xs<span class="token punctuation">,</span>Vs<span class="token punctuation">)</span> S return<span class="token punctuation">;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>control</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fstack</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token operator">=&gt;</span> ListItem<span class="token punctuation">(</span><span class="token punctuation">(</span>Env<span class="token punctuation">,</span>K<span class="token punctuation">,</span>C<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fstack</span><span class="token punctuation">&gt;</span></span>
         C
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>control</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token operator">=&gt;</span> GEnv <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>genv</span><span class="token punctuation">&gt;</span></span> GEnv <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>genv</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> return<span class="token punctuation">(</span>V<span class="token punctuation">:</span>Val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">~&gt;</span> _ <span class="token operator">=&gt;</span> V <span class="token operator">~&gt;</span> K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>control</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fstack</span><span class="token punctuation">&gt;</span></span> ListItem<span class="token punctuation">(</span><span class="token punctuation">(</span>Env<span class="token punctuation">,</span>K<span class="token punctuation">,</span>C<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>List <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fstack</span><span class="token punctuation">&gt;</span></span>
         <span class="token punctuation">(</span>_ <span class="token operator">=&gt;</span> C<span class="token punctuation">)</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>control</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> _ <span class="token operator">=&gt;</span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;nothing&quot;</span>
  <span class="token keyword keyword-rule">rule</span> return<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> return nothing<span class="token punctuation">;</span>
</pre><p>Like for division-by-zero, it is left unspecified what happens<br>
when the <code>nothing</code> value is used in domain calculations.  For<br>
example, from the the perspective of the language semantics,<br>
<code>7 +Int nothing</code> can evaluate to anything, or<br>
may not evaluate at all (be undefined).  If one wants to make sure that<br>
such artificial values are never misused, then one needs to define a static<br>
checker (also using <strong>K</strong>, like our the type checker in<br>
<code>examples/simple/typed/static</code>) and reject programs that do.<br>
Note that, unlike the undefined symbol <code>&#x22A5;</code> which had the sort <code>K</code><br>
instead of <code>Val</code>, we defined <code>nothing</code> to be a value.  That<br>
is because, as explained above, we do not want the program to get<br>
stuck when nothing is returned by a function.  Instead, we want the<br>
behavior to be unspecified; in particular, if one is careful to never<br>
use the returned value in domain computation, like it happens when we<br>
call a function for its side effects (e.g., with a statement of the<br>
form <code>f(x);</code>), then the program does not get stuck.</p>
<h2 class="mume-header" id="read">Read</h2>

<p>The <code>read()</code> expression construct simply evaluates to the next<br>
input value, at the same time discarding the input value from the<br>
<code>in</code> cell.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> read<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> I <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span><span class="token punctuation">&gt;</span></span> ListItem<span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>List <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>input</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="assignment">Assignment</h2>

<p>In SIMPLE, like in C, assignments are expression constructs and not statement<br>
constructs.  To make it a statement all one needs to do is to follow it by a<br>
semi-colon <code>;</code> (see the semantics for expression statements below).<br>
Like for the increment, we want to allow assignments not only to variables but<br>
also to array elements, e.g., <code>e1[e2] = e3</code> where <code>e1</code> evaluates<br>
to an array reference, <code>e2</code> to a natural number, and <code>e3</code> to any<br>
value.  Thus, we first compute the lvalue of the left-hand-side expression<br>
that appears in an assignment, and then we do the actual assignment to the<br>
resulting location:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-context">context</span> <span class="token punctuation">(</span>HOLE <span class="token operator">=&gt;</span> lvalue<span class="token punctuation">(</span>HOLE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> _

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> loc<span class="token punctuation">(</span>L<span class="token punctuation">)</span> <span class="token operator">=</span> V<span class="token punctuation">:</span>Val <span class="token operator">=&gt;</span> V <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; <span class="token punctuation">(</span>_ <span class="token operator">=&gt;</span> V<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="statements-1">Statements</h2>

<p>We next define the <strong>K</strong> semantics of statements.</p>
<h2 class="mume-header" id="blocks">Blocks</h2>

<p>Empty blocks are simply discarded, as shown in the first rule below.<br>
For non-empty blocks, we schedule the enclosed statement but we have to<br>
make sure the environment is recovered after the enclosed statement executes.<br>
Recall that we allow local variable declarations, whose scope is the block<br>
enclosing them.  That is the reason for which we have to recover the<br>
environment after the block.  This allows us to have a very simple semantics<br>
for variable declarations, as we did above.  One can make the two rules below<br>
computational if one wants them to count as computational steps.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span> S <span class="token punctuation">}</span> <span class="token operator">=&gt;</span> S <span class="token operator">~&gt;</span> setEnv<span class="token punctuation">(</span>Env<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
</pre><p>The basic definition of environment recovery is straightforward and<br>
given in the section on auxiliary constructs at the end of the file.</p>
<p>There are two common alternatives to the above semantics of blocks.<br>
One is to keep track of the variables which are declared in the block and only<br>
recover those at the end of the block.  This way one does more work for<br>
variable declarations but conceptually less work for environment recovery; we<br>
say <code>conceptually</code> because it is not clear that it is indeed the case that<br>
one does less work when AC matching is involved.  The other alternative is to<br>
work with a stack of environments instead of a flat environment, and push the<br>
current environment when entering a block and pop it when exiting it.  This<br>
way, one does more work when accessing variables (since one has to search the<br>
variable in the environment stack in a top-down manner), but on the other hand<br>
uses smaller environments and the definition gets closer to an implementation.<br>
Based on experience with dozens of language semantics and other <strong>K</strong> definitions,<br>
we have found that our approach above is the best trade-off between elegance<br>
and efficiency (especially since rewrite engines have built-in techniques to<br>
lazily copy terms, by need, thus not creating unnecessary copies),<br>
so it is the one that we follow in general.</p>
<h2 class="mume-header" id="sequential-composition">Sequential composition</h2>

<p>Sequential composition is desugared into <strong>K</strong>&apos;s builtin sequentialization<br>
operation (recall that, like in C, the semi-colon <code>;</code> is not a<br>
statement separator in SIMPLE &#x2014; it is either a statement terminator or a<br>
construct for a statement from an expression).  Note that <strong>K</strong> allows<br>
to define the semantics of SIMPLE in such a way that statements eventually<br>
dissolve from the top of the computation when they are completed; this is in<br>
sharp contrast to (artificially) <code>evaluating</code> them to a special<br>
<code>skip</code> statement value and then getting rid of that special value, as<br>
it is the case in other semantic approaches (where everything must evaluate<br>
to something).  This means that once <code>S&#x2081;</code> completes in the rule below, <code>S&#x2082;</code><br>
becomes automatically the next computation item without any additional<br>
(explicit or implicit) rules.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> S1<span class="token punctuation">:</span>Stmt S2<span class="token punctuation">:</span>Stmt <span class="token operator">=&gt;</span> S1 <span class="token operator">~&gt;</span> S2
</pre><p>A subtle aspect of the rule above is that <code>S&#x2081;</code> is declared to have sort<br>
<code>Stmts</code> and not <code>Stmt</code>.  That is because desugaring macros can indeed<br>
produce left associative sequential composition of statements.  For example,<br>
the code <code>var x=0; x=1;</code> is desugared to<br>
<code>(var x; x=0;) x=1;</code>, so although originally the first term of<br>
the sequential composition had sort <code>Stmt</code>, after desugaring it became<br>
of sort <code>Stmts</code>.  Note that the attribute <code>[right]</code> associated<br>
to the sequential compositon production is an attribute of the syntax, and not<br>
of the semantics: e.g., it tells the parser to parse<br>
<code>var x; x=0; x=1;</code> as <code>var x; (x=0; x=1;)</code>, but it<br>
does not tell the rewrite engine to rewrite <code>(var x; x=0;) x=1;</code> to<br>
<code>var x; (x=0; x=1;)</code>.</p>
<h2 class="mume-header" id="expression-statements">Expression statements</h2>

<p>Expression statements are only used for their side effects, so their result<br>
value is simply discarded.  Common examples of expression statements are ones<br>
of the form <code>++x;</code>, <code>x=e;</code>, <code>e1[e2]=e3;</code>, etc.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> _<span class="token punctuation">:</span>Val<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K
</pre><h2 class="mume-header" id="conditional">Conditional</h2>

<p>Since the conditional was declared with the <code>strict(1)</code> attribute, we<br>
can assume that its first argument will eventually be evaluated.  The rules<br>
below cover the only two possibilities in which the conditional is allowed to<br>
proceed (otherwise the rewriting process gets stuck).</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> if <span class="token punctuation">(</span> <span class="token boolean">true</span><span class="token punctuation">)</span> S else _ <span class="token operator">=&gt;</span> S
  <span class="token keyword keyword-rule">rule</span> if <span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> _ else S <span class="token operator">=&gt;</span> S
</pre><h2 class="mume-header" id="while-loop">While loop</h2>

<p>The simplest way to give the semantics of the while loop is by unrolling.<br>
Note, however, that its unrolling is only allowed when the while loop reaches<br>
the top of the computation (to avoid non-termination of unrolling).  The<br>
simple while loop semantics below works because our while loops in SIMPLE are<br>
indeed very basic.  If we allowed break/continue of loops then we would need<br>
a completely different semantics, which would also involve the <code>control</code> cell.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> while <span class="token punctuation">(</span>E<span class="token punctuation">)</span> S <span class="token operator">=&gt;</span> if <span class="token punctuation">(</span>E<span class="token punctuation">)</span> <span class="token punctuation">{</span>S while<span class="token punctuation">(</span>E<span class="token punctuation">)</span>S<span class="token punctuation">}</span>
</pre><h2 class="mume-header" id="print">Print</h2>

<p>The <code>print</code> statement was strict, so all its arguments are now<br>
evaluated (recall that <code>print</code> is variadic).  We append each of<br>
its evaluated arguments to the output buffer, and discard the residual<br>
<code>print</code> statement with an empty list of arguments.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> print<span class="token punctuation">(</span>V<span class="token punctuation">:</span>Val<span class="token punctuation">,</span> Es <span class="token operator">=&gt;</span> Es<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>output</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>List <span class="token operator">=&gt;</span> ListItem<span class="token punctuation">(</span>V<span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>output</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> print<span class="token punctuation">(</span><span class="token punctuation">.</span>Vals<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K
</pre><h2 class="mume-header" id="exceptions">Exceptions</h2>

<p>SIMPLE allows parametric exceptions, in that one can throw and catch a<br>
particular value.  The statement <code>try S&#x2081; catch(X) S&#x2082;</code><br>
proceeds with the evaluation of <code>S&#x2081;</code>.  If <code>S&#x2081;</code> evaluates normally, i.e.,<br>
without any exception thrown, then <code>S&#x2082;</code> is discarded and the execution<br>
continues normally.  If <code>S&#x2081;</code> throws an exception with a statement of the<br>
form <code>throw E</code>, then <code>E</code> is first evaluated to some value <code>V</code><br>
(<code>throw</code> was declared to be strict), then <code>V</code> is bound to <code>X</code>, then<br>
<code>S&#x2082;</code> is evaluated in the new environment while the reminder of <code>S&#x2081;</code> is<br>
discarded, then the environment is recovered and the execution continues<br>
normally with the statement following the <code>try S&#x2081; catch(X) S&#x2082;</code> statement.<br>
Exceptions can be nested and the statements in the<br>
<code>catch</code> part (<code>S&#x2082;</code> in our case) can throw exceptions to the<br>
upper level.  One should be careful with how one handles the control data<br>
structures here, so that the abrupt changes of control due to exception<br>
throwing and to function returns interact correctly with each other.<br>
For example, we want to allow function calls inside the statement <code>S&#x2081;</code> in<br>
a <code>try S&#x2081; catch(X) S&#x2082;</code> block which can throw an exception<br>
that is not caught by the function but instead is propagated to the<br>
<code>try S&#x2081; catch(X) S&#x2082;</code> block that called the function.<br>
Therefore, we have to make sure that the function stack as well as other<br>
potential control structures are also properly modified when the exception<br>
is thrown to correctly recover the execution context.  This can be easily<br>
achieved by pushing/popping the entire current control context onto the<br>
exception stack.  The three rules below modularly do precisely the above.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span>Stmt<span class="token punctuation">,</span>K<span class="token punctuation">,</span>Map<span class="token punctuation">,</span>ControlCellFragment<span class="token punctuation">)</span>

  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;popx&quot;</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span>try S1 catch<span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token punctuation">{</span>S2<span class="token punctuation">}</span> <span class="token operator">=&gt;</span> S1 <span class="token operator">~&gt;</span> popx<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>control</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>xstack</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token operator">=&gt;</span> ListItem<span class="token punctuation">(</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> S2<span class="token punctuation">,</span> K<span class="token punctuation">,</span> Env<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>xstack</span><span class="token punctuation">&gt;</span></span>
         C
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>control</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> popx <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>xstack</span><span class="token punctuation">&gt;</span></span> ListItem<span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>List <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>xstack</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> throw V<span class="token punctuation">:</span>Val<span class="token punctuation">;</span> <span class="token operator">~&gt;</span> _ <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> var X <span class="token operator">=</span> V<span class="token punctuation">;</span> S2 <span class="token punctuation">}</span> <span class="token operator">~&gt;</span> K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>control</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>xstack</span><span class="token punctuation">&gt;</span></span> ListItem<span class="token punctuation">(</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> S2<span class="token punctuation">,</span> K<span class="token punctuation">,</span> Env<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>List <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>xstack</span><span class="token punctuation">&gt;</span></span>
         <span class="token punctuation">(</span>_ <span class="token operator">=&gt;</span> C<span class="token punctuation">)</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>control</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> _ <span class="token operator">=&gt;</span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
</pre><p>The catch statement <code>S&#x2082;</code> needs to be executed in the original environment,<br>
but where the thrown value <code>V</code> is bound to the catch variable <code>X</code>.  We here<br>
chose to rely on two previously defined constructs when giving semantics to<br>
the catch part of the statement: (1) the variable declaration with<br>
initialization, for binding <code>X</code> to <code>V</code>; and (2) the block construct for<br>
preventing <code>X</code> from shadowing variables in the original environment upon the<br>
completion of <code>S&#x2082;</code>.</p>
<h2 class="mume-header" id="threads">Threads</h2>

<p>SIMPLE&apos;s threads can be created and terminated dynamically, and can<br>
synchronize by acquiring and releasing re-entrant locks and by rendezvous.<br>
We discuss the seven rules giving the semantics of these operations below.</p>
<h2 class="mume-header" id="thread-creation">Thread creation</h2>

<p>Threads can be created by any other threads using the <code>spawn S</code><br>
construct.  The spawn expression construct evaluates to the unique identifier<br>
of the newly created thread and, at the same time, a new thread cell is added<br>
into the configuration, initialized with the <code>S</code> statement and sharing the<br>
same environment with the parent thread.  Note that the newly created<br>
<code>thread</code> cell is torn.  That means that the remaining cells are added<br>
and initialized automatically as described in the definition of SIMPLE&apos;s<br>
configuration.  This is part of <strong>K</strong>&apos;s configuration abstraction mechanism.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>thread</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> spawn S <span class="token operator">=&gt;</span> <span class="token operator">!</span>T<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>thread</span><span class="token punctuation">&gt;</span></span>
       <span class="token punctuation">(</span><span class="token punctuation">.</span>Bag <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>thread</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
               <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> S <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
               <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
               <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">&gt;</span></span> <span class="token operator">!</span>T <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">&gt;</span></span>
             <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>thread</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>
</pre><h2 class="mume-header" id="thread-termination">Thread termination</h2>

<p>Dually to the above, when a thread terminates its assigned computation (the<br>
contents of its <code>k</code> cell) is empty, so the thread can be dissolved.<br>
However, since no discipline is imposed on how locks are acquired and released,<br>
it can be the case that a terminating thread still holds locks.  Those locks<br>
must be released, so other threads attempting to acquire them do not deadlock.<br>
We achieve that by removing all the locks held by the terminating thread in its<br>
<code>holds</code> cell from the set of busy locks in the <code>busy</code> cell<br>
(<code>keys(H)</code> returns the domain of the map <code>H</code> as a set, that is, only<br>
the locks themselves ignoring their multiplicity).  As seen below, a lock is<br>
added to the <code>busy</code> cell as soon as it is acquired for the first time<br>
by a thread.  The unique identifier of the terminated thread is also collected<br>
into the <code>terminated</code> cell, so the <code>join</code> construct knows which<br>
threads have terminated.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>thread</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span>K<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>holds</span><span class="token punctuation">&gt;</span></span>H<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>holds</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">&gt;</span></span>T<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>thread</span><span class="token punctuation">&gt;</span></span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Bag<span class="token punctuation">)</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>busy</span><span class="token punctuation">&gt;</span></span> Busy <span class="token operator">=&gt;</span> Busy <span class="token operator">-</span>Set keys<span class="token punctuation">(</span>H<span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>busy</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>terminated</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Set <span class="token operator">=&gt;</span> SetItem<span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>terminated</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="thread-joining">Thread joining</h2>

<p>Thread joining is now straightforward: all we need to do is to check whether<br>
the identifier of the thread to be joined is in the <code>terminated</code> cell.<br>
If yes, then the <code>join</code> statement dissolves and the joining thread<br>
continues normally; if not, then the joining thread gets stuck.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> join T<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>terminated</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> SetItem<span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>terminated</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="acquire-lock">Acquire lock</h2>

<p>There are two cases to distinguish when a thread attempts to acquire a lock<br>
(in SIMPLE any value can be used as a lock):<br>
(1) The thread does not currently have the lock, in which case it has to<br>
take it provided that the lock is not already taken by another thread (see<br>
the side condition of the first rule).<br>
(2) The thread already has the lock, in which case it just increments its<br>
counter for the lock (the locks are re-entrant).  These two cases are captured<br>
by the two rules below:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> acquire V<span class="token punctuation">:</span>Val<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>holds</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Map <span class="token operator">=&gt;</span> V <span class="token operator">|</span><span class="token operator">-</span>&gt; <span class="token number">0</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>holds</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>busy</span><span class="token punctuation">&gt;</span></span> Busy <span class="token punctuation">(</span><span class="token punctuation">.</span>Set <span class="token operator">=&gt;</span> SetItem<span class="token punctuation">(</span>V<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>busy</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> <span class="token punctuation">(</span>notBool<span class="token punctuation">(</span>V in Busy<span class="token punctuation">)</span><span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> acquire V<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>holds</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> V<span class="token punctuation">:</span>Val <span class="token operator">|</span><span class="token operator">-</span>&gt; <span class="token punctuation">(</span>N <span class="token operator">=&gt;</span> N <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>holds</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="release-lock">Release lock</h2>

<p>Similarly, there are two corresponding cases to distinguish when a thread<br>
releases a lock:<br>
(1) The thread holds the lock more than once, in which case all it needs to do<br>
is to decrement the lock counter.<br>
(2) The thread holds the lock only once, in which case it needs to remove it<br>
from its <code>holds</code> cell and also from the the shared <code>busy</code> cell,<br>
so other threads can acquire it if they need to.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> release V<span class="token punctuation">:</span>Val<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>holds</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> V <span class="token operator">|</span><span class="token operator">-</span>&gt; <span class="token punctuation">(</span>N <span class="token operator">=&gt;</span> N <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>holds</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> N &gt;<span class="token keyword keyword-Int">Int</span> <span class="token number">0</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> release V<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>holds</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> V<span class="token punctuation">:</span>Val <span class="token operator">|</span><span class="token operator">-</span>&gt; <span class="token number">0</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Map <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>holds</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>busy</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> SetItem<span class="token punctuation">(</span>V<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Set <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>busy</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="rendezvous-synchronization">Rendezvous synchronization</h2>

<p>In addition to synchronization through acquire and release of locks, SIMPLE<br>
also provides a construct for rendezvous synchronization.  A thread whose next<br>
statement to execute is <code>rendezvous(V)</code> gets stuck until another<br>
thread reaches an identical statement; when that happens, the two threads<br>
drop their rendezvous statements and continue their executions.  If three<br>
threads happen to have an identical rendezvous statement as their next<br>
statement, then precisely two of them will synchronize and the other will<br>
remain blocked until another thread reaches a similar rendezvous statement.<br>
The rule below is as simple as it can be.  Note, however, that, again, it is<br>
<strong>K</strong>&apos;s mechanism for configuration abstraction that makes it work as desired:<br>
since the only cell which can multiply containing a <code>k</code> cell inside is<br>
the <code>thread</code> cell, the only way to concretize the rule below to the<br>
actual configuration of SIMPLE is to include each <code>k</code> cell in a<br>
<code>thread</code> cell.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> rendezvous V<span class="token punctuation">:</span>Val<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> rendezvous V<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="auxiliary-declarations-and-operations">Auxiliary declarations and operations</h2>

<p>In this section we define all the auxiliary constructs used in the<br>
above semantics.</p>
<h2 class="mume-header" id="making-declarations">Making declarations</h2>

<p>The <code>mkDecls</code> auxiliary construct turns a list of identifiers<br>
and a list of values in a sequence of corresponding variable<br>
declarations.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> mkDecls<span class="token punctuation">(</span>Ids<span class="token punctuation">,</span>Vals<span class="token punctuation">)</span>  <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> mkDecls<span class="token punctuation">(</span><span class="token punctuation">(</span>X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span> Xs<span class="token punctuation">:</span>Ids<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>V<span class="token punctuation">:</span>Val<span class="token punctuation">,</span> Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> var X<span class="token operator">=</span>V<span class="token punctuation">;</span> mkDecls<span class="token punctuation">(</span>Xs<span class="token punctuation">,</span>Vs<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> mkDecls<span class="token punctuation">(</span><span class="token punctuation">.</span>Ids<span class="token punctuation">,</span><span class="token punctuation">.</span>Vals<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</pre><h2 class="mume-header" id="location-lookup">Location lookup</h2>

<p>The operation below is straightforward.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> lookup<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> lookup<span class="token punctuation">(</span>L<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> V <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; V<span class="token punctuation">:</span>Val <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="environment-recovery">Environment recovery</h2>

<p>We have already discussed the environment recovery auxiliary operation in the<br>
IMP++ tutorial:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token comment">// TODO: eliminate the env wrapper, like we did in IMP++</span>

  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> setEnv<span class="token punctuation">(</span>Map<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> setEnv<span class="token punctuation">(</span>Env<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> _ <span class="token operator">=&gt;</span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
</pre><p>While theoretically sufficient, the basic definition for environment<br>
recovery alone is suboptimal.  Consider a loop <code>while (E)S</code>,<br>
whose semantics (see above) was given by unrolling.  <code>S</code><br>
is a block.  Then the semantics of blocks above, together with the<br>
unrolling semantics of the while loop, will yield a computation<br>
structure in the <code>k</code> cell that increasingly grows, adding a new<br>
environment recovery task right in front of the already existing sequence of<br>
similar environment recovery tasks (this phenomenon is similar to the ``tail<br>
recursion&apos;&apos; problem).  Of course, when we have a sequence of environment<br>
recovery tasks, we only need to keep the last one.  The elegant rule below<br>
does precisely that, thus avoiding the unnecessary computation explosion<br>
problem:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>setEnv<span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> setEnv<span class="token punctuation">(</span>_<span class="token punctuation">)</span>
</pre><p>In fact, the above follows a common convention in <strong>K</strong> for recovery<br>
operations of cell contents: the meaning of a computation task of the form<br>
<code>cell(C)</code> that reaches the top of the computation is that the current<br>
contents of cell <code>cell</code> is discarded and gets replaced with <code>C</code>.  We<br>
did not add support for these special computation tasks in our current<br>
implementation of <strong>K</strong>, so we need to define them as above.</p>
<h2 class="mume-header" id="lvalue-and-loc">lvalue and loc</h2>

<p>For convenience in giving the semantics of constructs like the increment and<br>
the assignment, that we want to operate the same way on variables and on<br>
array elements, we used an auxiliary <code>lvalue(E)</code> construct which was<br>
expected to evaluate to the lvalue of the expression <code>E</code>.  This is only<br>
defined when <code>E</code> has an lvalue, that is, when <code>E</code> is either a variable or<br>
evaluates to an array element.  <code>lvalue(E)</code> evaluates to a value of<br>
the form <code>loc(L)</code>, where <code>L</code> is the location where the value of <code>E</code><br>
can be found; for clarity, we use <code>loc</code> to structurally distinguish<br>
natural numbers from location values.  In giving semantics to <code>lvalue</code><br>
there are two cases to consider.  (1) If <code>E</code> is a variable, then all we need<br>
to do is to grab its location from the environment.  (2) If <code>E</code> is an array<br>
element, then we first evaluate the array and its index in order to identify<br>
the exact location of the element of concern, and then return that location;<br>
the last rule below works because its preceding context declarations ensure<br>
that the array and its index are evaluated, and then the rule for array lookup<br>
(defined above) rewrites the evaluated array access construct to its<br>
corresponding store lookup operation.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token comment">// For parsing reasons, we prefer to allow lvalue to take a K</span>

  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> lvalue<span class="token punctuation">(</span>K<span class="token punctuation">)</span>
  <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> loc<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span>

<span class="token comment">// Local variable</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> lvalue<span class="token punctuation">(</span>X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=&gt;</span> loc<span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> X <span class="token operator">|</span><span class="token operator">-</span>&gt; L<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>

<span class="token comment">// Array element: evaluate the array and its index;</span>
<span class="token comment">// then the array lookup rule above applies.</span>

  <span class="token keyword keyword-context">context</span> lvalue<span class="token punctuation">(</span>_<span class="token punctuation">:</span><span class="token punctuation">:</span>Exp<span class="token punctuation">[</span>HOLE<span class="token punctuation">:</span><span class="token punctuation">:</span>Exps<span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-context">context</span> lvalue<span class="token punctuation">(</span>HOLE<span class="token punctuation">:</span><span class="token punctuation">:</span>Exp<span class="token punctuation">[</span>_<span class="token punctuation">:</span><span class="token punctuation">:</span>Exps<span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment">// Finally, return the address of the desired object member</span>

  <span class="token keyword keyword-rule">rule</span> lvalue<span class="token punctuation">(</span>lookup<span class="token punctuation">(</span>L<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> loc<span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">)</span>
</pre><h2 class="mume-header" id="initializing-multiple-locations">Initializing multiple locations</h2>

<p>The following operation initializes a sequence of locations with the same<br>
value:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Map <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;...&quot;</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;|-&gt;&quot;</span> K <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> N<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>M <span class="token operator">|</span><span class="token operator">-</span>&gt; _ <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Map  <span class="token keyword keyword-requires">requires</span> N &gt;<span class="token keyword keyword-Int">Int</span> M
  <span class="token keyword keyword-rule">rule</span> N<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>M <span class="token operator">|</span><span class="token operator">-</span>&gt; K <span class="token operator">=&gt;</span> N <span class="token operator">|</span><span class="token operator">-</span>&gt; K <span class="token punctuation">(</span>N <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>M <span class="token operator">|</span><span class="token operator">-</span>&gt; K  <span class="token keyword keyword-requires">requires</span> N <span class="token operator">&lt;=</span><span class="token keyword keyword-Int">Int</span> M
</pre><p>The semantics of SIMPLE is now complete.  Make sure you kompile the<br>
definition with the right options in order to generate the desired model.<br>
No kompile options are needed if you only only want to execute the definition<br>
(and thus get an interpreter), but if you want to search for a different<br>
program behaviors then you need to kompile with the --enable-search option</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>Go to <a href="#ebook-heading-lesson-2-simple-typed-static">Lesson 2, SIMPLE typed static</a></p>
</div></div><div id="ebook-heading-lesson-2-simple-typed-static" ebook-toc-level-4 heading="Lesson 2, SIMPLE typed static"><div><h1 class="mume-header" id="simple-typed-static">SIMPLE &#x2014; Typed &#x2014; Static</h1>

<p>Author: Grigore Ro&#x219;u (<a href="mailto:grosu@illinois.edu">grosu@illinois.edu</a>)<br>
Organization: University of Illinois at Urbana-Champaign</p>
<p>Author: Traian Florin &#x218;erb&#x103;nu&#x21B;&#x103; (<a href="mailto:traian.serbanuta@unibuc.ro">traian.serbanuta@unibuc.ro</a>)<br>
Organization: University of Bucharest</p>
<h2 class="mume-header" id="abstract">Abstract</h2>

<p>This is the <strong>K</strong> definition of the static semantics of the typed SIMPLE<br>
language, or in other words, a type system for the typed SIMPLE<br>
language in <strong>K</strong>.  We do not re-discuss the various features of the<br>
SIMPLE language here.  The reader is referred to the untyped version of<br>
the language for such discussions.  We here only focus on the new and<br>
interesting problems raised by the addition of type declarations, and<br>
what it takes to devise a type system/checker for the language.</p>
<p>When designing a type system for a language, no matter in what<br>
paradigm, we have to decide upon the intended typing policy.  Note<br>
that we can have multiple type systems for the same language, one for<br>
each typing policy.  For example, should we accept programs which<br>
don&apos;t have a main function?  Or should we allow functions that do not<br>
return explicitly?  Or should we allow functions whose type expects<br>
them to return a value (say an <code>int</code>) to use a plain<br>
<code>return;</code> statement, which returns no value, like in C?<br>
And so on and so forth.  Typically, there are two opposite tensions<br>
when designing a type system.  On the one hand, you want your type<br>
system to be as permissive as possible, that is, to accept as many<br>
programs that do not get stuck when executed with the untyped<br>
semantics as possible; this will keep the programmers using your<br>
language happy.  On the other hand, you want your type system to have<br>
a reasonable performance when implemented; this will keep both the<br>
programmers and the implementers of your language happy.  For example,<br>
a type system for rejecting programs that could perform<br>
division-by-zero is not expected to be feasible in general.  A simple<br>
guideline when designing typing policies is to imagine how the<br>
semantics of the untyped language may get stuck and try to prevent<br>
those situations from happening.</p>
<p>Before we give the <strong>K</strong> type system of SIMPLE formally, we discuss,<br>
informally, the intended typing policy:</p>
<ul>
<li>
<p>Each program should contain a <code>main()</code> function.  Indeed,<br>
the untyped SIMPLE semantics will get stuck on any program which does<br>
not have a <code>main</code> function.</p>
</li>
<li>
<p>Each primitive value has its own type, which can be <code>int</code><br>
<code>bool</code>, or <code>string</code>.  There is also a type <code>void</code><br>
for nonexistent values, for example for the result of a function meant<br>
to return no value (but only be used for its side effects, like a<br>
procedure).</p>
</li>
<li>
<p>The syntax of untyped SIMPLE is extended to allow type<br>
declarations for all the variables, including array variables.  This is<br>
done in a C/Java-style.  For example, <code>int x;</code> or<br>
<code>int x=7, y=x+3;</code>, or <code>int[][][] a[10,20];</code><br>
(the latter defines a <code>10 &#xD7; 20</code> matrix of arrays of integers).<br>
Recall from untyped SIMPLE that, unlike in C/Java, our multi-dimensional<br>
arrays use comma-separated arguments, although they have the array-of-array<br>
semantics.</p>
</li>
<li>
<p>Functions are also typed in a C/Java style.  However, since in SIMPLE<br>
we allow functions to be passed to and returned by other functions, we also<br>
need function types.  We will use the conventional higher-order arrow-notation<br>
for function types, but will separate the argument types with commas.  For<br>
example, a function returning an array of <code>bool</code> elements and<br>
taking as argument an array <code>x</code> of two-integer-argument functions<br>
returning an integer, is declared using a syntax of the form<br>
<code>bool[] f(((int,int)-&gt;int)[] x) { ... }</code><br>
and has the type <code>((int,int)-&gt;int)[] -&gt; bool[]</code>.</p>
</li>
<li>
<p>We allow any variable declarations at the top level.  Functions<br>
can only be declared at the top level.  Each function can only access the<br>
other functions and variables declared at the top level, or its own locally<br>
declared variables.  SIMPLE has static scoping.</p>
</li>
<li>
<p>The various expression and statement constructs take only elements of<br>
the expected types.</p>
</li>
<li>
<p>Increment and assignment can operate both on variables and on array<br>
elements.  For example, if <code>f</code> has type <code>int-&gt;int[][]</code> and<br>
function <code>g</code> has the type <code>int-&gt;int</code>, then the<br>
increment expression <code>++f(7)[g(2),g(3)]</code> is valid.</p>
</li>
<li>
<p>Functions should only return values of their declared result<br>
type.  To give the programmers more flexibility, we allow functions to<br>
use <code>return;</code> statements to terminate without returning an<br>
actual value, or to not explicitly use any return statement,<br>
regardless of their declared return type.  This flexibility can be<br>
handy when writing programs using certain functions only for their<br>
side effects.  Nevertheless, as the dynamic semantics shows, a return<br>
value is automatically generated when an explicit <code>return</code><br>
statement is not encountered.</p>
</li>
<li>
<p>For simplicity, we here limit exceptions to only throw and catch<br>
integer values.  We let it as an exercise to the reader to extend the<br>
semantics to allow throwing and catching arbitrary-type exceptions.<br>
Like in programming languages like Java, one can go even further and<br>
define a semantics where thrown exceptions are propagated through<br>
try-catch statements until one of the corresponding type is found.<br>
We will do this when we define the KOOL language, not here.<br>
To keep the definition if SIMPLE simple, here we do not attempt to<br>
reject programs which throw uncaught exceptions.</p>
</li>
</ul>
<p>Like in untyped SIMPLE, some constructs can be desugared into a<br>
smaller set of basic constructs.  In general, it should be clear why a<br>
program does not type by looking at the top of the <code>k</code> cells in<br>
its stuck configuration.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> SIMPLE<span class="token operator">-</span>TYPED<span class="token operator">-</span>STATIC<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> DOMAINS<span class="token operator">-</span>SYNTAX
</pre><h2 class="mume-header" id="syntax">Syntax</h2>

<p>The syntax of typed SIMPLE extends that of untyped SIMPLE with support<br>
for declaring types to variables and functions.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Id">Id</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;main&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
</pre><h2 class="mume-header" id="types">Types</h2>

<p>Primitive, array and function types, as well as lists (or tuples) of types.<br>
The lists of types are useful for function arguments.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Type <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;void&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;int&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;bool&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;string&quot;</span>
                <span class="token operator">|</span> Type <span class="token string">&quot;[&quot;</span> <span class="token string">&quot;]&quot;</span>
                <span class="token operator">|</span> <span class="token string">&quot;(&quot;</span> Type <span class="token string">&quot;)&quot;</span>             <span class="token punctuation">[</span><span class="token class-name">bracket</span><span class="token punctuation">]</span>
                &gt; Types <span class="token string">&quot;-&gt;&quot;</span> Type

  <span class="token keyword keyword-syntax">syntax</span> Types <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Type<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>          <span class="token punctuation">[</span>overload<span class="token punctuation">(</span>exps<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h2 class="mume-header" id="declarations">Declarations</h2>

<p>Variable and function declarations have the expected syntax.  For variables,<br>
we basically just replaced the <code>var</code> keyword of untyped SIMPLE with a<br>
type.  For functions, besides replacing the <code>function</code> keyword with a<br>
type, we also introduce a new syntactic category for typed variables,<br>
<code>Param</code>, and lists over it.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Param <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Type <span class="token keyword keyword-Id">Id</span>
  <span class="token keyword keyword-syntax">syntax</span> Params <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Param<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>

  <span class="token keyword keyword-syntax">syntax</span> Stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Type Exps <span class="token string">&quot;;&quot;</span>
                <span class="token operator">|</span> Type <span class="token keyword keyword-Id">Id</span> <span class="token string">&quot;(&quot;</span> Params <span class="token string">&quot;)&quot;</span> Block
</pre><h2 class="mume-header" id="expressions">Expressions</h2>

<p>The syntax of expressions is identical to that in untyped SIMPLE,<br>
except for the logical conjunction and disjunction which have<br>
different strictness attributes, because they now have different<br>
evaluation strategies.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span> <span class="token operator">|</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token operator">|</span> <span class="token keyword keyword-String">String</span> <span class="token operator">|</span> <span class="token keyword keyword-Id">Id</span>
               <span class="token operator">|</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span>             <span class="token punctuation">[</span><span class="token class-name">bracket</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;++&quot;</span> Exp
               &gt; Exp <span class="token string">&quot;[&quot;</span> Exps <span class="token string">&quot;]&quot;</span>        <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               &gt; Exp <span class="token string">&quot;(&quot;</span> Exps <span class="token string">&quot;)&quot;</span>        <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;-&quot;</span> Exp                 <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;sizeOf&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span>    <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;read&quot;</span> <span class="token string">&quot;(&quot;</span> <span class="token string">&quot;)&quot;</span>
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;*&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;/&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;%&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;+&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;-&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               &gt; <span class="token class-name">non-assoc</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;&lt;&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;&lt;=&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;&gt;&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;&gt;=&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;==&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;!=&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               &gt; <span class="token string">&quot;!&quot;</span> Exp                 <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;&amp;&amp;&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;||&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               &gt; <span class="token string">&quot;spawn&quot;</span> Block
               &gt; Exp <span class="token string">&quot;=&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">right</span><span class="token punctuation">]</span>
</pre><p>Note that <code>spawn</code> has not been declared strict.  This may<br>
seem unexpected,  because the child thread shares the same environment<br>
with the parent thread, so from a typing perspective the spawned<br>
statement makes the same sense in a child thread as it makes in the<br>
parent thread.  The reason for not declaring it strict is because we<br>
want to disallow programs where the spawned thread calls the<br>
<code>return</code> statement, because those programs would get stuck in<br>
the dynamic semantics.  The type semantics of spawn below will reject<br>
such programs.</p>
<p>We still need lists of expressions, defined below, but note that we do<br>
not need lists of identifiers anymore.  They have been replaced by the lists<br>
of parameters.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Exps <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Exp<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>          <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> overload<span class="token punctuation">(</span>exps<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h2 class="mume-header" id="statements">Statements</h2>

<p>The statements have the same syntax as in untyped SIMPLE, except for<br>
the exceptions, which now type their parameter.  Note that, unlike in untyped<br>
SIMPLE, all statement constructs which have arguments and are not desugared<br>
are strict, including the conditional and the <code>while</code>.  Indeed, from a<br>
typing perspective, they are all strict: first type their arguments and then<br>
type the actual construct.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Block <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;{&quot;</span> <span class="token string">&quot;}&quot;</span>
                <span class="token operator">|</span> <span class="token string">&quot;{&quot;</span> Stmt <span class="token string">&quot;}&quot;</span>

  <span class="token keyword keyword-syntax">syntax</span> Stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Block
                <span class="token operator">|</span> Exp <span class="token string">&quot;;&quot;</span>                                  <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;if&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Block <span class="token string">&quot;else&quot;</span> Block      <span class="token punctuation">[</span><span class="token class-name">avoid</span><span class="token punctuation">,</span> <span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;if&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Block                   <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;while&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Block                <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;for&quot;</span> <span class="token string">&quot;(&quot;</span> Stmt Exp <span class="token string">&quot;;&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Block     <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;return&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                         <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;return&quot;</span> <span class="token string">&quot;;&quot;</span>
                <span class="token operator">|</span> <span class="token string">&quot;print&quot;</span> <span class="token string">&quot;(&quot;</span> Exps <span class="token string">&quot;)&quot;</span> <span class="token string">&quot;;&quot;</span>                 <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;try&quot;</span> Block <span class="token string">&quot;catch&quot;</span> <span class="token string">&quot;(&quot;</span> Param <span class="token string">&quot;)&quot;</span> Block  <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;throw&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                          <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;join&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                           <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;acquire&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                        <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;release&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                        <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;rendezvous&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                     <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
</pre><p>Note that the sequential composition is now sequentially strict,<br>
because, unlike in the dynamic semantics where statements dissolved,<br>
they now reduce to the <code>stmt</code> type, which is a result.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Stmt Stmt                             <span class="token punctuation">[</span><span class="token class-name">seqstrict</span><span class="token punctuation">,</span> <span class="token class-name">right</span><span class="token punctuation">]</span>
</pre><h2 class="mume-header" id="desugaring-macros">Desugaring macros</h2>

<p>We use the same desugaring macros like in untyped SIMPLE, but, of<br>
course, including the types of the involved variables.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> if <span class="token punctuation">(</span>E<span class="token punctuation">)</span> S <span class="token operator">=&gt;</span> if <span class="token punctuation">(</span>E<span class="token punctuation">)</span> S else <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword keyword-rule">rule</span> for<span class="token punctuation">(</span>Start Cond<span class="token punctuation">;</span> Step<span class="token punctuation">)</span> <span class="token punctuation">{</span>S<span class="token punctuation">:</span>Stmt<span class="token punctuation">}</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>Start while<span class="token punctuation">(</span>Cond<span class="token punctuation">)</span><span class="token punctuation">{</span>S Step<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span>
  <span class="token keyword keyword-rule">rule</span> for<span class="token punctuation">(</span>Start Cond<span class="token punctuation">;</span> Step<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>Start while<span class="token punctuation">(</span>Cond<span class="token punctuation">)</span><span class="token punctuation">{</span>Step<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span>
  <span class="token keyword keyword-rule">rule</span> T<span class="token punctuation">:</span>Type E1<span class="token punctuation">:</span>Exp<span class="token punctuation">,</span> E2<span class="token punctuation">:</span>Exp<span class="token punctuation">,</span> Es<span class="token punctuation">:</span>Exps<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> T E1<span class="token punctuation">;</span> T E2<span class="token punctuation">,</span> Es<span class="token punctuation">;</span>               <span class="token punctuation">[</span>anywhere<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> T<span class="token punctuation">:</span>Type X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=</span> E<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> T X<span class="token punctuation">;</span> X <span class="token operator">=</span> E<span class="token punctuation">;</span>                                  <span class="token punctuation">[</span>anywhere<span class="token punctuation">]</span>

<span class="token keyword keyword-endmodule">endmodule</span>


<span class="token keyword keyword-module">module</span> SIMPLE<span class="token operator">-</span>TYPED<span class="token operator">-</span>STATIC
  <span class="token keyword keyword-imports">imports</span> SIMPLE<span class="token operator">-</span>TYPED<span class="token operator">-</span>STATIC<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> DOMAINS
</pre><h2 class="mume-header" id="static-semantics">Static semantics</h2>

<p>Here we define the type system of SIMPLE.  Like concrete semantics,<br>
type systems defined in <strong>K</strong> are also executable.  However, <strong>K</strong> type<br>
systems turn into type checkers instead of interpreters when executed.</p>
<p>The typing process is done in two (overlapping) phases.  In the first<br>
phase the global environment is built, which contains type bindings<br>
for all the globally declared variables and functions.  For functions,<br>
the declared types will be ``trusted&apos;&apos; during the first phase and<br>
simply bound to their corresponding function names and placed in the<br>
global type environment.  At the same time, type-checking tasks that<br>
the function bodies indeed respect their claimed types are generated.<br>
All these tasks are (concurrently) verified during the second phase.<br>
This way, all the global variable and function declarations are<br>
available in the global type environment and can be used in order to<br>
type-check each function code.  This is consistent with the semantics<br>
of untyped SIMPLE, where functions can access all the global variables<br>
and can call any other function declared in the same program.  The<br>
two phases may overlap because of the <strong>K</strong> concurrent semantics.  For<br>
example, a function task can be started while the first phase is still<br>
running; moreover, it may even complete before the first phase does,<br>
namely when all the global variables and functions that it needs have<br>
already been processed and made available in the global environment by<br>
the first phase task.</p>
<h2 class="mume-header" id="extended-syntax-and-results">Extended syntax and results</h2>

<p>The idea is to start with a configuration holding the program to type<br>
in one of its cells, then apply rewrite rules on it mixing types and<br>
language syntax, and eventually obtain a type instead of the original<br>
program.  In other words, the program reduces to its type using<br>
the <strong>K</strong> rules giving the type system of the language.  In doing so,<br>
additional typing tasks for function bodies are generated and solved<br>
the same way.  If this rewriting process gets stuck, then we say that<br>
the program is not well-typed.  Otherwise the program is well-typed<br>
(by definition).  We did not need types for statements and for blocks<br>
as part of the typed SIMPLE syntax, because programmers are not allowed<br>
to use such types explicitly.  However, we are going to need them in the<br>
type system, because blocks and statements reduce to them.</p>
<p>We start by allowing types to be used inside expressions and statements in<br>
our language.  This way, types can be used together with language syntax in<br>
subsequent <strong>K</strong> rules without any parsing errors.  Like in the type system of<br>
IMP++ in the <strong>K</strong> tutorial, we prefer to group the block and statement types<br>
under one syntactic sub-category of types, because this allows us to more<br>
compactly state that certain terms can be either blocks or statements.  Also,<br>
since programs and fragments of program will reduce to their types, in order<br>
for the strictness and context declarations to be executable we state that<br>
types are results (same like we did in the IMP++ tutorial).</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Type
  <span class="token keyword keyword-syntax">syntax</span> Exps <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Types
  <span class="token keyword keyword-syntax">syntax</span> BlockOrStmtType <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;block&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;stmt&quot;</span>
  <span class="token keyword keyword-syntax">syntax</span> Type <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> BlockOrStmtType
  <span class="token keyword keyword-syntax">syntax</span> Block <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> BlockOrStmtType
  <span class="token keyword keyword-syntax">syntax</span> KResult <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Type
                   <span class="token operator">|</span> Types    <span class="token comment">//TODO: remove this, eventually</span>
</pre><h2 class="mume-header" id="configuration">Configuration</h2>

<p>The configuration of our type system consists of a <code>tasks</code> cell<br>
holding various typing <code>task</code> cells, and a global type environment.<br>
Each task includes a <code>k</code> cell holding the code to type, a <code>tenv</code><br>
cell holding the local type environment, and a <code>return</code> cell holding<br>
the return type of the currently checked function.  The latter is needed in<br>
order to check whether return statements return values of the expected type.<br>
Initially, the program is placed in a <code>k</code> cell inside a<br>
<code>task</code> cell.  Since the cells with multiplicity <code>?</code> are not<br>
included in the initial configuration, the <code>task</code> cell holding<br>
the original program in its <code>k</code> cell will contain no other<br>
subcells.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-configuration">configuration</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>T</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>yellow<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tasks</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>orange<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>task</span> <span class="token attr-name">multiplicity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>*<span class="token punctuation">&quot;</span></span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>yellow<span class="token punctuation">&quot;</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Set<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>green<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> $PGM<span class="token punctuation">:</span>Stmt <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tenv</span> <span class="token attr-name">multiplicity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>?<span class="token punctuation">&quot;</span></span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>cyan<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tenv</span><span class="token punctuation">&gt;</span></span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>returnType</span> <span class="token attr-name">multiplicity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>?<span class="token punctuation">&quot;</span></span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>black<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> void <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>returnType</span><span class="token punctuation">&gt;</span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>task</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tasks</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">//                  &lt;br/&gt;</span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>gtenv</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>blue<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>gtenv</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>T</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="variable-declarations">Variable declarations</h2>

<p>Variable declarations type as statements, that is, they reduce to the<br>
type <code>stmt</code>.  There are only two cases that need to be<br>
considered: when a simple variable is declared and when an array<br>
variable is declared.  The macros at the end of the syntax module<br>
above take care of reducing other variable declarations, including<br>
ones where the declared variables are initialized, to only these two<br>
cases.  The first case has two subcases: when the variable declaration<br>
is global (i.e., the <code>task</code> cell contains only the <code>k</code><br>
cell), in which case it is added to the global type environment<br>
checking at the same time that the variable has not been already<br>
declared; and when the variable declaration is local (i.e., a<br>
<code>tenv</code> cell is available), in which case it is simply added to<br>
the local type environment, possibly shadowing previous homonymous<br>
variables.  The third case reduces to the second, incrementally moving<br>
the array dimension into the type until the array becomes a simple<br>
variable.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>task</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> T<span class="token punctuation">:</span>Type X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">;</span> <span class="token operator">=&gt;</span> stmt <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>task</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>gtenv</span><span class="token punctuation">&gt;</span></span> Rho <span class="token punctuation">(</span><span class="token punctuation">.</span>Map <span class="token operator">=&gt;</span> X <span class="token operator">|</span><span class="token operator">-</span>&gt; T<span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>gtenv</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> notBool<span class="token punctuation">(</span>X in keys<span class="token punctuation">(</span>Rho<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> T<span class="token punctuation">:</span>Type X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">;</span> <span class="token operator">=&gt;</span> stmt <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tenv</span><span class="token punctuation">&gt;</span></span> Rho <span class="token operator">=&gt;</span> Rho<span class="token punctuation">[</span>X &lt;<span class="token operator">-</span> T<span class="token punctuation">]</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tenv</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-context">context</span> _<span class="token punctuation">:</span>Type _<span class="token punctuation">:</span><span class="token punctuation">:</span>Exp<span class="token punctuation">[</span>HOLE<span class="token punctuation">:</span><span class="token punctuation">:</span>Exps<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// The rule below may need to sort E to Exp in the future, if the</span>
<span class="token comment">// parser gets stricter; without that information, it may not be able</span>
<span class="token comment">// to complete the LHS into T E[int,Ts],.Exps; (and similarly for the RHS)</span>
  <span class="token keyword keyword-rule">rule</span> T<span class="token punctuation">:</span>Type E<span class="token punctuation">:</span>Exp<span class="token punctuation">[</span>int<span class="token punctuation">,</span>Ts<span class="token punctuation">:</span>Types<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">=&gt;</span> T<span class="token punctuation">[</span><span class="token punctuation">]</span> E<span class="token punctuation">[</span>Ts<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// I want to write the rule below as _:Type (E:Exp[.Types] =&gt; E),</span>
<span class="token comment">// but the list completion seems to not work well with that.</span>
  <span class="token keyword keyword-rule">rule</span> T<span class="token punctuation">:</span>Type E<span class="token punctuation">:</span>Exp<span class="token punctuation">[</span><span class="token punctuation">.</span>Types<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">=&gt;</span> T E<span class="token punctuation">;</span>
</pre><h2 class="mume-header" id="function-declarations">Function declarations</h2>

<p>Functions are allowed to be declared only at the top level (the<br>
<code>task</code> cell holds only its <code>k</code> subcell).  Each function<br>
declaration reduces to a variable declaration (a binding of its name<br>
to its declared function type), but also adds a task into the<br>
<code>tasks</code> cell.  The task consists of a typing of the statement<br>
declaring all the function parameters followed by the function body,<br>
together with the expected return type of the function.  The<br>
<code>getTypes</code> and <code>mkDecls</code> functions, defined at the end of<br>
the file in the section on auxiliary operations, extracts the list of<br>
types and makes a sequence of variable declarations from a list of<br>
function parameters, respectively.  Note that, although in the dynamic<br>
semantics we include a terminating <code>return</code> statement at the<br>
end of the function body to eliminate from the analysis the case when<br>
the function does not provide an explicit return, we do not need to<br>
include such a similar <code>return</code> statement here.  That&apos;s because<br>
the <code>return</code> statements type to <code>stmt</code> anyway, and the<br>
entire code of the function body needs to type anyway.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>task</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> T<span class="token punctuation">:</span>Type F<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">(</span>Ps<span class="token punctuation">:</span>Params<span class="token punctuation">)</span> S <span class="token operator">=&gt;</span> getTypes<span class="token punctuation">(</span>Ps<span class="token punctuation">)</span><span class="token operator">-</span>&gt;T F<span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>task</span><span class="token punctuation">&gt;</span></span>
       <span class="token punctuation">(</span><span class="token punctuation">.</span>Bag <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>task</span><span class="token punctuation">&gt;</span></span>
               <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> mkDecls<span class="token punctuation">(</span>Ps<span class="token punctuation">)</span> S <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tenv</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tenv</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>returnType</span><span class="token punctuation">&gt;</span></span> T <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>returnType</span><span class="token punctuation">&gt;</span></span>
             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>task</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>
</pre><h2 class="mume-header" id="checking-if-main-exists">Checking if <code>main()</code> exists}</h2>

<p>Once the entire program is processed (generating appropriate tasks<br>
to type check its function bodies), we can dissolve the main<br>
<code>task</code> cell (the one holding only a <code>k</code> subcell).  Since<br>
we want to enforce that programs include a main function, we also<br>
generate a function task executing <code>main()</code> to ensure that it<br>
types (remove this task creation if you do not want your type system<br>
to reject programs without a <code>main</code> function).</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>task</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> stmt <span class="token operator">=&gt;</span> main<span class="token punctuation">(</span><span class="token punctuation">.</span>Exps<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span><span class="token punctuation">.</span>Bag <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tenv</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tenv</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>task</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="collecting-the-terminated-tasks">Collecting the terminated tasks</h2>

<p>Similarly, once a non-main task (i.e., one which contains a<br>
<code>tenv</code> subcells) is completed using the subsequent rules (i.e.,<br>
its <code>k</code> cell holds only the <code>block</code> or <code>stmt</code><br>
type), we can dissolve its corresponding cell.  Note that it is<br>
important to ensure that we only dissolve tasks containing a<br>
<code>tenv</code> cell with the rule below, because the main task should<br>
<code>not</code> dissolve this way!  It should do what the above rule says.<br>
In the end, there should be no task cell left in the configuration<br>
when the program correctly type checks.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>task</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> _<span class="token punctuation">:</span>BlockOrStmtType <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tenv</span><span class="token punctuation">&gt;</span></span> _ <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tenv</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>task</span><span class="token punctuation">&gt;</span></span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Bag
</pre><h2 class="mume-header" id="basic-values">Basic values</h2>

<p>The first three rewrite rules below reduce the primitive values to<br>
their types, as we typically do when we define type systems in <strong>K</strong>.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> _<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">=&gt;</span> int
  <span class="token keyword keyword-rule">rule</span> _<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span> <span class="token operator">=&gt;</span> bool
  <span class="token keyword keyword-rule">rule</span> _<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span> <span class="token operator">=&gt;</span> string
</pre><h2 class="mume-header" id="variable-lookup">Variable lookup</h2>

<p>There are three cases to distinguish for variable lookup: (1) if the<br>
variable is bound in the local type environment, then look its type up<br>
there; (2) if a local environment exists and the variable is not bound<br>
in it, then look its type up in the global environment; (3) finally,<br>
if there is no local environment, meaning that we are executing the<br>
top-level pass, then look the variable&apos;s type up in the global<br>
environment, too.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=&gt;</span> T <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tenv</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> X <span class="token operator">|</span><span class="token operator">-</span>&gt; T <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tenv</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=&gt;</span> T <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tenv</span><span class="token punctuation">&gt;</span></span> Rho <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tenv</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>gtenv</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> X <span class="token operator">|</span><span class="token operator">-</span>&gt; T <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>gtenv</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> notBool<span class="token punctuation">(</span>X in keys<span class="token punctuation">(</span>Rho<span class="token punctuation">)</span><span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>task</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=&gt;</span> T <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>task</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>gtenv</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> X <span class="token operator">|</span><span class="token operator">-</span>&gt; T <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>gtenv</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="increment">Increment</h2>

<p>We want the increment operation to apply to any lvalue, including<br>
array elements, not only to variables.  For that reason, we define a<br>
special context extracting the type of the argument of the increment<br>
operation only if that argument is an lvalue.  Otherwise the rewriting<br>
process gets stuck.  The operation <code>ltype</code> is defined at the<br>
end of this file, in the auxiliary operation section.  It essentially<br>
acts as a filter, getting stuck if its argument is not an lvalue and<br>
letting it reduce otherwise.  The type of the lvalue is expected to be<br>
an integer in order to be allowed to be incremented, as seen in the<br>
rule <code>++ int =&gt; int</code> below.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-context">context</span> <span class="token operator">++</span><span class="token punctuation">(</span>HOLE <span class="token operator">=&gt;</span> ltype<span class="token punctuation">(</span>HOLE<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token operator">++</span> int <span class="token operator">=&gt;</span> int
</pre><h2 class="mume-header" id="common-expression-constructs">Common expression constructs</h2>

<p>The rules below are straightforward and self-explanatory:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> int <span class="token operator">+</span> int <span class="token operator">=&gt;</span> int
  <span class="token keyword keyword-rule">rule</span> string <span class="token operator">+</span> string <span class="token operator">=&gt;</span> string
  <span class="token keyword keyword-rule">rule</span> int <span class="token operator">-</span> int <span class="token operator">=&gt;</span> int
  <span class="token keyword keyword-rule">rule</span> int <span class="token operator">*</span> int <span class="token operator">=&gt;</span> int
  <span class="token keyword keyword-rule">rule</span> int <span class="token operator">/</span> int <span class="token operator">=&gt;</span> int
  <span class="token keyword keyword-rule">rule</span> int <span class="token operator">%</span> int <span class="token operator">=&gt;</span> int
  <span class="token keyword keyword-rule">rule</span> <span class="token operator">-</span> int <span class="token operator">=&gt;</span> int
  <span class="token keyword keyword-rule">rule</span> int &lt; int <span class="token operator">=&gt;</span> bool
  <span class="token keyword keyword-rule">rule</span> int <span class="token operator">&lt;=</span> int <span class="token operator">=&gt;</span> bool
  <span class="token keyword keyword-rule">rule</span> int &gt; int <span class="token operator">=&gt;</span> bool
  <span class="token keyword keyword-rule">rule</span> int <span class="token operator">&gt;=</span> int <span class="token operator">=&gt;</span> bool
  <span class="token keyword keyword-rule">rule</span> T<span class="token punctuation">:</span>Type <span class="token operator">==</span> T <span class="token operator">=&gt;</span> bool
  <span class="token keyword keyword-rule">rule</span> T<span class="token punctuation">:</span>Type <span class="token operator">!=</span> T <span class="token operator">=&gt;</span> bool
  <span class="token keyword keyword-rule">rule</span> bool <span class="token operator">&amp;&amp;</span> bool <span class="token operator">=&gt;</span> bool
  <span class="token keyword keyword-rule">rule</span> bool <span class="token operator">||</span> bool <span class="token operator">=&gt;</span> bool
  <span class="token keyword keyword-rule">rule</span> <span class="token operator">!</span> bool <span class="token operator">=&gt;</span> bool
</pre><h2 class="mume-header" id="array-access-and-size">Array access and size</h2>

<p>Array access requires each index to type to an integer, and the<br>
array type to be at least as deep as the number of indexes:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token comment">// NOTE:</span>
<span class="token comment">// We used to need parentheses in the RHS, to avoid capturing Ts as an attribute</span>
<span class="token comment">// Let&apos;s hope that is not a problem anymore.</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">[</span>int<span class="token punctuation">,</span> Ts<span class="token punctuation">:</span>Types<span class="token punctuation">]</span> <span class="token operator">=&gt;</span> T<span class="token punctuation">[</span>Ts<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> T<span class="token punctuation">:</span>Type<span class="token punctuation">[</span><span class="token punctuation">.</span>Types<span class="token punctuation">]</span> <span class="token operator">=&gt;</span> T
</pre><p><code>sizeOf</code> only needs to check that its argument is an array:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> sizeOf<span class="token punctuation">(</span>_T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> int
</pre><h2 class="mume-header" id="inputoutput">Input/Output</h2>

<p>The read expression construct types to an integer, while print types<br>
to a statement provided that all its arguments type to integers or<br>
strings.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> read<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> int

  <span class="token keyword keyword-rule">rule</span> print<span class="token punctuation">(</span>T<span class="token punctuation">:</span>Type<span class="token punctuation">,</span> Ts <span class="token operator">=&gt;</span> Ts<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword keyword-requires">requires</span> T <span class="token operator">==</span>K int orBool T <span class="token operator">==</span>K string
  <span class="token keyword keyword-rule">rule</span> print<span class="token punctuation">(</span><span class="token punctuation">.</span>Types<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">=&gt;</span> stmt
</pre><h2 class="mume-header" id="assignment">Assignment</h2>

<p>The special context and the rule for assignment below are similar<br>
to those for increment: the LHS of the assignment must be an lvalue<br>
and, in that case, it must have the same type as the RHS, which then<br>
becomes the type of the assignment.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-context">context</span> <span class="token punctuation">(</span>HOLE <span class="token operator">=&gt;</span> ltype<span class="token punctuation">(</span>HOLE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> _
  <span class="token keyword keyword-rule">rule</span> T<span class="token punctuation">:</span>Type <span class="token operator">=</span> T <span class="token operator">=&gt;</span> T
</pre><h2 class="mume-header" id="function-application-and-return">Function application and return</h2>

<p>Function application requires the type of the function and the<br>
types of the passed values to be compatible.  Note that a special case<br>
is needed to handle the no-argument case:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>Ts<span class="token punctuation">:</span>Types <span class="token operator">-</span>&gt; T<span class="token punctuation">)</span><span class="token punctuation">(</span>Ts<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> T <span class="token keyword keyword-requires">requires</span> Ts <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K <span class="token punctuation">.</span>Types
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>void <span class="token operator">-</span>&gt; T<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">.</span>Types<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> T
</pre><p>The returned value must have the same type as the declared<br>
function return type.  If an empty return is encountered, than<br>
we should check that we are in a function (and not a thread)<br>
context, that is, a <code>return</code> cell must be available:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> return T<span class="token punctuation">:</span>Type<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> stmt <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>returnType</span><span class="token punctuation">&gt;</span></span> T <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>returnType</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> return<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> stmt <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>returnType</span><span class="token punctuation">&gt;</span></span> _ <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>returnType</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="blocks">Blocks</h2>

<p>To avoid having to recover type environments after blocks, we prefer<br>
to start a new task for block body, making sure that the new task<br>
is passed the same type environment and return cells.  The value<br>
returned by <code>return</code> statements must have the same type as<br>
stated in the <code>return</code> cell.  The <code>print</code> variadic<br>
function is allowed to only print integers and strings.  The thrown<br>
exceptions can only have integer type.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">=&gt;</span> block

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>task</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>S<span class="token punctuation">}</span> <span class="token operator">=&gt;</span> block <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tenv</span><span class="token punctuation">&gt;</span></span> Rho <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tenv</span><span class="token punctuation">&gt;</span></span> R <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>task</span><span class="token punctuation">&gt;</span></span>
       <span class="token punctuation">(</span><span class="token punctuation">.</span>Bag <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>task</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> S <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tenv</span><span class="token punctuation">&gt;</span></span> Rho <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tenv</span><span class="token punctuation">&gt;</span></span> R <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>task</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>
</pre><h2 class="mume-header" id="expression-statement">Expression statement</h2>

<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> _<span class="token punctuation">:</span>Type<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> stmt
</pre><h2 class="mume-header" id="conditional-and-while-loop">Conditional and <code>while</code> loop</h2>

<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> if <span class="token punctuation">(</span>bool<span class="token punctuation">)</span> block else block <span class="token operator">=&gt;</span> stmt
  <span class="token keyword keyword-rule">rule</span> while <span class="token punctuation">(</span>bool<span class="token punctuation">)</span> block <span class="token operator">=&gt;</span> stmt
</pre><h2 class="mume-header" id="exceptions">Exceptions</h2>

<p>We currently force the parameters of exceptions to only be integers.<br>
Moreover, for simplicity, we assume that integer exceptions can be<br>
thrown from anywhere, including from functions which do not define<br>
any try-catch block (with the currently unchecked &#x2012;also for<br>
simplicity&#x2012; expectation that the caller functions would catch those<br>
exceptions).</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> try block catch<span class="token punctuation">(</span>int X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>S<span class="token punctuation">}</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>int X<span class="token punctuation">;</span> S<span class="token punctuation">}</span>
  <span class="token keyword keyword-rule">rule</span> try block catch<span class="token punctuation">(</span>int X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>int X<span class="token punctuation">;</span><span class="token punctuation">}</span>
  <span class="token keyword keyword-rule">rule</span> throw int<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> stmt
</pre><h2 class="mume-header" id="concurrency">Concurrency</h2>

<p>Nothing special about typing the concurrency constructs, except that<br>
we do not want the spawned thread to return, so we do not include any<br>
<code>return</code> cell in the new task cell for the thread statement.<br>
Same like with the functions above, we do not check for thrown<br>
exceptions which are not caught.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> spawn S <span class="token operator">=&gt;</span> int <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tenv</span><span class="token punctuation">&gt;</span></span> Rho <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tenv</span><span class="token punctuation">&gt;</span></span>
       <span class="token punctuation">(</span><span class="token punctuation">.</span>Bag <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>task</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> S <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tenv</span><span class="token punctuation">&gt;</span></span> Rho <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tenv</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>task</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> join int<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> stmt
  <span class="token keyword keyword-rule">rule</span> acquire _<span class="token punctuation">:</span>Type<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> stmt
  <span class="token keyword keyword-rule">rule</span> release _<span class="token punctuation">:</span>Type<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> stmt
  <span class="token keyword keyword-rule">rule</span> rendezvous _<span class="token punctuation">:</span>Type<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> stmt

  <span class="token keyword keyword-rule">rule</span> _<span class="token punctuation">:</span>BlockOrStmtType _<span class="token punctuation">:</span>BlockOrStmtType <span class="token operator">=&gt;</span> stmt
</pre><h2 class="mume-header" id="auxiliary-constructs">Auxiliary constructs</h2>

<p>The function <code>mkDecls</code> turns a list of parameters into a<br>
list of variable declarations.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> mkDecls<span class="token punctuation">(</span>Params<span class="token punctuation">)</span>  <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> mkDecls<span class="token punctuation">(</span>T<span class="token punctuation">:</span>Type X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span> Ps<span class="token punctuation">:</span>Params<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> T X<span class="token punctuation">;</span> mkDecls<span class="token punctuation">(</span>Ps<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> mkDecls<span class="token punctuation">(</span><span class="token punctuation">.</span>Params<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</pre><p>The <code>ltype</code> context allows only expressions which have an<br>
lvalue to evaluate.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> LValue <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Id">Id</span>
  <span class="token keyword keyword-rule">rule</span> isLValue<span class="token punctuation">(</span>_<span class="token punctuation">:</span>Exp<span class="token punctuation">[</span>_<span class="token punctuation">:</span>Exps<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> LValue  <span class="token comment">// K should be able to infer this</span>
                         <span class="token comment">// if not added, then it gets stuck with an Id on k cell</span>

<span class="token comment">// Instead of the second LValue production above you can use a rule:</span>
<span class="token comment">//  rule isLValue(_:Exp[_:Exps]) =&gt; true</span>

  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> ltype<span class="token punctuation">(</span>Exp<span class="token punctuation">)</span>
<span class="token comment">//  context ltype(HOLE:LValue)</span>
<span class="token comment">// The above context does not work due to some error, so we write instead</span>
  <span class="token keyword keyword-context">context</span> ltype<span class="token punctuation">(</span>HOLE<span class="token punctuation">)</span> <span class="token keyword keyword-requires">requires</span> isLValue<span class="token punctuation">(</span>HOLE<span class="token punctuation">)</span>
</pre><p>The function <code>getTypes</code> is the same as in SIMPLE typed dynamic.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Types <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> getTypes<span class="token punctuation">(</span>Params<span class="token punctuation">)</span>  <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> getTypes<span class="token punctuation">(</span>T<span class="token punctuation">:</span>Type _<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> T<span class="token punctuation">,</span> <span class="token punctuation">.</span>Types   <span class="token comment">// I would like to not use .Types</span>
  <span class="token keyword keyword-rule">rule</span> getTypes<span class="token punctuation">(</span>T<span class="token punctuation">:</span>Type _<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span> P<span class="token punctuation">,</span> Ps<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> T<span class="token punctuation">,</span> getTypes<span class="token punctuation">(</span>P<span class="token punctuation">,</span>Ps<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> getTypes<span class="token punctuation">(</span><span class="token punctuation">.</span>Params<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> void<span class="token punctuation">,</span> <span class="token punctuation">.</span>Types

<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>Go to <a href="#ebook-heading-lesson-3-simple-typed-dynamic">Lesson 3, SIMPLE typed dynamic</a></p>
</div></div><div id="ebook-heading-lesson-3-simple-typed-dynamic" ebook-toc-level-4 heading="Lesson 3, SIMPLE typed dynamic"><div><h1 class="mume-header" id="simple-typed-dynamic">SIMPLE &#x2014; Typed &#x2014; Dynamic</h1>

<p>Author: Grigore Ro&#x219;u (<a href="mailto:grosu@illinois.edu">grosu@illinois.edu</a>)<br>
Organization: University of Illinois at Urbana-Champaign</p>
<p>Author: Traian Florin &#x218;erb&#x103;nu&#x21B;&#x103; (<a href="mailto:traian.serbanuta@unibuc.ro">traian.serbanuta@unibuc.ro</a>)<br>
Organization: University of Bucharest</p>
<h2 class="mume-header" id="abstract">Abstract</h2>

<p>This is the <strong>K</strong> dynamic semantics of the typed SIMPLE language.<br>
It is very similar to the semantics of the untyped SIMPLE, the<br>
difference being that we now dynamically check the typing policy<br>
described in the static semantics of typed SIMPLE.  Because of the<br>
dynamic nature of the semantics, we can also perform some additional<br>
checks which were not possible in the static semantics, such as<br>
memory leaks due to accessing an array out of its bounds.  We will<br>
highlight the differences between the dynamically typed and the<br>
untyped SIMPLE as we proceed with the semantics.  We recommend the<br>
reader to consult the typing policy and the syntax of types discussed<br>
in the static semantics of the typed SIMPLE language.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> SIMPLE<span class="token operator">-</span>TYPED<span class="token operator">-</span>DYNAMIC<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> DOMAINS<span class="token operator">-</span>SYNTAX
</pre><h2 class="mume-header" id="syntax">Syntax</h2>

<p>The syntax of typed SIMPLE extends that of untyped SIMPLE with support<br>
for declaring types to variables and functions.</p>
<p>The syntax below is identical to that of the static semantics of typed<br>
SIMPLE.  However, the <strong>K</strong> strictness attributes are like those of the untyped<br>
SIMPLE, to capture the desired evaluation strategies of the various language<br>
constructs.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Id">Id</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;main&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
</pre><h2 class="mume-header" id="types">Types</h2>

<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Type <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;void&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;int&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;bool&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;string&quot;</span>
                <span class="token operator">|</span> Type <span class="token string">&quot;[&quot;</span> <span class="token string">&quot;]&quot;</span>
                <span class="token operator">|</span> <span class="token string">&quot;(&quot;</span> Type <span class="token string">&quot;)&quot;</span>           <span class="token punctuation">[</span><span class="token class-name">bracket</span><span class="token punctuation">]</span>
                &gt; Types <span class="token string">&quot;-&gt;&quot;</span> Type
  <span class="token keyword keyword-syntax">syntax</span> Types <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Type<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>        <span class="token punctuation">[</span>overload<span class="token punctuation">(</span>exps<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h2 class="mume-header" id="declarations">Declarations</h2>

<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Param <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Type <span class="token keyword keyword-Id">Id</span>
  <span class="token keyword keyword-syntax">syntax</span> Params <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Param<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>

  <span class="token keyword keyword-syntax">syntax</span> Stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Type Exps <span class="token string">&quot;;&quot;</span>
                <span class="token operator">|</span> Type <span class="token keyword keyword-Id">Id</span> <span class="token string">&quot;(&quot;</span> Params <span class="token string">&quot;)&quot;</span> Block
</pre><h2 class="mume-header" id="expressions">Expressions</h2>

<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span> <span class="token operator">|</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token operator">|</span> <span class="token keyword keyword-String">String</span> <span class="token operator">|</span> <span class="token keyword keyword-Id">Id</span>
               <span class="token operator">|</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span>             <span class="token punctuation">[</span><span class="token class-name">bracket</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;++&quot;</span> Exp
               &gt; Exp <span class="token string">&quot;[&quot;</span> Exps <span class="token string">&quot;]&quot;</span>        <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               &gt; Exp <span class="token string">&quot;(&quot;</span> Exps <span class="token string">&quot;)&quot;</span>        <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;-&quot;</span> Exp                 <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;sizeOf&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span>    <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;read&quot;</span> <span class="token string">&quot;(&quot;</span> <span class="token string">&quot;)&quot;</span>
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;*&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;/&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;%&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;+&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;-&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               &gt; <span class="token class-name">non-assoc</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;&lt;&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;&lt;=&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;&gt;&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;&gt;=&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;==&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;!=&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               &gt; <span class="token string">&quot;!&quot;</span> Exp                 <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;&amp;&amp;&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;||&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               &gt; <span class="token string">&quot;spawn&quot;</span> Block
               &gt; Exp <span class="token string">&quot;=&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">right</span><span class="token punctuation">]</span>
</pre><p>Like in the static semantics, there is no need for lists of identifiers<br>
(because we now have lists of parameters).</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Exps <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Exp<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>          <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> overload<span class="token punctuation">(</span>exps<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Val
  <span class="token keyword keyword-syntax">syntax</span> Vals <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Val<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>          <span class="token punctuation">[</span>overload<span class="token punctuation">(</span>exps<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h2 class="mume-header" id="statements">Statements</h2>

<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Block <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;{&quot;</span> <span class="token string">&quot;}&quot;</span>
                <span class="token operator">|</span> <span class="token string">&quot;{&quot;</span> Stmt <span class="token string">&quot;}&quot;</span>

  <span class="token keyword keyword-syntax">syntax</span> Stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Block
                <span class="token operator">|</span> Exp <span class="token string">&quot;;&quot;</span>                               <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;if&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Block <span class="token string">&quot;else&quot;</span> Block   <span class="token punctuation">[</span><span class="token class-name">avoid</span><span class="token punctuation">,</span> <span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;if&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Block                <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;while&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Block
                <span class="token operator">|</span> <span class="token string">&quot;for&quot;</span> <span class="token string">&quot;(&quot;</span> Stmt Exp <span class="token string">&quot;;&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Block  <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;print&quot;</span> <span class="token string">&quot;(&quot;</span> Exps <span class="token string">&quot;)&quot;</span> <span class="token string">&quot;;&quot;</span>              <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;return&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                      <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;return&quot;</span> <span class="token string">&quot;;&quot;</span>
                <span class="token operator">|</span> <span class="token string">&quot;try&quot;</span> Block <span class="token string">&quot;catch&quot;</span> <span class="token string">&quot;(&quot;</span> Param <span class="token string">&quot;)&quot;</span> Block
            <span class="token operator">|</span> <span class="token string">&quot;throw&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                       <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;join&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                        <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;acquire&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                     <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;release&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                     <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;rendezvous&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                  <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-syntax">syntax</span> Stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Stmt Stmt                          <span class="token punctuation">[</span><span class="token class-name">right</span><span class="token punctuation">]</span>
</pre><p>The same desugaring macros like in the statically typed SIMPLE.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> if <span class="token punctuation">(</span>E<span class="token punctuation">)</span> S <span class="token operator">=&gt;</span> if <span class="token punctuation">(</span>E<span class="token punctuation">)</span> S else <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword keyword-rule">rule</span> for<span class="token punctuation">(</span>Start Cond<span class="token punctuation">;</span> Step<span class="token punctuation">)</span> <span class="token punctuation">{</span>S<span class="token punctuation">:</span>Stmt<span class="token punctuation">}</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>Start while<span class="token punctuation">(</span>Cond<span class="token punctuation">)</span><span class="token punctuation">{</span>S Step<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span>
  <span class="token keyword keyword-rule">rule</span> for<span class="token punctuation">(</span>Start Cond<span class="token punctuation">;</span> Step<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>Start while<span class="token punctuation">(</span>Cond<span class="token punctuation">)</span><span class="token punctuation">{</span>Step<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span>
  <span class="token keyword keyword-rule">rule</span> T<span class="token punctuation">:</span>Type E1<span class="token punctuation">:</span>Exp<span class="token punctuation">,</span> E2<span class="token punctuation">:</span>Exp<span class="token punctuation">,</span> Es<span class="token punctuation">:</span>Exps<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> T E1<span class="token punctuation">;</span> T E2<span class="token punctuation">,</span> Es<span class="token punctuation">;</span>               <span class="token punctuation">[</span>anywhere<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> T<span class="token punctuation">:</span>Type X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=</span> E<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> T X<span class="token punctuation">;</span> X <span class="token operator">=</span> E<span class="token punctuation">;</span>                                  <span class="token punctuation">[</span>anywhere<span class="token punctuation">]</span>

<span class="token keyword keyword-endmodule">endmodule</span>


<span class="token keyword keyword-module">module</span> SIMPLE<span class="token operator">-</span>TYPED<span class="token operator">-</span>DYNAMIC
  <span class="token keyword keyword-imports">imports</span> SIMPLE<span class="token operator">-</span>TYPED<span class="token operator">-</span>DYNAMIC<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> DOMAINS
</pre><h2 class="mume-header" id="semantics">Semantics</h2>

<h3 class="mume-header" id="values-and-results">Values and results</h3>

<p>These are similar to those of untyped SIMPLE, except that the array<br>
references and the function abstrations now also hold their types.<br>
These types are needed in order to easily compute the type of any<br>
value in the language (see the auxiliary <code>typeOf</code> operation at<br>
the end of this module).</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span> <span class="token operator">|</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token operator">|</span> <span class="token keyword keyword-String">String</span>
               <span class="token operator">|</span> array<span class="token punctuation">(</span>Type<span class="token punctuation">,</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span>
               <span class="token operator">|</span> lambda<span class="token punctuation">(</span>Type<span class="token punctuation">,</span>Params<span class="token punctuation">,</span>Stmt<span class="token punctuation">)</span>
  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Val
  <span class="token keyword keyword-syntax">syntax</span> Exps <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Vals
  <span class="token keyword keyword-syntax">syntax</span> KResult <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Val
                   <span class="token operator">|</span> Vals  <span class="token comment">// TODO: should not need this</span>
</pre><h3 class="mume-header" id="configuration">Configuration</h3>

<p>The configuration is almost identical to that of untyped SIMPLE,<br>
except for a <code>return</code> cell inside the <code>control</code> cell.<br>
This <code>return</code> cell will hold, like in the static semantics of<br>
typed SIMPLE, the expected type of the value returned by the function<br>
being executed.  The contents of this cell will be set whenever a<br>
function is invoked and will be checked whenever the evaluation of the<br>
function body encounters an explicit <code>return</code> statement.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token comment">// the syntax declarations below are required because the sorts are</span>
  <span class="token comment">// referenced directly by a production and, because of the way KIL to KORE</span>
  <span class="token comment">// is implemented, the configuration syntax is not available yet</span>
  <span class="token comment">// should simply work once KIL is removed completely</span>
  <span class="token comment">// check other definitions for this hack as well</span>

  <span class="token keyword keyword-syntax">syntax</span> ControlCell
  <span class="token keyword keyword-syntax">syntax</span> ControlCellFragment

  <span class="token keyword keyword-configuration">configuration</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>T</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>red<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>threads</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>orange<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>thread</span> <span class="token attr-name">multiplicity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>*<span class="token punctuation">&quot;</span></span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>yellow<span class="token punctuation">&quot;</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Map<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>pink<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token number">0</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">&gt;</span></span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>green<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span>$PGM<span class="token punctuation">:</span>Stmt <span class="token operator">~&gt;</span> execute<span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">//                      &lt;br/&gt;</span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>control</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>cyan<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fstack</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>blue<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fstack</span><span class="token punctuation">&gt;</span></span>
                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>xstack</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>purple<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>xstack</span><span class="token punctuation">&gt;</span></span>
                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>returnType</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>LimeGreen<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> void <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>returnType</span><span class="token punctuation">&gt;</span></span>
                       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>control</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">//                      &lt;br/&gt;</span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>violet<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>holds</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>black<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>holds</span><span class="token punctuation">&gt;</span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>thread</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>threads</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">//                  &lt;br/&gt;</span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>genv</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>pink<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>genv</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>white<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>busy</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>cyan<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span>Set<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>busy</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>terminated</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>red<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Set <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>terminated</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>magenta<span class="token punctuation">&quot;</span></span> <span class="token attr-name">stream</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>stdin<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>input</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>output</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>brown<span class="token punctuation">&quot;</span></span> <span class="token attr-name">stream</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>stdout<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>output</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nextLoc</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>gray<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token number">0</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>nextLoc</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>T</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="declarations-and-initialization">Declarations and Initialization</h2>

<h3 class="mume-header" id="variable-declaration">Variable Declaration</h3>

<p>The <code>undefined</code> construct is now parameterized by a type.<br>
A main difference between untyped SIMPLE and dynamically typed SIMPLE<br>
is that the latter assigns a type to each of its locations and that<br>
type cannot be changed during the execution of the program.  We do not<br>
do any memory management in our semantic definitions here, so<br>
locations cannot be reclaimed, garbage collected and/or reused.  Each<br>
location corresponds precisely to an allocated variable or array<br>
element, whose type was explicitly or implicitly declared in the<br>
program and does not change.  It is therefore safe to type each<br>
location and then never allow that type to change.  The typed<br>
undefined values effectively assign both a type and an undefined value<br>
to a location.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> undefined<span class="token punctuation">(</span>Type<span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> T<span class="token punctuation">:</span>Type X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token operator">=&gt;</span> Env<span class="token punctuation">[</span>X &lt;<span class="token operator">-</span> L<span class="token punctuation">]</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Map <span class="token operator">=&gt;</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; undefined<span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nextLoc</span><span class="token punctuation">&gt;</span></span> L<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">=&gt;</span> L <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>nextLoc</span><span class="token punctuation">&gt;</span></span>
</pre><h3 class="mume-header" id="array-declaration">Array Declaration</h3>

<p>The dynamic semantics of typed array declarations is similar to that<br>
in untyped SIMPLE, but we have to make sure that we associate the<br>
right type to the allocated locations.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> T<span class="token punctuation">:</span>Type X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">[</span>N<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token operator">=&gt;</span> Env<span class="token punctuation">[</span>X &lt;<span class="token operator">-</span> L<span class="token punctuation">]</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Map <span class="token operator">=&gt;</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; array<span class="token punctuation">(</span>T<span class="token punctuation">,</span> L <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">,</span> N<span class="token punctuation">)</span>
                          <span class="token punctuation">(</span>L <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">(</span>L <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> N<span class="token punctuation">)</span> <span class="token operator">|</span><span class="token operator">-</span>&gt; undefined<span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nextLoc</span><span class="token punctuation">&gt;</span></span> L<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">=&gt;</span> L <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span> <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> N <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>nextLoc</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> N <span class="token operator">&gt;=</span><span class="token keyword keyword-Int">Int</span> <span class="token number">0</span>

  <span class="token keyword keyword-context">context</span> _<span class="token punctuation">:</span>Type _<span class="token punctuation">:</span><span class="token punctuation">:</span>Exp<span class="token punctuation">[</span>HOLE<span class="token punctuation">:</span><span class="token punctuation">:</span>Exps<span class="token punctuation">]</span><span class="token punctuation">;</span>
</pre><p>The desugaring of multi-dimensional arrays into unidimensional<br>
ones is also similar to that in untyped SIMPLE, although we have to<br>
make sure that all the declared variables have the right types.  The<br>
auxiliary operation <code>T&lt;Vs&gt;</code>, defined at the end of the file,<br>
adds the length of <code>Vs</code> dimensions to the type <code>T</code>.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token comment">// TODO: Check the desugaring below to be consistent with the one for untyped simple</span>

  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Id">Id</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;$1&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token string">&quot;$2&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> T<span class="token punctuation">:</span>Type X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">[</span>N1<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> N2<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token operator">=&gt;</span> T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Vs</span><span class="token punctuation">&gt;</span></span> X<span class="token punctuation">[</span>N1<span class="token punctuation">]</span><span class="token punctuation">;</span>
       <span class="token punctuation">{</span>
         T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Vs</span><span class="token punctuation">&gt;</span></span> $<span class="token number">1</span><span class="token operator">=</span>X<span class="token punctuation">;</span>
         for<span class="token punctuation">(</span>int $<span class="token number">2</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> $<span class="token number">2</span> <span class="token operator">&lt;=</span> N1 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>$<span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           T X<span class="token punctuation">[</span>N2<span class="token punctuation">,</span>Vs<span class="token punctuation">]</span><span class="token punctuation">;</span>
           $<span class="token number">1</span><span class="token punctuation">[</span>$<span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> X<span class="token punctuation">;</span>
         <span class="token punctuation">}</span>
       <span class="token punctuation">}</span>
</pre><h3 class="mume-header" id="function-declaration">Function declaration</h3>

<p>Store all function parameters, as well as the return type, as part<br>
of the lambda abstraction.  In the spirit of dynamic typing, we will<br>
make sure that parameters are well typed when the function is invoked.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> T<span class="token punctuation">:</span>Type F<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">(</span>Ps<span class="token punctuation">:</span>Params<span class="token punctuation">)</span> S <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token operator">=&gt;</span> Env<span class="token punctuation">[</span>F &lt;<span class="token operator">-</span> L<span class="token punctuation">]</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Map <span class="token operator">=&gt;</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; lambda<span class="token punctuation">(</span>T<span class="token punctuation">,</span> Ps<span class="token punctuation">,</span> S<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nextLoc</span><span class="token punctuation">&gt;</span></span> L <span class="token operator">=&gt;</span> L <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>nextLoc</span><span class="token punctuation">&gt;</span></span>
</pre><h3 class="mume-header" id="calling-main">Calling <code>main()</code></h3>

<p>When done with the first pass, call <code>main()</code>.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;execute&quot;</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> execute <span class="token operator">=&gt;</span> main<span class="token punctuation">(</span><span class="token punctuation">.</span>Exps<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>genv</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token operator">=&gt;</span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>genv</span><span class="token punctuation">&gt;</span></span>
</pre><h3 class="mume-header" id="expressions-1">Expressions</h3>

<h3 class="mume-header" id="variable-lookup">Variable lookup</h3>

<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=&gt;</span> V <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> X <span class="token operator">|</span><span class="token operator">-</span>&gt; L <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; V<span class="token punctuation">:</span>Val <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
</pre><h3 class="mume-header" id="variablearray-increment">Variable/Array increment</h3>

<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-context">context</span> <span class="token operator">++</span><span class="token punctuation">(</span>HOLE <span class="token operator">=&gt;</span> lvalue<span class="token punctuation">(</span>HOLE<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token operator">++</span>loc<span class="token punctuation">(</span>L<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> I <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; <span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">=&gt;</span> I <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
</pre><h3 class="mume-header" id="arithmetic-operators">Arithmetic operators</h3>

<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">+</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> Str1 <span class="token operator">+</span> Str2 <span class="token operator">=&gt;</span> Str1 <span class="token operator">+</span><span class="token keyword keyword-String">String</span> Str2
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">-</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">*</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">*</span><span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">/</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">/</span><span class="token keyword keyword-Int">Int</span> I2 <span class="token keyword keyword-requires">requires</span> I2 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K <span class="token number">0</span>
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">%</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">%</span><span class="token keyword keyword-Int">Int</span> I2 <span class="token keyword keyword-requires">requires</span> I2 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K <span class="token number">0</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token operator">-</span> I <span class="token operator">=&gt;</span> <span class="token number">0</span> <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> I
  <span class="token keyword keyword-rule">rule</span> I1 &lt; I2 <span class="token operator">=&gt;</span> I1 &lt;<span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">&lt;=</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">&lt;=</span><span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> I1 &gt; I2 <span class="token operator">=&gt;</span> I1 &gt;<span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">&gt;=</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">&gt;=</span><span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> V1<span class="token punctuation">:</span>Val <span class="token operator">==</span> V2<span class="token punctuation">:</span>Val <span class="token operator">=&gt;</span> V1 <span class="token operator">==</span>K V2
  <span class="token keyword keyword-rule">rule</span> V1<span class="token punctuation">:</span>Val <span class="token operator">!=</span> V2<span class="token punctuation">:</span>Val <span class="token operator">=&gt;</span> V1 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K V2
  <span class="token keyword keyword-rule">rule</span> <span class="token operator">!</span> T <span class="token operator">=&gt;</span> notBool<span class="token punctuation">(</span>T<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">true</span>  <span class="token operator">&amp;&amp;</span> E <span class="token operator">=&gt;</span> E
  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">false</span> <span class="token operator">&amp;&amp;</span> _ <span class="token operator">=&gt;</span> <span class="token boolean">false</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">true</span>  <span class="token operator">||</span> _ <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">false</span> <span class="token operator">||</span> E <span class="token operator">=&gt;</span> E
</pre><h3 class="mume-header" id="array-lookup">Array lookup</h3>

<p>Check array bounds, as part of the dynamic typing policy.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token comment">// Same comment as for simple untyped regarding [anywhere]</span>
  <span class="token keyword keyword-rule">rule</span> V<span class="token punctuation">:</span>Val<span class="token punctuation">[</span>N1<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> N2<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">]</span> <span class="token operator">=&gt;</span> V<span class="token punctuation">[</span>N1<span class="token punctuation">]</span><span class="token punctuation">[</span>N2<span class="token punctuation">,</span> Vs<span class="token punctuation">]</span>
    <span class="token punctuation">[</span>anywhere<span class="token punctuation">]</span>

<span class="token comment">// Same comment as for simple untyped regarding [anywhere]</span>
  <span class="token keyword keyword-rule">rule</span> array<span class="token punctuation">(</span>_<span class="token punctuation">:</span>Type<span class="token punctuation">,</span> L<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> M<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span><span class="token punctuation">[</span>N<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">]</span> <span class="token operator">=&gt;</span> lookup<span class="token punctuation">(</span>L <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> N<span class="token punctuation">)</span>
    <span class="token keyword keyword-requires">requires</span> N <span class="token operator">&gt;=</span><span class="token keyword keyword-Int">Int</span> <span class="token number">0</span> andBool N &lt;<span class="token keyword keyword-Int">Int</span> M  <span class="token punctuation">[</span>anywhere<span class="token punctuation">]</span>
</pre><h3 class="mume-header" id="size-of-an-array">Size of an array</h3>

<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> sizeOf<span class="token punctuation">(</span>array<span class="token punctuation">(</span>_<span class="token punctuation">,</span>_<span class="token punctuation">,</span>N<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> N
</pre><h3 class="mume-header" id="function-call">Function call</h3>

<p>Define function call and return together, to see their relationship.<br>
Note that the operation <code>mkDecls</code> now declares properly typed<br>
instantiated variables, and that the semantics of <code>return</code> also<br>
checks that that type of the returned value is expected one.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token punctuation">(</span>Type<span class="token punctuation">,</span>Map<span class="token punctuation">,</span>K<span class="token punctuation">,</span>ControlCellFragment<span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> lambda<span class="token punctuation">(</span>T<span class="token punctuation">,</span>Ps<span class="token punctuation">,</span>S<span class="token punctuation">)</span><span class="token punctuation">(</span>Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> K <span class="token operator">=&gt;</span> mkDecls<span class="token punctuation">(</span>Ps<span class="token punctuation">,</span>Vs<span class="token punctuation">)</span> S return<span class="token punctuation">;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>control</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fstack</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token operator">=&gt;</span> ListItem<span class="token punctuation">(</span><span class="token punctuation">(</span>T&apos;<span class="token punctuation">,</span>Env<span class="token punctuation">,</span>K<span class="token punctuation">,</span>C<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fstack</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>returnType</span><span class="token punctuation">&gt;</span></span> T&apos; <span class="token operator">=&gt;</span> T <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>returnType</span><span class="token punctuation">&gt;</span></span>
         C
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>control</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token operator">=&gt;</span> GEnv <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>genv</span><span class="token punctuation">&gt;</span></span> GEnv <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>genv</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> return V<span class="token punctuation">:</span>Val<span class="token punctuation">;</span> <span class="token operator">~&gt;</span> _ <span class="token operator">=&gt;</span> V <span class="token operator">~&gt;</span> K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>control</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fstack</span><span class="token punctuation">&gt;</span></span> ListItem<span class="token punctuation">(</span><span class="token punctuation">(</span>T&apos;<span class="token punctuation">,</span>Env<span class="token punctuation">,</span>K<span class="token punctuation">,</span>C<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>List <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fstack</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>returnType</span><span class="token punctuation">&gt;</span></span> T <span class="token operator">=&gt;</span> T&apos; <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>returnType</span><span class="token punctuation">&gt;</span></span>
         <span class="token punctuation">(</span>_ <span class="token operator">=&gt;</span> C<span class="token punctuation">)</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>control</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> _ <span class="token operator">=&gt;</span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> typeOf<span class="token punctuation">(</span>V<span class="token punctuation">)</span> <span class="token operator">==</span>K T   <span class="token comment">// check the type of the returned value</span>
</pre><p>Like the <code>undefined</code> above, <code>nothing</code> also gets<br>
tagged with a type now.  The empty <code>return</code> statement is<br>
completed to return the <code>nothing</code> value tagged as expected.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> nothing<span class="token punctuation">(</span>Type<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> return<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> return nothing<span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>returnType</span><span class="token punctuation">&gt;</span></span> T <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>returnType</span><span class="token punctuation">&gt;</span></span>
</pre><h3 class="mume-header" id="read">Read</h3>

<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> read<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> I <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span><span class="token punctuation">&gt;</span></span> ListItem<span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>List <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>input</span><span class="token punctuation">&gt;</span></span>
</pre><h3 class="mume-header" id="assignment">Assignment</h3>

<p>The assignment now checks that the type of the assigned location is<br>
preserved:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-context">context</span> <span class="token punctuation">(</span>HOLE <span class="token operator">=&gt;</span> lvalue<span class="token punctuation">(</span>HOLE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> _

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> loc<span class="token punctuation">(</span>L<span class="token punctuation">)</span> <span class="token operator">=</span> V<span class="token punctuation">:</span>Val <span class="token operator">=&gt;</span> V <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; <span class="token punctuation">(</span>V&apos; <span class="token operator">=&gt;</span> V<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> typeOf<span class="token punctuation">(</span>V<span class="token punctuation">)</span> <span class="token operator">==</span>K typeOf<span class="token punctuation">(</span>V&apos;<span class="token punctuation">)</span>
</pre><h3 class="mume-header" id="statements-1">Statements</h3>

<h3 class="mume-header" id="blocks">Blocks</h3>

<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span> S <span class="token punctuation">}</span> <span class="token operator">=&gt;</span> S <span class="token operator">~&gt;</span> setEnv<span class="token punctuation">(</span>Env<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
</pre><h3 class="mume-header" id="sequential-composition">Sequential composition</h3>

<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> S1<span class="token punctuation">:</span>Stmt S2<span class="token punctuation">:</span>Stmt <span class="token operator">=&gt;</span> S1 <span class="token operator">~&gt;</span> S2
</pre><h3 class="mume-header" id="expression-statements">Expression statements</h3>

<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> _<span class="token punctuation">:</span>Val<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K
</pre><h3 class="mume-header" id="conditional">Conditional</h3>

<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> if <span class="token punctuation">(</span> <span class="token boolean">true</span><span class="token punctuation">)</span> S else _ <span class="token operator">=&gt;</span> S
  <span class="token keyword keyword-rule">rule</span> if <span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> _ else S <span class="token operator">=&gt;</span> S
</pre><h3 class="mume-header" id="while-loop">While loop</h3>

<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> while <span class="token punctuation">(</span>E<span class="token punctuation">)</span> S <span class="token operator">=&gt;</span> if <span class="token punctuation">(</span>E<span class="token punctuation">)</span> <span class="token punctuation">{</span>S while<span class="token punctuation">(</span>E<span class="token punctuation">)</span>S<span class="token punctuation">}</span>
</pre><h3 class="mume-header" id="print">Print</h3>

<p>We only allow printing integers and strings:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> print<span class="token punctuation">(</span>V<span class="token punctuation">:</span>Val<span class="token punctuation">,</span> Es <span class="token operator">=&gt;</span> Es<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>output</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>List <span class="token operator">=&gt;</span> ListItem<span class="token punctuation">(</span>V<span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>output</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> typeOf<span class="token punctuation">(</span>V<span class="token punctuation">)</span> <span class="token operator">==</span>K int orBool typeOf<span class="token punctuation">(</span>V<span class="token punctuation">)</span> <span class="token operator">==</span>K string
  <span class="token keyword keyword-rule">rule</span> print<span class="token punctuation">(</span><span class="token punctuation">.</span>Vals<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K
</pre><h3 class="mume-header" id="exceptions">Exceptions</h3>

<p>Exception parameters are now typed, but note that the semantics below<br>
works correctly only when the thrown exception has the same type as<br>
the innermost try-catch paramete.  To keep things simple, for the time<br>
being we can assume that SIMPLE only throws and catches integer<br>
values, in which case our semantics below works fine:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token punctuation">(</span>Param<span class="token punctuation">,</span>Stmt<span class="token punctuation">,</span>K<span class="token punctuation">,</span>Map<span class="token punctuation">,</span>ControlCellFragment<span class="token punctuation">)</span>  <span class="token comment">// Param instead of Id</span>

  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;popx&quot;</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span>try S1 catch<span class="token punctuation">(</span>P<span class="token punctuation">)</span> S2 <span class="token operator">=&gt;</span> S1 <span class="token operator">~&gt;</span> popx<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>control</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>xstack</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token operator">=&gt;</span> ListItem<span class="token punctuation">(</span><span class="token punctuation">(</span>P<span class="token punctuation">,</span> S2<span class="token punctuation">,</span> K<span class="token punctuation">,</span> Env<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>xstack</span><span class="token punctuation">&gt;</span></span>
         C
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>control</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> popx <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>xstack</span><span class="token punctuation">&gt;</span></span> ListItem<span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>List <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>xstack</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> throw V<span class="token punctuation">:</span>Val<span class="token punctuation">;</span> <span class="token operator">~&gt;</span> _ <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> T X <span class="token operator">=</span> V<span class="token punctuation">;</span> S2 <span class="token punctuation">}</span> <span class="token operator">~&gt;</span> K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>control</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>xstack</span><span class="token punctuation">&gt;</span></span> ListItem<span class="token punctuation">(</span><span class="token punctuation">(</span>T<span class="token punctuation">:</span>Type X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span> S2<span class="token punctuation">,</span> K<span class="token punctuation">,</span> Env<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>List <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>xstack</span><span class="token punctuation">&gt;</span></span>
         <span class="token punctuation">(</span>_ <span class="token operator">=&gt;</span> C<span class="token punctuation">)</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>control</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> _ <span class="token operator">=&gt;</span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
</pre><h3 class="mume-header" id="threads">Threads</h3>

<h3 class="mume-header" id="thread-creation">Thread creation</h3>

<pre data-role="codeBlock" data-info="k" class="language-k">   <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>thread</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> spawn S <span class="token operator">=&gt;</span> <span class="token operator">!</span>T<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>thread</span><span class="token punctuation">&gt;</span></span>
        <span class="token punctuation">(</span><span class="token punctuation">.</span>Bag <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>thread</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> S <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">&gt;</span></span> <span class="token operator">!</span>T <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">&gt;</span></span>
              <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>thread</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>
</pre><h3 class="mume-header" id="thread-termination">Thread termination</h3>

<pre data-role="codeBlock" data-info="k" class="language-k">   <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>thread</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span>K<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>holds</span><span class="token punctuation">&gt;</span></span>H<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>holds</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">&gt;</span></span>T<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>thread</span><span class="token punctuation">&gt;</span></span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Bag<span class="token punctuation">)</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>busy</span><span class="token punctuation">&gt;</span></span> Busy <span class="token operator">=&gt;</span> Busy <span class="token operator">-</span>Set keys<span class="token punctuation">(</span>H<span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>busy</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>terminated</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Set <span class="token operator">=&gt;</span> SetItem<span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>terminated</span><span class="token punctuation">&gt;</span></span>
</pre><h3 class="mume-header" id="thread-joining">Thread joining</h3>

<pre data-role="codeBlock" data-info="k" class="language-k">   <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> join T<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>terminated</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> SetItem<span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>terminated</span><span class="token punctuation">&gt;</span></span>
</pre><h3 class="mume-header" id="acquire-lock">Acquire lock</h3>

<pre data-role="codeBlock" data-info="k" class="language-k">   <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> acquire V<span class="token punctuation">:</span>Val<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>holds</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Map <span class="token operator">=&gt;</span> V <span class="token operator">|</span><span class="token operator">-</span>&gt; <span class="token number">0</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>holds</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>busy</span><span class="token punctuation">&gt;</span></span> Busy <span class="token punctuation">(</span><span class="token punctuation">.</span>Set <span class="token operator">=&gt;</span> SetItem<span class="token punctuation">(</span>V<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>busy</span><span class="token punctuation">&gt;</span></span>
     <span class="token keyword keyword-requires">requires</span> <span class="token punctuation">(</span>notBool<span class="token punctuation">(</span>V in Busy<span class="token punctuation">:</span>Set<span class="token punctuation">)</span><span class="token punctuation">)</span>

   <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> acquire V<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>holds</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> V<span class="token punctuation">:</span>Val <span class="token operator">|</span><span class="token operator">-</span>&gt; <span class="token punctuation">(</span>N<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">=&gt;</span> N <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>holds</span><span class="token punctuation">&gt;</span></span>
</pre><h3 class="mume-header" id="release-lock">Release lock</h3>

<pre data-role="codeBlock" data-info="k" class="language-k">   <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> release V<span class="token punctuation">:</span>Val<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>holds</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> V <span class="token operator">|</span><span class="token operator">-</span>&gt; <span class="token punctuation">(</span>N <span class="token operator">=&gt;</span> N<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>holds</span><span class="token punctuation">&gt;</span></span>
      <span class="token keyword keyword-requires">requires</span> N &gt;<span class="token keyword keyword-Int">Int</span> <span class="token number">0</span>

   <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> release V<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>holds</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> V<span class="token punctuation">:</span>Val <span class="token operator">|</span><span class="token operator">-</span>&gt; <span class="token number">0</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Map <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>holds</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>busy</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> SetItem<span class="token punctuation">(</span>V<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Set <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>busy</span><span class="token punctuation">&gt;</span></span>
</pre><h3 class="mume-header" id="rendezvous-synchronization">Rendezvous synchronization</h3>

<pre data-role="codeBlock" data-info="k" class="language-k">   <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> rendezvous V<span class="token punctuation">:</span>Val<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> rendezvous V<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
</pre><h3 class="mume-header" id="auxiliary-declarations-and-operations">Auxiliary declarations and operations</h3>

<p>Turns a list of parameters and a list of instance values for them<br>
into a list of variable declarations.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> mkDecls<span class="token punctuation">(</span>Params<span class="token punctuation">,</span>Vals<span class="token punctuation">)</span>  <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> mkDecls<span class="token punctuation">(</span><span class="token punctuation">(</span>T<span class="token punctuation">:</span>Type X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span> Ps<span class="token punctuation">:</span>Params<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>V<span class="token punctuation">:</span>Val<span class="token punctuation">,</span> Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token operator">=&gt;</span> T X<span class="token operator">=</span>V<span class="token punctuation">;</span> mkDecls<span class="token punctuation">(</span>Ps<span class="token punctuation">,</span>Vs<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> mkDecls<span class="token punctuation">(</span><span class="token punctuation">.</span>Params<span class="token punctuation">,</span><span class="token punctuation">.</span>Vals<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</pre><p>Location lookup.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> lookup<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span>  <span class="token comment">// see NOTES.md for why Exp instead of KItem</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> lookup<span class="token punctuation">(</span>L<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> V <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; V<span class="token punctuation">:</span>Val <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
</pre><p>Environment recovery.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token comment">// TODO: same comment regarding setEnv(...) as for simple untyped</span>

  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> setEnv<span class="token punctuation">(</span>Map<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> setEnv<span class="token punctuation">(</span>Env<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> _ <span class="token operator">=&gt;</span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>setEnv<span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> setEnv<span class="token punctuation">(</span>_<span class="token punctuation">)</span>
</pre><p>lvalue and loc</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> lvalue<span class="token punctuation">(</span>K<span class="token punctuation">)</span>
  <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> loc<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> lvalue<span class="token punctuation">(</span>X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=&gt;</span> loc<span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> X <span class="token operator">|</span><span class="token operator">-</span>&gt; L<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>

  <span class="token comment">//context lvalue(_[HOLE])</span>
  <span class="token comment">//context lvalue(HOLE[_])</span>
  <span class="token keyword keyword-context">context</span> lvalue<span class="token punctuation">(</span>_<span class="token punctuation">:</span><span class="token punctuation">:</span>Exp<span class="token punctuation">[</span>HOLE<span class="token punctuation">:</span><span class="token punctuation">:</span>Exps<span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-context">context</span> lvalue<span class="token punctuation">(</span>HOLE<span class="token punctuation">:</span><span class="token punctuation">:</span>Exp<span class="token punctuation">[</span>_<span class="token punctuation">:</span><span class="token punctuation">:</span>Exps<span class="token punctuation">]</span><span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> lvalue<span class="token punctuation">(</span>lookup<span class="token punctuation">(</span>L<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> loc<span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">)</span>
</pre><p>Adds the corresponding depth to an array type</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Type <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Type <span class="token string">&quot;&lt;&quot;</span> Vals <span class="token string">&quot;&gt;&quot;</span>  <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> T<span class="token punctuation">:</span>Type<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">_,Vs:</span>Vals</span><span class="token punctuation">&gt;</span></span> <span class="token operator">=&gt;</span> T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Vs</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> T<span class="token punctuation">:</span>Type<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>.Vals</span><span class="token punctuation">&gt;</span></span> <span class="token operator">=&gt;</span> T
</pre><p>Sequences of locations.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Map <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;...&quot;</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;|-&gt;&quot;</span> K <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> N<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>M <span class="token operator">|</span><span class="token operator">-</span>&gt; _ <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Map  <span class="token keyword keyword-requires">requires</span> N &gt;<span class="token keyword keyword-Int">Int</span> M
  <span class="token keyword keyword-rule">rule</span> N<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>M <span class="token operator">|</span><span class="token operator">-</span>&gt; K <span class="token operator">=&gt;</span> N <span class="token operator">|</span><span class="token operator">-</span>&gt; K <span class="token punctuation">(</span>N <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>M <span class="token operator">|</span><span class="token operator">-</span>&gt; K  <span class="token keyword keyword-requires">requires</span> N <span class="token operator">&lt;=</span><span class="token keyword keyword-Int">Int</span> M

<span class="token comment">// Type of a value.</span>
  <span class="token keyword keyword-syntax">syntax</span> Type <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> typeOf<span class="token punctuation">(</span>K<span class="token punctuation">)</span>  <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> typeOf<span class="token punctuation">(</span>_<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> int
  <span class="token keyword keyword-rule">rule</span> typeOf<span class="token punctuation">(</span>_<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> bool
  <span class="token keyword keyword-rule">rule</span> typeOf<span class="token punctuation">(</span>_<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> string
  <span class="token keyword keyword-rule">rule</span> typeOf<span class="token punctuation">(</span>array<span class="token punctuation">(</span>T<span class="token punctuation">,</span>_<span class="token punctuation">,</span>_<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>   <span class="token comment">// () needed! K parses [] as &quot;no tags&quot;</span>
  <span class="token keyword keyword-rule">rule</span> typeOf<span class="token punctuation">(</span>lambda<span class="token punctuation">(</span>T<span class="token punctuation">,</span>Ps<span class="token punctuation">,</span>_<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> getTypes<span class="token punctuation">(</span>Ps<span class="token punctuation">)</span> <span class="token operator">-</span>&gt; T
  <span class="token keyword keyword-rule">rule</span> typeOf<span class="token punctuation">(</span>undefined<span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> T
  <span class="token keyword keyword-rule">rule</span> typeOf<span class="token punctuation">(</span>nothing<span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> T
</pre><p>List of types of a parameter.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Types <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> getTypes<span class="token punctuation">(</span>Params<span class="token punctuation">)</span>  <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> getTypes<span class="token punctuation">(</span>T<span class="token punctuation">:</span>Type _<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> T<span class="token punctuation">,</span> <span class="token punctuation">.</span>Types   <span class="token comment">// I would like to not use .Types</span>
  <span class="token keyword keyword-rule">rule</span> getTypes<span class="token punctuation">(</span>T<span class="token punctuation">:</span>Type _<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span> P<span class="token punctuation">,</span> Ps<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> T<span class="token punctuation">,</span> getTypes<span class="token punctuation">(</span>P<span class="token punctuation">,</span>Ps<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> getTypes<span class="token punctuation">(</span><span class="token punctuation">.</span>Params<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> void<span class="token punctuation">,</span> <span class="token punctuation">.</span>Types
<span class="token keyword keyword-endmodule">endmodule</span>
</pre></div></div><div id="ebook-heading-part-8-kool-designing-object-oriented-programming-languages" ebook-toc-level-3 heading="Part 8: KOOL: Designing Object-Oriented Programming Languages"><div><h1 class="mume-header" id="kool-untyped">KOOL &#x2014; Untyped</h1>

<p>Author: Grigore Ro&#x219;u (<a href="mailto:grosu@illinois.edu">grosu@illinois.edu</a>)<br>
Organization: University of Illinois at Urbana-Champaign</p>
<p>Author: Traian Florin &#x218;erb&#x103;nu&#x21B;&#x103; (<a href="mailto:traian.serbanuta@unibuc.ro">traian.serbanuta@unibuc.ro</a>)<br>
Organization: University of Bucharest</p>
<h2 class="mume-header" id="abstract">Abstract</h2>

<p>This is the <strong>K</strong> semantic definition of the untyped KOOL language.  KOOL<br>
is aimed at being a pedagogical and research language that captures<br>
the essence of the object-oriented programming paradigm.  Its untyped<br>
variant discussed here is simpler than the typed one, ignoring several<br>
intricate aspects of types in the presence of objects.  A program<br>
consists of a set of class declarations.  Each class can extend at<br>
most one other class (KOOL is single-inheritance).  A class can<br>
declare a set of fields and a set of methods, all public and called<br>
the class&apos; <em>members</em>.  Specifically, KOOL includes the<br>
following features:</p>
<ul>
<li>
<p>Class declarations, where a class may or may not explicitly<br>
extend another class.  In case a class does not explicitly extend<br>
another class, then it is assumed that it extends the default top-most<br>
and empty (i.e., no members) class called <code>Object</code>.  Each class<br>
is required to declare precisely one homonymous method, called its<br>
<em>constructor</em>.  Each valid program should contain one class<br>
named <code>Main</code>, whose constructor, <code>Main()</code>, takes no<br>
arguments.  The execution of a program consists of creating an object<br>
instance of class <code>Main</code> and invoking the constructor<br>
<code>Main()</code> on it, that is, of executing <code>new Main();</code>.</p>
</li>
<li>
<p>All features of SIMPLE (see <code>examples/simple/untyped</code>),<br>
i.e., multidimensional arrays, function (here called &quot;method&quot;)<br>
abstractions with call-by-value parameter passing style and static<br>
scoping, blocks with locals, input/output, parametric exceptions, and<br>
concurrency via dynamic thread creation/termination and synchronization.<br>
The only change in the syntax of SIMPLE when imported in KOOL is the<br>
function declaration keyword, <code>function</code>, which is changed into<br>
<code>method</code>.  The exact same desugaring macros from SIMPLE are<br>
also included in KOOL.  We can think of KOOL&apos;s classes as embedding<br>
SIMPLE programs (extended with OO constructs, as discussed next).</p>
</li>
<li>
<p>Object creation using the <code>new C(e1,...,en)</code><br>
expression construct.  An object instance of class <code>C</code> is first<br>
created and then the constructor <code>C(e1,...,en)</code> is implicitly<br>
called on that object.  KOOL only allows (and requires) one<br>
constructor per class.  The class constructor can be called either<br>
implicitly during a new object creation for the class, or explicitly.<br>
The superclass constructor is <strong>not</strong> implicitly invoked when a<br>
class constructor is invoked; if you want to invoke the superclass<br>
constructor from a subclass constructor then you have to do it<br>
explicitly.</p>
</li>
<li>
<p>An expression construct <code>this</code>, which evaluates to the<br>
current object.</p>
</li>
<li>
<p>An expression construct <code>super</code>, which is used (only) in<br>
combination with member lookup (see next) to refer to a superclass<br>
field or method.</p>
</li>
<li>
<p>A member lookup expression construct <code>e.x</code>, where <code>e</code><br>
is an expression (either an expression expected to evaluate to an object<br>
or the <code>super</code> construct) and <code>x</code> is a class member name,<br>
that is, a field or a method name.</p>
</li>
<li>
<p>Expression constructs <code>e instanceOf C</code> and<br>
<code>(C) e</code>, where <code>e</code> is an expression expected<br>
to evaluate to an object and <code>C</code> a class name.  The former<br>
tells whether the class of <code>e</code> is a subclass of <code>C</code>,<br>
that is, whether <code>e</code> can be used as an instance of <code>C</code>,<br>
and the latter changes the class of <code>e</code> to <code>C</code>.  These<br>
operations always succeed: the former returns a Boolean value, while<br>
the latter changes the current class of <code>e</code> to <code>C</code><br>
regardless of whether it is safe to do so or not.  The typed version<br>
of KOOL will check the safety of casting by ensuring that the instance<br>
class of the object is a subclass of <code>C</code>.  In untyped KOOL we<br>
do not want to perform this check because we want to allow the<br>
programmer maximum of flexibility: if one always accesses only<br>
available members, then the program can execute successfully despite<br>
the potentially unsafe cast.</p>
</li>
</ul>
<p>There are some specific aspects of KOOL that need to be discussed.</p>
<p>First, KOOL is higher-order, allowing function abstractions to be<br>
treated like any other values in the language.  For example, if<br>
<code>m</code> is a method of object <code>e</code> then <code>e.m</code><br>
evaluates to the corresponding function abstraction.  The function<br>
abstraction is in fact a closure, because in addition to the method<br>
parameters and body it also encapsulates the object value (i.e., the<br>
environment of the object together with its current class&#x2014;see below)<br>
that <code>e</code> evaluates to.  This way, function abstractions can be<br>
invoked anywhere and have the capability to change the state of their<br>
object.  For example, if <code>m</code> is a method of object <code>e</code><br>
which increments a field <code>c</code> of <code>e</code> when invoked, and if<br>
<code>getm</code> is another method of <code>e</code> which simply returns<br>
<code>m</code> when invoked, then the double application<br>
<code>(e.getm())()</code> has the same effect as <code>e.m()</code>, that is,<br>
increments the counter <code>c</code> of <code>e</code>.  Note that the<br>
higher-order nature of KOOL was not originally planned; it came as a<br>
natural consequence of evaluating methods to closures and we decided<br>
to keep it.  If you do not like it then do not use it.</p>
<p>Second, since all the fields and methods are public in KOOL and since<br>
they can be redeclared in subclasses, it is not immediately clear how<br>
to lookup the member <code>x</code> when we write <code>e.x</code> and<br>
<code>e</code> is different from <code>super</code>.  We distinguish two cases,<br>
depending on whether <code>e.x</code> occurs in a method invocation<br>
context (i.e., <code>e.x(...)</code>) or in a field context.  KOOL has<br>
dynamic method dispatch, so if <code>e.x</code> is invoked as a method<br>
then <code>x</code> will be searched for starting with the instance class of<br>
the object value to which <code>e</code> evaluates.  If <code>e.x</code><br>
occurs in a non-method-invocation context then <code>x</code> will be<br>
treated as a field (although it may hold a method closure due to the<br>
higher-order nature of KOOL) and thus will be searched starting with<br>
the current class of the object value of <code>e</code> (which, because of<br>
<code>this</code> and casting, may be different from its instance class).<br>
In order to achieve the above, each object value will consist of a<br>
pair holding the current class of the object and an environment stack<br>
with one layer for each class in the object&apos;s instance class hierarchy.</p>
<p>Third, although KOOL is dynamic method dispatch, its capabilities<br>
described above are powerful enough to allow us to mimic static<br>
method dispatch.  For example, suppose that you want to invoke method<br>
<code>m()</code> statically.  Then all you need to do is to declare a<br>
local variable and bind it to <code>m</code>, for example <code>var staticm = m;</code>, and<br>
then call <code>staticm()</code>.  This works because<br>
<code>staticm</code> is first bound to the method closure that <code>m</code><br>
evaluates to, and then looked up as any local variable when invoked.<br>
We only enable the dynamic method dispatch when we have an object<br>
member on an application position, e.g., <code>m()</code>.</p>
<p>In what follows, we limit our comments to the new, KOOL-specific<br>
aspects of the language.  We refer the reader to the untyped SIMPLE<br>
language for documentation on the the remaining features, because<br>
those were all borrowed from SIMPLE.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> KOOL<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> DOMAINS<span class="token operator">-</span>SYNTAX
</pre><h2 class="mume-header" id="syntax">Syntax</h2>

<p>The syntax of KOOL extends that of SIMPLE with object-oriented<br>
constructs.  We removed from the <strong>K</strong> annotated syntax of SIMPLE two<br>
constructs, namely the one for function declarations (because we want<br>
to call them <code>methods</code> now) and the one for function application<br>
(because application is not strict in the first argument<br>
anymore&#x2014;needs to initiate dynamic method dispatch).  The additional<br>
syntax includes:</p>
<ul>
<li>First, we need a new dedicated identifier, <code>Object</code>, for<br>
the default top-most class.</li>
<li>Second, we rename the <code>function</code> keyword of SIMPLE into <code>method</code>.</li>
<li>Third, we add syntax for class declarations together with a<br>
macro making classes which extend nothing to extend <code>Object</code>.</li>
<li>Fourth, we change the strictness attribute of application<br>
into <code>strict(2)</code>.</li>
<li>Finally, we add syntax and corresponding strictness<br>
for the KOOL object-oriented constructs.</li>
</ul>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Id">Id</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;Object&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token string">&quot;Main&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-syntax">syntax</span> Stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;var&quot;</span> Exps <span class="token string">&quot;;&quot;</span>
                <span class="token operator">|</span> <span class="token string">&quot;method&quot;</span> <span class="token keyword keyword-Id">Id</span> <span class="token string">&quot;(&quot;</span> Ids <span class="token string">&quot;)&quot;</span> Block  <span class="token comment">// called &quot;function&quot; in SIMPLE</span>
                <span class="token operator">|</span> <span class="token string">&quot;class&quot;</span> <span class="token keyword keyword-Id">Id</span> Block               <span class="token comment">// KOOL</span>
                <span class="token operator">|</span> <span class="token string">&quot;class&quot;</span> <span class="token keyword keyword-Id">Id</span> <span class="token string">&quot;extends&quot;</span> <span class="token keyword keyword-Id">Id</span> Block  <span class="token comment">// KOOL</span>

  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span> <span class="token operator">|</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token operator">|</span> <span class="token keyword keyword-String">String</span> <span class="token operator">|</span> <span class="token keyword keyword-Id">Id</span>
               <span class="token operator">|</span> <span class="token string">&quot;this&quot;</span>                                 <span class="token comment">// KOOL</span>
               <span class="token operator">|</span> <span class="token string">&quot;super&quot;</span>                                <span class="token comment">// KOOL</span>
               <span class="token operator">|</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span>             <span class="token punctuation">[</span><span class="token class-name">bracket</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;++&quot;</span> Exp
               <span class="token operator">|</span> Exp <span class="token string">&quot;instanceOf&quot;</span> <span class="token keyword keyword-Id">Id</span>     <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token comment">// KOOL</span>
               <span class="token operator">|</span> <span class="token string">&quot;(&quot;</span> <span class="token keyword keyword-Id">Id</span> <span class="token string">&quot;)&quot;</span> Exp          <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token comment">// KOOL  cast</span>
               <span class="token operator">|</span> <span class="token string">&quot;new&quot;</span> <span class="token keyword keyword-Id">Id</span> <span class="token string">&quot;(&quot;</span> Exps <span class="token string">&quot;)&quot;</span>   <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token comment">// KOOL</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;.&quot;</span> <span class="token keyword keyword-Id">Id</span>                             <span class="token comment">// KOOL</span>
               &gt; Exp <span class="token string">&quot;[&quot;</span> Exps <span class="token string">&quot;]&quot;</span>        <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               &gt; Exp <span class="token string">&quot;(&quot;</span> Exps <span class="token string">&quot;)&quot;</span>        <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token comment">// was strict in SIMPLE</span>
               <span class="token operator">|</span> <span class="token string">&quot;-&quot;</span> Exp                 <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;sizeOf&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span>    <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;read&quot;</span> <span class="token string">&quot;(&quot;</span> <span class="token string">&quot;)&quot;</span>
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;*&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;/&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;%&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;+&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;-&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               &gt; <span class="token class-name">non-assoc</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;&lt;&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;&lt;=&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;&gt;&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;&gt;=&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;==&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;!=&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               &gt; <span class="token string">&quot;!&quot;</span> Exp                 <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;&amp;&amp;&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;||&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               &gt; <span class="token string">&quot;spawn&quot;</span> Block
               &gt; Exp <span class="token string">&quot;=&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">right</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-syntax">syntax</span> Ids  <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>

  <span class="token keyword keyword-syntax">syntax</span> Exps <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Exp<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>          <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> overload<span class="token punctuation">(</span>exps<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Val
  <span class="token keyword keyword-syntax">syntax</span> Vals <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Val<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>          <span class="token punctuation">[</span>overload<span class="token punctuation">(</span>exps<span class="token punctuation">)</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-syntax">syntax</span> Block <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;{&quot;</span> <span class="token string">&quot;}&quot;</span>
                <span class="token operator">|</span> <span class="token string">&quot;{&quot;</span> Stmt <span class="token string">&quot;}&quot;</span>

  <span class="token keyword keyword-syntax">syntax</span> Stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Block
                <span class="token operator">|</span> Exp <span class="token string">&quot;;&quot;</span>                               <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;if&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Block <span class="token string">&quot;else&quot;</span> Block   <span class="token punctuation">[</span><span class="token class-name">avoid</span><span class="token punctuation">,</span> <span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;if&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Block                <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;while&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Block
                <span class="token operator">|</span> <span class="token string">&quot;for&quot;</span> <span class="token string">&quot;(&quot;</span> Stmt Exp <span class="token string">&quot;;&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Block  <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;return&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                      <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;return&quot;</span> <span class="token string">&quot;;&quot;</span>                          <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;print&quot;</span> <span class="token string">&quot;(&quot;</span> Exps <span class="token string">&quot;)&quot;</span> <span class="token string">&quot;;&quot;</span>              <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;try&quot;</span> Block <span class="token string">&quot;catch&quot;</span> <span class="token string">&quot;(&quot;</span> <span class="token keyword keyword-Id">Id</span> <span class="token string">&quot;)&quot;</span> Block
                <span class="token operator">|</span> <span class="token string">&quot;throw&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                       <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;join&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                        <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;acquire&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                     <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;release&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                     <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;rendezvous&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                  <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-syntax">syntax</span> Stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Stmt Stmt                          <span class="token punctuation">[</span><span class="token class-name">right</span><span class="token punctuation">]</span>
</pre><p>Old desugaring rules, from SIMPLE</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> if <span class="token punctuation">(</span>E<span class="token punctuation">)</span> S <span class="token operator">=&gt;</span> if <span class="token punctuation">(</span>E<span class="token punctuation">)</span> S else <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword keyword-rule">rule</span> for<span class="token punctuation">(</span>Start Cond<span class="token punctuation">;</span> Step<span class="token punctuation">)</span> <span class="token punctuation">{</span>S<span class="token punctuation">}</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>Start while <span class="token punctuation">(</span>Cond<span class="token punctuation">)</span> <span class="token punctuation">{</span>S Step<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span>
  <span class="token keyword keyword-rule">rule</span> var E1<span class="token punctuation">:</span><span class="token punctuation">:</span>Exp<span class="token punctuation">,</span> E2<span class="token punctuation">:</span><span class="token punctuation">:</span>Exp<span class="token punctuation">,</span> Es<span class="token punctuation">:</span><span class="token punctuation">:</span>Exps<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> var E1<span class="token punctuation">;</span> var E2<span class="token punctuation">,</span> Es<span class="token punctuation">;</span>       <span class="token punctuation">[</span>anywhere<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> var X<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=</span> E<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> var X<span class="token punctuation">;</span> X <span class="token operator">=</span> E<span class="token punctuation">;</span>                              <span class="token punctuation">[</span>anywhere<span class="token punctuation">]</span>
</pre><p>New desugaring rule</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> class C<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> S <span class="token operator">=&gt;</span> class C extends Object S                     <span class="token comment">// KOOL</span>

<span class="token keyword keyword-endmodule">endmodule</span>
</pre><h2 class="mume-header" id="semantics">Semantics</h2>

<p>We first discuss the new configuration of KOOL, which extends that of<br>
SIMPLE.  Then we include the semantics of the constructs borrowed from<br>
SIMPLE unchanged; we refrain from discussing those, because they were<br>
already discussed in the <strong>K</strong> definition of SIMPLE.  Then we discuss<br>
changes to SIMPLE&apos;s semantics needed for the more general meaning of<br>
the previous SIMPLE constructs (for example for thread spawning,<br>
assignment, etc.).  Finally, we discuss in detail the<br>
semantics of the additional KOOL constructs.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> KOOL<span class="token operator">-</span>UNTYPED
  <span class="token keyword keyword-imports">imports</span> KOOL<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> DOMAINS
</pre><h2 class="mume-header" id="configuration">Configuration</h2>

<p>KOOL removes one cell and adds two nested cells to the configuration<br>
of SIMPLE.  The cell which is removed is the one holding the global<br>
environment, because a KOOL program consists of a set of classes only,<br>
with no global declarations.  In fact, since informally speaking each<br>
KOOL class now includes a SIMPLE program, it is safe to say that the<br>
global variables in SIMPLE became class fields in KOOL.  Let us now<br>
discuss the new cells that are added to the configuration of SIMPLE.</p>
<ul>
<li>
<p>The cell <code>crntObj</code> holds data pertaining to the current<br>
object, that is, the object environment in which the code in cell<br>
<code>k</code> executes: <code>crntClass</code> holds the current class (which<br>
can change as methods of the current object are invoked);<br>
<code>envStack</code> holds the stack of environments as a list,<br>
each layer corresponding to one class in the objects&apos; instance class<br>
hierarchy; <code>location</code>, which is optional, holds the location in<br>
the store where the current object is or has to be located (this is<br>
useful both for method closures and for the semantics of object<br>
creation).</p>
</li>
<li>
<p>The cell <code>classes</code> holds all the declared classes, each<br>
class being held in its own <code>class</code> cell which contains a name<br>
(<code>className</code>), a parent (<code>extends</code>), and the actual<br>
member declarations (<code>declarations</code>).</p>
</li>
</ul>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token comment">// the syntax declarations below are required because the sorts are</span>
  <span class="token comment">// referenced directly by a production and, because of the way KIL to KORE</span>
  <span class="token comment">// is implemented, the configuration syntax is not available yet</span>
  <span class="token comment">// should simply work once KIL is removed completely</span>
  <span class="token comment">// check other definitions for this hack as well</span>
  <span class="token keyword keyword-syntax">syntax</span> EnvCell
  <span class="token keyword keyword-syntax">syntax</span> ControlCell
  <span class="token keyword keyword-syntax">syntax</span> EnvStackCell
  <span class="token keyword keyword-syntax">syntax</span> CrntObjCellFragment

  <span class="token keyword keyword-configuration">configuration</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>T</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>red<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>threads</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>orange<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>thread</span> <span class="token attr-name">multiplicity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>*<span class="token punctuation">&quot;</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Set<span class="token punctuation">&quot;</span></span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>yellow<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>green<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> $PGM<span class="token punctuation">:</span>Stmt <span class="token operator">~&gt;</span> execute <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
                    <span class="token comment">//&lt;br/&gt; // TODO(KORE): support latex annotations #1799</span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>control</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>cyan<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fstack</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>blue<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fstack</span><span class="token punctuation">&gt;</span></span>
                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>xstack</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>purple<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>xstack</span><span class="token punctuation">&gt;</span></span>
                      <span class="token comment">//&lt;br/&gt; // TODO(KORE): support latex annotations #1799</span>
                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntObj</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Fuchsia<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>  <span class="token comment">// KOOL</span>
                           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntClass</span><span class="token punctuation">&gt;</span></span> Object <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntClass</span><span class="token punctuation">&gt;</span></span>
                           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>envStack</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>envStack</span><span class="token punctuation">&gt;</span></span>
                           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>location</span> <span class="token attr-name">multiplicity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>?<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>location</span><span class="token punctuation">&gt;</span></span>
                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntObj</span><span class="token punctuation">&gt;</span></span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>control</span><span class="token punctuation">&gt;</span></span>
                    <span class="token comment">//&lt;br/&gt; // TODO(KORE): support latex annotations #1799</span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>violet<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>holds</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>black<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>holds</span><span class="token punctuation">&gt;</span></span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>pink<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token number">0</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">&gt;</span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>thread</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>threads</span><span class="token punctuation">&gt;</span></span>
                <span class="token comment">//&lt;br/&gt; // TODO(KORE): support latex annotations #1799</span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>white<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>busy</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>cyan<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span>Set <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>busy</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>terminated</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>red<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Set <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>terminated</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>magenta<span class="token punctuation">&quot;</span></span> <span class="token attr-name">stream</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>stdin<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>input</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>output</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>brown<span class="token punctuation">&quot;</span></span> <span class="token attr-name">stream</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>stdout<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>output</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nextLoc</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>gray<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token number">0</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>nextLoc</span><span class="token punctuation">&gt;</span></span>
                <span class="token comment">//&lt;br/&gt; // TODO(KORE): support latex annotations #1799</span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>classes</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Fuchsia<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>        <span class="token comment">// KOOL</span>
                     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>classData</span> <span class="token attr-name">multiplicity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>*<span class="token punctuation">&quot;</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Map<span class="token punctuation">&quot;</span></span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Fuchsia<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
                        <span class="token comment">// the Map has as its key the first child of the cell,</span>
                        <span class="token comment">// in this case the className cell.</span>
                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>className</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Fuchsia<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> Main <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>className</span><span class="token punctuation">&gt;</span></span>
                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>baseClass</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Fuchsia<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> Object <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>baseClass</span><span class="token punctuation">&gt;</span></span>
                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>declarations</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Fuchsia<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>declarations</span><span class="token punctuation">&gt;</span></span>
                     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>classData</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>classes</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>T</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="unchanged-semantics-from-untyped-simple">Unchanged Semantics from untyped SIMPLE</h2>

<p>The semantics below is taken over from SIMPLE unchanged.<br>
The semantics of function declaration and invocation, including the<br>
use of the special <code>lambda</code> abstraction value, needs to change<br>
in order to account for the fact that methods are now invoked into<br>
their object&apos;s environment.  The semantics of function return actually<br>
stays unchanged.  Also, the semantics of program initialization is<br>
different: now we have to create an instance of the <code>Main</code><br>
class which also calls the constructor <code>Main()</code>, while in<br>
SIMPLE we only had to invoke the function <code>Main()</code>.<br>
Finally, the semantics of thread spawning needs to change, too: the<br>
parent thread needs to also share its object environment with the<br>
spawned thread (in addition to its local environment, like in SIMPLE).<br>
This is needed in order to be able to spawn method invokations under<br>
dynamic method dispatch; for example, <code>spawn { run(); }</code><br>
will need to look up the method <code>run()</code> in the newly created<br>
thread, operation which will most likely fail unless the child thread<br>
sees the object environment of the parent thread.  Note that the<br>
<code>spawn</code> statement of KOOL is more permissive than the threads<br>
of Java.  In fact, the latter can be implemented in terms of our<br>
<code>spawn</code>&#x2014;see the program <code>threads.kool</code> for a sketch.</p>
<p>Below is a subset of the values of SIMPLE, which are also values<br>
of KOOL.  We will add other values later in the semantics, such as<br>
object and method closures.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span> <span class="token operator">|</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token operator">|</span> <span class="token keyword keyword-String">String</span>
               <span class="token operator">|</span> array<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Val
  <span class="token keyword keyword-syntax">syntax</span> Exps <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Vals
  <span class="token keyword keyword-syntax">syntax</span> KResult <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Val
  <span class="token keyword keyword-syntax">syntax</span> KResult <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Vals
</pre><p>The semantics below are taken verbatim from the untyped SIMPLE<br>
definition.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;undefined&quot;</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> var X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token operator">=&gt;</span> Env<span class="token punctuation">[</span>X &lt;<span class="token operator">-</span> L<span class="token punctuation">]</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Map <span class="token operator">=&gt;</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; undefined <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nextLoc</span><span class="token punctuation">&gt;</span></span> L<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">=&gt;</span> L <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>nextLoc</span><span class="token punctuation">&gt;</span></span>


  <span class="token keyword keyword-context">context</span> var _<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">[</span>HOLE<span class="token punctuation">]</span><span class="token punctuation">;</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> var X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">[</span>N<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token operator">=&gt;</span> Env<span class="token punctuation">[</span>X &lt;<span class="token operator">-</span> L<span class="token punctuation">]</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Map <span class="token operator">=&gt;</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; array<span class="token punctuation">(</span>L <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">,</span> N<span class="token punctuation">)</span>
                          <span class="token punctuation">(</span>L <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">(</span>L <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> N<span class="token punctuation">)</span> <span class="token operator">|</span><span class="token operator">-</span>&gt; undefined <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nextLoc</span><span class="token punctuation">&gt;</span></span> L<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">=&gt;</span> L <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span> <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> N <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>nextLoc</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> N <span class="token operator">&gt;=</span><span class="token keyword keyword-Int">Int</span> <span class="token number">0</span>


  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Id">Id</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;$1&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token string">&quot;$2&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> var X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">[</span>N1<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> N2<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token operator">=&gt;</span> var X<span class="token punctuation">[</span>N1<span class="token punctuation">]</span><span class="token punctuation">;</span>
       <span class="token punctuation">{</span>
         var $<span class="token number">1</span><span class="token operator">=</span>X<span class="token punctuation">;</span>
         for<span class="token punctuation">(</span>var $<span class="token number">2</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> $<span class="token number">2</span> <span class="token operator">&lt;=</span> N1 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>$<span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           var X<span class="token punctuation">[</span>N2<span class="token punctuation">,</span>Vs<span class="token punctuation">]</span><span class="token punctuation">;</span>
           $<span class="token number">1</span><span class="token punctuation">[</span>$<span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> X<span class="token punctuation">;</span>
         <span class="token punctuation">}</span>
       <span class="token punctuation">}</span>


  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=&gt;</span> V <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> X <span class="token operator">|</span><span class="token operator">-</span>&gt; L <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; V<span class="token punctuation">:</span>Val <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>


  <span class="token keyword keyword-context">context</span> <span class="token operator">++</span><span class="token punctuation">(</span>HOLE <span class="token operator">=&gt;</span> lvalue<span class="token punctuation">(</span>HOLE<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token operator">++</span>loc<span class="token punctuation">(</span>L<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> I <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; <span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">=&gt;</span> I <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>


  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">+</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> Str1 <span class="token operator">+</span> Str2 <span class="token operator">=&gt;</span> Str1 <span class="token operator">+</span><span class="token keyword keyword-String">String</span> Str2
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">-</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">*</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">*</span><span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">/</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">/</span><span class="token keyword keyword-Int">Int</span> I2 <span class="token keyword keyword-requires">requires</span> I2 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K <span class="token number">0</span>
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">%</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">%</span><span class="token keyword keyword-Int">Int</span> I2 <span class="token keyword keyword-requires">requires</span> I2 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K <span class="token number">0</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token operator">-</span> I <span class="token operator">=&gt;</span> <span class="token number">0</span> <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> I
  <span class="token keyword keyword-rule">rule</span> I1 &lt; I2 <span class="token operator">=&gt;</span> I1 &lt;<span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">&lt;=</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">&lt;=</span><span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> I1 &gt; I2 <span class="token operator">=&gt;</span> I1 &gt;<span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">&gt;=</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">&gt;=</span><span class="token keyword keyword-Int">Int</span> I2

  <span class="token keyword keyword-rule">rule</span> V1<span class="token punctuation">:</span>Val <span class="token operator">==</span> V2<span class="token punctuation">:</span>Val <span class="token operator">=&gt;</span> V1 <span class="token operator">==</span>K V2
  <span class="token keyword keyword-rule">rule</span> V1<span class="token punctuation">:</span>Val <span class="token operator">!=</span> V2<span class="token punctuation">:</span>Val <span class="token operator">=&gt;</span> V1 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K V2
  <span class="token keyword keyword-rule">rule</span> <span class="token operator">!</span> T <span class="token operator">=&gt;</span> notBool<span class="token punctuation">(</span>T<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">true</span>  <span class="token operator">&amp;&amp;</span> E <span class="token operator">=&gt;</span> E
  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">false</span> <span class="token operator">&amp;&amp;</span> _ <span class="token operator">=&gt;</span> <span class="token boolean">false</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">true</span>  <span class="token operator">||</span> _ <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">false</span> <span class="token operator">||</span> E <span class="token operator">=&gt;</span> E


  <span class="token keyword keyword-rule">rule</span> V<span class="token punctuation">:</span>Val<span class="token punctuation">[</span>N1<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> N2<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">]</span> <span class="token operator">=&gt;</span> V<span class="token punctuation">[</span>N1<span class="token punctuation">]</span><span class="token punctuation">[</span>N2<span class="token punctuation">,</span> Vs<span class="token punctuation">]</span>
    <span class="token punctuation">[</span>anywhere<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> array<span class="token punctuation">(</span>L<span class="token punctuation">,</span>_<span class="token punctuation">)</span><span class="token punctuation">[</span>N<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">]</span> <span class="token operator">=&gt;</span> lookup<span class="token punctuation">(</span>L <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> N<span class="token punctuation">)</span>
    <span class="token punctuation">[</span>anywhere<span class="token punctuation">]</span>


  <span class="token keyword keyword-rule">rule</span> sizeOf<span class="token punctuation">(</span>array<span class="token punctuation">(</span>_<span class="token punctuation">,</span>N<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> N
</pre><p>The semantics of function application needs to change into dynamic<br>
method dispatch invocation, which is defined shortly.  However,<br>
interestingly, the semantics of return stays unchanged.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> return<span class="token punctuation">(</span>V<span class="token punctuation">:</span>Val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">~&gt;</span> _ <span class="token operator">=&gt;</span> V <span class="token operator">~&gt;</span> K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>control</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fstack</span><span class="token punctuation">&gt;</span></span> ListItem<span class="token punctuation">(</span>fstackFrame<span class="token punctuation">(</span>Env<span class="token punctuation">,</span>K<span class="token punctuation">,</span>XS<span class="token punctuation">,</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntObj</span><span class="token punctuation">&gt;</span></span> CO <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntObj</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>List <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fstack</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>xstack</span><span class="token punctuation">&gt;</span></span> _ <span class="token operator">=&gt;</span> XS <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>xstack</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntObj</span><span class="token punctuation">&gt;</span></span> _ <span class="token operator">=&gt;</span> CO <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntObj</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>control</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> _ <span class="token operator">=&gt;</span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;nothing&quot;</span>
  <span class="token keyword keyword-rule">rule</span> return<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> return nothing<span class="token punctuation">;</span>


  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> read<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> I <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span><span class="token punctuation">&gt;</span></span> ListItem<span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>List <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>input</span><span class="token punctuation">&gt;</span></span>


  <span class="token keyword keyword-context">context</span> <span class="token punctuation">(</span>HOLE <span class="token operator">=&gt;</span> lvalue<span class="token punctuation">(</span>HOLE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> _

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> loc<span class="token punctuation">(</span>L<span class="token punctuation">)</span> <span class="token operator">=</span> V<span class="token punctuation">:</span>Val <span class="token operator">=&gt;</span> V <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; <span class="token punctuation">(</span>_ <span class="token operator">=&gt;</span> V<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span> S <span class="token punctuation">}</span> <span class="token operator">=&gt;</span> S <span class="token operator">~&gt;</span> setEnv<span class="token punctuation">(</span>Env<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>


  <span class="token keyword keyword-rule">rule</span> S1<span class="token punctuation">:</span><span class="token punctuation">:</span>Stmt S2<span class="token punctuation">:</span><span class="token punctuation">:</span>Stmt <span class="token operator">=&gt;</span> S1 <span class="token operator">~&gt;</span> S2

  <span class="token keyword keyword-rule">rule</span> _<span class="token punctuation">:</span>Val<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K

  <span class="token keyword keyword-rule">rule</span> if <span class="token punctuation">(</span> <span class="token boolean">true</span><span class="token punctuation">)</span> S else _ <span class="token operator">=&gt;</span> S
  <span class="token keyword keyword-rule">rule</span> if <span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> _ else S <span class="token operator">=&gt;</span> S

  <span class="token keyword keyword-rule">rule</span> while <span class="token punctuation">(</span>E<span class="token punctuation">)</span> S <span class="token operator">=&gt;</span> if <span class="token punctuation">(</span>E<span class="token punctuation">)</span> <span class="token punctuation">{</span>S while<span class="token punctuation">(</span>E<span class="token punctuation">)</span>S<span class="token punctuation">}</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> print<span class="token punctuation">(</span>V<span class="token punctuation">:</span>Val<span class="token punctuation">,</span> Es <span class="token operator">=&gt;</span> Es<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>output</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>List <span class="token operator">=&gt;</span> ListItem<span class="token punctuation">(</span>V<span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>output</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> print<span class="token punctuation">(</span><span class="token punctuation">.</span>Vals<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K


  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> xstackFrame<span class="token punctuation">(</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span>Stmt<span class="token punctuation">,</span>K<span class="token punctuation">,</span>Map<span class="token punctuation">,</span>K<span class="token punctuation">)</span>
  <span class="token comment">// TODO(KORE): drop the additional production once parsing issue #1842 is fixed</span>
                 <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span>Stmt<span class="token punctuation">,</span>K<span class="token punctuation">,</span>Map<span class="token punctuation">,</span>K<span class="token punctuation">)</span>

  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;popx&quot;</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span>try S1 catch<span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token punctuation">{</span>S2<span class="token punctuation">}</span> <span class="token operator">=&gt;</span> S1 <span class="token operator">~&gt;</span> popx<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>control</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>xstack</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token operator">=&gt;</span> ListItem<span class="token punctuation">(</span>xstackFrame<span class="token punctuation">(</span>X<span class="token punctuation">,</span> S2<span class="token punctuation">,</span> K<span class="token punctuation">,</span> Env<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>xstack</span><span class="token punctuation">&gt;</span></span>
         C
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>control</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> popx <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>xstack</span><span class="token punctuation">&gt;</span></span> ListItem<span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>List <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>xstack</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> throw V<span class="token punctuation">:</span>Val<span class="token punctuation">;</span> <span class="token operator">~&gt;</span> _ <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> var X <span class="token operator">=</span> V<span class="token punctuation">;</span> S2 <span class="token punctuation">}</span> <span class="token operator">~&gt;</span> K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>control</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>xstack</span><span class="token punctuation">&gt;</span></span> ListItem<span class="token punctuation">(</span>xstackFrame<span class="token punctuation">(</span>X<span class="token punctuation">,</span> S2<span class="token punctuation">,</span> K<span class="token punctuation">,</span> Env<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>List <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>xstack</span><span class="token punctuation">&gt;</span></span>
         <span class="token punctuation">(</span>_ <span class="token operator">=&gt;</span> C<span class="token punctuation">)</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>control</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> _ <span class="token operator">=&gt;</span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
</pre><p>Thread spawning needs a new semantics, because we want the child<br>
thread to also share the object environment with its parent.  The new<br>
semantics of thread spawning will be defined shortly.  However,<br>
interestingly, the other concurrency constructs keep their semantics<br>
from SIMPLE unchanged.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token comment">// TODO(KORE): ..Bag should be . throughout this definition #1772</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>thread</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span>K<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>holds</span><span class="token punctuation">&gt;</span></span>H<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>holds</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">&gt;</span></span>T<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>thread</span><span class="token punctuation">&gt;</span></span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Bag<span class="token punctuation">)</span>
  <span class="token comment">/*
  rule (&lt;thread&gt;... &lt;k&gt;.&lt;/k&gt; &lt;holds&gt;H&lt;/holds&gt; &lt;id&gt;T&lt;/id&gt; ...&lt;/thread&gt; =&gt; .)
  */</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>busy</span><span class="token punctuation">&gt;</span></span> Busy <span class="token operator">=&gt;</span> Busy <span class="token operator">-</span>Set keys<span class="token punctuation">(</span>H<span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>busy</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>terminated</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Set <span class="token operator">=&gt;</span> SetItem<span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>terminated</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> join T<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>terminated</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> SetItem<span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>terminated</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> acquire V<span class="token punctuation">:</span>Val<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>holds</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Map <span class="token operator">=&gt;</span> V <span class="token operator">|</span><span class="token operator">-</span>&gt; <span class="token number">0</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>holds</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>busy</span><span class="token punctuation">&gt;</span></span> Busy <span class="token punctuation">(</span><span class="token punctuation">.</span>Set <span class="token operator">=&gt;</span> SetItem<span class="token punctuation">(</span>V<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>busy</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> <span class="token punctuation">(</span>notBool<span class="token punctuation">(</span>V in Busy<span class="token punctuation">:</span>Set<span class="token punctuation">)</span><span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> acquire V<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>holds</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> V<span class="token punctuation">:</span>Val <span class="token operator">|</span><span class="token operator">-</span>&gt; <span class="token punctuation">(</span>N<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">=&gt;</span> N <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>holds</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> release V<span class="token punctuation">:</span>Val<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>holds</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> V <span class="token operator">|</span><span class="token operator">-</span>&gt; <span class="token punctuation">(</span>N <span class="token operator">=&gt;</span> N<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>holds</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> N &gt;<span class="token keyword keyword-Int">Int</span> <span class="token number">0</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> release V<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>holds</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> V<span class="token punctuation">:</span>Val <span class="token operator">|</span><span class="token operator">-</span>&gt; <span class="token number">0</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Map <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>holds</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>busy</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> SetItem<span class="token punctuation">(</span>V<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Set <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>busy</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> rendezvous V<span class="token punctuation">:</span>Val<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> rendezvous V<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="unchanged-auxiliary-operations-from-untyped-simple">Unchanged auxiliary operations from untyped SIMPLE</h2>

<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> mkDecls<span class="token punctuation">(</span>Ids<span class="token punctuation">,</span>Vals<span class="token punctuation">)</span>  <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> mkDecls<span class="token punctuation">(</span><span class="token punctuation">(</span>X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span> Xs<span class="token punctuation">:</span>Ids<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>V<span class="token punctuation">:</span>Val<span class="token punctuation">,</span> Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> var X<span class="token operator">=</span>V<span class="token punctuation">;</span> mkDecls<span class="token punctuation">(</span>Xs<span class="token punctuation">,</span>Vs<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> mkDecls<span class="token punctuation">(</span><span class="token punctuation">.</span>Ids<span class="token punctuation">,</span><span class="token punctuation">.</span>Vals<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token comment">// TODO(KORE): clarify sort inferences #1803</span>
  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> lookup<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span>
  <span class="token comment">/*
  syntax KItem ::= lookup(Int)
  */</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> lookup<span class="token punctuation">(</span>L<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> V <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; V<span class="token punctuation">:</span>Val <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> setEnv<span class="token punctuation">(</span>Map<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> setEnv<span class="token punctuation">(</span>Env<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> _ <span class="token operator">=&gt;</span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>setEnv<span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> setEnv<span class="token punctuation">(</span>_<span class="token punctuation">)</span>
  <span class="token comment">// TODO: How can we make sure that the second rule above applies before the first one?</span>
  <span class="token comment">//       Probably we&apos;ll deal with this using strategies, eventually.</span>

  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> lvalue<span class="token punctuation">(</span>K<span class="token punctuation">)</span>
  <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> loc<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> lvalue<span class="token punctuation">(</span>X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=&gt;</span> loc<span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> X <span class="token operator">|</span><span class="token operator">-</span>&gt; L<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-context">context</span> lvalue<span class="token punctuation">(</span>_<span class="token punctuation">:</span><span class="token punctuation">:</span>Exp<span class="token punctuation">[</span>HOLE<span class="token punctuation">:</span><span class="token punctuation">:</span>Exps<span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-context">context</span> lvalue<span class="token punctuation">(</span>HOLE<span class="token punctuation">:</span><span class="token punctuation">:</span>Exp<span class="token punctuation">[</span>_<span class="token punctuation">:</span><span class="token punctuation">:</span>Exps<span class="token punctuation">]</span><span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> lvalue<span class="token punctuation">(</span>lookup<span class="token punctuation">(</span>L<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> loc<span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">)</span>


  <span class="token keyword keyword-syntax">syntax</span> Map <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;...&quot;</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;|-&gt;&quot;</span> K
    <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> N<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>M <span class="token operator">|</span><span class="token operator">-</span>&gt; _ <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Map  <span class="token keyword keyword-requires">requires</span> N &gt;<span class="token keyword keyword-Int">Int</span> M
  <span class="token keyword keyword-rule">rule</span> N<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>M <span class="token operator">|</span><span class="token operator">-</span>&gt; K <span class="token operator">=&gt;</span> N <span class="token operator">|</span><span class="token operator">-</span>&gt; K <span class="token punctuation">(</span>N <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>M <span class="token operator">|</span><span class="token operator">-</span>&gt; K  <span class="token keyword keyword-requires">requires</span> N <span class="token operator">&lt;=</span><span class="token keyword keyword-Int">Int</span> M
</pre><h2 class="mume-header" id="changes-to-the-existing-untyped-simple-semantics">Changes to the existing untyped SIMPLE semantics</h2>

<p>When we extend a language, sometimes we need to do more than just add<br>
new language constructs and semantics for them.  Sometimes we want to<br>
also extend the semantics of existing language constructs, in order to<br>
get more from them.</p>
<h2 class="mume-header" id="program-initialization">Program initialization</h2>

<p>In SIMPLE, once all the global declarations were processed, the<br>
function <code>main()</code> was invoked.  In KOOL, the global<br>
declarations are classes, and their specific semantics is given<br>
shortly; essentially, they are pre-processed one by one and added<br>
into the <code>class</code> cell structure in the configuration.<br>
Once all the classes are processed, the computation item<br>
<code>execute</code>, which was placed right after the program in the<br>
initial configuration, is reached.  In SIMPLE, the program was<br>
initialized by calling the method <code>main()</code>.  In KOOL, the<br>
program is initialized by creating an object instance of class<br>
<code>Main</code>.  This will also implicitly call the method<br>
<code>Main()</code> (the <code>Main</code> class constructor).  The emptiness<br>
of the <code>env</code> cell below is just a sanity check, to make sure<br>
that the user has not declared anything but classes at the top level<br>
of the program.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;execute&quot;</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> execute <span class="token operator">=&gt;</span> new Main<span class="token punctuation">(</span><span class="token punctuation">.</span>Exps<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
</pre><p>The semantics of <code>new</code> (defined below) requires the<br>
execution of all the class&apos; declarations (and also of its<br>
superclasses&apos;).</p>
<h2 class="mume-header" id="object-and-method-closures">Object and method closures</h2>

<p>Before we can define the semantics of method application (previously<br>
called function application in SIMPLE), we need to add two more values<br>
to the language, namely object and method closures:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> objectClosure<span class="token punctuation">(</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span> List<span class="token punctuation">)</span>
               <span class="token operator">|</span> methodClosure<span class="token punctuation">(</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span>Ids<span class="token punctuation">,</span>Stmt<span class="token punctuation">)</span>
</pre><p>An object value consists of an <code>objectClosure</code>-wrapped bag<br>
containing the current class of the object and the environment stack<br>
of the object.  The current class of an object will always be one of<br>
the classes mapped to an environment in the environment stack of the<br>
object.  A method closure encapsulates the method&apos;s parameters and<br>
code (last two arguments), as well as the object context in which the<br>
method code should execute.  This object context includes the current<br>
class of the object (the first argument of <code>methodClosure</code>) and<br>
the object environment stack (located in the object stored at the<br>
location specified as the second argument of <code>methodClosure</code>).</p>
<h2 class="mume-header" id="method-application">Method application</h2>

<p>KOOL has a complex mechanism to invoke methods, because it allows both<br>
dynamic method dispatch and methods as first-class-citizen values (the<br>
latter making it a higher-order language).  The invocation mechanism<br>
will be defined later.  What is sufficient to know for now is that<br>
the two arguments of the application construct eventually reduce to<br>
values, the first being a method closure and the latter a list of<br>
values.  The semantics of the method closure application is then as<br>
expected: the local environment and control are stacked, then we<br>
switch to method closure&apos;s class and object environment and execute<br>
the method body.  The <code>mkDecls</code> construct is the one that came<br>
with the unchanged semantics of SIMPLE above.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> fstackFrame<span class="token punctuation">(</span>Map<span class="token punctuation">,</span>K<span class="token punctuation">,</span>List<span class="token punctuation">,</span>K<span class="token punctuation">)</span>
  <span class="token comment">// TODO(KORE): drop the additional production once parsing issue #1842 is fixed</span>
                 <span class="token operator">|</span> <span class="token punctuation">(</span>Map<span class="token punctuation">,</span>K<span class="token punctuation">,</span>K<span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> methodClosure<span class="token punctuation">(</span>Class<span class="token punctuation">,</span>OL<span class="token punctuation">,</span>Xs<span class="token punctuation">,</span>S<span class="token punctuation">)</span><span class="token punctuation">(</span>Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> K
           <span class="token operator">=&gt;</span> mkDecls<span class="token punctuation">(</span>Xs<span class="token punctuation">,</span>Vs<span class="token punctuation">)</span> S return<span class="token punctuation">;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> OL <span class="token operator">|</span><span class="token operator">-</span>&gt; objectClosure<span class="token punctuation">(</span>_<span class="token punctuation">,</span> EnvStack<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
     <span class="token comment">//&lt;br/&gt; // TODO(KORE): support latex annotations #1799</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>control</span><span class="token punctuation">&gt;</span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>xstack</span><span class="token punctuation">&gt;</span></span> XS <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>xstack</span><span class="token punctuation">&gt;</span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fstack</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token operator">=&gt;</span> ListItem<span class="token punctuation">(</span>fstackFrame<span class="token punctuation">(</span>Env<span class="token punctuation">,</span> K<span class="token punctuation">,</span> XS<span class="token punctuation">,</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntObj</span><span class="token punctuation">&gt;</span></span> Obj&apos; <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntObj</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span>
          <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fstack</span><span class="token punctuation">&gt;</span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntObj</span><span class="token punctuation">&gt;</span></span> Obj&apos; <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntClass</span><span class="token punctuation">&gt;</span></span> Class <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntClass</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>envStack</span><span class="token punctuation">&gt;</span></span> EnvStack <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>envStack</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntObj</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>control</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="spawn">Spawn</h2>

<p>We want to extend the semantics of <code>spawn</code> to also share the<br>
current object environment with the child thread, in addition to the<br>
current environment.  This extension will allow us to also use method<br>
invocations in the spawned statements, which will be thus looked up as<br>
expected, using dynamic method dispatch.  This lookup operation would<br>
fail if the child thread did not have access to its parent&apos;s object<br>
environment.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>thread</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> spawn S <span class="token operator">=&gt;</span> <span class="token operator">!</span>T<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntObj</span><span class="token punctuation">&gt;</span></span> Obj <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntObj</span><span class="token punctuation">&gt;</span></span>
       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>thread</span><span class="token punctuation">&gt;</span></span>
       <span class="token punctuation">(</span><span class="token punctuation">.</span>Bag <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>thread</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
               <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> S <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
               <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
               <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">&gt;</span></span> <span class="token operator">!</span>T <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">&gt;</span></span>
               <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntObj</span><span class="token punctuation">&gt;</span></span> Obj <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntObj</span><span class="token punctuation">&gt;</span></span>
             <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>thread</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>
</pre><h2 class="mume-header" id="semantics-of-the-new-kool-constructs">Semantics of the new KOOL constructs</h2>

<h2 class="mume-header" id="class-declaration">Class declaration</h2>

<p>Initially, the classes forming the program are moved into their<br>
corresponding cells:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> class Class1 extends Class2 <span class="token punctuation">{</span> S <span class="token punctuation">}</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>classes</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">(</span><span class="token punctuation">.</span>Bag <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>classData</span><span class="token punctuation">&gt;</span></span>
                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>className</span><span class="token punctuation">&gt;</span></span> Class1 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>className</span><span class="token punctuation">&gt;</span></span>
                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>baseClass</span><span class="token punctuation">&gt;</span></span> Class2 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>baseClass</span><span class="token punctuation">&gt;</span></span>
                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>declarations</span><span class="token punctuation">&gt;</span></span> S <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>declarations</span><span class="token punctuation">&gt;</span></span>
                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>classData</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>
       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>classes</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="method-declaration">Method declaration</h2>

<p>Like in SIMPLE, method names are added to the environment and bound<br>
to their code.  However, unlike in SIMPLE where each function was<br>
executed in the same environment, namely the program global<br>
environment, a method in KOOL needs to be executed into its object&apos;s<br>
environment.  Thus, methods evaluate to closures, which encapsulate<br>
their object&apos;s context (i.e., the current class and environment stack<br>
of the object) in addition to method&apos;s parameters and body.  This<br>
approach to bind method names to method closures in the environment<br>
will also allow objects to pass their methods to other objects, to<br>
dynamically change their methods by assigning them other method<br>
closures, and even to allow all these to be done from other objects.<br>
This gives the KOOL programmer a lot of power; one should use this<br>
power wisely, though, because programs can become easily hard to<br>
understand and reason about if one overuses these features.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> method F<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">(</span>Xs<span class="token punctuation">:</span>Ids<span class="token punctuation">)</span> S <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntClass</span><span class="token punctuation">&gt;</span></span> Class<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntClass</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>location</span><span class="token punctuation">&gt;</span></span> OL<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>location</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token operator">=&gt;</span> Env<span class="token punctuation">[</span>F &lt;<span class="token operator">-</span> L<span class="token punctuation">]</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Map <span class="token operator">=&gt;</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; methodClosure<span class="token punctuation">(</span>Class<span class="token punctuation">,</span>OL<span class="token punctuation">,</span>Xs<span class="token punctuation">,</span>S<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nextLoc</span><span class="token punctuation">&gt;</span></span> L <span class="token operator">=&gt;</span> L <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>nextLoc</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="new">New</h2>

<p>The semantics of <code>new</code> consists of two actions: memory<br>
allocation for the new object and execution of the corresponding<br>
constructor.  Then the created object is returned as the result of the<br>
<code>new</code> operation; the value returned by the constructor, if any,<br>
is discarded.  The current environment and object are stored onto the<br>
stack and recovered after new (according to the semantics of<br>
<code>return</code> borrowed from SIMPLE, when the statement<br>
<code>return this;</code> in the rule below is reached and evaluated),<br>
because the object creation part of <code>new</code> will destroy them.<br>
The rule below also initializes the object creation process by<br>
emptying the local environment and the current object, and allocating<br>
a location in the store where the created object will be eventually<br>
stored (this is what the <code>storeObj</code> task after the object<br>
creation task in the rule below will do&#x2014;its rule is defined<br>
shortly).  The location where the object will be stored is also made<br>
available in the <code>crntObj</code> cell, so that method closures can<br>
refer to it (see rule above).</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;envStackFrame&quot;</span> <span class="token string">&quot;(&quot;</span> <span class="token keyword keyword-Id">Id</span> <span class="token string">&quot;,&quot;</span> Map <span class="token string">&quot;)&quot;</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> new Class<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">(</span>Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> K
           <span class="token operator">=&gt;</span> create<span class="token punctuation">(</span>Class<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> storeObj <span class="token operator">~&gt;</span> Class<span class="token punctuation">(</span>Vs<span class="token punctuation">)</span><span class="token punctuation">;</span> return this<span class="token punctuation">;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nextLoc</span><span class="token punctuation">&gt;</span></span> L<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">=&gt;</span> L <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>nextLoc</span><span class="token punctuation">&gt;</span></span>
     <span class="token comment">//&lt;br/&gt; // TODO(KORE): support latex annotations #1799</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>control</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>xstack</span><span class="token punctuation">&gt;</span></span> XS <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>xstack</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntObj</span><span class="token punctuation">&gt;</span></span> Obj
                   <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntClass</span><span class="token punctuation">&gt;</span></span> Object <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntClass</span><span class="token punctuation">&gt;</span></span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>envStack</span><span class="token punctuation">&gt;</span></span> ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>Object<span class="token punctuation">,</span> <span class="token punctuation">.</span>Map<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>envStack</span><span class="token punctuation">&gt;</span></span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>location</span><span class="token punctuation">&gt;</span></span> L <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>location</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntObj</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fstack</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token operator">=&gt;</span> ListItem<span class="token punctuation">(</span>fstackFrame<span class="token punctuation">(</span>Env<span class="token punctuation">,</span> K<span class="token punctuation">,</span> XS<span class="token punctuation">,</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntObj</span><span class="token punctuation">&gt;</span></span> Obj <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntObj</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fstack</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>control</span><span class="token punctuation">&gt;</span></span>
</pre><p>The creation of a new object (the memory allocation part only) is<br>
a recursive process, requiring to first create an object for the<br>
superclass.  A memory object representation is a layered structure:<br>
for each class on the path from the instance class to the root of the<br>
hierarchy there is a layer including the memory allocated for the<br>
members (both fields and methods) of that class.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> create<span class="token punctuation">(</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> create<span class="token punctuation">(</span>Class<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">)</span>
           <span class="token operator">=&gt;</span> create<span class="token punctuation">(</span>Class1<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> setCrntClass<span class="token punctuation">(</span>Class<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> S <span class="token operator">~&gt;</span> addEnvLayer <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>className</span><span class="token punctuation">&gt;</span></span> Class <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>className</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>baseClass</span><span class="token punctuation">&gt;</span></span> Class1<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>baseClass</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>declarations</span><span class="token punctuation">&gt;</span></span> S <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>declarations</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> create<span class="token punctuation">(</span>Object<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
</pre><p>The next operation sets the current class of the current object.<br>
This is necessary to be done at each layer, because the current class<br>
of the object is enclosed as part of the method closures (see the<br>
semantics of method declarations above).</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> setCrntClass<span class="token punctuation">(</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> setCrntClass<span class="token punctuation">(</span>C<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntClass</span><span class="token punctuation">&gt;</span></span> _ <span class="token operator">=&gt;</span> C <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntClass</span><span class="token punctuation">&gt;</span></span>
</pre><p>The next operation adds a new tagged environment layer to the<br>
current object and gets ready for the next layer by clearing the<br>
environment (note that <code>create</code> expects the environment to be<br>
empty).</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;addEnvLayer&quot;</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> addEnvLayer <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntClass</span><span class="token punctuation">&gt;</span></span> Class<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntClass</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>envStack</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token operator">=&gt;</span> ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>Class<span class="token punctuation">,</span> Env<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>envStack</span><span class="token punctuation">&gt;</span></span>
</pre><p>The following operation stores the created object at the location<br>
reserved by <code>new</code>.  Note that the location reserved by<br>
<code>new</code> was temporarily stored in the <code>crntObj</code> cell<br>
precisely for this purpose.  Now that the newly created object is<br>
stored at its location and that all method closures are aware of it,<br>
the location is unnecessary and thus we delete it from the<br>
<code>crntObj</code> cell.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;storeObj&quot;</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> storeObj <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntObj</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntClass</span><span class="token punctuation">&gt;</span></span> CC <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntClass</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>envStack</span><span class="token punctuation">&gt;</span></span> ES <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>envStack</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>location</span><span class="token punctuation">&gt;</span></span> L<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>location</span><span class="token punctuation">&gt;</span></span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Bag<span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntObj</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Map <span class="token operator">=&gt;</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; objectClosure<span class="token punctuation">(</span>CC<span class="token punctuation">,</span> ES<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="self-reference">Self reference</h2>

<p>The semantics of <code>this</code> is straightforward: evaluate to the<br>
current object.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> this <span class="token operator">=&gt;</span> objectClosure<span class="token punctuation">(</span>CC<span class="token punctuation">,</span> ES<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntObj</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntClass</span><span class="token punctuation">&gt;</span></span> CC <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntClass</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>envStack</span><span class="token punctuation">&gt;</span></span> ES <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>envStack</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntObj</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="object-member-access">Object member access</h2>

<p>We can access an object member (field or method) either explicitly,<br>
using the construct <code>e.x</code>, or implicitly, using only the member<br>
name <code>x</code> directly.  The borrowed semantics of SIMPLE will<br>
already lookup a sole name in the local environment.  The first rule<br>
below reduces implicit member access to explicit access when the name<br>
cannot be found in the local environment.  There are two cases to<br>
analyze for explicit object member access, depending upon whether the<br>
object is a proper object or it is just a redirection to the parent<br>
class via the construct <code>super</code>.  In the first case, we<br>
evaluate the object expression and lookup the member starting with the<br>
current class (static scoping).  Note the use of the conditional<br>
evaluation context.  In the second case, we just lookup the member<br>
starting with the superclass of the current class.  In both cases,<br>
the <code>lookupMember</code> task eventually yields a <code>lookup(L)</code><br>
task for some appropriate location <code>L</code>, which will be further<br>
solved with the corresponding rule borrowed from SIMPLE.  Note that the<br>
current object is not altered by <code>super</code>, so future method<br>
invocations see the entire object, as needed for dynamic method dispatch.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=&gt;</span> this <span class="token punctuation">.</span> X <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env<span class="token punctuation">:</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> notBool<span class="token punctuation">(</span>X in keys<span class="token punctuation">(</span>Env<span class="token punctuation">)</span><span class="token punctuation">)</span>

  <span class="token keyword keyword-context">context</span> HOLE<span class="token punctuation">.</span>_<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token keyword keyword-requires">requires</span> <span class="token punctuation">(</span>HOLE <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K super<span class="token punctuation">)</span>

<span class="token comment">// TODO: explain how Assoc matching has been replaced with two rules here.</span>
<span class="token comment">// Maybe also improve it a bit.</span>

<span class="token comment">/*  rule objectClosure(&lt;crntClass&gt; Class:Id &lt;/crntClass&gt;
                     &lt;envStack&gt;... envStackFrame(Class,EnvC) EStack &lt;/envStack&gt;)
       . X:Id
    =&gt; lookupMember(envStackFrame(Class,EnvC) EStack, X) */</span>

  <span class="token keyword keyword-rule">rule</span> objectClosure<span class="token punctuation">(</span>Class<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span> ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>Class<span class="token punctuation">,</span>Env<span class="token punctuation">)</span><span class="token punctuation">)</span> EStack<span class="token punctuation">)</span>
       <span class="token punctuation">.</span> X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span>
    <span class="token operator">=&gt;</span> lookupMember<span class="token punctuation">(</span>ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>Class<span class="token punctuation">,</span>Env<span class="token punctuation">)</span><span class="token punctuation">)</span> EStack<span class="token punctuation">,</span> X<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> objectClosure<span class="token punctuation">(</span>Class<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>Class&apos;<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span>_<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>List<span class="token punctuation">)</span> _<span class="token punctuation">)</span>
       <span class="token punctuation">.</span> _X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span>
    <span class="token keyword keyword-requires">requires</span> Class <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K Class&apos;

<span class="token comment">/*  rule &lt;k&gt; super . X =&gt; lookupMember(EStack, X) ...&lt;/k&gt;
       &lt;crntClass&gt; Class &lt;/crntClass&gt;
       &lt;envStack&gt;... envStackFrame(Class,EnvC) EStack &lt;/envStack&gt; */</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> super <span class="token punctuation">.</span> X <span class="token operator">=&gt;</span> lookupMember<span class="token punctuation">(</span>EStack<span class="token punctuation">,</span> X<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntClass</span><span class="token punctuation">&gt;</span></span> Class<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntClass</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>envStack</span><span class="token punctuation">&gt;</span></span> ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>Class<span class="token punctuation">,</span>_<span class="token punctuation">)</span><span class="token punctuation">)</span> EStack <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>envStack</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> super <span class="token punctuation">.</span> _X <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntClass</span><span class="token punctuation">&gt;</span></span> Class <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntClass</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>envStack</span><span class="token punctuation">&gt;</span></span> ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>Class&apos;<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span>_<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>List <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>envStack</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> Class <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K Class&apos;
</pre><h2 class="mume-header" id="method-invocation">Method invocation</h2>

<p>Unlike in SIMPLE, in KOOL application was declared strict only in its<br>
second argument.  That is because we want to ensure dynamic method<br>
dispatch when the first argument is a method access.  As a<br>
consequence, we need to consider all the cases of interest for the<br>
first argument and to explicitly say what to do in each case.  In all<br>
cases except for method access in a proper object (i.e., not<br>
<code>super</code>), we want the same behavior for the first argument as<br>
if it was not in a method invocation position.  When it is a member<br>
access (the third rule below), we look it up starting with the<br>
instance class of the corresponding object.  This ensures dynamic<br>
dispatch for methods; it actually dynamically dispatches field<br>
accesses, too, which is correct in KOOL, because one can assign method<br>
closures to fields and the field appeared in a method invocation<br>
context.  The last context declaration below says that method<br>
applications or array accesses are also allowed as first argument to<br>
applications; that is because methods are allowed to return methods<br>
and arrays are allowed to hold methods in KOOL, since it is<br>
higher-order.  If that is the case, then we want to evaluate the<br>
method call or the array access.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span>X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=&gt;</span> V<span class="token punctuation">)</span><span class="token punctuation">(</span>_<span class="token punctuation">:</span>Exps<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> X <span class="token operator">|</span><span class="token operator">-</span>&gt; L <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; V<span class="token punctuation">:</span>Val <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span>X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=&gt;</span> this <span class="token punctuation">.</span> X<span class="token punctuation">)</span><span class="token punctuation">(</span>_<span class="token punctuation">:</span>Exps<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> notBool<span class="token punctuation">(</span>X in keys<span class="token punctuation">(</span>Env<span class="token punctuation">)</span><span class="token punctuation">)</span>

  <span class="token keyword keyword-context">context</span> HOLE<span class="token punctuation">.</span>_<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token keyword keyword-requires">requires</span> HOLE <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K super

  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>objectClosure<span class="token punctuation">(</span>_<span class="token punctuation">,</span> EStack<span class="token punctuation">)</span> <span class="token punctuation">.</span> X
    <span class="token operator">=&gt;</span> lookupMember<span class="token punctuation">(</span>EStack<span class="token punctuation">,</span> X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span>_<span class="token punctuation">:</span>Exps<span class="token punctuation">)</span>

<span class="token comment">/*  rule &lt;k&gt; (super . X
            =&gt; lookupMember(EStack,X))(_:Exps)...&lt;/k&gt;
       &lt;crntClass&gt; Class &lt;/crntClass&gt;
       &lt;envStack&gt;... envStackFrame(Class,_) EStack &lt;/envStack&gt; */</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span>super <span class="token punctuation">.</span> X
            <span class="token operator">=&gt;</span> lookupMember<span class="token punctuation">(</span>EStack<span class="token punctuation">,</span>X<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span>_<span class="token punctuation">:</span>Exps<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntClass</span><span class="token punctuation">&gt;</span></span> Class <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntClass</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>envStack</span><span class="token punctuation">&gt;</span></span> ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>Class<span class="token punctuation">,</span>_<span class="token punctuation">)</span><span class="token punctuation">)</span> EStack <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>envStack</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span>super <span class="token punctuation">.</span> _X<span class="token punctuation">)</span><span class="token punctuation">(</span>_<span class="token punctuation">:</span>Exps<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntClass</span><span class="token punctuation">&gt;</span></span> Class <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntClass</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>envStack</span><span class="token punctuation">&gt;</span></span> ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>Class&apos;<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span>_<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>List <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>envStack</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> Class <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K Class&apos;

  <span class="token comment">// TODO(KORE): fix getKLabel #1801</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>A<span class="token punctuation">:</span>Exp<span class="token punctuation">(</span>B<span class="token punctuation">:</span>Exps<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span>C<span class="token punctuation">:</span>Exps<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> A<span class="token punctuation">(</span>B<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> #freezerFunCall<span class="token punctuation">(</span>C<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>A<span class="token punctuation">:</span>Exp<span class="token punctuation">[</span>B<span class="token punctuation">:</span>Exps<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span>C<span class="token punctuation">:</span>Exps<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> A<span class="token punctuation">[</span>B<span class="token punctuation">]</span> <span class="token operator">~&gt;</span> #freezerFunCall<span class="token punctuation">(</span>C<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> V<span class="token punctuation">:</span>Val <span class="token operator">~&gt;</span> #freezerFunCall<span class="token punctuation">(</span>C<span class="token punctuation">:</span>Exps<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> V<span class="token punctuation">(</span>C<span class="token punctuation">)</span>
  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;#freezerFunCall&quot;</span> <span class="token string">&quot;(&quot;</span> K <span class="token string">&quot;)&quot;</span>
  <span class="token comment">/*
  context HOLE(_:Exps)
    when getKLabel(HOLE) ==K #klabel(`_(_)`) orBool getKLabel(HOLE) ==K #klabel(`_[_]`)
  */</span>
</pre><p>Eventually, each of the rules above produces a <code>lookup(L)</code><br>
task as a replacement for the method.  When that happens, we just<br>
lookup the value at location <code>L</code>:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span>lookup<span class="token punctuation">(</span>L<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> V<span class="token punctuation">)</span><span class="token punctuation">(</span>_<span class="token punctuation">:</span>Exps<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; V<span class="token punctuation">:</span>Val <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
</pre><p>The value <code>V</code> looked up above is expected to be a method closure,<br>
in which case the semantics of method application given above will<br>
apply.  Otherwise, the execution will get stuck.</p>
<h2 class="mume-header" id="instance-of">Instance Of</h2>

<p>It searches the object environment for a layer corresponding to the<br>
desired class.  It returns <code>true</code> iff it can find the class,<br>
otherwise it returns <code>false</code>; it only gets stuck when its first<br>
argument does not evaluate to an object.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> objectClosure<span class="token punctuation">(</span>_<span class="token punctuation">,</span> ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>C<span class="token punctuation">,</span>_<span class="token punctuation">)</span><span class="token punctuation">)</span> _<span class="token punctuation">)</span>
       instanceOf C <span class="token operator">=&gt;</span> <span class="token boolean">true</span>

  <span class="token keyword keyword-rule">rule</span> objectClosure<span class="token punctuation">(</span>_<span class="token punctuation">,</span> <span class="token punctuation">(</span>ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>C<span class="token punctuation">,</span>_<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>List<span class="token punctuation">)</span> _<span class="token punctuation">)</span>
       instanceOf C<span class="token string">&apos;  requires C =/=K C&apos;</span>
<span class="token comment">//TODO: remove the sort cast ::Id of C above, when sort inference bug fixed</span>

  <span class="token keyword keyword-rule">rule</span> objectClosure<span class="token punctuation">(</span>_<span class="token punctuation">,</span> <span class="token punctuation">.</span>List<span class="token punctuation">)</span> instanceOf _ <span class="token operator">=&gt;</span> <span class="token boolean">false</span>
</pre><h2 class="mume-header" id="cast">Cast</h2>

<p>In untyped KOOL, we prefer to not check the validity of casting.  In<br>
other words, any cast is allowed on any object, simply changing the<br>
current class of the object to the desired class.  The execution will<br>
get stuck later if one attempts to access a field which is not<br>
available.  Moreover, the execution may complete successfully even<br>
in the presence of invalid casts, provided that each accessed member<br>
during the current execution is, or happens to be, available.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>C<span class="token punctuation">)</span> objectClosure<span class="token punctuation">(</span>_ <span class="token punctuation">,</span> EnvStack<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> objectClosure<span class="token punctuation">(</span>C <span class="token punctuation">,</span>EnvStack<span class="token punctuation">)</span>
</pre><h2 class="mume-header" id="kool-specific-auxiliary-declarations-and-operations">KOOL-specific auxiliary declarations and operations</h2>

<p>Here we define all the auxiliary constructs used in the above<br>
KOOL-specific semantics (those used in the SIMPLE fragment<br>
have already been defined in a corresponding section above).</p>
<h2 class="mume-header" id="objects-as-lvalues">Objects as lvalues</h2>

<p>The current machinery borrowed with the semantics of SIMPLE allows us<br>
to enrich the set of lvalues, this way allowing new means to assign<br>
values to locations.  In KOOL, we want object member names to be<br>
lvalues, so that we can assign values to them using the already<br>
existing machinery.  The first rule below ensures that the object is<br>
always explicit, the evaluation context enforces the object to be<br>
evaluated, and finally the second rule initiates the lookup for the<br>
member&apos;s location based on the current class of the object.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> lvalue<span class="token punctuation">(</span>X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=&gt;</span> this <span class="token punctuation">.</span> X<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> notBool<span class="token punctuation">(</span>X in keys<span class="token punctuation">(</span>Env<span class="token punctuation">)</span><span class="token punctuation">)</span>

  <span class="token keyword keyword-context">context</span> lvalue<span class="token punctuation">(</span><span class="token punctuation">(</span>HOLE <span class="token punctuation">.</span> _<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">:</span>Exp<span class="token punctuation">)</span>

<span class="token comment">/*  rule lvalue(objectClosure(&lt;crntClass&gt; C &lt;/crntClass&gt;
                            &lt;envStack&gt;... envStackFrame(C,EnvC) EStack &lt;/envStack&gt;)
              . X
              =&gt; lookupMember(&lt;envStack&gt; envStackFrame(C,EnvC) EStack &lt;/envStack&gt;,
                              X))  */</span>
  <span class="token keyword keyword-rule">rule</span> lvalue<span class="token punctuation">(</span>objectClosure<span class="token punctuation">(</span>Class<span class="token punctuation">,</span> ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>Class<span class="token punctuation">,</span>Env<span class="token punctuation">)</span><span class="token punctuation">)</span> EStack<span class="token punctuation">)</span>
              <span class="token punctuation">.</span> X
              <span class="token operator">=&gt;</span> lookupMember<span class="token punctuation">(</span>ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>Class<span class="token punctuation">,</span>Env<span class="token punctuation">)</span><span class="token punctuation">)</span> EStack<span class="token punctuation">,</span>
                              X<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> lvalue<span class="token punctuation">(</span>objectClosure<span class="token punctuation">(</span>Class<span class="token punctuation">,</span> <span class="token punctuation">(</span>ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>Class&apos;<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span>_<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>List<span class="token punctuation">)</span> _<span class="token punctuation">)</span>
              <span class="token punctuation">.</span> _X<span class="token punctuation">)</span>
    <span class="token keyword keyword-requires">requires</span> Class <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K Class&apos;
</pre><h2 class="mume-header" id="lookup-member">Lookup member</h2>

<p>It searches for the given member in the given environment stack,<br>
starting with the most concrete class and going up in the hierarchy.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token comment">// TODO(KORE): clarify sort inferences #1803</span>
  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> lookupMember<span class="token punctuation">(</span>List<span class="token punctuation">,</span> <span class="token keyword keyword-Id">Id</span><span class="token punctuation">)</span>  <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token comment">/*
  syntax KItem ::= lookupMember(EnvStackCell,Id)  [function]
  */</span>

<span class="token comment">//  rule lookupMember(&lt;envStack&gt; envStackFrame(_, &lt;env&gt;... X|-&gt;L ...&lt;/env&gt;) ...&lt;/envStack&gt;, X)</span>
<span class="token comment">//    =&gt; lookup(L)</span>
  <span class="token keyword keyword-rule">rule</span> lookupMember<span class="token punctuation">(</span>ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>_<span class="token punctuation">,</span> X<span class="token operator">|</span><span class="token operator">-</span>&gt;L _<span class="token punctuation">)</span><span class="token punctuation">)</span> _<span class="token punctuation">,</span> X<span class="token punctuation">)</span>
    <span class="token operator">=&gt;</span> lookup<span class="token punctuation">(</span>L<span class="token punctuation">)</span>

<span class="token comment">//  rule lookupMember(&lt;envStack&gt; envStackFrame(_, &lt;env&gt; Env &lt;/env&gt;) =&gt; .List ...&lt;/envStack&gt;, X)</span>
<span class="token comment">//    when notBool(X in keys(Env))</span>
  <span class="token keyword keyword-rule">rule</span> lookupMember<span class="token punctuation">(</span>ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>_<span class="token punctuation">,</span> Env<span class="token punctuation">)</span><span class="token punctuation">)</span> Rest<span class="token punctuation">,</span> X<span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
       lookupMember<span class="token punctuation">(</span>Rest<span class="token punctuation">,</span> X<span class="token punctuation">)</span>
    <span class="token keyword keyword-requires">requires</span> notBool<span class="token punctuation">(</span>X in keys<span class="token punctuation">(</span>Env<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">//TODO: beautify the above</span>

<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>Go to <a href="#ebook-heading-lesson-2-kool-typed-dynamic">Lesson 2, KOOL typed dynamic</a>.</p>
</div></div><div id="ebook-heading-lesson-1-kool-untyped" ebook-toc-level-4 heading="Lesson 1, KOOL untyped"><div><h1 class="mume-header" id="kool-untyped">KOOL &#x2014; Untyped</h1>

<p>Author: Grigore Ro&#x219;u (<a href="mailto:grosu@illinois.edu">grosu@illinois.edu</a>)<br>
Organization: University of Illinois at Urbana-Champaign</p>
<p>Author: Traian Florin &#x218;erb&#x103;nu&#x21B;&#x103; (<a href="mailto:traian.serbanuta@unibuc.ro">traian.serbanuta@unibuc.ro</a>)<br>
Organization: University of Bucharest</p>
<h2 class="mume-header" id="abstract">Abstract</h2>

<p>This is the <strong>K</strong> semantic definition of the untyped KOOL language.  KOOL<br>
is aimed at being a pedagogical and research language that captures<br>
the essence of the object-oriented programming paradigm.  Its untyped<br>
variant discussed here is simpler than the typed one, ignoring several<br>
intricate aspects of types in the presence of objects.  A program<br>
consists of a set of class declarations.  Each class can extend at<br>
most one other class (KOOL is single-inheritance).  A class can<br>
declare a set of fields and a set of methods, all public and called<br>
the class&apos; <em>members</em>.  Specifically, KOOL includes the<br>
following features:</p>
<ul>
<li>
<p>Class declarations, where a class may or may not explicitly<br>
extend another class.  In case a class does not explicitly extend<br>
another class, then it is assumed that it extends the default top-most<br>
and empty (i.e., no members) class called <code>Object</code>.  Each class<br>
is required to declare precisely one homonymous method, called its<br>
<em>constructor</em>.  Each valid program should contain one class<br>
named <code>Main</code>, whose constructor, <code>Main()</code>, takes no<br>
arguments.  The execution of a program consists of creating an object<br>
instance of class <code>Main</code> and invoking the constructor<br>
<code>Main()</code> on it, that is, of executing <code>new Main();</code>.</p>
</li>
<li>
<p>All features of SIMPLE (see <code>examples/simple/untyped</code>),<br>
i.e., multidimensional arrays, function (here called &quot;method&quot;)<br>
abstractions with call-by-value parameter passing style and static<br>
scoping, blocks with locals, input/output, parametric exceptions, and<br>
concurrency via dynamic thread creation/termination and synchronization.<br>
The only change in the syntax of SIMPLE when imported in KOOL is the<br>
function declaration keyword, <code>function</code>, which is changed into<br>
<code>method</code>.  The exact same desugaring macros from SIMPLE are<br>
also included in KOOL.  We can think of KOOL&apos;s classes as embedding<br>
SIMPLE programs (extended with OO constructs, as discussed next).</p>
</li>
<li>
<p>Object creation using the <code>new C(e1,...,en)</code><br>
expression construct.  An object instance of class <code>C</code> is first<br>
created and then the constructor <code>C(e1,...,en)</code> is implicitly<br>
called on that object.  KOOL only allows (and requires) one<br>
constructor per class.  The class constructor can be called either<br>
implicitly during a new object creation for the class, or explicitly.<br>
The superclass constructor is <strong>not</strong> implicitly invoked when a<br>
class constructor is invoked; if you want to invoke the superclass<br>
constructor from a subclass constructor then you have to do it<br>
explicitly.</p>
</li>
<li>
<p>An expression construct <code>this</code>, which evaluates to the<br>
current object.</p>
</li>
<li>
<p>An expression construct <code>super</code>, which is used (only) in<br>
combination with member lookup (see next) to refer to a superclass<br>
field or method.</p>
</li>
<li>
<p>A member lookup expression construct <code>e.x</code>, where <code>e</code><br>
is an expression (either an expression expected to evaluate to an object<br>
or the <code>super</code> construct) and <code>x</code> is a class member name,<br>
that is, a field or a method name.</p>
</li>
<li>
<p>Expression constructs <code>e instanceOf C</code> and<br>
<code>(C) e</code>, where <code>e</code> is an expression expected<br>
to evaluate to an object and <code>C</code> a class name.  The former<br>
tells whether the class of <code>e</code> is a subclass of <code>C</code>,<br>
that is, whether <code>e</code> can be used as an instance of <code>C</code>,<br>
and the latter changes the class of <code>e</code> to <code>C</code>.  These<br>
operations always succeed: the former returns a Boolean value, while<br>
the latter changes the current class of <code>e</code> to <code>C</code><br>
regardless of whether it is safe to do so or not.  The typed version<br>
of KOOL will check the safety of casting by ensuring that the instance<br>
class of the object is a subclass of <code>C</code>.  In untyped KOOL we<br>
do not want to perform this check because we want to allow the<br>
programmer maximum of flexibility: if one always accesses only<br>
available members, then the program can execute successfully despite<br>
the potentially unsafe cast.</p>
</li>
</ul>
<p>There are some specific aspects of KOOL that need to be discussed.</p>
<p>First, KOOL is higher-order, allowing function abstractions to be<br>
treated like any other values in the language.  For example, if<br>
<code>m</code> is a method of object <code>e</code> then <code>e.m</code><br>
evaluates to the corresponding function abstraction.  The function<br>
abstraction is in fact a closure, because in addition to the method<br>
parameters and body it also encapsulates the object value (i.e., the<br>
environment of the object together with its current class&#x2014;see below)<br>
that <code>e</code> evaluates to.  This way, function abstractions can be<br>
invoked anywhere and have the capability to change the state of their<br>
object.  For example, if <code>m</code> is a method of object <code>e</code><br>
which increments a field <code>c</code> of <code>e</code> when invoked, and if<br>
<code>getm</code> is another method of <code>e</code> which simply returns<br>
<code>m</code> when invoked, then the double application<br>
<code>(e.getm())()</code> has the same effect as <code>e.m()</code>, that is,<br>
increments the counter <code>c</code> of <code>e</code>.  Note that the<br>
higher-order nature of KOOL was not originally planned; it came as a<br>
natural consequence of evaluating methods to closures and we decided<br>
to keep it.  If you do not like it then do not use it.</p>
<p>Second, since all the fields and methods are public in KOOL and since<br>
they can be redeclared in subclasses, it is not immediately clear how<br>
to lookup the member <code>x</code> when we write <code>e.x</code> and<br>
<code>e</code> is different from <code>super</code>.  We distinguish two cases,<br>
depending on whether <code>e.x</code> occurs in a method invocation<br>
context (i.e., <code>e.x(...)</code>) or in a field context.  KOOL has<br>
dynamic method dispatch, so if <code>e.x</code> is invoked as a method<br>
then <code>x</code> will be searched for starting with the instance class of<br>
the object value to which <code>e</code> evaluates.  If <code>e.x</code><br>
occurs in a non-method-invocation context then <code>x</code> will be<br>
treated as a field (although it may hold a method closure due to the<br>
higher-order nature of KOOL) and thus will be searched starting with<br>
the current class of the object value of <code>e</code> (which, because of<br>
<code>this</code> and casting, may be different from its instance class).<br>
In order to achieve the above, each object value will consist of a<br>
pair holding the current class of the object and an environment stack<br>
with one layer for each class in the object&apos;s instance class hierarchy.</p>
<p>Third, although KOOL is dynamic method dispatch, its capabilities<br>
described above are powerful enough to allow us to mimic static<br>
method dispatch.  For example, suppose that you want to invoke method<br>
<code>m()</code> statically.  Then all you need to do is to declare a<br>
local variable and bind it to <code>m</code>, for example <code>var staticm = m;</code>, and<br>
then call <code>staticm()</code>.  This works because<br>
<code>staticm</code> is first bound to the method closure that <code>m</code><br>
evaluates to, and then looked up as any local variable when invoked.<br>
We only enable the dynamic method dispatch when we have an object<br>
member on an application position, e.g., <code>m()</code>.</p>
<p>In what follows, we limit our comments to the new, KOOL-specific<br>
aspects of the language.  We refer the reader to the untyped SIMPLE<br>
language for documentation on the the remaining features, because<br>
those were all borrowed from SIMPLE.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> KOOL<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> DOMAINS<span class="token operator">-</span>SYNTAX
</pre><h2 class="mume-header" id="syntax">Syntax</h2>

<p>The syntax of KOOL extends that of SIMPLE with object-oriented<br>
constructs.  We removed from the <strong>K</strong> annotated syntax of SIMPLE two<br>
constructs, namely the one for function declarations (because we want<br>
to call them <code>methods</code> now) and the one for function application<br>
(because application is not strict in the first argument<br>
anymore&#x2014;needs to initiate dynamic method dispatch).  The additional<br>
syntax includes:</p>
<ul>
<li>First, we need a new dedicated identifier, <code>Object</code>, for<br>
the default top-most class.</li>
<li>Second, we rename the <code>function</code> keyword of SIMPLE into <code>method</code>.</li>
<li>Third, we add syntax for class declarations together with a<br>
macro making classes which extend nothing to extend <code>Object</code>.</li>
<li>Fourth, we change the strictness attribute of application<br>
into <code>strict(2)</code>.</li>
<li>Finally, we add syntax and corresponding strictness<br>
for the KOOL object-oriented constructs.</li>
</ul>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Id">Id</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;Object&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token string">&quot;Main&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-syntax">syntax</span> Stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;var&quot;</span> Exps <span class="token string">&quot;;&quot;</span>
                <span class="token operator">|</span> <span class="token string">&quot;method&quot;</span> <span class="token keyword keyword-Id">Id</span> <span class="token string">&quot;(&quot;</span> Ids <span class="token string">&quot;)&quot;</span> Block  <span class="token comment">// called &quot;function&quot; in SIMPLE</span>
                <span class="token operator">|</span> <span class="token string">&quot;class&quot;</span> <span class="token keyword keyword-Id">Id</span> Block               <span class="token comment">// KOOL</span>
                <span class="token operator">|</span> <span class="token string">&quot;class&quot;</span> <span class="token keyword keyword-Id">Id</span> <span class="token string">&quot;extends&quot;</span> <span class="token keyword keyword-Id">Id</span> Block  <span class="token comment">// KOOL</span>

  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span> <span class="token operator">|</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token operator">|</span> <span class="token keyword keyword-String">String</span> <span class="token operator">|</span> <span class="token keyword keyword-Id">Id</span>
               <span class="token operator">|</span> <span class="token string">&quot;this&quot;</span>                                 <span class="token comment">// KOOL</span>
               <span class="token operator">|</span> <span class="token string">&quot;super&quot;</span>                                <span class="token comment">// KOOL</span>
               <span class="token operator">|</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span>             <span class="token punctuation">[</span><span class="token class-name">bracket</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;++&quot;</span> Exp
               <span class="token operator">|</span> Exp <span class="token string">&quot;instanceOf&quot;</span> <span class="token keyword keyword-Id">Id</span>     <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token comment">// KOOL</span>
               <span class="token operator">|</span> <span class="token string">&quot;(&quot;</span> <span class="token keyword keyword-Id">Id</span> <span class="token string">&quot;)&quot;</span> Exp          <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token comment">// KOOL  cast</span>
               <span class="token operator">|</span> <span class="token string">&quot;new&quot;</span> <span class="token keyword keyword-Id">Id</span> <span class="token string">&quot;(&quot;</span> Exps <span class="token string">&quot;)&quot;</span>   <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token comment">// KOOL</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;.&quot;</span> <span class="token keyword keyword-Id">Id</span>                             <span class="token comment">// KOOL</span>
               &gt; Exp <span class="token string">&quot;[&quot;</span> Exps <span class="token string">&quot;]&quot;</span>        <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               &gt; Exp <span class="token string">&quot;(&quot;</span> Exps <span class="token string">&quot;)&quot;</span>        <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token comment">// was strict in SIMPLE</span>
               <span class="token operator">|</span> <span class="token string">&quot;-&quot;</span> Exp                 <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;sizeOf&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span>    <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;read&quot;</span> <span class="token string">&quot;(&quot;</span> <span class="token string">&quot;)&quot;</span>
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;*&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;/&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;%&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;+&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;-&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               &gt; <span class="token class-name">non-assoc</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;&lt;&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;&lt;=&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;&gt;&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;&gt;=&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;==&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;!=&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               &gt; <span class="token string">&quot;!&quot;</span> Exp                 <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;&amp;&amp;&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;||&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               &gt; <span class="token string">&quot;spawn&quot;</span> Block
               &gt; Exp <span class="token string">&quot;=&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">right</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-syntax">syntax</span> Ids  <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>

  <span class="token keyword keyword-syntax">syntax</span> Exps <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Exp<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>          <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> overload<span class="token punctuation">(</span>exps<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Val
  <span class="token keyword keyword-syntax">syntax</span> Vals <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Val<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>          <span class="token punctuation">[</span>overload<span class="token punctuation">(</span>exps<span class="token punctuation">)</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-syntax">syntax</span> Block <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;{&quot;</span> <span class="token string">&quot;}&quot;</span>
                <span class="token operator">|</span> <span class="token string">&quot;{&quot;</span> Stmt <span class="token string">&quot;}&quot;</span>

  <span class="token keyword keyword-syntax">syntax</span> Stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Block
                <span class="token operator">|</span> Exp <span class="token string">&quot;;&quot;</span>                               <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;if&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Block <span class="token string">&quot;else&quot;</span> Block   <span class="token punctuation">[</span><span class="token class-name">avoid</span><span class="token punctuation">,</span> <span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;if&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Block                <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;while&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Block
                <span class="token operator">|</span> <span class="token string">&quot;for&quot;</span> <span class="token string">&quot;(&quot;</span> Stmt Exp <span class="token string">&quot;;&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Block  <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;return&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                      <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;return&quot;</span> <span class="token string">&quot;;&quot;</span>                          <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;print&quot;</span> <span class="token string">&quot;(&quot;</span> Exps <span class="token string">&quot;)&quot;</span> <span class="token string">&quot;;&quot;</span>              <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;try&quot;</span> Block <span class="token string">&quot;catch&quot;</span> <span class="token string">&quot;(&quot;</span> <span class="token keyword keyword-Id">Id</span> <span class="token string">&quot;)&quot;</span> Block
                <span class="token operator">|</span> <span class="token string">&quot;throw&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                       <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;join&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                        <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;acquire&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                     <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;release&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                     <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;rendezvous&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                  <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-syntax">syntax</span> Stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Stmt Stmt                          <span class="token punctuation">[</span><span class="token class-name">right</span><span class="token punctuation">]</span>
</pre><p>Old desugaring rules, from SIMPLE</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> if <span class="token punctuation">(</span>E<span class="token punctuation">)</span> S <span class="token operator">=&gt;</span> if <span class="token punctuation">(</span>E<span class="token punctuation">)</span> S else <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword keyword-rule">rule</span> for<span class="token punctuation">(</span>Start Cond<span class="token punctuation">;</span> Step<span class="token punctuation">)</span> <span class="token punctuation">{</span>S<span class="token punctuation">}</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>Start while <span class="token punctuation">(</span>Cond<span class="token punctuation">)</span> <span class="token punctuation">{</span>S Step<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span>
  <span class="token keyword keyword-rule">rule</span> var E1<span class="token punctuation">:</span><span class="token punctuation">:</span>Exp<span class="token punctuation">,</span> E2<span class="token punctuation">:</span><span class="token punctuation">:</span>Exp<span class="token punctuation">,</span> Es<span class="token punctuation">:</span><span class="token punctuation">:</span>Exps<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> var E1<span class="token punctuation">;</span> var E2<span class="token punctuation">,</span> Es<span class="token punctuation">;</span>       <span class="token punctuation">[</span>anywhere<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> var X<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=</span> E<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> var X<span class="token punctuation">;</span> X <span class="token operator">=</span> E<span class="token punctuation">;</span>                              <span class="token punctuation">[</span>anywhere<span class="token punctuation">]</span>
</pre><p>New desugaring rule</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> class C<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> S <span class="token operator">=&gt;</span> class C extends Object S                     <span class="token comment">// KOOL</span>

<span class="token keyword keyword-endmodule">endmodule</span>
</pre><h2 class="mume-header" id="semantics">Semantics</h2>

<p>We first discuss the new configuration of KOOL, which extends that of<br>
SIMPLE.  Then we include the semantics of the constructs borrowed from<br>
SIMPLE unchanged; we refrain from discussing those, because they were<br>
already discussed in the <strong>K</strong> definition of SIMPLE.  Then we discuss<br>
changes to SIMPLE&apos;s semantics needed for the more general meaning of<br>
the previous SIMPLE constructs (for example for thread spawning,<br>
assignment, etc.).  Finally, we discuss in detail the<br>
semantics of the additional KOOL constructs.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> KOOL<span class="token operator">-</span>UNTYPED
  <span class="token keyword keyword-imports">imports</span> KOOL<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> DOMAINS
</pre><h2 class="mume-header" id="configuration">Configuration</h2>

<p>KOOL removes one cell and adds two nested cells to the configuration<br>
of SIMPLE.  The cell which is removed is the one holding the global<br>
environment, because a KOOL program consists of a set of classes only,<br>
with no global declarations.  In fact, since informally speaking each<br>
KOOL class now includes a SIMPLE program, it is safe to say that the<br>
global variables in SIMPLE became class fields in KOOL.  Let us now<br>
discuss the new cells that are added to the configuration of SIMPLE.</p>
<ul>
<li>
<p>The cell <code>crntObj</code> holds data pertaining to the current<br>
object, that is, the object environment in which the code in cell<br>
<code>k</code> executes: <code>crntClass</code> holds the current class (which<br>
can change as methods of the current object are invoked);<br>
<code>envStack</code> holds the stack of environments as a list,<br>
each layer corresponding to one class in the objects&apos; instance class<br>
hierarchy; <code>location</code>, which is optional, holds the location in<br>
the store where the current object is or has to be located (this is<br>
useful both for method closures and for the semantics of object<br>
creation).</p>
</li>
<li>
<p>The cell <code>classes</code> holds all the declared classes, each<br>
class being held in its own <code>class</code> cell which contains a name<br>
(<code>className</code>), a parent (<code>extends</code>), and the actual<br>
member declarations (<code>declarations</code>).</p>
</li>
</ul>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token comment">// the syntax declarations below are required because the sorts are</span>
  <span class="token comment">// referenced directly by a production and, because of the way KIL to KORE</span>
  <span class="token comment">// is implemented, the configuration syntax is not available yet</span>
  <span class="token comment">// should simply work once KIL is removed completely</span>
  <span class="token comment">// check other definitions for this hack as well</span>
  <span class="token keyword keyword-syntax">syntax</span> EnvCell
  <span class="token keyword keyword-syntax">syntax</span> ControlCell
  <span class="token keyword keyword-syntax">syntax</span> EnvStackCell
  <span class="token keyword keyword-syntax">syntax</span> CrntObjCellFragment

  <span class="token keyword keyword-configuration">configuration</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>T</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>red<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>threads</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>orange<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>thread</span> <span class="token attr-name">multiplicity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>*<span class="token punctuation">&quot;</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Set<span class="token punctuation">&quot;</span></span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>yellow<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>green<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> $PGM<span class="token punctuation">:</span>Stmt <span class="token operator">~&gt;</span> execute <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
                    <span class="token comment">//&lt;br/&gt; // TODO(KORE): support latex annotations #1799</span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>control</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>cyan<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fstack</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>blue<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fstack</span><span class="token punctuation">&gt;</span></span>
                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>xstack</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>purple<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>xstack</span><span class="token punctuation">&gt;</span></span>
                      <span class="token comment">//&lt;br/&gt; // TODO(KORE): support latex annotations #1799</span>
                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntObj</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Fuchsia<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>  <span class="token comment">// KOOL</span>
                           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntClass</span><span class="token punctuation">&gt;</span></span> Object <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntClass</span><span class="token punctuation">&gt;</span></span>
                           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>envStack</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>envStack</span><span class="token punctuation">&gt;</span></span>
                           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>location</span> <span class="token attr-name">multiplicity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>?<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>location</span><span class="token punctuation">&gt;</span></span>
                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntObj</span><span class="token punctuation">&gt;</span></span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>control</span><span class="token punctuation">&gt;</span></span>
                    <span class="token comment">//&lt;br/&gt; // TODO(KORE): support latex annotations #1799</span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>violet<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>holds</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>black<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>holds</span><span class="token punctuation">&gt;</span></span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>pink<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token number">0</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">&gt;</span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>thread</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>threads</span><span class="token punctuation">&gt;</span></span>
                <span class="token comment">//&lt;br/&gt; // TODO(KORE): support latex annotations #1799</span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>white<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>busy</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>cyan<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span>Set <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>busy</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>terminated</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>red<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Set <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>terminated</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>magenta<span class="token punctuation">&quot;</span></span> <span class="token attr-name">stream</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>stdin<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>input</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>output</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>brown<span class="token punctuation">&quot;</span></span> <span class="token attr-name">stream</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>stdout<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>output</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nextLoc</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>gray<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token number">0</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>nextLoc</span><span class="token punctuation">&gt;</span></span>
                <span class="token comment">//&lt;br/&gt; // TODO(KORE): support latex annotations #1799</span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>classes</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Fuchsia<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>        <span class="token comment">// KOOL</span>
                     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>classData</span> <span class="token attr-name">multiplicity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>*<span class="token punctuation">&quot;</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Map<span class="token punctuation">&quot;</span></span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Fuchsia<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
                        <span class="token comment">// the Map has as its key the first child of the cell,</span>
                        <span class="token comment">// in this case the className cell.</span>
                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>className</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Fuchsia<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> Main <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>className</span><span class="token punctuation">&gt;</span></span>
                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>baseClass</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Fuchsia<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> Object <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>baseClass</span><span class="token punctuation">&gt;</span></span>
                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>declarations</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Fuchsia<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>declarations</span><span class="token punctuation">&gt;</span></span>
                     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>classData</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>classes</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>T</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="unchanged-semantics-from-untyped-simple">Unchanged Semantics from untyped SIMPLE</h2>

<p>The semantics below is taken over from SIMPLE unchanged.<br>
The semantics of function declaration and invocation, including the<br>
use of the special <code>lambda</code> abstraction value, needs to change<br>
in order to account for the fact that methods are now invoked into<br>
their object&apos;s environment.  The semantics of function return actually<br>
stays unchanged.  Also, the semantics of program initialization is<br>
different: now we have to create an instance of the <code>Main</code><br>
class which also calls the constructor <code>Main()</code>, while in<br>
SIMPLE we only had to invoke the function <code>Main()</code>.<br>
Finally, the semantics of thread spawning needs to change, too: the<br>
parent thread needs to also share its object environment with the<br>
spawned thread (in addition to its local environment, like in SIMPLE).<br>
This is needed in order to be able to spawn method invokations under<br>
dynamic method dispatch; for example, <code>spawn { run(); }</code><br>
will need to look up the method <code>run()</code> in the newly created<br>
thread, operation which will most likely fail unless the child thread<br>
sees the object environment of the parent thread.  Note that the<br>
<code>spawn</code> statement of KOOL is more permissive than the threads<br>
of Java.  In fact, the latter can be implemented in terms of our<br>
<code>spawn</code>&#x2014;see the program <code>threads.kool</code> for a sketch.</p>
<p>Below is a subset of the values of SIMPLE, which are also values<br>
of KOOL.  We will add other values later in the semantics, such as<br>
object and method closures.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span> <span class="token operator">|</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token operator">|</span> <span class="token keyword keyword-String">String</span>
               <span class="token operator">|</span> array<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Val
  <span class="token keyword keyword-syntax">syntax</span> Exps <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Vals
  <span class="token keyword keyword-syntax">syntax</span> KResult <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Val
  <span class="token keyword keyword-syntax">syntax</span> KResult <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Vals
</pre><p>The semantics below are taken verbatim from the untyped SIMPLE<br>
definition.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;undefined&quot;</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> var X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token operator">=&gt;</span> Env<span class="token punctuation">[</span>X &lt;<span class="token operator">-</span> L<span class="token punctuation">]</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Map <span class="token operator">=&gt;</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; undefined <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nextLoc</span><span class="token punctuation">&gt;</span></span> L<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">=&gt;</span> L <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>nextLoc</span><span class="token punctuation">&gt;</span></span>


  <span class="token keyword keyword-context">context</span> var _<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">[</span>HOLE<span class="token punctuation">]</span><span class="token punctuation">;</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> var X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">[</span>N<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token operator">=&gt;</span> Env<span class="token punctuation">[</span>X &lt;<span class="token operator">-</span> L<span class="token punctuation">]</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Map <span class="token operator">=&gt;</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; array<span class="token punctuation">(</span>L <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">,</span> N<span class="token punctuation">)</span>
                          <span class="token punctuation">(</span>L <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">(</span>L <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> N<span class="token punctuation">)</span> <span class="token operator">|</span><span class="token operator">-</span>&gt; undefined <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nextLoc</span><span class="token punctuation">&gt;</span></span> L<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">=&gt;</span> L <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span> <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> N <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>nextLoc</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> N <span class="token operator">&gt;=</span><span class="token keyword keyword-Int">Int</span> <span class="token number">0</span>


  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Id">Id</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;$1&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token string">&quot;$2&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> var X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">[</span>N1<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> N2<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token operator">=&gt;</span> var X<span class="token punctuation">[</span>N1<span class="token punctuation">]</span><span class="token punctuation">;</span>
       <span class="token punctuation">{</span>
         var $<span class="token number">1</span><span class="token operator">=</span>X<span class="token punctuation">;</span>
         for<span class="token punctuation">(</span>var $<span class="token number">2</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> $<span class="token number">2</span> <span class="token operator">&lt;=</span> N1 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>$<span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           var X<span class="token punctuation">[</span>N2<span class="token punctuation">,</span>Vs<span class="token punctuation">]</span><span class="token punctuation">;</span>
           $<span class="token number">1</span><span class="token punctuation">[</span>$<span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> X<span class="token punctuation">;</span>
         <span class="token punctuation">}</span>
       <span class="token punctuation">}</span>


  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=&gt;</span> V <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> X <span class="token operator">|</span><span class="token operator">-</span>&gt; L <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; V<span class="token punctuation">:</span>Val <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>


  <span class="token keyword keyword-context">context</span> <span class="token operator">++</span><span class="token punctuation">(</span>HOLE <span class="token operator">=&gt;</span> lvalue<span class="token punctuation">(</span>HOLE<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token operator">++</span>loc<span class="token punctuation">(</span>L<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> I <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; <span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">=&gt;</span> I <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>


  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">+</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> Str1 <span class="token operator">+</span> Str2 <span class="token operator">=&gt;</span> Str1 <span class="token operator">+</span><span class="token keyword keyword-String">String</span> Str2
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">-</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">*</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">*</span><span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">/</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">/</span><span class="token keyword keyword-Int">Int</span> I2 <span class="token keyword keyword-requires">requires</span> I2 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K <span class="token number">0</span>
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">%</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">%</span><span class="token keyword keyword-Int">Int</span> I2 <span class="token keyword keyword-requires">requires</span> I2 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K <span class="token number">0</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token operator">-</span> I <span class="token operator">=&gt;</span> <span class="token number">0</span> <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> I
  <span class="token keyword keyword-rule">rule</span> I1 &lt; I2 <span class="token operator">=&gt;</span> I1 &lt;<span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">&lt;=</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">&lt;=</span><span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> I1 &gt; I2 <span class="token operator">=&gt;</span> I1 &gt;<span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">&gt;=</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">&gt;=</span><span class="token keyword keyword-Int">Int</span> I2

  <span class="token keyword keyword-rule">rule</span> V1<span class="token punctuation">:</span>Val <span class="token operator">==</span> V2<span class="token punctuation">:</span>Val <span class="token operator">=&gt;</span> V1 <span class="token operator">==</span>K V2
  <span class="token keyword keyword-rule">rule</span> V1<span class="token punctuation">:</span>Val <span class="token operator">!=</span> V2<span class="token punctuation">:</span>Val <span class="token operator">=&gt;</span> V1 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K V2
  <span class="token keyword keyword-rule">rule</span> <span class="token operator">!</span> T <span class="token operator">=&gt;</span> notBool<span class="token punctuation">(</span>T<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">true</span>  <span class="token operator">&amp;&amp;</span> E <span class="token operator">=&gt;</span> E
  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">false</span> <span class="token operator">&amp;&amp;</span> _ <span class="token operator">=&gt;</span> <span class="token boolean">false</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">true</span>  <span class="token operator">||</span> _ <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">false</span> <span class="token operator">||</span> E <span class="token operator">=&gt;</span> E


  <span class="token keyword keyword-rule">rule</span> V<span class="token punctuation">:</span>Val<span class="token punctuation">[</span>N1<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> N2<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">]</span> <span class="token operator">=&gt;</span> V<span class="token punctuation">[</span>N1<span class="token punctuation">]</span><span class="token punctuation">[</span>N2<span class="token punctuation">,</span> Vs<span class="token punctuation">]</span>
    <span class="token punctuation">[</span>anywhere<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> array<span class="token punctuation">(</span>L<span class="token punctuation">,</span>_<span class="token punctuation">)</span><span class="token punctuation">[</span>N<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">]</span> <span class="token operator">=&gt;</span> lookup<span class="token punctuation">(</span>L <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> N<span class="token punctuation">)</span>
    <span class="token punctuation">[</span>anywhere<span class="token punctuation">]</span>


  <span class="token keyword keyword-rule">rule</span> sizeOf<span class="token punctuation">(</span>array<span class="token punctuation">(</span>_<span class="token punctuation">,</span>N<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> N
</pre><p>The semantics of function application needs to change into dynamic<br>
method dispatch invocation, which is defined shortly.  However,<br>
interestingly, the semantics of return stays unchanged.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> return<span class="token punctuation">(</span>V<span class="token punctuation">:</span>Val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">~&gt;</span> _ <span class="token operator">=&gt;</span> V <span class="token operator">~&gt;</span> K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>control</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fstack</span><span class="token punctuation">&gt;</span></span> ListItem<span class="token punctuation">(</span>fstackFrame<span class="token punctuation">(</span>Env<span class="token punctuation">,</span>K<span class="token punctuation">,</span>XS<span class="token punctuation">,</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntObj</span><span class="token punctuation">&gt;</span></span> CO <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntObj</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>List <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fstack</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>xstack</span><span class="token punctuation">&gt;</span></span> _ <span class="token operator">=&gt;</span> XS <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>xstack</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntObj</span><span class="token punctuation">&gt;</span></span> _ <span class="token operator">=&gt;</span> CO <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntObj</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>control</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> _ <span class="token operator">=&gt;</span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;nothing&quot;</span>
  <span class="token keyword keyword-rule">rule</span> return<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> return nothing<span class="token punctuation">;</span>


  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> read<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> I <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span><span class="token punctuation">&gt;</span></span> ListItem<span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>List <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>input</span><span class="token punctuation">&gt;</span></span>


  <span class="token keyword keyword-context">context</span> <span class="token punctuation">(</span>HOLE <span class="token operator">=&gt;</span> lvalue<span class="token punctuation">(</span>HOLE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> _

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> loc<span class="token punctuation">(</span>L<span class="token punctuation">)</span> <span class="token operator">=</span> V<span class="token punctuation">:</span>Val <span class="token operator">=&gt;</span> V <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; <span class="token punctuation">(</span>_ <span class="token operator">=&gt;</span> V<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span> S <span class="token punctuation">}</span> <span class="token operator">=&gt;</span> S <span class="token operator">~&gt;</span> setEnv<span class="token punctuation">(</span>Env<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>


  <span class="token keyword keyword-rule">rule</span> S1<span class="token punctuation">:</span><span class="token punctuation">:</span>Stmt S2<span class="token punctuation">:</span><span class="token punctuation">:</span>Stmt <span class="token operator">=&gt;</span> S1 <span class="token operator">~&gt;</span> S2

  <span class="token keyword keyword-rule">rule</span> _<span class="token punctuation">:</span>Val<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K

  <span class="token keyword keyword-rule">rule</span> if <span class="token punctuation">(</span> <span class="token boolean">true</span><span class="token punctuation">)</span> S else _ <span class="token operator">=&gt;</span> S
  <span class="token keyword keyword-rule">rule</span> if <span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> _ else S <span class="token operator">=&gt;</span> S

  <span class="token keyword keyword-rule">rule</span> while <span class="token punctuation">(</span>E<span class="token punctuation">)</span> S <span class="token operator">=&gt;</span> if <span class="token punctuation">(</span>E<span class="token punctuation">)</span> <span class="token punctuation">{</span>S while<span class="token punctuation">(</span>E<span class="token punctuation">)</span>S<span class="token punctuation">}</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> print<span class="token punctuation">(</span>V<span class="token punctuation">:</span>Val<span class="token punctuation">,</span> Es <span class="token operator">=&gt;</span> Es<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>output</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>List <span class="token operator">=&gt;</span> ListItem<span class="token punctuation">(</span>V<span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>output</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> print<span class="token punctuation">(</span><span class="token punctuation">.</span>Vals<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K


  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> xstackFrame<span class="token punctuation">(</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span>Stmt<span class="token punctuation">,</span>K<span class="token punctuation">,</span>Map<span class="token punctuation">,</span>K<span class="token punctuation">)</span>
  <span class="token comment">// TODO(KORE): drop the additional production once parsing issue #1842 is fixed</span>
                 <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span>Stmt<span class="token punctuation">,</span>K<span class="token punctuation">,</span>Map<span class="token punctuation">,</span>K<span class="token punctuation">)</span>

  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;popx&quot;</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span>try S1 catch<span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token punctuation">{</span>S2<span class="token punctuation">}</span> <span class="token operator">=&gt;</span> S1 <span class="token operator">~&gt;</span> popx<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>control</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>xstack</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token operator">=&gt;</span> ListItem<span class="token punctuation">(</span>xstackFrame<span class="token punctuation">(</span>X<span class="token punctuation">,</span> S2<span class="token punctuation">,</span> K<span class="token punctuation">,</span> Env<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>xstack</span><span class="token punctuation">&gt;</span></span>
         C
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>control</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> popx <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>xstack</span><span class="token punctuation">&gt;</span></span> ListItem<span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>List <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>xstack</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> throw V<span class="token punctuation">:</span>Val<span class="token punctuation">;</span> <span class="token operator">~&gt;</span> _ <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> var X <span class="token operator">=</span> V<span class="token punctuation">;</span> S2 <span class="token punctuation">}</span> <span class="token operator">~&gt;</span> K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>control</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>xstack</span><span class="token punctuation">&gt;</span></span> ListItem<span class="token punctuation">(</span>xstackFrame<span class="token punctuation">(</span>X<span class="token punctuation">,</span> S2<span class="token punctuation">,</span> K<span class="token punctuation">,</span> Env<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>List <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>xstack</span><span class="token punctuation">&gt;</span></span>
         <span class="token punctuation">(</span>_ <span class="token operator">=&gt;</span> C<span class="token punctuation">)</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>control</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> _ <span class="token operator">=&gt;</span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
</pre><p>Thread spawning needs a new semantics, because we want the child<br>
thread to also share the object environment with its parent.  The new<br>
semantics of thread spawning will be defined shortly.  However,<br>
interestingly, the other concurrency constructs keep their semantics<br>
from SIMPLE unchanged.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token comment">// TODO(KORE): ..Bag should be . throughout this definition #1772</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>thread</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span>K<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>holds</span><span class="token punctuation">&gt;</span></span>H<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>holds</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">&gt;</span></span>T<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>thread</span><span class="token punctuation">&gt;</span></span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Bag<span class="token punctuation">)</span>
  <span class="token comment">/*
  rule (&lt;thread&gt;... &lt;k&gt;.&lt;/k&gt; &lt;holds&gt;H&lt;/holds&gt; &lt;id&gt;T&lt;/id&gt; ...&lt;/thread&gt; =&gt; .)
  */</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>busy</span><span class="token punctuation">&gt;</span></span> Busy <span class="token operator">=&gt;</span> Busy <span class="token operator">-</span>Set keys<span class="token punctuation">(</span>H<span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>busy</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>terminated</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Set <span class="token operator">=&gt;</span> SetItem<span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>terminated</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> join T<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>terminated</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> SetItem<span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>terminated</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> acquire V<span class="token punctuation">:</span>Val<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>holds</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Map <span class="token operator">=&gt;</span> V <span class="token operator">|</span><span class="token operator">-</span>&gt; <span class="token number">0</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>holds</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>busy</span><span class="token punctuation">&gt;</span></span> Busy <span class="token punctuation">(</span><span class="token punctuation">.</span>Set <span class="token operator">=&gt;</span> SetItem<span class="token punctuation">(</span>V<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>busy</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> <span class="token punctuation">(</span>notBool<span class="token punctuation">(</span>V in Busy<span class="token punctuation">:</span>Set<span class="token punctuation">)</span><span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> acquire V<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>holds</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> V<span class="token punctuation">:</span>Val <span class="token operator">|</span><span class="token operator">-</span>&gt; <span class="token punctuation">(</span>N<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">=&gt;</span> N <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>holds</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> release V<span class="token punctuation">:</span>Val<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>holds</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> V <span class="token operator">|</span><span class="token operator">-</span>&gt; <span class="token punctuation">(</span>N <span class="token operator">=&gt;</span> N<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>holds</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> N &gt;<span class="token keyword keyword-Int">Int</span> <span class="token number">0</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> release V<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>holds</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> V<span class="token punctuation">:</span>Val <span class="token operator">|</span><span class="token operator">-</span>&gt; <span class="token number">0</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Map <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>holds</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>busy</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> SetItem<span class="token punctuation">(</span>V<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Set <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>busy</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> rendezvous V<span class="token punctuation">:</span>Val<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> rendezvous V<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="unchanged-auxiliary-operations-from-untyped-simple">Unchanged auxiliary operations from untyped SIMPLE</h2>

<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> mkDecls<span class="token punctuation">(</span>Ids<span class="token punctuation">,</span>Vals<span class="token punctuation">)</span>  <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> mkDecls<span class="token punctuation">(</span><span class="token punctuation">(</span>X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span> Xs<span class="token punctuation">:</span>Ids<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>V<span class="token punctuation">:</span>Val<span class="token punctuation">,</span> Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> var X<span class="token operator">=</span>V<span class="token punctuation">;</span> mkDecls<span class="token punctuation">(</span>Xs<span class="token punctuation">,</span>Vs<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> mkDecls<span class="token punctuation">(</span><span class="token punctuation">.</span>Ids<span class="token punctuation">,</span><span class="token punctuation">.</span>Vals<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token comment">// TODO(KORE): clarify sort inferences #1803</span>
  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> lookup<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span>
  <span class="token comment">/*
  syntax KItem ::= lookup(Int)
  */</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> lookup<span class="token punctuation">(</span>L<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> V <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; V<span class="token punctuation">:</span>Val <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> setEnv<span class="token punctuation">(</span>Map<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> setEnv<span class="token punctuation">(</span>Env<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> _ <span class="token operator">=&gt;</span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>setEnv<span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> setEnv<span class="token punctuation">(</span>_<span class="token punctuation">)</span>
  <span class="token comment">// TODO: How can we make sure that the second rule above applies before the first one?</span>
  <span class="token comment">//       Probably we&apos;ll deal with this using strategies, eventually.</span>

  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> lvalue<span class="token punctuation">(</span>K<span class="token punctuation">)</span>
  <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> loc<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> lvalue<span class="token punctuation">(</span>X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=&gt;</span> loc<span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> X <span class="token operator">|</span><span class="token operator">-</span>&gt; L<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-context">context</span> lvalue<span class="token punctuation">(</span>_<span class="token punctuation">:</span><span class="token punctuation">:</span>Exp<span class="token punctuation">[</span>HOLE<span class="token punctuation">:</span><span class="token punctuation">:</span>Exps<span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-context">context</span> lvalue<span class="token punctuation">(</span>HOLE<span class="token punctuation">:</span><span class="token punctuation">:</span>Exp<span class="token punctuation">[</span>_<span class="token punctuation">:</span><span class="token punctuation">:</span>Exps<span class="token punctuation">]</span><span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> lvalue<span class="token punctuation">(</span>lookup<span class="token punctuation">(</span>L<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> loc<span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">)</span>


  <span class="token keyword keyword-syntax">syntax</span> Map <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;...&quot;</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;|-&gt;&quot;</span> K
    <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> N<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>M <span class="token operator">|</span><span class="token operator">-</span>&gt; _ <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Map  <span class="token keyword keyword-requires">requires</span> N &gt;<span class="token keyword keyword-Int">Int</span> M
  <span class="token keyword keyword-rule">rule</span> N<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>M <span class="token operator">|</span><span class="token operator">-</span>&gt; K <span class="token operator">=&gt;</span> N <span class="token operator">|</span><span class="token operator">-</span>&gt; K <span class="token punctuation">(</span>N <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>M <span class="token operator">|</span><span class="token operator">-</span>&gt; K  <span class="token keyword keyword-requires">requires</span> N <span class="token operator">&lt;=</span><span class="token keyword keyword-Int">Int</span> M
</pre><h2 class="mume-header" id="changes-to-the-existing-untyped-simple-semantics">Changes to the existing untyped SIMPLE semantics</h2>

<p>When we extend a language, sometimes we need to do more than just add<br>
new language constructs and semantics for them.  Sometimes we want to<br>
also extend the semantics of existing language constructs, in order to<br>
get more from them.</p>
<h2 class="mume-header" id="program-initialization">Program initialization</h2>

<p>In SIMPLE, once all the global declarations were processed, the<br>
function <code>main()</code> was invoked.  In KOOL, the global<br>
declarations are classes, and their specific semantics is given<br>
shortly; essentially, they are pre-processed one by one and added<br>
into the <code>class</code> cell structure in the configuration.<br>
Once all the classes are processed, the computation item<br>
<code>execute</code>, which was placed right after the program in the<br>
initial configuration, is reached.  In SIMPLE, the program was<br>
initialized by calling the method <code>main()</code>.  In KOOL, the<br>
program is initialized by creating an object instance of class<br>
<code>Main</code>.  This will also implicitly call the method<br>
<code>Main()</code> (the <code>Main</code> class constructor).  The emptiness<br>
of the <code>env</code> cell below is just a sanity check, to make sure<br>
that the user has not declared anything but classes at the top level<br>
of the program.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;execute&quot;</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> execute <span class="token operator">=&gt;</span> new Main<span class="token punctuation">(</span><span class="token punctuation">.</span>Exps<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
</pre><p>The semantics of <code>new</code> (defined below) requires the<br>
execution of all the class&apos; declarations (and also of its<br>
superclasses&apos;).</p>
<h2 class="mume-header" id="object-and-method-closures">Object and method closures</h2>

<p>Before we can define the semantics of method application (previously<br>
called function application in SIMPLE), we need to add two more values<br>
to the language, namely object and method closures:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> objectClosure<span class="token punctuation">(</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span> List<span class="token punctuation">)</span>
               <span class="token operator">|</span> methodClosure<span class="token punctuation">(</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span>Ids<span class="token punctuation">,</span>Stmt<span class="token punctuation">)</span>
</pre><p>An object value consists of an <code>objectClosure</code>-wrapped bag<br>
containing the current class of the object and the environment stack<br>
of the object.  The current class of an object will always be one of<br>
the classes mapped to an environment in the environment stack of the<br>
object.  A method closure encapsulates the method&apos;s parameters and<br>
code (last two arguments), as well as the object context in which the<br>
method code should execute.  This object context includes the current<br>
class of the object (the first argument of <code>methodClosure</code>) and<br>
the object environment stack (located in the object stored at the<br>
location specified as the second argument of <code>methodClosure</code>).</p>
<h2 class="mume-header" id="method-application">Method application</h2>

<p>KOOL has a complex mechanism to invoke methods, because it allows both<br>
dynamic method dispatch and methods as first-class-citizen values (the<br>
latter making it a higher-order language).  The invocation mechanism<br>
will be defined later.  What is sufficient to know for now is that<br>
the two arguments of the application construct eventually reduce to<br>
values, the first being a method closure and the latter a list of<br>
values.  The semantics of the method closure application is then as<br>
expected: the local environment and control are stacked, then we<br>
switch to method closure&apos;s class and object environment and execute<br>
the method body.  The <code>mkDecls</code> construct is the one that came<br>
with the unchanged semantics of SIMPLE above.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> fstackFrame<span class="token punctuation">(</span>Map<span class="token punctuation">,</span>K<span class="token punctuation">,</span>List<span class="token punctuation">,</span>K<span class="token punctuation">)</span>
  <span class="token comment">// TODO(KORE): drop the additional production once parsing issue #1842 is fixed</span>
                 <span class="token operator">|</span> <span class="token punctuation">(</span>Map<span class="token punctuation">,</span>K<span class="token punctuation">,</span>K<span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> methodClosure<span class="token punctuation">(</span>Class<span class="token punctuation">,</span>OL<span class="token punctuation">,</span>Xs<span class="token punctuation">,</span>S<span class="token punctuation">)</span><span class="token punctuation">(</span>Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> K
           <span class="token operator">=&gt;</span> mkDecls<span class="token punctuation">(</span>Xs<span class="token punctuation">,</span>Vs<span class="token punctuation">)</span> S return<span class="token punctuation">;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> OL <span class="token operator">|</span><span class="token operator">-</span>&gt; objectClosure<span class="token punctuation">(</span>_<span class="token punctuation">,</span> EnvStack<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
     <span class="token comment">//&lt;br/&gt; // TODO(KORE): support latex annotations #1799</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>control</span><span class="token punctuation">&gt;</span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>xstack</span><span class="token punctuation">&gt;</span></span> XS <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>xstack</span><span class="token punctuation">&gt;</span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fstack</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token operator">=&gt;</span> ListItem<span class="token punctuation">(</span>fstackFrame<span class="token punctuation">(</span>Env<span class="token punctuation">,</span> K<span class="token punctuation">,</span> XS<span class="token punctuation">,</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntObj</span><span class="token punctuation">&gt;</span></span> Obj&apos; <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntObj</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span>
          <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fstack</span><span class="token punctuation">&gt;</span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntObj</span><span class="token punctuation">&gt;</span></span> Obj&apos; <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntClass</span><span class="token punctuation">&gt;</span></span> Class <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntClass</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>envStack</span><span class="token punctuation">&gt;</span></span> EnvStack <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>envStack</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntObj</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>control</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="spawn">Spawn</h2>

<p>We want to extend the semantics of <code>spawn</code> to also share the<br>
current object environment with the child thread, in addition to the<br>
current environment.  This extension will allow us to also use method<br>
invocations in the spawned statements, which will be thus looked up as<br>
expected, using dynamic method dispatch.  This lookup operation would<br>
fail if the child thread did not have access to its parent&apos;s object<br>
environment.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>thread</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> spawn S <span class="token operator">=&gt;</span> <span class="token operator">!</span>T<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntObj</span><span class="token punctuation">&gt;</span></span> Obj <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntObj</span><span class="token punctuation">&gt;</span></span>
       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>thread</span><span class="token punctuation">&gt;</span></span>
       <span class="token punctuation">(</span><span class="token punctuation">.</span>Bag <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>thread</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
               <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> S <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
               <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
               <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">&gt;</span></span> <span class="token operator">!</span>T <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">&gt;</span></span>
               <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntObj</span><span class="token punctuation">&gt;</span></span> Obj <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntObj</span><span class="token punctuation">&gt;</span></span>
             <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>thread</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>
</pre><h2 class="mume-header" id="semantics-of-the-new-kool-constructs">Semantics of the new KOOL constructs</h2>

<h2 class="mume-header" id="class-declaration">Class declaration</h2>

<p>Initially, the classes forming the program are moved into their<br>
corresponding cells:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> class Class1 extends Class2 <span class="token punctuation">{</span> S <span class="token punctuation">}</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>classes</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">(</span><span class="token punctuation">.</span>Bag <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>classData</span><span class="token punctuation">&gt;</span></span>
                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>className</span><span class="token punctuation">&gt;</span></span> Class1 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>className</span><span class="token punctuation">&gt;</span></span>
                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>baseClass</span><span class="token punctuation">&gt;</span></span> Class2 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>baseClass</span><span class="token punctuation">&gt;</span></span>
                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>declarations</span><span class="token punctuation">&gt;</span></span> S <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>declarations</span><span class="token punctuation">&gt;</span></span>
                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>classData</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>
       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>classes</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="method-declaration">Method declaration</h2>

<p>Like in SIMPLE, method names are added to the environment and bound<br>
to their code.  However, unlike in SIMPLE where each function was<br>
executed in the same environment, namely the program global<br>
environment, a method in KOOL needs to be executed into its object&apos;s<br>
environment.  Thus, methods evaluate to closures, which encapsulate<br>
their object&apos;s context (i.e., the current class and environment stack<br>
of the object) in addition to method&apos;s parameters and body.  This<br>
approach to bind method names to method closures in the environment<br>
will also allow objects to pass their methods to other objects, to<br>
dynamically change their methods by assigning them other method<br>
closures, and even to allow all these to be done from other objects.<br>
This gives the KOOL programmer a lot of power; one should use this<br>
power wisely, though, because programs can become easily hard to<br>
understand and reason about if one overuses these features.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> method F<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">(</span>Xs<span class="token punctuation">:</span>Ids<span class="token punctuation">)</span> S <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntClass</span><span class="token punctuation">&gt;</span></span> Class<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntClass</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>location</span><span class="token punctuation">&gt;</span></span> OL<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>location</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token operator">=&gt;</span> Env<span class="token punctuation">[</span>F &lt;<span class="token operator">-</span> L<span class="token punctuation">]</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Map <span class="token operator">=&gt;</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; methodClosure<span class="token punctuation">(</span>Class<span class="token punctuation">,</span>OL<span class="token punctuation">,</span>Xs<span class="token punctuation">,</span>S<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nextLoc</span><span class="token punctuation">&gt;</span></span> L <span class="token operator">=&gt;</span> L <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>nextLoc</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="new">New</h2>

<p>The semantics of <code>new</code> consists of two actions: memory<br>
allocation for the new object and execution of the corresponding<br>
constructor.  Then the created object is returned as the result of the<br>
<code>new</code> operation; the value returned by the constructor, if any,<br>
is discarded.  The current environment and object are stored onto the<br>
stack and recovered after new (according to the semantics of<br>
<code>return</code> borrowed from SIMPLE, when the statement<br>
<code>return this;</code> in the rule below is reached and evaluated),<br>
because the object creation part of <code>new</code> will destroy them.<br>
The rule below also initializes the object creation process by<br>
emptying the local environment and the current object, and allocating<br>
a location in the store where the created object will be eventually<br>
stored (this is what the <code>storeObj</code> task after the object<br>
creation task in the rule below will do&#x2014;its rule is defined<br>
shortly).  The location where the object will be stored is also made<br>
available in the <code>crntObj</code> cell, so that method closures can<br>
refer to it (see rule above).</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;envStackFrame&quot;</span> <span class="token string">&quot;(&quot;</span> <span class="token keyword keyword-Id">Id</span> <span class="token string">&quot;,&quot;</span> Map <span class="token string">&quot;)&quot;</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> new Class<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">(</span>Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> K
           <span class="token operator">=&gt;</span> create<span class="token punctuation">(</span>Class<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> storeObj <span class="token operator">~&gt;</span> Class<span class="token punctuation">(</span>Vs<span class="token punctuation">)</span><span class="token punctuation">;</span> return this<span class="token punctuation">;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nextLoc</span><span class="token punctuation">&gt;</span></span> L<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">=&gt;</span> L <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>nextLoc</span><span class="token punctuation">&gt;</span></span>
     <span class="token comment">//&lt;br/&gt; // TODO(KORE): support latex annotations #1799</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>control</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>xstack</span><span class="token punctuation">&gt;</span></span> XS <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>xstack</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntObj</span><span class="token punctuation">&gt;</span></span> Obj
                   <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntClass</span><span class="token punctuation">&gt;</span></span> Object <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntClass</span><span class="token punctuation">&gt;</span></span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>envStack</span><span class="token punctuation">&gt;</span></span> ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>Object<span class="token punctuation">,</span> <span class="token punctuation">.</span>Map<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>envStack</span><span class="token punctuation">&gt;</span></span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>location</span><span class="token punctuation">&gt;</span></span> L <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>location</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntObj</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fstack</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token operator">=&gt;</span> ListItem<span class="token punctuation">(</span>fstackFrame<span class="token punctuation">(</span>Env<span class="token punctuation">,</span> K<span class="token punctuation">,</span> XS<span class="token punctuation">,</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntObj</span><span class="token punctuation">&gt;</span></span> Obj <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntObj</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fstack</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>control</span><span class="token punctuation">&gt;</span></span>
</pre><p>The creation of a new object (the memory allocation part only) is<br>
a recursive process, requiring to first create an object for the<br>
superclass.  A memory object representation is a layered structure:<br>
for each class on the path from the instance class to the root of the<br>
hierarchy there is a layer including the memory allocated for the<br>
members (both fields and methods) of that class.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> create<span class="token punctuation">(</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> create<span class="token punctuation">(</span>Class<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">)</span>
           <span class="token operator">=&gt;</span> create<span class="token punctuation">(</span>Class1<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> setCrntClass<span class="token punctuation">(</span>Class<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> S <span class="token operator">~&gt;</span> addEnvLayer <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>className</span><span class="token punctuation">&gt;</span></span> Class <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>className</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>baseClass</span><span class="token punctuation">&gt;</span></span> Class1<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>baseClass</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>declarations</span><span class="token punctuation">&gt;</span></span> S <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>declarations</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> create<span class="token punctuation">(</span>Object<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
</pre><p>The next operation sets the current class of the current object.<br>
This is necessary to be done at each layer, because the current class<br>
of the object is enclosed as part of the method closures (see the<br>
semantics of method declarations above).</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> setCrntClass<span class="token punctuation">(</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> setCrntClass<span class="token punctuation">(</span>C<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntClass</span><span class="token punctuation">&gt;</span></span> _ <span class="token operator">=&gt;</span> C <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntClass</span><span class="token punctuation">&gt;</span></span>
</pre><p>The next operation adds a new tagged environment layer to the<br>
current object and gets ready for the next layer by clearing the<br>
environment (note that <code>create</code> expects the environment to be<br>
empty).</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;addEnvLayer&quot;</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> addEnvLayer <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntClass</span><span class="token punctuation">&gt;</span></span> Class<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntClass</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>envStack</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token operator">=&gt;</span> ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>Class<span class="token punctuation">,</span> Env<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>envStack</span><span class="token punctuation">&gt;</span></span>
</pre><p>The following operation stores the created object at the location<br>
reserved by <code>new</code>.  Note that the location reserved by<br>
<code>new</code> was temporarily stored in the <code>crntObj</code> cell<br>
precisely for this purpose.  Now that the newly created object is<br>
stored at its location and that all method closures are aware of it,<br>
the location is unnecessary and thus we delete it from the<br>
<code>crntObj</code> cell.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;storeObj&quot;</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> storeObj <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntObj</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntClass</span><span class="token punctuation">&gt;</span></span> CC <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntClass</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>envStack</span><span class="token punctuation">&gt;</span></span> ES <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>envStack</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>location</span><span class="token punctuation">&gt;</span></span> L<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>location</span><span class="token punctuation">&gt;</span></span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Bag<span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntObj</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Map <span class="token operator">=&gt;</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; objectClosure<span class="token punctuation">(</span>CC<span class="token punctuation">,</span> ES<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="self-reference">Self reference</h2>

<p>The semantics of <code>this</code> is straightforward: evaluate to the<br>
current object.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> this <span class="token operator">=&gt;</span> objectClosure<span class="token punctuation">(</span>CC<span class="token punctuation">,</span> ES<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntObj</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntClass</span><span class="token punctuation">&gt;</span></span> CC <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntClass</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>envStack</span><span class="token punctuation">&gt;</span></span> ES <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>envStack</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntObj</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="object-member-access">Object member access</h2>

<p>We can access an object member (field or method) either explicitly,<br>
using the construct <code>e.x</code>, or implicitly, using only the member<br>
name <code>x</code> directly.  The borrowed semantics of SIMPLE will<br>
already lookup a sole name in the local environment.  The first rule<br>
below reduces implicit member access to explicit access when the name<br>
cannot be found in the local environment.  There are two cases to<br>
analyze for explicit object member access, depending upon whether the<br>
object is a proper object or it is just a redirection to the parent<br>
class via the construct <code>super</code>.  In the first case, we<br>
evaluate the object expression and lookup the member starting with the<br>
current class (static scoping).  Note the use of the conditional<br>
evaluation context.  In the second case, we just lookup the member<br>
starting with the superclass of the current class.  In both cases,<br>
the <code>lookupMember</code> task eventually yields a <code>lookup(L)</code><br>
task for some appropriate location <code>L</code>, which will be further<br>
solved with the corresponding rule borrowed from SIMPLE.  Note that the<br>
current object is not altered by <code>super</code>, so future method<br>
invocations see the entire object, as needed for dynamic method dispatch.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=&gt;</span> this <span class="token punctuation">.</span> X <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env<span class="token punctuation">:</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> notBool<span class="token punctuation">(</span>X in keys<span class="token punctuation">(</span>Env<span class="token punctuation">)</span><span class="token punctuation">)</span>

  <span class="token keyword keyword-context">context</span> HOLE<span class="token punctuation">.</span>_<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token keyword keyword-requires">requires</span> <span class="token punctuation">(</span>HOLE <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K super<span class="token punctuation">)</span>

<span class="token comment">// TODO: explain how Assoc matching has been replaced with two rules here.</span>
<span class="token comment">// Maybe also improve it a bit.</span>

<span class="token comment">/*  rule objectClosure(&lt;crntClass&gt; Class:Id &lt;/crntClass&gt;
                     &lt;envStack&gt;... envStackFrame(Class,EnvC) EStack &lt;/envStack&gt;)
       . X:Id
    =&gt; lookupMember(envStackFrame(Class,EnvC) EStack, X) */</span>

  <span class="token keyword keyword-rule">rule</span> objectClosure<span class="token punctuation">(</span>Class<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span> ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>Class<span class="token punctuation">,</span>Env<span class="token punctuation">)</span><span class="token punctuation">)</span> EStack<span class="token punctuation">)</span>
       <span class="token punctuation">.</span> X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span>
    <span class="token operator">=&gt;</span> lookupMember<span class="token punctuation">(</span>ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>Class<span class="token punctuation">,</span>Env<span class="token punctuation">)</span><span class="token punctuation">)</span> EStack<span class="token punctuation">,</span> X<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> objectClosure<span class="token punctuation">(</span>Class<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>Class&apos;<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span>_<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>List<span class="token punctuation">)</span> _<span class="token punctuation">)</span>
       <span class="token punctuation">.</span> _X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span>
    <span class="token keyword keyword-requires">requires</span> Class <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K Class&apos;

<span class="token comment">/*  rule &lt;k&gt; super . X =&gt; lookupMember(EStack, X) ...&lt;/k&gt;
       &lt;crntClass&gt; Class &lt;/crntClass&gt;
       &lt;envStack&gt;... envStackFrame(Class,EnvC) EStack &lt;/envStack&gt; */</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> super <span class="token punctuation">.</span> X <span class="token operator">=&gt;</span> lookupMember<span class="token punctuation">(</span>EStack<span class="token punctuation">,</span> X<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntClass</span><span class="token punctuation">&gt;</span></span> Class<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntClass</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>envStack</span><span class="token punctuation">&gt;</span></span> ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>Class<span class="token punctuation">,</span>_<span class="token punctuation">)</span><span class="token punctuation">)</span> EStack <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>envStack</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> super <span class="token punctuation">.</span> _X <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntClass</span><span class="token punctuation">&gt;</span></span> Class <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntClass</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>envStack</span><span class="token punctuation">&gt;</span></span> ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>Class&apos;<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span>_<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>List <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>envStack</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> Class <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K Class&apos;
</pre><h2 class="mume-header" id="method-invocation">Method invocation</h2>

<p>Unlike in SIMPLE, in KOOL application was declared strict only in its<br>
second argument.  That is because we want to ensure dynamic method<br>
dispatch when the first argument is a method access.  As a<br>
consequence, we need to consider all the cases of interest for the<br>
first argument and to explicitly say what to do in each case.  In all<br>
cases except for method access in a proper object (i.e., not<br>
<code>super</code>), we want the same behavior for the first argument as<br>
if it was not in a method invocation position.  When it is a member<br>
access (the third rule below), we look it up starting with the<br>
instance class of the corresponding object.  This ensures dynamic<br>
dispatch for methods; it actually dynamically dispatches field<br>
accesses, too, which is correct in KOOL, because one can assign method<br>
closures to fields and the field appeared in a method invocation<br>
context.  The last context declaration below says that method<br>
applications or array accesses are also allowed as first argument to<br>
applications; that is because methods are allowed to return methods<br>
and arrays are allowed to hold methods in KOOL, since it is<br>
higher-order.  If that is the case, then we want to evaluate the<br>
method call or the array access.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span>X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=&gt;</span> V<span class="token punctuation">)</span><span class="token punctuation">(</span>_<span class="token punctuation">:</span>Exps<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> X <span class="token operator">|</span><span class="token operator">-</span>&gt; L <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; V<span class="token punctuation">:</span>Val <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span>X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=&gt;</span> this <span class="token punctuation">.</span> X<span class="token punctuation">)</span><span class="token punctuation">(</span>_<span class="token punctuation">:</span>Exps<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> notBool<span class="token punctuation">(</span>X in keys<span class="token punctuation">(</span>Env<span class="token punctuation">)</span><span class="token punctuation">)</span>

  <span class="token keyword keyword-context">context</span> HOLE<span class="token punctuation">.</span>_<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token keyword keyword-requires">requires</span> HOLE <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K super

  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>objectClosure<span class="token punctuation">(</span>_<span class="token punctuation">,</span> EStack<span class="token punctuation">)</span> <span class="token punctuation">.</span> X
    <span class="token operator">=&gt;</span> lookupMember<span class="token punctuation">(</span>EStack<span class="token punctuation">,</span> X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span>_<span class="token punctuation">:</span>Exps<span class="token punctuation">)</span>

<span class="token comment">/*  rule &lt;k&gt; (super . X
            =&gt; lookupMember(EStack,X))(_:Exps)...&lt;/k&gt;
       &lt;crntClass&gt; Class &lt;/crntClass&gt;
       &lt;envStack&gt;... envStackFrame(Class,_) EStack &lt;/envStack&gt; */</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span>super <span class="token punctuation">.</span> X
            <span class="token operator">=&gt;</span> lookupMember<span class="token punctuation">(</span>EStack<span class="token punctuation">,</span>X<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span>_<span class="token punctuation">:</span>Exps<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntClass</span><span class="token punctuation">&gt;</span></span> Class <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntClass</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>envStack</span><span class="token punctuation">&gt;</span></span> ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>Class<span class="token punctuation">,</span>_<span class="token punctuation">)</span><span class="token punctuation">)</span> EStack <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>envStack</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span>super <span class="token punctuation">.</span> _X<span class="token punctuation">)</span><span class="token punctuation">(</span>_<span class="token punctuation">:</span>Exps<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntClass</span><span class="token punctuation">&gt;</span></span> Class <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntClass</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>envStack</span><span class="token punctuation">&gt;</span></span> ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>Class&apos;<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span>_<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>List <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>envStack</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> Class <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K Class&apos;

  <span class="token comment">// TODO(KORE): fix getKLabel #1801</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>A<span class="token punctuation">:</span>Exp<span class="token punctuation">(</span>B<span class="token punctuation">:</span>Exps<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span>C<span class="token punctuation">:</span>Exps<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> A<span class="token punctuation">(</span>B<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> #freezerFunCall<span class="token punctuation">(</span>C<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>A<span class="token punctuation">:</span>Exp<span class="token punctuation">[</span>B<span class="token punctuation">:</span>Exps<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span>C<span class="token punctuation">:</span>Exps<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> A<span class="token punctuation">[</span>B<span class="token punctuation">]</span> <span class="token operator">~&gt;</span> #freezerFunCall<span class="token punctuation">(</span>C<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> V<span class="token punctuation">:</span>Val <span class="token operator">~&gt;</span> #freezerFunCall<span class="token punctuation">(</span>C<span class="token punctuation">:</span>Exps<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> V<span class="token punctuation">(</span>C<span class="token punctuation">)</span>
  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;#freezerFunCall&quot;</span> <span class="token string">&quot;(&quot;</span> K <span class="token string">&quot;)&quot;</span>
  <span class="token comment">/*
  context HOLE(_:Exps)
    when getKLabel(HOLE) ==K #klabel(`_(_)`) orBool getKLabel(HOLE) ==K #klabel(`_[_]`)
  */</span>
</pre><p>Eventually, each of the rules above produces a <code>lookup(L)</code><br>
task as a replacement for the method.  When that happens, we just<br>
lookup the value at location <code>L</code>:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span>lookup<span class="token punctuation">(</span>L<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> V<span class="token punctuation">)</span><span class="token punctuation">(</span>_<span class="token punctuation">:</span>Exps<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; V<span class="token punctuation">:</span>Val <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
</pre><p>The value <code>V</code> looked up above is expected to be a method closure,<br>
in which case the semantics of method application given above will<br>
apply.  Otherwise, the execution will get stuck.</p>
<h2 class="mume-header" id="instance-of">Instance Of</h2>

<p>It searches the object environment for a layer corresponding to the<br>
desired class.  It returns <code>true</code> iff it can find the class,<br>
otherwise it returns <code>false</code>; it only gets stuck when its first<br>
argument does not evaluate to an object.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> objectClosure<span class="token punctuation">(</span>_<span class="token punctuation">,</span> ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>C<span class="token punctuation">,</span>_<span class="token punctuation">)</span><span class="token punctuation">)</span> _<span class="token punctuation">)</span>
       instanceOf C <span class="token operator">=&gt;</span> <span class="token boolean">true</span>

  <span class="token keyword keyword-rule">rule</span> objectClosure<span class="token punctuation">(</span>_<span class="token punctuation">,</span> <span class="token punctuation">(</span>ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>C<span class="token punctuation">,</span>_<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>List<span class="token punctuation">)</span> _<span class="token punctuation">)</span>
       instanceOf C<span class="token string">&apos;  requires C =/=K C&apos;</span>
<span class="token comment">//TODO: remove the sort cast ::Id of C above, when sort inference bug fixed</span>

  <span class="token keyword keyword-rule">rule</span> objectClosure<span class="token punctuation">(</span>_<span class="token punctuation">,</span> <span class="token punctuation">.</span>List<span class="token punctuation">)</span> instanceOf _ <span class="token operator">=&gt;</span> <span class="token boolean">false</span>
</pre><h2 class="mume-header" id="cast">Cast</h2>

<p>In untyped KOOL, we prefer to not check the validity of casting.  In<br>
other words, any cast is allowed on any object, simply changing the<br>
current class of the object to the desired class.  The execution will<br>
get stuck later if one attempts to access a field which is not<br>
available.  Moreover, the execution may complete successfully even<br>
in the presence of invalid casts, provided that each accessed member<br>
during the current execution is, or happens to be, available.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>C<span class="token punctuation">)</span> objectClosure<span class="token punctuation">(</span>_ <span class="token punctuation">,</span> EnvStack<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> objectClosure<span class="token punctuation">(</span>C <span class="token punctuation">,</span>EnvStack<span class="token punctuation">)</span>
</pre><h2 class="mume-header" id="kool-specific-auxiliary-declarations-and-operations">KOOL-specific auxiliary declarations and operations</h2>

<p>Here we define all the auxiliary constructs used in the above<br>
KOOL-specific semantics (those used in the SIMPLE fragment<br>
have already been defined in a corresponding section above).</p>
<h2 class="mume-header" id="objects-as-lvalues">Objects as lvalues</h2>

<p>The current machinery borrowed with the semantics of SIMPLE allows us<br>
to enrich the set of lvalues, this way allowing new means to assign<br>
values to locations.  In KOOL, we want object member names to be<br>
lvalues, so that we can assign values to them using the already<br>
existing machinery.  The first rule below ensures that the object is<br>
always explicit, the evaluation context enforces the object to be<br>
evaluated, and finally the second rule initiates the lookup for the<br>
member&apos;s location based on the current class of the object.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> lvalue<span class="token punctuation">(</span>X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=&gt;</span> this <span class="token punctuation">.</span> X<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> notBool<span class="token punctuation">(</span>X in keys<span class="token punctuation">(</span>Env<span class="token punctuation">)</span><span class="token punctuation">)</span>

  <span class="token keyword keyword-context">context</span> lvalue<span class="token punctuation">(</span><span class="token punctuation">(</span>HOLE <span class="token punctuation">.</span> _<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">:</span>Exp<span class="token punctuation">)</span>

<span class="token comment">/*  rule lvalue(objectClosure(&lt;crntClass&gt; C &lt;/crntClass&gt;
                            &lt;envStack&gt;... envStackFrame(C,EnvC) EStack &lt;/envStack&gt;)
              . X
              =&gt; lookupMember(&lt;envStack&gt; envStackFrame(C,EnvC) EStack &lt;/envStack&gt;,
                              X))  */</span>
  <span class="token keyword keyword-rule">rule</span> lvalue<span class="token punctuation">(</span>objectClosure<span class="token punctuation">(</span>Class<span class="token punctuation">,</span> ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>Class<span class="token punctuation">,</span>Env<span class="token punctuation">)</span><span class="token punctuation">)</span> EStack<span class="token punctuation">)</span>
              <span class="token punctuation">.</span> X
              <span class="token operator">=&gt;</span> lookupMember<span class="token punctuation">(</span>ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>Class<span class="token punctuation">,</span>Env<span class="token punctuation">)</span><span class="token punctuation">)</span> EStack<span class="token punctuation">,</span>
                              X<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> lvalue<span class="token punctuation">(</span>objectClosure<span class="token punctuation">(</span>Class<span class="token punctuation">,</span> <span class="token punctuation">(</span>ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>Class&apos;<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span>_<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>List<span class="token punctuation">)</span> _<span class="token punctuation">)</span>
              <span class="token punctuation">.</span> _X<span class="token punctuation">)</span>
    <span class="token keyword keyword-requires">requires</span> Class <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K Class&apos;
</pre><h2 class="mume-header" id="lookup-member">Lookup member</h2>

<p>It searches for the given member in the given environment stack,<br>
starting with the most concrete class and going up in the hierarchy.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token comment">// TODO(KORE): clarify sort inferences #1803</span>
  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> lookupMember<span class="token punctuation">(</span>List<span class="token punctuation">,</span> <span class="token keyword keyword-Id">Id</span><span class="token punctuation">)</span>  <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token comment">/*
  syntax KItem ::= lookupMember(EnvStackCell,Id)  [function]
  */</span>

<span class="token comment">//  rule lookupMember(&lt;envStack&gt; envStackFrame(_, &lt;env&gt;... X|-&gt;L ...&lt;/env&gt;) ...&lt;/envStack&gt;, X)</span>
<span class="token comment">//    =&gt; lookup(L)</span>
  <span class="token keyword keyword-rule">rule</span> lookupMember<span class="token punctuation">(</span>ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>_<span class="token punctuation">,</span> X<span class="token operator">|</span><span class="token operator">-</span>&gt;L _<span class="token punctuation">)</span><span class="token punctuation">)</span> _<span class="token punctuation">,</span> X<span class="token punctuation">)</span>
    <span class="token operator">=&gt;</span> lookup<span class="token punctuation">(</span>L<span class="token punctuation">)</span>

<span class="token comment">//  rule lookupMember(&lt;envStack&gt; envStackFrame(_, &lt;env&gt; Env &lt;/env&gt;) =&gt; .List ...&lt;/envStack&gt;, X)</span>
<span class="token comment">//    when notBool(X in keys(Env))</span>
  <span class="token keyword keyword-rule">rule</span> lookupMember<span class="token punctuation">(</span>ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>_<span class="token punctuation">,</span> Env<span class="token punctuation">)</span><span class="token punctuation">)</span> Rest<span class="token punctuation">,</span> X<span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
       lookupMember<span class="token punctuation">(</span>Rest<span class="token punctuation">,</span> X<span class="token punctuation">)</span>
    <span class="token keyword keyword-requires">requires</span> notBool<span class="token punctuation">(</span>X in keys<span class="token punctuation">(</span>Env<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">//TODO: beautify the above</span>

<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>Go to <a href="#ebook-heading-lesson-2-kool-typed-dynamic">Lesson 2, KOOL typed dynamic</a>.</p>
</div></div><div id="ebook-heading-lesson-2-kool-typed-dynamic" ebook-toc-level-4 heading="Lesson 2, KOOL typed dynamic"><div><h1 class="mume-header" id="kool-typed-dynamic">KOOL &#x2014; Typed &#x2014; Dynamic</h1>

<p>Author: Grigore Ro&#x219;u (<a href="mailto:grosu@illinois.edu">grosu@illinois.edu</a>)<br>
Organization: University of Illinois at Urbana-Champaign</p>
<p>Author: Traian Florin &#x218;erb&#x103;nu&#x21B;&#x103; (<a href="mailto:traian.serbanuta@unibuc.ro">traian.serbanuta@unibuc.ro</a>)<br>
Organization: University of Bucharest</p>
<h2 class="mume-header" id="abstract">Abstract</h2>

<p>This is the <strong>K</strong> dynamic semantics of the typed KOOL language.  It is<br>
very similar to the semantics of the untyped KOOL, the difference<br>
being that we now check the typing policy dynamically.  Since we have<br>
to now declare the types of variables and methods, we adopt a syntax<br>
for those which is close to Java.  Like in the semantics of<br>
untyped KOOL, where we borrowed almost all the semantics of untyped<br>
SIMPLE, we are going to also borrow much of the semantics of<br>
dynamically typed SIMPLE here.  We will highlight the differences<br>
between the dynamically typed and the untyped KOOL as we proceed with<br>
the semantics.  In general, the type policy of the typed KOOL language<br>
is similar to that of Java.  You may find it useful to also read<br>
the discussion in the preamble of the static semantics of typed KOOL<br>
before proceeding.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> KOOL<span class="token operator">-</span>TYPED<span class="token operator">-</span>DYNAMIC<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> DOMAINS<span class="token operator">-</span>SYNTAX
</pre><h2 class="mume-header" id="syntax">Syntax</h2>

<p>Like for the untyped KOOL language, the syntax of typed KOOL extends<br>
that of typed SIMPLE with object-oriented constructs.<br>
The syntax below was produced by copying and modifying/extending the<br>
syntax of dynamically typed SIMPLE.  In fact, the only change we made<br>
to the existing syntax of dynamically typed SIMPLE was to change the<br>
strictness of the application construct like in untyped KOOL, from<br>
<code>strict</code> to <code>strict(2)</code> (because application is not<br>
strict in the first argument anymore due to dynamic method dispatch).<br>
The KOOL-specific syntactic extensions are identical to those in<br>
untyped KOOL.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Id">Id</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;Object&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token string">&quot;Main&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
</pre><h2 class="mume-header" id="types">Types</h2>

<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Type <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;void&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;int&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;bool&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;string&quot;</span>
                <span class="token operator">|</span> <span class="token keyword keyword-Id">Id</span>                              <span class="token comment">// KOOL class</span>
                <span class="token operator">|</span> Type <span class="token string">&quot;[&quot;</span> <span class="token string">&quot;]&quot;</span>
                <span class="token operator">|</span> <span class="token string">&quot;(&quot;</span> Type <span class="token string">&quot;)&quot;</span>           <span class="token punctuation">[</span><span class="token class-name">bracket</span><span class="token punctuation">]</span>
                &gt; Types <span class="token string">&quot;-&gt;&quot;</span> Type
  <span class="token comment">// TODO(KORE): drop klabel once issues #1913 are fixed</span>
  <span class="token keyword keyword-syntax">syntax</span> Types <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Type<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>   <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span>_<span class="token punctuation">:</span><span class="token punctuation">:</span>Types<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token comment">/*
  syntax Types ::= List{Type,&quot;,&quot;}
  */</span>
</pre><h2 class="mume-header" id="declarations">Declarations</h2>

<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Param <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Type <span class="token keyword keyword-Id">Id</span>
  <span class="token keyword keyword-syntax">syntax</span> Params <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Param<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>

  <span class="token keyword keyword-syntax">syntax</span> Stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Type Exps <span class="token string">&quot;;&quot;</span> <span class="token punctuation">[</span><span class="token class-name">avoid</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> Type <span class="token keyword keyword-Id">Id</span> <span class="token string">&quot;(&quot;</span> Params <span class="token string">&quot;)&quot;</span> Block    <span class="token comment">// stays like in typed SIMPLE</span>
                <span class="token operator">|</span> <span class="token string">&quot;class&quot;</span> <span class="token keyword keyword-Id">Id</span> Block                <span class="token comment">// KOOL</span>
                <span class="token operator">|</span> <span class="token string">&quot;class&quot;</span> <span class="token keyword keyword-Id">Id</span> <span class="token string">&quot;extends&quot;</span> <span class="token keyword keyword-Id">Id</span> Block   <span class="token comment">// KOOL</span>
</pre><h2 class="mume-header" id="expressions">Expressions</h2>

<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span> <span class="token operator">|</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token operator">|</span> <span class="token keyword keyword-String">String</span> <span class="token operator">|</span> <span class="token keyword keyword-Id">Id</span>
               <span class="token operator">|</span> <span class="token string">&quot;this&quot;</span>                                 <span class="token comment">// KOOL</span>
               <span class="token operator">|</span> <span class="token string">&quot;super&quot;</span>                                <span class="token comment">// KOOL</span>
               <span class="token operator">|</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span>             <span class="token punctuation">[</span><span class="token class-name">bracket</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;++&quot;</span> Exp
               <span class="token operator">|</span> Exp <span class="token string">&quot;instanceOf&quot;</span> <span class="token keyword keyword-Id">Id</span>     <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token comment">// KOOL</span>
               <span class="token operator">|</span> <span class="token string">&quot;(&quot;</span> <span class="token keyword keyword-Id">Id</span> <span class="token string">&quot;)&quot;</span> Exp          <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token comment">// KOOL  cast</span>
               <span class="token operator">|</span> <span class="token string">&quot;new&quot;</span> <span class="token keyword keyword-Id">Id</span> <span class="token string">&quot;(&quot;</span> Exps <span class="token string">&quot;)&quot;</span>   <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token comment">// KOOL</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;.&quot;</span> <span class="token keyword keyword-Id">Id</span>                             <span class="token comment">// KOOL</span>
               &gt; Exp <span class="token string">&quot;[&quot;</span> Exps <span class="token string">&quot;]&quot;</span>        <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               &gt; Exp <span class="token string">&quot;(&quot;</span> Exps <span class="token string">&quot;)&quot;</span>        <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token comment">// was strict in SIMPLE</span>
               <span class="token operator">|</span> <span class="token string">&quot;-&quot;</span> Exp                 <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;sizeOf&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span>    <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;read&quot;</span> <span class="token string">&quot;(&quot;</span> <span class="token string">&quot;)&quot;</span>
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;*&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;/&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;%&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;+&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;-&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               &gt; <span class="token class-name">non-assoc</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;&lt;&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;&lt;=&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;&gt;&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;&gt;=&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;==&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;!=&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               &gt; <span class="token string">&quot;!&quot;</span> Exp                 <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;&amp;&amp;&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;||&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               &gt; <span class="token string">&quot;spawn&quot;</span> Block
               &gt; Exp <span class="token string">&quot;=&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">right</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-syntax">syntax</span> Exps <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Exp<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>          <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> overload<span class="token punctuation">(</span>exps<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Val
  <span class="token keyword keyword-syntax">syntax</span> Vals <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Val<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>          <span class="token punctuation">[</span>overload<span class="token punctuation">(</span>exps<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h2 class="mume-header" id="statements">Statements</h2>

<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Block <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;{&quot;</span> <span class="token string">&quot;}&quot;</span>
                <span class="token operator">|</span> <span class="token string">&quot;{&quot;</span> Stmt <span class="token string">&quot;}&quot;</span>

  <span class="token keyword keyword-syntax">syntax</span> Stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Block
                <span class="token operator">|</span> Exp <span class="token string">&quot;;&quot;</span>                               <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;if&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Block <span class="token string">&quot;else&quot;</span> Block   <span class="token punctuation">[</span><span class="token class-name">avoid</span><span class="token punctuation">,</span> <span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;if&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Block                <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;while&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Block
                <span class="token operator">|</span> <span class="token string">&quot;for&quot;</span> <span class="token string">&quot;(&quot;</span> Stmt Exp <span class="token string">&quot;;&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Block  <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;print&quot;</span> <span class="token string">&quot;(&quot;</span> Exps <span class="token string">&quot;)&quot;</span> <span class="token string">&quot;;&quot;</span>              <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;return&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                      <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;return&quot;</span> <span class="token string">&quot;;&quot;</span>
                <span class="token operator">|</span> <span class="token string">&quot;try&quot;</span> Block <span class="token string">&quot;catch&quot;</span> <span class="token string">&quot;(&quot;</span> Param <span class="token string">&quot;)&quot;</span> Block
                <span class="token operator">|</span> <span class="token string">&quot;throw&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                       <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;join&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                        <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;acquire&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                     <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;release&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                     <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;rendezvous&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                  <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-syntax">syntax</span> Stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Stmt Stmt                          <span class="token punctuation">[</span><span class="token class-name">right</span><span class="token punctuation">]</span>
</pre><h2 class="mume-header" id="desugaring-macros">Desugaring macros</h2>

<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> if <span class="token punctuation">(</span>E<span class="token punctuation">)</span> S <span class="token operator">=&gt;</span> if <span class="token punctuation">(</span>E<span class="token punctuation">)</span> S else <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword keyword-rule">rule</span> for<span class="token punctuation">(</span>Start Cond<span class="token punctuation">;</span> Step<span class="token punctuation">)</span> <span class="token punctuation">{</span>S<span class="token punctuation">:</span><span class="token punctuation">:</span>Stmt<span class="token punctuation">}</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>Start while<span class="token punctuation">(</span>Cond<span class="token punctuation">)</span><span class="token punctuation">{</span>S Step<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span>
  <span class="token keyword keyword-rule">rule</span> T<span class="token punctuation">:</span><span class="token punctuation">:</span>Type E1<span class="token punctuation">:</span><span class="token punctuation">:</span>Exp<span class="token punctuation">,</span> E2<span class="token punctuation">:</span><span class="token punctuation">:</span>Exp<span class="token punctuation">,</span> Es<span class="token punctuation">:</span><span class="token punctuation">:</span>Exps<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> T E1<span class="token punctuation">;</span> T E2<span class="token punctuation">,</span> Es<span class="token punctuation">;</span>           <span class="token punctuation">[</span>anywhere<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> T<span class="token punctuation">:</span><span class="token punctuation">:</span>Type X<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=</span> E<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> T X<span class="token punctuation">;</span> X <span class="token operator">=</span> E<span class="token punctuation">;</span>                                <span class="token punctuation">[</span>anywhere<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> class C<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> S <span class="token operator">=&gt;</span> class C extends Object S                     <span class="token comment">// KOOL</span>

<span class="token keyword keyword-endmodule">endmodule</span>
</pre><h2 class="mume-header" id="semantics">Semantics</h2>

<p>We first discuss the new configuration, then we include the semantics of<br>
the constructs borrowed from SIMPLE which stay unchanged, then those<br>
whose semantics had to change, and finally the semantics of the<br>
KOOL-specific constructs.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> KOOL<span class="token operator">-</span>TYPED<span class="token operator">-</span>DYNAMIC
  <span class="token keyword keyword-imports">imports</span> KOOL<span class="token operator">-</span>TYPED<span class="token operator">-</span>DYNAMIC<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> DOMAINS
</pre><h2 class="mume-header" id="configuration">Configuration</h2>

<p>The configuration of dynamically typed KOOL is almost identical to<br>
that of its untyped variant.  The only difference is the cell<br>
<code>return</code>, inside the <code>control</code> cell, whose role is to<br>
hold the expected return type of the invoked method.  That is because<br>
we want to dynamically check that the value that a method returns has<br>
the expected type.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token comment">// the syntax declarations below are required because the sorts are</span>
  <span class="token comment">// referenced directly by a production and, because of the way KIL to KORE</span>
  <span class="token comment">// is implemented, the configuration syntax is not available yet</span>
  <span class="token comment">// should simply work once KIL is removed completely</span>
  <span class="token comment">// check other definitions for this hack as well</span>
  <span class="token keyword keyword-syntax">syntax</span> EnvCell
  <span class="token keyword keyword-syntax">syntax</span> ControlCellFragment
  <span class="token keyword keyword-syntax">syntax</span> EnvStackCell
  <span class="token keyword keyword-syntax">syntax</span> CrntObjCellFragment

  <span class="token keyword keyword-configuration">configuration</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>T</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>red<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>threads</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>orange<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>thread</span> <span class="token attr-name">multiplicity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>*<span class="token punctuation">&quot;</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Set<span class="token punctuation">&quot;</span></span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>yellow<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>green<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span>$PGM<span class="token punctuation">:</span>Stmt <span class="token operator">~&gt;</span> execute<span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
                    <span class="token comment">//&lt;br/&gt; // TODO(KORE): support latex annotations #1799</span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>control</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>cyan<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fstack</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>blue<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fstack</span><span class="token punctuation">&gt;</span></span>
                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>xstack</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>purple<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>xstack</span><span class="token punctuation">&gt;</span></span>
                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>returnType</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>LimeGreen<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> void <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>returnType</span><span class="token punctuation">&gt;</span></span>  <span class="token comment">// KOOL</span>
                      <span class="token comment">//&lt;br/&gt; // TODO(KORE): support latex annotations #1799</span>
                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntObj</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Fuchsia<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>  <span class="token comment">// KOOL</span>
                           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntClass</span><span class="token punctuation">&gt;</span></span> Object <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntClass</span><span class="token punctuation">&gt;</span></span>
                           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>envStack</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>envStack</span><span class="token punctuation">&gt;</span></span>
                           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>location</span> <span class="token attr-name">multiplicity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>?<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>location</span><span class="token punctuation">&gt;</span></span>
                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntObj</span><span class="token punctuation">&gt;</span></span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>control</span><span class="token punctuation">&gt;</span></span>
                    <span class="token comment">//&lt;br/&gt; // TODO(KORE): support latex annotations #1799</span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>violet<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>holds</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>black<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>holds</span><span class="token punctuation">&gt;</span></span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>pink<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token number">0</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">&gt;</span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>thread</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>threads</span><span class="token punctuation">&gt;</span></span>
                <span class="token comment">//&lt;br/&gt; // TODO(KORE): support latex annotations #1799</span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>white<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>busy</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>cyan<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span>Set <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>busy</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>terminated</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>red<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Set <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>terminated</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>magenta<span class="token punctuation">&quot;</span></span> <span class="token attr-name">stream</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>stdin<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>input</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>output</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>brown<span class="token punctuation">&quot;</span></span> <span class="token attr-name">stream</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>stdout<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>output</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nextLoc</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>gray<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token number">0</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>nextLoc</span><span class="token punctuation">&gt;</span></span>
                <span class="token comment">//&lt;br/&gt; // TODO(KORE): support latex annotations #1799</span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>classes</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Fuchsia<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>        <span class="token comment">// KOOL</span>
                     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>classData</span> <span class="token attr-name">multiplicity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>*<span class="token punctuation">&quot;</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Map<span class="token punctuation">&quot;</span></span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Fuchsia<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>className</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Fuchsia<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> Main <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>className</span><span class="token punctuation">&gt;</span></span>
                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>baseClass</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Fuchsia<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> Object <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>baseClass</span><span class="token punctuation">&gt;</span></span>
                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>declarations</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Fuchsia<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>declarations</span><span class="token punctuation">&gt;</span></span>
                     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>classData</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>classes</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>T</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="unchanged-semantics-from-dynamically-typed-simple">Unchanged semantics from dynamically typed SIMPLE</h2>

<p>The semantics below is taken over from dynamically typed SIMPLE<br>
unchanged.  Like for untyped KOOL, the semantics of function/method<br>
declaration and invocation, and of program initialization needs to<br>
change.  Moreover, due to subtyping, the semantics of several imported<br>
SIMPLE constructs can be made more general, such as that of the<br>
return statement, that of the assignment, and that of the exceptions.<br>
We removed all these from the imported semantics of SIMPLE below and<br>
gave their modified semantics right after, together with the extended<br>
semantics of thread spawning (which is identical to that of untyped<br>
KOOL).</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span> <span class="token operator">|</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token operator">|</span> <span class="token keyword keyword-String">String</span>
               <span class="token operator">|</span> array<span class="token punctuation">(</span>Type<span class="token punctuation">,</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Val
  <span class="token keyword keyword-syntax">syntax</span> Exps <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Vals
  <span class="token keyword keyword-syntax">syntax</span> KResult <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Val
  <span class="token keyword keyword-syntax">syntax</span> KResult <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Vals


  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> undefined<span class="token punctuation">(</span>Type<span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> T<span class="token punctuation">:</span>Type X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token operator">=&gt;</span> Env<span class="token punctuation">[</span>X &lt;<span class="token operator">-</span> L<span class="token punctuation">]</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Map <span class="token operator">=&gt;</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; undefined<span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nextLoc</span><span class="token punctuation">&gt;</span></span> L<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">=&gt;</span> L <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>nextLoc</span><span class="token punctuation">&gt;</span></span>


  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> T<span class="token punctuation">:</span>Type X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">[</span>N<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token operator">=&gt;</span> Env<span class="token punctuation">[</span>X &lt;<span class="token operator">-</span> L<span class="token punctuation">]</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Map <span class="token operator">=&gt;</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; array<span class="token punctuation">(</span>T<span class="token punctuation">,</span> L <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">,</span> N<span class="token punctuation">)</span>
                          <span class="token punctuation">(</span>L <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">(</span>L <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> N<span class="token punctuation">)</span> <span class="token operator">|</span><span class="token operator">-</span>&gt; undefined<span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nextLoc</span><span class="token punctuation">&gt;</span></span> L<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">=&gt;</span> L <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span> <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> N <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>nextLoc</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> N <span class="token operator">&gt;=</span><span class="token keyword keyword-Int">Int</span> <span class="token number">0</span>

  <span class="token keyword keyword-context">context</span> _<span class="token punctuation">:</span>Type _<span class="token punctuation">:</span><span class="token punctuation">:</span>Exp<span class="token punctuation">[</span>HOLE<span class="token punctuation">:</span><span class="token punctuation">:</span>Exps<span class="token punctuation">]</span><span class="token punctuation">;</span>


  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Id">Id</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;$1&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token string">&quot;$2&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> T<span class="token punctuation">:</span>Type X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">[</span>N1<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> N2<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token operator">=&gt;</span> T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Vs</span><span class="token punctuation">&gt;</span></span> X<span class="token punctuation">[</span>N1<span class="token punctuation">]</span><span class="token punctuation">;</span>
       <span class="token punctuation">{</span>
         T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Vs</span><span class="token punctuation">&gt;</span></span> $<span class="token number">1</span><span class="token operator">=</span>X<span class="token punctuation">;</span>
         for<span class="token punctuation">(</span>int $<span class="token number">2</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> $<span class="token number">2</span> <span class="token operator">&lt;=</span> N1 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>$<span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           T X<span class="token punctuation">[</span>N2<span class="token punctuation">,</span>Vs<span class="token punctuation">]</span><span class="token punctuation">;</span>
           $<span class="token number">1</span><span class="token punctuation">[</span>$<span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> X<span class="token punctuation">;</span>
         <span class="token punctuation">}</span>
       <span class="token punctuation">}</span>


  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=&gt;</span> V <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> X <span class="token operator">|</span><span class="token operator">-</span>&gt; L <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; V<span class="token punctuation">:</span>Val <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>


  <span class="token keyword keyword-context">context</span> <span class="token operator">++</span><span class="token punctuation">(</span>HOLE <span class="token operator">=&gt;</span> lvalue<span class="token punctuation">(</span>HOLE<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token operator">++</span>loc<span class="token punctuation">(</span>L<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> I <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; <span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">=&gt;</span> I <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>


  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">+</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> Str1 <span class="token operator">+</span> Str2 <span class="token operator">=&gt;</span> Str1 <span class="token operator">+</span><span class="token keyword keyword-String">String</span> Str2
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">-</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">*</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">*</span><span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">/</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">/</span><span class="token keyword keyword-Int">Int</span> I2 <span class="token keyword keyword-requires">requires</span> I2 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K <span class="token number">0</span>
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">%</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">%</span><span class="token keyword keyword-Int">Int</span> I2 <span class="token keyword keyword-requires">requires</span> I2 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K <span class="token number">0</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token operator">-</span> I <span class="token operator">=&gt;</span> <span class="token number">0</span> <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> I
  <span class="token keyword keyword-rule">rule</span> I1 &lt; I2 <span class="token operator">=&gt;</span> I1 &lt;<span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">&lt;=</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">&lt;=</span><span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> I1 &gt; I2 <span class="token operator">=&gt;</span> I1 &gt;<span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">&gt;=</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">&gt;=</span><span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> V1<span class="token punctuation">:</span>Val <span class="token operator">==</span> V2<span class="token punctuation">:</span>Val <span class="token operator">=&gt;</span> V1 <span class="token operator">==</span>K V2
  <span class="token keyword keyword-rule">rule</span> V1<span class="token punctuation">:</span>Val <span class="token operator">!=</span> V2<span class="token punctuation">:</span>Val <span class="token operator">=&gt;</span> V1 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K V2
  <span class="token keyword keyword-rule">rule</span> <span class="token operator">!</span> T <span class="token operator">=&gt;</span> notBool<span class="token punctuation">(</span>T<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">true</span>  <span class="token operator">&amp;&amp;</span> E <span class="token operator">=&gt;</span> E
  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">false</span> <span class="token operator">&amp;&amp;</span> _ <span class="token operator">=&gt;</span> <span class="token boolean">false</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">true</span>  <span class="token operator">||</span> _ <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">false</span> <span class="token operator">||</span> E <span class="token operator">=&gt;</span> E


  <span class="token keyword keyword-rule">rule</span> V<span class="token punctuation">:</span>Val<span class="token punctuation">[</span>N1<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> N2<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">]</span> <span class="token operator">=&gt;</span> V<span class="token punctuation">[</span>N1<span class="token punctuation">]</span><span class="token punctuation">[</span>N2<span class="token punctuation">,</span> Vs<span class="token punctuation">]</span>
    <span class="token punctuation">[</span>anywhere<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> array<span class="token punctuation">(</span>_<span class="token punctuation">:</span>Type<span class="token punctuation">,</span> L<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> M<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span><span class="token punctuation">[</span>N<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">]</span> <span class="token operator">=&gt;</span> lookup<span class="token punctuation">(</span>L <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> N<span class="token punctuation">)</span>
    <span class="token keyword keyword-requires">requires</span> N <span class="token operator">&gt;=</span><span class="token keyword keyword-Int">Int</span> <span class="token number">0</span> andBool N &lt;<span class="token keyword keyword-Int">Int</span> M  <span class="token punctuation">[</span>anywhere<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> sizeOf<span class="token punctuation">(</span>array<span class="token punctuation">(</span>_<span class="token punctuation">,</span>_<span class="token punctuation">,</span>N<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> N


  <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> nothing<span class="token punctuation">(</span>Type<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> return<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> return nothing<span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>returnType</span><span class="token punctuation">&gt;</span></span> T <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>returnType</span><span class="token punctuation">&gt;</span></span>


  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> read<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> I <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span><span class="token punctuation">&gt;</span></span> ListItem<span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>List <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>input</span><span class="token punctuation">&gt;</span></span>


  <span class="token keyword keyword-context">context</span> <span class="token punctuation">(</span>HOLE <span class="token operator">=&gt;</span> lvalue<span class="token punctuation">(</span>HOLE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> _


  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span> S <span class="token punctuation">}</span> <span class="token operator">=&gt;</span> S <span class="token operator">~&gt;</span> setEnv<span class="token punctuation">(</span>Env<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>


  <span class="token keyword keyword-rule">rule</span> S1<span class="token punctuation">:</span>Stmt S2<span class="token punctuation">:</span>Stmt <span class="token operator">=&gt;</span> S1 <span class="token operator">~&gt;</span> S2


  <span class="token keyword keyword-rule">rule</span> _<span class="token punctuation">:</span>Val<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K


  <span class="token keyword keyword-rule">rule</span> if <span class="token punctuation">(</span> <span class="token boolean">true</span><span class="token punctuation">)</span> S else _ <span class="token operator">=&gt;</span> S
  <span class="token keyword keyword-rule">rule</span> if <span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> _ else S <span class="token operator">=&gt;</span> S


  <span class="token keyword keyword-rule">rule</span> while <span class="token punctuation">(</span>E<span class="token punctuation">)</span> S <span class="token operator">=&gt;</span> if <span class="token punctuation">(</span>E<span class="token punctuation">)</span> <span class="token punctuation">{</span>S while<span class="token punctuation">(</span>E<span class="token punctuation">)</span>S<span class="token punctuation">}</span>


  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> print<span class="token punctuation">(</span>V<span class="token punctuation">:</span>Val<span class="token punctuation">,</span> Es <span class="token operator">=&gt;</span> Es<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>output</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>List <span class="token operator">=&gt;</span> ListItem<span class="token punctuation">(</span>V<span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>output</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> typeOf<span class="token punctuation">(</span>V<span class="token punctuation">)</span> <span class="token operator">==</span>K int orBool typeOf<span class="token punctuation">(</span>V<span class="token punctuation">)</span> <span class="token operator">==</span>K string
  <span class="token keyword keyword-rule">rule</span> print<span class="token punctuation">(</span><span class="token punctuation">.</span>Vals<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K


  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>thread</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span>K<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>holds</span><span class="token punctuation">&gt;</span></span>H<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>holds</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">&gt;</span></span>T<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>thread</span><span class="token punctuation">&gt;</span></span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Bag<span class="token punctuation">)</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>busy</span><span class="token punctuation">&gt;</span></span> Busy <span class="token operator">=&gt;</span> Busy <span class="token operator">-</span>Set keys<span class="token punctuation">(</span>H<span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>busy</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>terminated</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Set <span class="token operator">=&gt;</span> SetItem<span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>terminated</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> join T<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>terminated</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> SetItem<span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>terminated</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> acquire V<span class="token punctuation">:</span>Val<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>holds</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Map <span class="token operator">=&gt;</span> V <span class="token operator">|</span><span class="token operator">-</span>&gt; <span class="token number">0</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>holds</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>busy</span><span class="token punctuation">&gt;</span></span> Busy <span class="token punctuation">(</span><span class="token punctuation">.</span>Set <span class="token operator">=&gt;</span> SetItem<span class="token punctuation">(</span>V<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>busy</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> <span class="token punctuation">(</span>notBool<span class="token punctuation">(</span>V in Busy<span class="token punctuation">:</span>Set<span class="token punctuation">)</span><span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> acquire V<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>holds</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> V<span class="token punctuation">:</span>Val <span class="token operator">|</span><span class="token operator">-</span>&gt; <span class="token punctuation">(</span>N<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">=&gt;</span> N <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>holds</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> release V<span class="token punctuation">:</span>Val<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>holds</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> V <span class="token operator">|</span><span class="token operator">-</span>&gt; <span class="token punctuation">(</span>N <span class="token operator">=&gt;</span> N<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>holds</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> N &gt;<span class="token keyword keyword-Int">Int</span> <span class="token number">0</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> release V<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>holds</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> V<span class="token punctuation">:</span>Val <span class="token operator">|</span><span class="token operator">-</span>&gt; <span class="token number">0</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Map <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>holds</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>busy</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> SetItem<span class="token punctuation">(</span>V<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Set <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>busy</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> rendezvous V<span class="token punctuation">:</span>Val<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> rendezvous V<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="unchanged-auxiliary-operations-from-dynamically-typed-simple">Unchanged auxiliary operations from dynamically typed SIMPLE</h2>

<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> mkDecls<span class="token punctuation">(</span>Params<span class="token punctuation">,</span>Vals<span class="token punctuation">)</span>  <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> mkDecls<span class="token punctuation">(</span><span class="token punctuation">(</span>T<span class="token punctuation">:</span>Type X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span> Ps<span class="token punctuation">:</span>Params<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>V<span class="token punctuation">:</span>Val<span class="token punctuation">,</span> Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token operator">=&gt;</span> T X<span class="token operator">=</span>V<span class="token punctuation">;</span> mkDecls<span class="token punctuation">(</span>Ps<span class="token punctuation">,</span>Vs<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> mkDecls<span class="token punctuation">(</span><span class="token punctuation">.</span>Params<span class="token punctuation">,</span><span class="token punctuation">.</span>Vals<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> lookup<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> lookup<span class="token punctuation">(</span>L<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> V <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; V<span class="token punctuation">:</span>Val <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> setEnv<span class="token punctuation">(</span>Map<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> setEnv<span class="token punctuation">(</span>Env<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> _ <span class="token operator">=&gt;</span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>setEnv<span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> setEnv<span class="token punctuation">(</span>_<span class="token punctuation">)</span>

  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> lvalue<span class="token punctuation">(</span>K<span class="token punctuation">)</span>
  <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> loc<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> lvalue<span class="token punctuation">(</span>X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=&gt;</span> loc<span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> X <span class="token operator">|</span><span class="token operator">-</span>&gt; L<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-context">context</span> lvalue<span class="token punctuation">(</span>_<span class="token punctuation">:</span><span class="token punctuation">:</span>Exp<span class="token punctuation">[</span>HOLE<span class="token punctuation">:</span><span class="token punctuation">:</span>Exps<span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-context">context</span> lvalue<span class="token punctuation">(</span>HOLE<span class="token punctuation">:</span><span class="token punctuation">:</span>Exp<span class="token punctuation">[</span>_<span class="token punctuation">:</span><span class="token punctuation">:</span>Exps<span class="token punctuation">]</span><span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> lvalue<span class="token punctuation">(</span>lookup<span class="token punctuation">(</span>L<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> loc<span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">)</span>

  <span class="token keyword keyword-syntax">syntax</span> Type <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Type <span class="token string">&quot;&lt;&quot;</span> Vals <span class="token string">&quot;&gt;&quot;</span>  <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> T<span class="token punctuation">:</span>Type<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">_,Vs:</span>Vals</span><span class="token punctuation">&gt;</span></span> <span class="token operator">=&gt;</span> T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Vs</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> T<span class="token punctuation">:</span>Type<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>.Vals</span><span class="token punctuation">&gt;</span></span> <span class="token operator">=&gt;</span> T

  <span class="token keyword keyword-syntax">syntax</span> Map <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;...&quot;</span> <span class="token keyword keyword-Int">Int</span> <span class="token string">&quot;|-&gt;&quot;</span> K <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> N<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>M <span class="token operator">|</span><span class="token operator">-</span>&gt; _ <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Map  <span class="token keyword keyword-requires">requires</span> N &gt;<span class="token keyword keyword-Int">Int</span> M
  <span class="token keyword keyword-rule">rule</span> N<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>M <span class="token operator">|</span><span class="token operator">-</span>&gt; K <span class="token operator">=&gt;</span> N <span class="token operator">|</span><span class="token operator">-</span>&gt; K <span class="token punctuation">(</span>N <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>M <span class="token operator">|</span><span class="token operator">-</span>&gt; K  <span class="token keyword keyword-requires">requires</span> N <span class="token operator">&lt;=</span><span class="token keyword keyword-Int">Int</span> M

  <span class="token keyword keyword-syntax">syntax</span> Type <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> typeOf<span class="token punctuation">(</span>K<span class="token punctuation">)</span>  <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> typeOf<span class="token punctuation">(</span>_<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> int
  <span class="token keyword keyword-rule">rule</span> typeOf<span class="token punctuation">(</span>_<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> bool
  <span class="token keyword keyword-rule">rule</span> typeOf<span class="token punctuation">(</span>_<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> string
  <span class="token keyword keyword-rule">rule</span> typeOf<span class="token punctuation">(</span>array<span class="token punctuation">(</span>T<span class="token punctuation">,</span>_<span class="token punctuation">,</span>_<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> typeOf<span class="token punctuation">(</span>undefined<span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> T
  <span class="token keyword keyword-rule">rule</span> typeOf<span class="token punctuation">(</span>nothing<span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> T

  <span class="token keyword keyword-syntax">syntax</span> Types <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> getTypes<span class="token punctuation">(</span>Params<span class="token punctuation">)</span>  <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> getTypes<span class="token punctuation">(</span>T<span class="token punctuation">:</span>Type _<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> T<span class="token punctuation">,</span> <span class="token punctuation">.</span>Types
  <span class="token keyword keyword-rule">rule</span> getTypes<span class="token punctuation">(</span>T<span class="token punctuation">:</span>Type _<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span> P<span class="token punctuation">,</span> Ps<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> T<span class="token punctuation">,</span> getTypes<span class="token punctuation">(</span>P<span class="token punctuation">,</span>Ps<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> getTypes<span class="token punctuation">(</span><span class="token punctuation">.</span>Params<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> void<span class="token punctuation">,</span> <span class="token punctuation">.</span>Types
</pre><h2 class="mume-header" id="changes-to-the-existing-dynamically-typed-simple-semantics">Changes to the existing dynamically typed SIMPLE semantics</h2>

<p>We extend/change the semantics of several SIMPLE constructs in order<br>
to take advantage of the richer KOOL semantic infrastructure and thus<br>
get more from the existing SIMPLE constructs.</p>
<h2 class="mume-header" id="program-initialization">Program initialization</h2>

<p>Like in untyped KOOL.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;execute&quot;</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> execute <span class="token operator">=&gt;</span> new Main<span class="token punctuation">(</span><span class="token punctuation">.</span>Exps<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="method-application">Method application</h2>

<p>The only change to untyped KOOL&apos;s values is that method closures are<br>
now typed (their first argument holds their type):</p>
<pre data-role="codeBlock" data-info="k" class="language-k"> <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> objectClosure<span class="token punctuation">(</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span>List<span class="token punctuation">)</span>
              <span class="token operator">|</span> methodClosure<span class="token punctuation">(</span>Type<span class="token punctuation">,</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span>Params<span class="token punctuation">,</span>Stmt<span class="token punctuation">)</span>
</pre><p>The type held by a method clossure will be the entire type of the<br>
method, not only its result type like the lambda-closure of typed<br>
SIMPLE.  The reason for this change comes from the the need to<br>
dynamically upcast values when passed to contexts where values of<br>
superclass types are expected; since we want method closures to be<br>
first-class-citizen values in our language, we have to be able to<br>
dynamically upcast them, and in order to do that elegantly it is<br>
convenient to store the entire ``current type&apos;&apos; of the method closure<br>
instead of just its result type.  Note that this was unnecessary in<br>
the semantics of the dynamically typed SIMPLE language.</p>
<p>Method closure application needs to also set a new return type in<br>
the <code>return</code> cell, like in dynamically typed SIMPLE, in order<br>
for the values returned by its body to be checked against the return<br>
type of the method.  To do this correctly, we also need to stack the<br>
current status of the <code>return</code> cell and then pop it when the<br>
method returns.  We have to do the same with the current object<br>
environment, so we group them together in the stack frame.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> fstackFrame<span class="token punctuation">(</span>Map<span class="token punctuation">,</span> K<span class="token punctuation">,</span> List<span class="token punctuation">,</span> Type<span class="token punctuation">,</span> K<span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> methodClosure<span class="token punctuation">(</span>_<span class="token operator">-</span>&gt;T<span class="token punctuation">,</span>Class<span class="token punctuation">,</span>OL<span class="token punctuation">,</span>Ps<span class="token punctuation">,</span>S<span class="token punctuation">)</span><span class="token punctuation">(</span>Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> K
           <span class="token operator">=&gt;</span> mkDecls<span class="token punctuation">(</span>Ps<span class="token punctuation">,</span>Vs<span class="token punctuation">)</span> S return<span class="token punctuation">;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> OL <span class="token operator">|</span><span class="token operator">-</span>&gt; objectClosure<span class="token punctuation">(</span>_<span class="token punctuation">,</span> EStack<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
     <span class="token comment">//&lt;br/&gt; // TODO(KORE): support latex annotations #1799</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>control</span><span class="token punctuation">&gt;</span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fstack</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token operator">=&gt;</span> ListItem<span class="token punctuation">(</span>fstackFrame<span class="token punctuation">(</span>Env<span class="token punctuation">,</span> K<span class="token punctuation">,</span> XS<span class="token punctuation">,</span> T<span class="token string">&apos;, &lt;crntObj&gt; Obj&apos;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntObj</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fstack</span><span class="token punctuation">&gt;</span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>xstack</span><span class="token punctuation">&gt;</span></span> XS <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>xstack</span><span class="token punctuation">&gt;</span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>returnType</span><span class="token punctuation">&gt;</span></span> T&apos; <span class="token operator">=&gt;</span> T <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>returnType</span><span class="token punctuation">&gt;</span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntObj</span><span class="token punctuation">&gt;</span></span> Obj&apos; <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntClass</span><span class="token punctuation">&gt;</span></span> Class <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntClass</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>envStack</span><span class="token punctuation">&gt;</span></span> EStack <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>envStack</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntObj</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>control</span><span class="token punctuation">&gt;</span></span>
</pre><p>At method return, we have to check that the type of the returned<br>
value is a subtype of the expected return type.  Moreover, if that is<br>
the case, then we also upcast the returned value to one of the<br>
expected type.  The computation item <code>unsafeCast(V,T)</code> changes<br>
the typeof <code>V</code> to <code>T</code> without any additional checks; however, it only<br>
does it when <code>V</code> is an object or a method, otherwise it returns <code>V</code><br>
unchanged.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> return V<span class="token punctuation">:</span>Val<span class="token punctuation">;</span> <span class="token operator">~&gt;</span> _
           <span class="token operator">=&gt;</span> subtype<span class="token punctuation">(</span>typeOf<span class="token punctuation">(</span>V<span class="token punctuation">)</span><span class="token punctuation">,</span> T<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> <span class="token boolean">true</span><span class="token operator">?</span> <span class="token operator">~&gt;</span> unsafeCast<span class="token punctuation">(</span>V<span class="token punctuation">,</span> T<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> K
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>control</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fstack</span><span class="token punctuation">&gt;</span></span> ListItem<span class="token punctuation">(</span>fstackFrame<span class="token punctuation">(</span>Env<span class="token punctuation">,</span> K<span class="token punctuation">,</span> XS<span class="token punctuation">,</span> RT<span class="token punctuation">,</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntObj</span><span class="token punctuation">&gt;</span></span> CO <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntObj</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>List <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fstack</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>xstack</span><span class="token punctuation">&gt;</span></span> _ <span class="token operator">=&gt;</span> XS <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>xstack</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>returnType</span><span class="token punctuation">&gt;</span></span> T<span class="token punctuation">:</span>Type <span class="token operator">=&gt;</span> RT <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>returnType</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntObj</span><span class="token punctuation">&gt;</span></span> _ <span class="token operator">=&gt;</span> CO <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntObj</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>control</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> _ <span class="token operator">=&gt;</span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="assignment">Assignment</h2>

<p>Typed KOOL allows to assign subtype instance values to supertype<br>
lvalues.  The semantics of assignment below is similar in spirit to<br>
dynamically typed SIMPLE&apos;s, but a check is performed that the assigned<br>
value&apos;s type is a subtype of the location&apos;s type.  If that is the<br>
case, then the assigned value is returned as a result and stored, but<br>
it is upcast appropriately first, so the context will continue to see<br>
a value of the expected type of the location.  Note that the type of a<br>
location is implicit in the type of its contents and it never changes<br>
during the execution of a program; its type is assigned when the<br>
location is allocated and initialized, and then only type-preserving<br>
values are allowed to be stored in each location.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> loc<span class="token punctuation">(</span>L<span class="token punctuation">)</span> <span class="token operator">=</span> V<span class="token punctuation">:</span>Val
           <span class="token operator">=&gt;</span> subtype<span class="token punctuation">(</span>typeOf<span class="token punctuation">(</span>V<span class="token punctuation">)</span><span class="token punctuation">,</span>typeOf<span class="token punctuation">(</span>V&apos;<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">~&gt;</span> <span class="token boolean">true</span><span class="token operator">?</span>
              <span class="token operator">~&gt;</span> unsafeCast<span class="token punctuation">(</span>V<span class="token punctuation">,</span> typeOf<span class="token punctuation">(</span>V&apos;<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; <span class="token punctuation">(</span>V<span class="token string">&apos; =&gt; unsafeCast(V, typeOf(V&apos;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="typed-exceptions">Typed exceptions</h2>

<p>Exceptions are propagated now until a catch that can handle them is<br>
encountered.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> xstackFrame<span class="token punctuation">(</span>Param<span class="token punctuation">,</span> Stmt<span class="token punctuation">,</span> K<span class="token punctuation">,</span> Map<span class="token punctuation">,</span> K<span class="token punctuation">)</span>
  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;popx&quot;</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span>try S1 catch<span class="token punctuation">(</span>P<span class="token punctuation">)</span> S2 <span class="token operator">=&gt;</span> S1 <span class="token operator">~&gt;</span> popx<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>control</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>xstack</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token operator">=&gt;</span> ListItem<span class="token punctuation">(</span>xstackFrame<span class="token punctuation">(</span>P<span class="token punctuation">,</span> S2<span class="token punctuation">,</span> K<span class="token punctuation">,</span> Env<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>xstack</span><span class="token punctuation">&gt;</span></span>
         C
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>control</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> popx <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>xstack</span><span class="token punctuation">&gt;</span></span> ListItem<span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>List <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>xstack</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> throw V<span class="token punctuation">:</span>Val<span class="token punctuation">;</span> <span class="token operator">~&gt;</span> _
        <span class="token operator">=&gt;</span> if <span class="token punctuation">(</span>subtype<span class="token punctuation">(</span>typeOf<span class="token punctuation">(</span>V<span class="token punctuation">)</span><span class="token punctuation">,</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> T X <span class="token operator">=</span> V<span class="token punctuation">;</span> S2 <span class="token punctuation">}</span> else <span class="token punctuation">{</span> throw V<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token operator">~&gt;</span> K
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>control</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>xstack</span><span class="token punctuation">&gt;</span></span> ListItem<span class="token punctuation">(</span>xstackFrame<span class="token punctuation">(</span>T<span class="token punctuation">:</span>Type X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span> S2<span class="token punctuation">,</span> K<span class="token punctuation">,</span> Env<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>List <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>xstack</span><span class="token punctuation">&gt;</span></span>
         <span class="token punctuation">(</span>_ <span class="token operator">=&gt;</span> C<span class="token punctuation">)</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>control</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> _ <span class="token operator">=&gt;</span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="spawn">Spawn</h2>

<p>Like in untyped KOOL.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>thread</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> spawn S <span class="token operator">=&gt;</span> <span class="token operator">!</span>T<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntObj</span><span class="token punctuation">&gt;</span></span> Obj <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntObj</span><span class="token punctuation">&gt;</span></span>
       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>thread</span><span class="token punctuation">&gt;</span></span>
       <span class="token punctuation">(</span><span class="token punctuation">.</span>Bag <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>thread</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
               <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> S <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
               <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
               <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">&gt;</span></span> <span class="token operator">!</span>T <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">&gt;</span></span>
               <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntObj</span><span class="token punctuation">&gt;</span></span> Obj <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntObj</span><span class="token punctuation">&gt;</span></span>
             <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>thread</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>
</pre><h2 class="mume-header" id="semantics-of-the-new-kool-constructs">Semantics of the new KOOL constructs</h2>

<h2 class="mume-header" id="class-declaration">Class declaration</h2>

<p>Like in untyped KOOL.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> class Class1 extends Class2 <span class="token punctuation">{</span> S <span class="token punctuation">}</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>classes</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">(</span><span class="token punctuation">.</span>Bag <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>classData</span><span class="token punctuation">&gt;</span></span>
                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>className</span><span class="token punctuation">&gt;</span></span> Class1 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>className</span><span class="token punctuation">&gt;</span></span>
                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>baseClass</span><span class="token punctuation">&gt;</span></span> Class2 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>baseClass</span><span class="token punctuation">&gt;</span></span>
                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>declarations</span><span class="token punctuation">&gt;</span></span> S <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>declarations</span><span class="token punctuation">&gt;</span></span>
                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>classData</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>
       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>classes</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="method-declaration">Method declaration</h2>

<p>Methods are now typed and we need to store their types in their<br>
closures, so that their type contract can be checked at invocation<br>
time.  The rule below is conceptually similar to that of untyped KOOL;<br>
the only difference is the addition of the types.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> T<span class="token punctuation">:</span>Type F<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">(</span>Ps<span class="token punctuation">:</span>Params<span class="token punctuation">)</span> S <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntClass</span><span class="token punctuation">&gt;</span></span> C <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntClass</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>location</span><span class="token punctuation">&gt;</span></span> OL <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>location</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token operator">=&gt;</span> Env<span class="token punctuation">[</span>F &lt;<span class="token operator">-</span> L<span class="token punctuation">]</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Map <span class="token operator">=&gt;</span> L<span class="token operator">|</span><span class="token operator">-</span>&gt;methodClosure<span class="token punctuation">(</span>getTypes<span class="token punctuation">(</span>Ps<span class="token punctuation">)</span><span class="token operator">-</span>&gt;T<span class="token punctuation">,</span>C<span class="token punctuation">,</span>OL<span class="token punctuation">,</span>Ps<span class="token punctuation">,</span>S<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nextLoc</span><span class="token punctuation">&gt;</span></span> L <span class="token operator">=&gt;</span> L <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>nextLoc</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="new">New</h2>

<p>The semantics of <code>new</code> in dynamically typed KOOL is also<br>
similar to that in untyped KOOL, the main difference being the<br>
management of the return types.  Indeed, when a new object is created<br>
we also have to stack the current type in the <code>return</code> cell in<br>
order to be recovered after the creation of the new object.  Only the<br>
first rule below needs to be changed; the others are identical to<br>
those in untyped KOOL.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> envStackFrame<span class="token punctuation">(</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span> Map<span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> new Class<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">(</span>Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> K
           <span class="token operator">=&gt;</span> create<span class="token punctuation">(</span>Class<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> <span class="token punctuation">(</span>storeObj <span class="token operator">~&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>Class<span class="token punctuation">(</span>Vs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> return this<span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nextLoc</span><span class="token punctuation">&gt;</span></span> L<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">=&gt;</span> L <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> <span class="token number">1</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>nextLoc</span><span class="token punctuation">&gt;</span></span>
     <span class="token comment">//&lt;br/&gt; // TODO(KORE): support latex annotations #1799</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>control</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>xstack</span><span class="token punctuation">&gt;</span></span> XS <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>xstack</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntObj</span><span class="token punctuation">&gt;</span></span> Obj
                   <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntClass</span><span class="token punctuation">&gt;</span></span> Object <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntClass</span><span class="token punctuation">&gt;</span></span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>envStack</span><span class="token punctuation">&gt;</span></span> ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>Object<span class="token punctuation">,</span> <span class="token punctuation">.</span>Map<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>envStack</span><span class="token punctuation">&gt;</span></span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>location</span><span class="token punctuation">&gt;</span></span> L <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>location</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntObj</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>returnType</span><span class="token punctuation">&gt;</span></span> T <span class="token operator">=&gt;</span> Class <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>returnType</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fstack</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token operator">=&gt;</span> ListItem<span class="token punctuation">(</span>fstackFrame<span class="token punctuation">(</span>Env<span class="token punctuation">,</span> K<span class="token punctuation">,</span> XS<span class="token punctuation">,</span> T<span class="token punctuation">,</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntObj</span><span class="token punctuation">&gt;</span></span>Obj<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntObj</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fstack</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>control</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> create<span class="token punctuation">(</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> create<span class="token punctuation">(</span>Class<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">)</span>
           <span class="token operator">=&gt;</span> create<span class="token punctuation">(</span>Class1<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> setCrntClass<span class="token punctuation">(</span>Class<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> S <span class="token operator">~&gt;</span> addEnvLayer <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>className</span><span class="token punctuation">&gt;</span></span> Class <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>className</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>baseClass</span><span class="token punctuation">&gt;</span></span> Class1<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>baseClass</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>declarations</span><span class="token punctuation">&gt;</span></span> S <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>declarations</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> create<span class="token punctuation">(</span>Object<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> setCrntClass<span class="token punctuation">(</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> setCrntClass<span class="token punctuation">(</span>C<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntClass</span><span class="token punctuation">&gt;</span></span> _ <span class="token operator">=&gt;</span> C <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntClass</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;addEnvLayer&quot;</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> addEnvLayer <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntClass</span><span class="token punctuation">&gt;</span></span> Class<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntClass</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>envStack</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token operator">=&gt;</span> ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>Class<span class="token punctuation">,</span> Env<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>envStack</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;storeObj&quot;</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> storeObj <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntObj</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntClass</span><span class="token punctuation">&gt;</span></span> Class <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntClass</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>envStack</span><span class="token punctuation">&gt;</span></span> EStack <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>envStack</span><span class="token punctuation">&gt;</span></span>
         <span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>location</span><span class="token punctuation">&gt;</span></span> L<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>location</span><span class="token punctuation">&gt;</span></span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Bag<span class="token punctuation">)</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntObj</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Map <span class="token operator">=&gt;</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; objectClosure<span class="token punctuation">(</span>Class<span class="token punctuation">,</span> EStack<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="self-reference">Self reference</h2>

<p>Like in untyped KOOL.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> this <span class="token operator">=&gt;</span> objectClosure<span class="token punctuation">(</span>Class<span class="token punctuation">,</span> EStack<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntObj</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntClass</span><span class="token punctuation">&gt;</span></span> Class <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntClass</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>envStack</span><span class="token punctuation">&gt;</span></span> EStack <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>envStack</span><span class="token punctuation">&gt;</span></span>
         <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntObj</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="object-member-access">Object member access</h2>

<p>Like in untyped KOOL.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=&gt;</span> this <span class="token punctuation">.</span> X <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env<span class="token punctuation">:</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> notBool<span class="token punctuation">(</span>X in keys<span class="token punctuation">(</span>Env<span class="token punctuation">)</span><span class="token punctuation">)</span>

  <span class="token keyword keyword-context">context</span> HOLE <span class="token punctuation">.</span> _<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token keyword keyword-requires">requires</span> <span class="token punctuation">(</span>HOLE <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K super<span class="token punctuation">)</span>

<span class="token comment">/*  rule objectClosure(&lt;crntObj&gt; &lt;crntClass&gt; Class:Id &lt;/crntClass&gt;
                     &lt;envStack&gt;... ListItem((Class,EnvC:EnvCell)) EStack &lt;/envStack&gt; &lt;/crntObj&gt;)
       . X:Id
    =&gt; lookupMember(&lt;envStack&gt; ListItem((Class,EnvC)) EStack &lt;/envStack&gt;, X) */</span>
  <span class="token keyword keyword-rule">rule</span> objectClosure<span class="token punctuation">(</span>Class<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span>
                     ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>Class<span class="token punctuation">,</span>Env<span class="token punctuation">)</span><span class="token punctuation">)</span> EStack<span class="token punctuation">)</span>
       <span class="token punctuation">.</span> X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span>
    <span class="token operator">=&gt;</span> lookupMember<span class="token punctuation">(</span>ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>Class<span class="token punctuation">,</span>Env<span class="token punctuation">)</span><span class="token punctuation">)</span> EStack<span class="token punctuation">,</span> X<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> objectClosure<span class="token punctuation">(</span>Class<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span>
                     <span class="token punctuation">(</span>ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>Class&apos;<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span>_<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>List<span class="token punctuation">)</span> _EStack<span class="token punctuation">)</span>
       <span class="token punctuation">.</span> _X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span>
    <span class="token keyword keyword-requires">requires</span> Class <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K Class&apos;

<span class="token comment">/*  rule &lt;k&gt; super . X =&gt; lookupMember(&lt;envStack&gt;EStack&lt;/envStack&gt;, X) ...&lt;/k&gt;
       &lt;crntClass&gt; Class &lt;/crntClass&gt;
       &lt;envStack&gt;... ListItem((Class,EnvC:EnvCell)) EStack &lt;/envStack&gt; */</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> super <span class="token punctuation">.</span> X <span class="token operator">=&gt;</span> lookupMember<span class="token punctuation">(</span>EStack<span class="token punctuation">,</span> X<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntClass</span><span class="token punctuation">&gt;</span></span> Class<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntClass</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>envStack</span><span class="token punctuation">&gt;</span></span> ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>Class<span class="token punctuation">,</span>_<span class="token punctuation">)</span><span class="token punctuation">)</span> EStack <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>envStack</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> super <span class="token punctuation">.</span> _X <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntClass</span><span class="token punctuation">&gt;</span></span> Class<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntClass</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>envStack</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span>ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>Class&apos;<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span>_<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>List<span class="token punctuation">)</span> _EStack <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>envStack</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> Class <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K Class&apos;
</pre><h2 class="mume-header" id="method-invocation">Method invocation</h2>

<p>The method lookup is the same as in untyped KOOL.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span>X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=&gt;</span> V<span class="token punctuation">)</span><span class="token punctuation">(</span>_<span class="token punctuation">:</span>Exps<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> X <span class="token operator">|</span><span class="token operator">-</span>&gt; L <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; V<span class="token punctuation">:</span>Val <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span>X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=&gt;</span> this <span class="token punctuation">.</span> X<span class="token punctuation">)</span><span class="token punctuation">(</span>_<span class="token punctuation">:</span>Exps<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> notBool<span class="token punctuation">(</span>X in keys<span class="token punctuation">(</span>Env<span class="token punctuation">)</span><span class="token punctuation">)</span>

  <span class="token keyword keyword-context">context</span> HOLE<span class="token punctuation">.</span>_<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token keyword keyword-requires">requires</span> HOLE <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K super

  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>objectClosure<span class="token punctuation">(</span>_<span class="token punctuation">,</span> EStack<span class="token punctuation">)</span> <span class="token punctuation">.</span> X
    <span class="token operator">=&gt;</span> lookupMember<span class="token punctuation">(</span>EStack<span class="token punctuation">,</span> X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span>_<span class="token punctuation">:</span>Exps<span class="token punctuation">)</span>

<span class="token comment">/*  rule &lt;k&gt; (super . X
            =&gt; lookupMember(&lt;envStack&gt;EStack&lt;/envStack&gt;,X))(_:Exps)...&lt;/k&gt;
       &lt;crntClass&gt; Class &lt;/crntClass&gt;
       &lt;envStack&gt;... ListItem((Class,_)) EStack &lt;/envStack&gt; */</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span>super <span class="token punctuation">.</span> X
            <span class="token operator">=&gt;</span> lookupMember<span class="token punctuation">(</span>EStack<span class="token punctuation">,</span>X<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span>_<span class="token punctuation">:</span>Exps<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntClass</span><span class="token punctuation">&gt;</span></span> Class<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntClass</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>envStack</span><span class="token punctuation">&gt;</span></span> ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>Class<span class="token punctuation">,</span>_<span class="token punctuation">)</span><span class="token punctuation">)</span> EStack <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>envStack</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span>super <span class="token punctuation">.</span> _X<span class="token punctuation">)</span><span class="token punctuation">(</span>_<span class="token punctuation">:</span>Exps<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>crntClass</span><span class="token punctuation">&gt;</span></span> Class<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>crntClass</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>envStack</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span>ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>Class&apos;<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span>_<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>List<span class="token punctuation">)</span> _EStack <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>envStack</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> Class <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K Class&apos;

  <span class="token comment">// TODO(KORE): fix getKLabel #1801</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>A<span class="token punctuation">:</span>Exp<span class="token punctuation">(</span>B<span class="token punctuation">:</span>Exps<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span>C<span class="token punctuation">:</span>Exps<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> A<span class="token punctuation">(</span>B<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> #freezerFunCall<span class="token punctuation">(</span>C<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>A<span class="token punctuation">:</span>Exp<span class="token punctuation">[</span>B<span class="token punctuation">:</span>Exps<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span>C<span class="token punctuation">:</span>Exps<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> A<span class="token punctuation">[</span>B<span class="token punctuation">]</span> <span class="token operator">~&gt;</span> #freezerFunCall<span class="token punctuation">(</span>C<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> V<span class="token punctuation">:</span>Val <span class="token operator">~&gt;</span> #freezerFunCall<span class="token punctuation">(</span>C<span class="token punctuation">:</span>Exps<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> V<span class="token punctuation">(</span>C<span class="token punctuation">)</span>
  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;#freezerFunCall&quot;</span> <span class="token string">&quot;(&quot;</span> K <span class="token string">&quot;)&quot;</span>
  <span class="token comment">/*
  context HOLE(_:Exps)
    requires getKLabel HOLE ==KLabel &apos;_`(_`) orBool getKLabel HOLE ==KLabel &apos;_`[_`]
  */</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span>lookup<span class="token punctuation">(</span>L<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> V<span class="token punctuation">)</span><span class="token punctuation">(</span>_<span class="token punctuation">:</span>Exps<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; V<span class="token punctuation">:</span>Val <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="instance-of">Instance of</h2>

<p>Like in untyped KOOL.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> objectClosure<span class="token punctuation">(</span>_<span class="token punctuation">,</span> ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>C<span class="token punctuation">,</span>_<span class="token punctuation">)</span><span class="token punctuation">)</span> _<span class="token punctuation">)</span>
       instanceOf C <span class="token operator">=&gt;</span> <span class="token boolean">true</span>

  <span class="token keyword keyword-rule">rule</span> objectClosure<span class="token punctuation">(</span>_<span class="token punctuation">,</span> <span class="token punctuation">(</span>ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>C<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span>_<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>List<span class="token punctuation">)</span> _<span class="token punctuation">)</span>
       instanceOf C<span class="token string">&apos;  requires C =/=K C&apos;</span>

  <span class="token keyword keyword-rule">rule</span> objectClosure<span class="token punctuation">(</span>_<span class="token punctuation">,</span> <span class="token punctuation">.</span>List<span class="token punctuation">)</span> instanceOf _ <span class="token operator">=&gt;</span> <span class="token boolean">false</span>
</pre><h2 class="mume-header" id="cast">Cast</h2>

<p>Unlike in untyped KOOL, in typed KOOL we actually check that the object<br>
can indeed be cast to the claimed type.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>C<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">)</span> objectClosure<span class="token punctuation">(</span>Irrelevant<span class="token punctuation">,</span> EStack<span class="token punctuation">)</span>
    <span class="token operator">=&gt;</span> objectClosure<span class="token punctuation">(</span>Irrelevant<span class="token punctuation">,</span> EStack<span class="token punctuation">)</span> instanceOf C <span class="token operator">~&gt;</span> <span class="token boolean">true</span><span class="token operator">?</span>
       <span class="token operator">~&gt;</span> objectClosure<span class="token punctuation">(</span>C<span class="token punctuation">,</span> EStack<span class="token punctuation">)</span>
</pre><h2 class="mume-header" id="kool-specific-auxiliary-declarations-and-operations">KOOL-specific auxiliary declarations and operations</h2>

<h2 class="mume-header" id="objects-as-lvalues">Objects as lvalues</h2>

<p>Like in untyped KOOL.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> lvalue<span class="token punctuation">(</span>X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=&gt;</span> this <span class="token punctuation">.</span> X<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Env <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> notBool<span class="token punctuation">(</span>X in keys<span class="token punctuation">(</span>Env<span class="token punctuation">)</span><span class="token punctuation">)</span>

  <span class="token keyword keyword-context">context</span> lvalue<span class="token punctuation">(</span><span class="token punctuation">(</span>HOLE <span class="token punctuation">.</span> _<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">:</span>Exp<span class="token punctuation">)</span>

<span class="token comment">/*  rule lvalue(objectClosure(&lt;crntObj&gt; &lt;crntClass&gt; C &lt;/crntClass&gt;
                            &lt;envStack&gt;... ListItem((C,EnvC:EnvCell)) EStack &lt;/envStack&gt; &lt;/crntObj&gt;)
              . X
              =&gt; lookupMember(&lt;envStack&gt; ListItem((C,EnvC)) EStack &lt;/envStack&gt;,
                              X)) */</span>
  <span class="token keyword keyword-rule">rule</span> lvalue<span class="token punctuation">(</span>objectClosure<span class="token punctuation">(</span>C<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span>
                            ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>C<span class="token punctuation">,</span>Env<span class="token punctuation">)</span><span class="token punctuation">)</span> EStack<span class="token punctuation">)</span>
              <span class="token punctuation">.</span> X
              <span class="token operator">=&gt;</span> lookupMember<span class="token punctuation">(</span>ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>C<span class="token punctuation">,</span>Env<span class="token punctuation">)</span><span class="token punctuation">)</span> EStack<span class="token punctuation">,</span>
                              X<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> lvalue<span class="token punctuation">(</span>objectClosure<span class="token punctuation">(</span>C<span class="token punctuation">,</span>
                            <span class="token punctuation">(</span>ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>C&apos;<span class="token punctuation">,</span>_<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>List<span class="token punctuation">)</span> _EStack<span class="token punctuation">)</span>
              <span class="token punctuation">.</span> _X<span class="token punctuation">)</span>
    <span class="token keyword keyword-requires">requires</span> C <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K C&apos;
</pre><h2 class="mume-header" id="lookup-member">Lookup member</h2>

<p>Like in untyped KOOL.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> lookupMember<span class="token punctuation">(</span>List<span class="token punctuation">,</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">)</span>  <span class="token punctuation">[</span>function<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> lookupMember<span class="token punctuation">(</span>ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>_<span class="token punctuation">,</span> X <span class="token operator">|</span><span class="token operator">-</span>&gt; L _<span class="token punctuation">)</span><span class="token punctuation">)</span> _<span class="token punctuation">,</span> X<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> lookup<span class="token punctuation">(</span>L<span class="token punctuation">)</span>

  <span class="token comment">// TODO: fix rule below as shown once we support functions with deep rewrites</span>
  <span class="token comment">// rule lookupMember(&lt;envStack&gt; ListItem((_, &lt;env&gt; Env &lt;/env&gt;)) =&gt; .List</span>
  <span class="token comment">//                     ...&lt;/envStack&gt;, X)</span>
  <span class="token comment">//   requires notBool(X in keys(Env))</span>
  <span class="token keyword keyword-rule">rule</span> lookupMember<span class="token punctuation">(</span>ListItem<span class="token punctuation">(</span>envStackFrame<span class="token punctuation">(</span>_<span class="token punctuation">,</span> Env<span class="token punctuation">)</span><span class="token punctuation">)</span> L<span class="token punctuation">,</span> X<span class="token punctuation">)</span>
    <span class="token operator">=&gt;</span> lookupMember<span class="token punctuation">(</span>L<span class="token punctuation">,</span> X<span class="token punctuation">)</span>
    <span class="token keyword keyword-requires">requires</span> notBool<span class="token punctuation">(</span>X in keys<span class="token punctuation">(</span>Env<span class="token punctuation">)</span><span class="token punctuation">)</span>
</pre><h2 class="mume-header" id="typeof-for-the-additional-values"><code>typeOf</code> for the additional values}</h2>

<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> typeOf<span class="token punctuation">(</span>objectClosure<span class="token punctuation">(</span>C<span class="token punctuation">,</span>_<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> C
  <span class="token keyword keyword-rule">rule</span> typeOf<span class="token punctuation">(</span>methodClosure<span class="token punctuation">(</span>T<span class="token punctuation">:</span>Type<span class="token punctuation">,</span>_<span class="token punctuation">,</span>_<span class="token punctuation">,</span>_Ps<span class="token punctuation">:</span>Params<span class="token punctuation">,</span>_<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> T
</pre><h2 class="mume-header" id="subtype-checking">Subtype checking</h2>

<p>The subclass relation induces a subtyping relation.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> subtype<span class="token punctuation">(</span>Types<span class="token punctuation">,</span>Types<span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> subtype<span class="token punctuation">(</span>T<span class="token punctuation">:</span>Type<span class="token punctuation">,</span> T<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">true</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> subtype<span class="token punctuation">(</span>C1<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span> C<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> subtype<span class="token punctuation">(</span>C2<span class="token punctuation">,</span> C<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>className</span><span class="token punctuation">&gt;</span></span> C1 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>className</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>baseClass</span><span class="token punctuation">&gt;</span></span> C2<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>baseClass</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> C1 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K C

  <span class="token keyword keyword-rule">rule</span> subtype<span class="token punctuation">(</span>Object<span class="token punctuation">,</span>Class<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">false</span>
    <span class="token keyword keyword-requires">requires</span> Class <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K Object

  <span class="token keyword keyword-rule">rule</span> subtype<span class="token punctuation">(</span>Ts1<span class="token operator">-</span>&gt;T2<span class="token punctuation">,</span>Ts1<span class="token string">&apos;-&gt;T2&apos;</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> subtype<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>T2<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">:</span>Type<span class="token punctuation">,</span>Ts1<span class="token string">&apos;),((T2&apos;</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">:</span>Type<span class="token punctuation">,</span>Ts1<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment">// Note that the following rule would be wrong!</span>
<span class="token comment">//  rule subtype(T[],T&apos;[]) =&gt; subtype(T,T&apos;)</span>

  <span class="token keyword keyword-rule">rule</span> subtype<span class="token punctuation">(</span><span class="token punctuation">(</span>T<span class="token punctuation">:</span>Type<span class="token punctuation">,</span>Ts<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>T<span class="token string">&apos;:Type,Ts&apos;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> subtype<span class="token punctuation">(</span>T<span class="token punctuation">,</span>T<span class="token string">&apos;) &amp;&amp; subtype(Ts,Ts&apos;</span><span class="token punctuation">)</span>
    <span class="token keyword keyword-requires">requires</span> Ts <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K <span class="token punctuation">.</span>Types
  <span class="token keyword keyword-rule">rule</span> subtype<span class="token punctuation">(</span><span class="token punctuation">.</span>Types<span class="token punctuation">,</span><span class="token punctuation">.</span>Types<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
</pre><h2 class="mume-header" id="unsafe-casting">Unsafe Casting</h2>

<p>Performs unsafe casting.  One should only use it in combination with<br>
the subtype relation above.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> unsafeCast<span class="token punctuation">(</span>Val<span class="token punctuation">,</span>Type<span class="token punctuation">)</span>  <span class="token punctuation">[</span>function<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> unsafeCast<span class="token punctuation">(</span>objectClosure<span class="token punctuation">(</span>_<span class="token punctuation">,</span>EStack<span class="token punctuation">)</span><span class="token punctuation">,</span> C<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">)</span>
    <span class="token operator">=&gt;</span> objectClosure<span class="token punctuation">(</span>C<span class="token punctuation">,</span>EStack<span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> unsafeCast<span class="token punctuation">(</span>methodClosure<span class="token punctuation">(</span>_T&apos;<span class="token punctuation">,</span>C<span class="token punctuation">,</span>OL<span class="token punctuation">,</span>Ps<span class="token punctuation">,</span>S<span class="token punctuation">)</span><span class="token punctuation">,</span> T<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> methodClosure<span class="token punctuation">(</span>T<span class="token punctuation">,</span>C<span class="token punctuation">,</span>OL<span class="token punctuation">,</span>Ps<span class="token punctuation">,</span>S<span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> unsafeCast<span class="token punctuation">(</span>V<span class="token punctuation">:</span>Val<span class="token punctuation">,</span> T<span class="token punctuation">:</span>Type<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> V  <span class="token keyword keyword-requires">requires</span> typeOf<span class="token punctuation">(</span>V<span class="token punctuation">)</span> <span class="token operator">==</span>K T
</pre><h2 class="mume-header" id="generic-guard">Generic guard</h2>

<p>A generic computational guard: it allows the computation to continue<br>
only if a prefix guard evaluates to true.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;true?&quot;</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">true</span> <span class="token operator">~&gt;</span> <span class="token boolean">true</span><span class="token operator">?</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K

<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>Go to <a href="#ebook-heading-lesson-3-kool-typed-static">Lesson 3, KOOL typed static</a>.</p>
</div></div><div id="ebook-heading-lesson-3-kool-typed-static" ebook-toc-level-4 heading="Lesson 3, KOOL typed static"><div><h1 class="mume-header" id="kool-typed-static">KOOL &#x2014; Typed &#x2014; Static</h1>

<p>Author: Grigore Ro&#x219;u (<a href="mailto:grosu@illinois.edu">grosu@illinois.edu</a>)<br>
Organization: University of Illinois at Urbana-Champaign</p>
<p>Author: Traian Florin &#x218;erb&#x103;nu&#x21B;&#x103; (<a href="mailto:traian.serbanuta@unibuc.ro">traian.serbanuta@unibuc.ro</a>)<br>
Organization: University of Bucharest</p>
<h2 class="mume-header" id="abstract">Abstract</h2>

<p>This is the <strong>K</strong> static semantics of the typed KOOL language.<br>
It extends the static semantics of typed SIMPLE with static semantics<br>
for the object-oriented constructs.  Also, the static semantics of<br>
some of the existing SIMPLE constructs need to change, in order to<br>
become more generous with regards to the set of accepted programs,<br>
mostly due to subtyping.  For example, the assignment construct<br>
<code>x = e</code> required that both the variable <code>x</code> and the<br>
expression <code>e</code> had the same type in SIMPLE.  In KOOL, the type<br>
of <code>e</code> can be a subtype of the type of <code>x</code>.<br>
Specifically, we define the following typing policy for KOOL,<br>
everything else not mentioned below borrowing its semantics from<br>
SIMPLE:</p>
<ul>
<li>
<p>Each class <code>C</code> yields a homonymous type, which can be<br>
explicitly used in programs to type variables and methods, possibly in<br>
combination with other types.</p>
</li>
<li>
<p>Since now we have user-defined types, we check that each type<br>
used in a KOOL program is well-formed, that is, it is constructed only<br>
from primitive and class types corresponding to declared classes.</p>
</li>
<li>
<p>Class members and their types form a <strong>class type<br>
environment</strong>.  Each class will have such a type environment.<br>
Each member in a class is allowed to be declared only once.  Since in<br>
KOOL we allow methods to be assigned to fields, we make no distinction<br>
between field and method members; in other words, we reject programs<br>
declaring both a field and a method with the same name.</p>
</li>
<li>
<p>If an identifier is not found in the local type environment, it<br>
will be searched for in the current class type environment.  If not<br>
there, then it will be searched for in its superclass&apos; type<br>
environment.  And so on and so forth.  If not found until the<br>
<code>Object</code> class is reached, a typing error is reported.</p>
</li>
<li>
<p>The assignment allows variables to be assigned values of<br>
more concrete types.  The result type of the assignment expression<br>
construct will be the (more abstract) type of the assigned variable,<br>
and not the (more concrete) type of the expression, like in Java.</p>
</li>
<li>
<p>Exceptions are changed (from SIMPLE) to allow throwing and<br>
catching only objects, like in Java.  Also, unlike in SIMPLE, we do<br>
not check whether the type of the thrown exception matches the type of<br>
the caught variable, because exceptions can be caught by other<br>
<code>try/catch</code> blocks, even by ones in other methods.  To avoid<br>
having to annotate each method with what exceptions it can throw, we<br>
prefer to not check the type safety of exceptions (although this is an<br>
excellent homework!).  We only check that the <code>try</code> block<br>
type-checks and that the <code>catch</code> block type-checks after we bind<br>
the caught variable to its claimed type.</p>
</li>
<li>
<p>Class declarations are not allowed to have any cycles in their<br>
extends relation.  Such cycles would lead to non-termination of<br>
<code>new</code>, as it actually does in the dynamic semantics of KOOL<br>
where no such circularity checks are performed.</p>
</li>
<li>
<p>Methods overriding other methods should be in the right subtyping<br>
relationship with the overridden methods: co-variant in the codomain<br>
and contra-variant in the domain.</p>
</li>
</ul>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> KOOL<span class="token operator">-</span>TYPED<span class="token operator">-</span>STATIC<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> DOMAINS<span class="token operator">-</span>SYNTAX
</pre><h2 class="mume-header" id="syntax">Syntax</h2>

<p>The syntax of statically typed KOOL is identical to that of<br>
dynamically typed KOOL, they both taking as input the same programs.<br>
What differs is the <strong>K</strong> strictness attributes.  Like in statically<br>
typed SIMPLE, almost all language constructs are strict now, since we<br>
want each to type its arguments almost all the time.  Like in the<br>
other two KOOL definitions, we prefer to copy and then modify/extend<br>
the syntax of statically typed SIMPLE.</p>
<p><strong>Note</strong>: This paragraph is old, now we can do things better.  We keep<br>
it here only for historical reasons, to see how much we used to suffer &#x1F603;</p>
<p><strong>Annoying K-tool technical problem:</strong><br>
Currently, the <strong>K</strong> tool treats the &quot;non-terminal&quot; productions (i.e.,<br>
productions consisting of just one non-terminal), also called<br>
&quot;subsorting&quot; production, differently from the other productions.<br>
Specifically, it does not insert a node in the AST for them.  This may<br>
look desirable at first, but it has a big problem: it does not allow<br>
us to treat the subsort differently in different context.  For<br>
example, since we want <em><code>Id</code></em> to be both a type (a class name) and a<br>
program variable, and since we want expressions to reduce to their<br>
types, we are in an impossible situations in which we do not know how<br>
to treat an identifier in the semantics: as a type, i.e., a result of<br>
computations, or as a program variable, i.e., a non-result.  Ideally,<br>
we would like to tag the identifiers at parse-time with their local<br>
interpretation, but that, unfortunately, is not possible with the<br>
current parsing capabilities of the <strong>K</strong> tool, because it requires to<br>
insert additional information in the AST for the subsort productions.<br>
This will be fixed soon.  Until then, unfortunately, we have to do the<br>
job of the parser manually.  Instead of subsorting <em><code>Id</code></em> directly<br>
to <em><code>Type</code></em>, we &quot;wrap&quot; it first, say with a wrapper called<br>
<code>class(...)</code>, exactly how the parser should have done.<br>
The major drawback of this is that all the typed KOOL programs<br>
in <code>kool/typed/programs</code> need to also be modified to always<br>
declare class types accordingly.  The modified programs can be found<br>
in <code>kool/typed/static/programs</code>.  So make sure you execute the<br>
static semantics of KOOL using the modified programs.  To avoid seeing<br>
the wrapper in the generated documentation, we associate it an<br>
&quot;invisibility&quot; latex attribute below.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> <span class="token keyword keyword-Id">Id</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;Object&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token string">&quot;Main&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
</pre><h2 class="mume-header" id="types">Types</h2>

<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Type <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;void&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;int&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;bool&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;string&quot;</span>
                <span class="token operator">|</span> <span class="token keyword keyword-Id">Id</span>                     <span class="token punctuation">[</span><span class="token class-name">klabel</span><span class="token punctuation">(</span><span class="token string">&quot;class&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">,</span> <span class="token class-name">avoid</span><span class="token punctuation">]</span>  <span class="token comment">// see next</span>
                <span class="token operator">|</span> Type <span class="token string">&quot;[&quot;</span> <span class="token string">&quot;]&quot;</span>
                <span class="token operator">|</span> <span class="token string">&quot;(&quot;</span> Type <span class="token string">&quot;)&quot;</span>           <span class="token punctuation">[</span><span class="token class-name">bracket</span><span class="token punctuation">]</span>
                &gt; Types <span class="token string">&quot;-&gt;&quot;</span> Type

  <span class="token keyword keyword-syntax">syntax</span> Types <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Type<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>        <span class="token punctuation">[</span>overload<span class="token punctuation">(</span>exps<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h2 class="mume-header" id="declarations">Declarations</h2>

<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Param <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Type <span class="token keyword keyword-Id">Id</span>
  <span class="token keyword keyword-syntax">syntax</span> Params <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Param<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>

  <span class="token keyword keyword-syntax">syntax</span> Stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Type Exps <span class="token string">&quot;;&quot;</span> <span class="token punctuation">[</span><span class="token class-name">avoid</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> Type <span class="token keyword keyword-Id">Id</span> <span class="token string">&quot;(&quot;</span> Params <span class="token string">&quot;)&quot;</span> Block
                <span class="token operator">|</span> <span class="token string">&quot;class&quot;</span> <span class="token keyword keyword-Id">Id</span> Block
                <span class="token operator">|</span> <span class="token string">&quot;class&quot;</span> <span class="token keyword keyword-Id">Id</span> <span class="token string">&quot;extends&quot;</span> <span class="token keyword keyword-Id">Id</span> Block
</pre><h2 class="mume-header" id="expressions">Expressions</h2>

<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> FieldReference <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Exp <span class="token string">&quot;.&quot;</span> <span class="token keyword keyword-Id">Id</span>          <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> ArrayReference <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Exp <span class="token string">&quot;[&quot;</span> Exps <span class="token string">&quot;]&quot;</span>    <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span> <span class="token operator">|</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token operator">|</span> <span class="token keyword keyword-String">String</span> <span class="token operator">|</span> <span class="token keyword keyword-Id">Id</span>
               <span class="token operator">|</span> <span class="token string">&quot;this&quot;</span>
               <span class="token operator">|</span> <span class="token string">&quot;super&quot;</span>
               <span class="token operator">|</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span>             <span class="token punctuation">[</span><span class="token class-name">bracket</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;++&quot;</span> Exp
               <span class="token operator">|</span> Exp <span class="token string">&quot;instanceOf&quot;</span> <span class="token keyword keyword-Id">Id</span>     <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;(&quot;</span> <span class="token keyword keyword-Id">Id</span> <span class="token string">&quot;)&quot;</span> Exp          <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;new&quot;</span> <span class="token keyword keyword-Id">Id</span> <span class="token string">&quot;(&quot;</span> Exps <span class="token string">&quot;)&quot;</span>   <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
               &gt; Exp <span class="token string">&quot;(&quot;</span> Exps <span class="token string">&quot;)&quot;</span>        <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;-&quot;</span> Exp                 <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;sizeOf&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span>    <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;read&quot;</span> <span class="token string">&quot;(&quot;</span> <span class="token string">&quot;)&quot;</span>
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;*&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;/&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;%&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;+&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;-&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               &gt; <span class="token class-name">non-assoc</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;&lt;&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;&lt;=&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;&gt;&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;&gt;=&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;==&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;!=&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               &gt; <span class="token string">&quot;!&quot;</span> Exp                 <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;&amp;&amp;&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;||&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               &gt; <span class="token string">&quot;spawn&quot;</span> Block  <span class="token comment">// not strict: to check return and exceptions</span>
               &gt; Exp <span class="token string">&quot;=&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">right</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> FieldReference <span class="token operator">|</span> ArrayReference
  <span class="token keyword keyword-syntax priority">syntax priority</span> _<span class="token punctuation">.</span>__KOOL<span class="token operator">-</span>TYPED<span class="token operator">-</span>STATIC<span class="token operator">-</span>SYNTAX &gt; _<span class="token punctuation">[</span>_<span class="token punctuation">]</span>_KOOL<span class="token operator">-</span>TYPED<span class="token operator">-</span>STATIC<span class="token operator">-</span>SYNTAX &gt; _<span class="token punctuation">(</span>_<span class="token punctuation">)</span>_KOOL<span class="token operator">-</span>TYPED<span class="token operator">-</span>STATIC<span class="token operator">-</span>SYNTAX

  <span class="token keyword keyword-syntax">syntax</span> Exps <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Exp<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>          <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> overload<span class="token punctuation">(</span>exps<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h2 class="mume-header" id="statements">Statements</h2>

<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Block <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;{&quot;</span> <span class="token string">&quot;}&quot;</span>
                <span class="token operator">|</span> <span class="token string">&quot;{&quot;</span> Stmt <span class="token string">&quot;}&quot;</span>

  <span class="token keyword keyword-syntax">syntax</span> Stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Block
                <span class="token operator">|</span> Exp <span class="token string">&quot;;&quot;</span>                                 <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;if&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Block <span class="token string">&quot;else&quot;</span> Block     <span class="token punctuation">[</span><span class="token class-name">avoid</span><span class="token punctuation">,</span> <span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;if&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Block                  <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;while&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Block               <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;for&quot;</span> <span class="token string">&quot;(&quot;</span> Stmt Exp <span class="token string">&quot;;&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Block    <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;return&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                        <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;return&quot;</span> <span class="token string">&quot;;&quot;</span>
                <span class="token operator">|</span> <span class="token string">&quot;print&quot;</span> <span class="token string">&quot;(&quot;</span> Exps <span class="token string">&quot;)&quot;</span> <span class="token string">&quot;;&quot;</span>                <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;try&quot;</span> Block <span class="token string">&quot;catch&quot;</span> <span class="token string">&quot;(&quot;</span> Param <span class="token string">&quot;)&quot;</span> Block <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;throw&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                         <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;join&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                          <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;acquire&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                       <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;release&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                       <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;rendezvous&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                    <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-syntax">syntax</span> Stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Stmt Stmt                            <span class="token punctuation">[</span><span class="token class-name">seqstrict</span><span class="token punctuation">,</span> <span class="token class-name">right</span><span class="token punctuation">]</span>
</pre><h2 class="mume-header" id="desugaring-macros">Desugaring macros</h2>

<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> if <span class="token punctuation">(</span>E<span class="token punctuation">)</span> S <span class="token operator">=&gt;</span> if <span class="token punctuation">(</span>E<span class="token punctuation">)</span> S else <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword keyword-rule">rule</span> for<span class="token punctuation">(</span>Start Cond<span class="token punctuation">;</span> Step<span class="token punctuation">)</span> <span class="token punctuation">{</span>S<span class="token punctuation">:</span>Stmt<span class="token punctuation">}</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>Start while<span class="token punctuation">(</span>Cond<span class="token punctuation">)</span><span class="token punctuation">{</span>S Step<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span>
  <span class="token keyword keyword-rule">rule</span> T<span class="token punctuation">:</span>Type E1<span class="token punctuation">:</span>Exp<span class="token punctuation">,</span> E2<span class="token punctuation">:</span>Exp<span class="token punctuation">,</span> Es<span class="token punctuation">:</span>Exps<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> T E1<span class="token punctuation">;</span> T E2<span class="token punctuation">,</span> Es<span class="token punctuation">;</span>               <span class="token punctuation">[</span>anywhere<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> T<span class="token punctuation">:</span>Type X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=</span> E<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> T X<span class="token punctuation">;</span> X <span class="token operator">=</span> E<span class="token punctuation">;</span>                                  <span class="token punctuation">[</span>anywhere<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> class C<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> S <span class="token operator">=&gt;</span> class C extends Object S

<span class="token keyword keyword-endmodule">endmodule</span>
</pre><h2 class="mume-header" id="static-semantics">Static semantics</h2>

<p>We first discuss the configuration, then give the static semantics<br>
taken over unchanged from SIMPLE, then discuss the static semantics of<br>
SIMPLE syntactic constructs that needs to change, and in the end we<br>
discuss the static semantics and additional checks specifically<br>
related to the KOOL proper syntax.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> KOOL<span class="token operator">-</span>TYPED<span class="token operator">-</span>STATIC
  <span class="token keyword keyword-imports">imports</span> KOOL<span class="token operator">-</span>TYPED<span class="token operator">-</span>STATIC<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> DOMAINS
</pre><h2 class="mume-header" id="configuration">Configuration</h2>

<p>The configuration of our type system consists of a <code>tasks</code><br>
cell with the same meaning like in statically typed SIMPLE, of an<br>
<code>out</code> cell streamed to the standard output that will be used to<br>
display typing error messages, and of a cell <code>classes</code> holding<br>
data about each class in a separate <code>class</code> cell.  The<br>
<code>task</code> cells now have two additional optional subcells, namely<br>
<code>ctenvT</code> and <code>inClass</code>.  The former holds a temporary<br>
class type environment; its contents will be transferred into the<br>
<code>ctenv</code> cell of the corresponding class as soon as all the<br>
fields and methods in the task are processed.  In fact, there will be<br>
three types of tasks in the subsequent semantics, each determined by<br>
the subset of cells that it holds:</p>
<ol>
<li>
<p><strong>Main task</strong>, holding only a <code>k</code> cell holding the<br>
original program as a set of classes.  The role of this task is to<br>
process each class, generating a class task (see next) for each.</p>
</li>
<li>
<p><strong>Class task</strong>, holding <code>k</code>, <code>ctenvT</code>, and<br>
<code>inClass</code> subcells.  The role of this task type is to process<br>
a class&apos; contents, generating a class type environment in the<br>
<code>ctenvT</code> cell and a method task (see next) for each method in<br>
the class.  To avoid interference with object member lookup rules<br>
below, it is important to add the class type environment to a class<br>
atomically; this is the reason for which we use <code>ctenvT</code><br>
temporary cells within class tasks (instead of adding each member<br>
incrementally to the class&apos; type environment).</p>
</li>
<li>
<p><strong>Method task</strong>, holding <code>k</code>, <code>tenv</code> and<br>
<code>return</code> cells.  These tasks are similar to SIMPLE&apos;s function<br>
tasks, so we do not discuss them here any further.</p>
</li>
</ol>
<p>Each <code>class</code> cell hods its name (in the <code>className</code><br>
cell) and the name of the class it extends (in the <code>extends</code><br>
cell), as well as its type environment (in the <code>ctenv</code> cell)<br>
and the set of all its superclasses (in the <code>extendsAll</code> cell).<br>
The later is useful for example for checking whether there are cycles<br>
in the class extends relation.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-configuration">configuration</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>T</span> <span class="token attr-name">multiplicity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>?<span class="token punctuation">&quot;</span></span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>yellow<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tasks</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>orange<span class="token punctuation">&quot;</span></span> <span class="token attr-name">multiplicity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>?<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>task</span> <span class="token attr-name">multiplicity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>*<span class="token punctuation">&quot;</span></span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>yellow<span class="token punctuation">&quot;</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Set<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>green<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> $PGM<span class="token punctuation">:</span>Stmt <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tenv</span> <span class="token attr-name">multiplicity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>?<span class="token punctuation">&quot;</span></span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>cyan<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tenv</span><span class="token punctuation">&gt;</span></span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ctenvT</span> <span class="token attr-name">multiplicity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>?<span class="token punctuation">&quot;</span></span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>blue<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ctenvT</span><span class="token punctuation">&gt;</span></span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>returnType</span> <span class="token attr-name">multiplicity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>?<span class="token punctuation">&quot;</span></span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>black<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> void <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>returnType</span><span class="token punctuation">&gt;</span></span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>inClass</span> <span class="token attr-name">multiplicity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>?<span class="token punctuation">&quot;</span></span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Fuchsia<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>inClass</span><span class="token punctuation">&gt;</span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>task</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tasks</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">//                  &lt;br/&gt;</span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>classes</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Fuchsia<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>classData</span> <span class="token attr-name">multiplicity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>*<span class="token punctuation">&quot;</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Map<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>className</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Fuchsia<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> Object <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>className</span><span class="token punctuation">&gt;</span></span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>baseClass</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Fuchsia<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>baseClass</span><span class="token punctuation">&gt;</span></span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>baseClasses</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Fuchsia<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Set <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>baseClasses</span><span class="token punctuation">&gt;</span></span>
                      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ctenv</span> <span class="token attr-name">multiplicity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>?<span class="token punctuation">&quot;</span></span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>blue<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ctenv</span><span class="token punctuation">&gt;</span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>classData</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>classes</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>T</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>output</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>brown<span class="token punctuation">&quot;</span></span> <span class="token attr-name">stream</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>stdout<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>List <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>output</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="unchanged-semantics-from-statically-typed-simple">Unchanged semantics from statically typed SIMPLE</h2>

<p>The syntax and rules below are borrowed unchanged from statically<br>
typed SIMPLE, so we do not discuss them much here.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Type
  <span class="token keyword keyword-syntax">syntax</span> Exps <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Types
  <span class="token keyword keyword-syntax">syntax</span> BlockOrStmtType <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;block&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;stmt&quot;</span>
  <span class="token keyword keyword-syntax">syntax</span> Type <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> BlockOrStmtType
  <span class="token keyword keyword-syntax">syntax</span> Block <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> BlockOrStmtType
  <span class="token keyword keyword-syntax">syntax</span> KResult <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Type
                   <span class="token operator">|</span> Types  <span class="token comment">// TODO: should not be needed</span>


  <span class="token keyword keyword-context">context</span> _<span class="token punctuation">:</span>Type _<span class="token punctuation">:</span><span class="token punctuation">:</span>Exp<span class="token punctuation">[</span>HOLE<span class="token punctuation">:</span><span class="token punctuation">:</span>Exps<span class="token punctuation">]</span><span class="token punctuation">;</span>

  <span class="token keyword keyword-rule">rule</span> T<span class="token punctuation">:</span>Type E<span class="token punctuation">:</span>Exp<span class="token punctuation">[</span>int<span class="token punctuation">,</span>Ts<span class="token punctuation">:</span>Types<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">=&gt;</span> T<span class="token punctuation">[</span><span class="token punctuation">]</span> E<span class="token punctuation">[</span>Ts<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-rule">rule</span> T<span class="token punctuation">:</span>Type E<span class="token punctuation">:</span>Exp<span class="token punctuation">[</span><span class="token punctuation">.</span>Types<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">=&gt;</span> T E<span class="token punctuation">;</span>


  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>task</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> _<span class="token punctuation">:</span>BlockOrStmtType <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tenv</span><span class="token punctuation">&gt;</span></span> _ <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tenv</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>task</span><span class="token punctuation">&gt;</span></span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Bag


  <span class="token keyword keyword-rule">rule</span> _<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">=&gt;</span> int
  <span class="token keyword keyword-rule">rule</span> _<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span> <span class="token operator">=&gt;</span> bool
  <span class="token keyword keyword-rule">rule</span> _<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span> <span class="token operator">=&gt;</span> string


  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=&gt;</span> T <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tenv</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> X <span class="token operator">|</span><span class="token operator">-</span>&gt; T <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tenv</span><span class="token punctuation">&gt;</span></span>


  <span class="token keyword keyword-context">context</span> <span class="token operator">++</span><span class="token punctuation">(</span>HOLE <span class="token operator">=&gt;</span> ltype<span class="token punctuation">(</span>HOLE<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token operator">++</span> int <span class="token operator">=&gt;</span> int
  <span class="token keyword keyword-rule">rule</span> int <span class="token operator">+</span> int <span class="token operator">=&gt;</span> int
  <span class="token keyword keyword-rule">rule</span> string <span class="token operator">+</span> string <span class="token operator">=&gt;</span> string
  <span class="token keyword keyword-rule">rule</span> int <span class="token operator">-</span> int <span class="token operator">=&gt;</span> int
  <span class="token keyword keyword-rule">rule</span> int <span class="token operator">*</span> int <span class="token operator">=&gt;</span> int
  <span class="token keyword keyword-rule">rule</span> int <span class="token operator">/</span> int <span class="token operator">=&gt;</span> int
  <span class="token keyword keyword-rule">rule</span> int <span class="token operator">%</span> int <span class="token operator">=&gt;</span> int
  <span class="token keyword keyword-rule">rule</span> <span class="token operator">-</span> int <span class="token operator">=&gt;</span> int
  <span class="token keyword keyword-rule">rule</span> int &lt; int <span class="token operator">=&gt;</span> bool
  <span class="token keyword keyword-rule">rule</span> int <span class="token operator">&lt;=</span> int <span class="token operator">=&gt;</span> bool
  <span class="token keyword keyword-rule">rule</span> int &gt; int <span class="token operator">=&gt;</span> bool
  <span class="token keyword keyword-rule">rule</span> int <span class="token operator">&gt;=</span> int <span class="token operator">=&gt;</span> bool
  <span class="token keyword keyword-rule">rule</span> T<span class="token punctuation">:</span>Type <span class="token operator">==</span> T <span class="token operator">=&gt;</span> bool
  <span class="token keyword keyword-rule">rule</span> T<span class="token punctuation">:</span>Type <span class="token operator">!=</span> T <span class="token operator">=&gt;</span> bool
  <span class="token keyword keyword-rule">rule</span> bool <span class="token operator">&amp;&amp;</span> bool <span class="token operator">=&gt;</span> bool
  <span class="token keyword keyword-rule">rule</span> bool <span class="token operator">||</span> bool <span class="token operator">=&gt;</span> bool
  <span class="token keyword keyword-rule">rule</span> <span class="token operator">!</span> bool <span class="token operator">=&gt;</span> bool


  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">[</span>int<span class="token punctuation">,</span> Ts<span class="token punctuation">:</span>Types<span class="token punctuation">]</span> <span class="token operator">=&gt;</span> T<span class="token punctuation">[</span>Ts<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> T<span class="token punctuation">:</span>Type<span class="token punctuation">[</span><span class="token punctuation">.</span>Types<span class="token punctuation">]</span> <span class="token operator">=&gt;</span> T

  <span class="token keyword keyword-rule">rule</span> sizeOf<span class="token punctuation">(</span>_T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> int


  <span class="token keyword keyword-rule">rule</span> read<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> int

  <span class="token keyword keyword-rule">rule</span> print<span class="token punctuation">(</span>T<span class="token punctuation">:</span>Type<span class="token punctuation">,</span> Ts <span class="token operator">=&gt;</span> Ts<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword keyword-requires">requires</span> T <span class="token operator">==</span>K int orBool T <span class="token operator">==</span>K string
  <span class="token keyword keyword-rule">rule</span> print<span class="token punctuation">(</span><span class="token punctuation">.</span>Types<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">=&gt;</span> stmt


  <span class="token keyword keyword-context">context</span> <span class="token punctuation">(</span>HOLE <span class="token operator">=&gt;</span> ltype<span class="token punctuation">(</span>HOLE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> _


  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> return<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> stmt <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>returnType</span><span class="token punctuation">&gt;</span></span> _ <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>returnType</span><span class="token punctuation">&gt;</span></span>


  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">=&gt;</span> block

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>task</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>S<span class="token punctuation">:</span>Stmt<span class="token punctuation">}</span> <span class="token operator">=&gt;</span> block <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tenv</span><span class="token punctuation">&gt;</span></span> Rho <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tenv</span><span class="token punctuation">&gt;</span></span> R <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>task</span><span class="token punctuation">&gt;</span></span>
       <span class="token punctuation">(</span><span class="token punctuation">.</span>Bag <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>task</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> S <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tenv</span><span class="token punctuation">&gt;</span></span> Rho <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tenv</span><span class="token punctuation">&gt;</span></span> R <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>task</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> _<span class="token punctuation">:</span>Type<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> stmt
  <span class="token keyword keyword-rule">rule</span> if <span class="token punctuation">(</span>bool<span class="token punctuation">)</span> block else block <span class="token operator">=&gt;</span> stmt
  <span class="token keyword keyword-rule">rule</span> while <span class="token punctuation">(</span>bool<span class="token punctuation">)</span> block <span class="token operator">=&gt;</span> stmt

  <span class="token keyword keyword-rule">rule</span> join int<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> stmt
  <span class="token keyword keyword-rule">rule</span> acquire _<span class="token punctuation">:</span>Type<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> stmt
  <span class="token keyword keyword-rule">rule</span> release _<span class="token punctuation">:</span>Type<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> stmt
  <span class="token keyword keyword-rule">rule</span> rendezvous _<span class="token punctuation">:</span>Type<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> stmt

  <span class="token keyword keyword-syntax">syntax</span> Stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> BlockOrStmtType
  <span class="token keyword keyword-rule">rule</span> _<span class="token punctuation">:</span>BlockOrStmtType _<span class="token punctuation">:</span>BlockOrStmtType <span class="token operator">=&gt;</span> stmt
</pre><h2 class="mume-header" id="unchanged-auxiliary-operations-from-dynamically-typed-simple">Unchanged auxiliary operations from dynamically typed SIMPLE</h2>

<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> mkDecls<span class="token punctuation">(</span>Params<span class="token punctuation">)</span>  <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> mkDecls<span class="token punctuation">(</span>T<span class="token punctuation">:</span>Type X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span> Ps<span class="token punctuation">:</span>Params<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> T X<span class="token punctuation">;</span> mkDecls<span class="token punctuation">(</span>Ps<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> mkDecls<span class="token punctuation">(</span><span class="token punctuation">.</span>Params<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token keyword keyword-syntax">syntax</span> LValue <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Id">Id</span>
                  <span class="token operator">|</span> FieldReference
                  <span class="token operator">|</span> ArrayReference
  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> LValue

  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> ltype<span class="token punctuation">(</span>Exp<span class="token punctuation">)</span>
<span class="token comment">// We would like to say:</span>
<span class="token comment">//  context ltype(HOLE:LValue)</span>
<span class="token comment">// but we currently cannot type the HOLE</span>
  <span class="token keyword keyword-context">context</span> ltype<span class="token punctuation">(</span>HOLE<span class="token punctuation">)</span> <span class="token keyword keyword-requires">requires</span> isLValue<span class="token punctuation">(</span>HOLE<span class="token punctuation">)</span>

<span class="token comment">// OLD approach:</span>
<span class="token comment">//  syntax Exp ::= ltype(Exp)  [function]</span>
<span class="token comment">//  rule ltype(X:Id) =&gt; X</span>
<span class="token comment">//  rule ltype(E:Exp [Es:Exps]) =&gt; E[Es]</span>

  <span class="token keyword keyword-syntax">syntax</span> Types <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> getTypes<span class="token punctuation">(</span>Params<span class="token punctuation">)</span>  <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> getTypes<span class="token punctuation">(</span>T<span class="token punctuation">:</span>Type _<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> T<span class="token punctuation">,</span> <span class="token punctuation">.</span>Types
  <span class="token keyword keyword-rule">rule</span> getTypes<span class="token punctuation">(</span>T<span class="token punctuation">:</span>Type _<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span> P<span class="token punctuation">,</span> Ps<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> T<span class="token punctuation">,</span> getTypes<span class="token punctuation">(</span>P<span class="token punctuation">,</span>Ps<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> getTypes<span class="token punctuation">(</span><span class="token punctuation">.</span>Params<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> void<span class="token punctuation">,</span> <span class="token punctuation">.</span>Types
</pre><h2 class="mume-header" id="changes-to-the-existing-statically-typed-simple-semantics">Changes to the existing statically typed SIMPLE semantics</h2>

<p>Below we give the new static semantics for language constructs that<br>
come from SIMPLE, but whose SIMPLE static semantics was too<br>
restrictive or too permissive and thus had to change.</p>
<h2 class="mume-header" id="local-variable-declaration">Local variable declaration</h2>

<p>Since we can define new types in KOOL (corresponding to classes), the<br>
variable declaration needs to now check that the claimed types exist.<br>
The operation <code>checkType</code>, defined at the end of this module,<br>
checks whether the argument type is correct (it actually works with<br>
lists of types as well).</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> T<span class="token punctuation">:</span>Type X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">;</span> <span class="token operator">=&gt;</span> checkType<span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> stmt <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tenv</span><span class="token punctuation">&gt;</span></span> Rho <span class="token operator">=&gt;</span> Rho<span class="token punctuation">[</span>X &lt;<span class="token operator">-</span> T<span class="token punctuation">]</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tenv</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="class-member-declaration">Class member declaration</h2>

<p>In class tasks, variable declarations mean class member declarations.<br>
Since we reduce method declarations to variable declarations (see<br>
below), a variable declaration in a class task can mean either a field<br>
or a method declaration.  Unlike local variable declarations, which<br>
can shadow previous homonymous local or member declarations, member<br>
declarations are regarded as a set, so we disallow multiple<br>
declarations for the same member (one could improve upon this, like in<br>
Java, by treating members with different types or number of arguments<br>
as different, etc., but we do not do it here).  We also issue an error<br>
message if one attempts to redeclare the same class member.  The<br>
framed variable declaration in the second rule below should be read<br>
&quot;stuck&quot;.  In fact, it is nothing but a unary operation called<br>
<code>stuck</code>, which takes a <strong>K</strong>-term as argument and does nothing<br>
with it; this <code>stuck</code> operation is displayed as a frame in this<br>
PDF document because of its latex attribute (see the ASCII .k file,<br>
at the end of this module).</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> T<span class="token punctuation">:</span>Type X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">;</span> <span class="token operator">=&gt;</span> checkType<span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> stmt <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ctenvT</span><span class="token punctuation">&gt;</span></span> Rho <span class="token punctuation">(</span><span class="token punctuation">.</span>Map <span class="token operator">=&gt;</span> X <span class="token operator">|</span><span class="token operator">-</span>&gt; T<span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ctenvT</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> notBool<span class="token punctuation">(</span>X in keys<span class="token punctuation">(</span>Rho<span class="token punctuation">)</span><span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> T<span class="token punctuation">:</span>Type X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">;</span> <span class="token operator">=&gt;</span> stuck<span class="token punctuation">(</span>T X<span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ctenvT</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> X <span class="token operator">|</span><span class="token operator">-</span>&gt; _ <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ctenvT</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>inClass</span><span class="token punctuation">&gt;</span></span> C<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>inClass</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">//       &lt;br/&gt;</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>output</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>List <span class="token operator">=&gt;</span> ListItem<span class="token punctuation">(</span><span class="token string">&quot;Member \&quot;&quot;</span> <span class="token operator">+</span><span class="token keyword keyword-String">String</span> Id2String<span class="token punctuation">(</span>X<span class="token punctuation">)</span>
                              <span class="token operator">+</span><span class="token keyword keyword-String">String</span> <span class="token string">&quot;\&quot; declared twice in class \&quot;&quot;</span>
                              <span class="token operator">+</span><span class="token keyword keyword-String">String</span> Id2String<span class="token punctuation">(</span>C<span class="token punctuation">)</span> <span class="token operator">+</span><span class="token keyword keyword-String">String</span> <span class="token string">&quot;\&quot;!\n&quot;</span><span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>output</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="method-declaration">Method declaration</h2>

<p>A method declaration requires two conceptual checks to be performed:<br>
first, that the method&apos;s type is consistent with the type of the<br>
homonymous method that it overrides, if any; and second, that its body<br>
types correctly.  At the same time, it should also be added to the<br>
type environment of its class.  The first conceptual task is performed<br>
using the <code>checkMethod</code> operation defined below, and the second<br>
by generating a corresponding method task.  To add it to the class<br>
type environment, we take advantage of the fact that KOOL is higher<br>
order and reduce the problem to a field declaration problem, which we<br>
have already defined.  The role of the <code>ctenvT</code> cell in the<br>
rule below is to structurally ensure that the method declaration takes<br>
place in a class task (we do not want to allow methods to be declared,<br>
for example, inside other methods).</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> T<span class="token punctuation">:</span>Type F<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">(</span>Ps<span class="token punctuation">:</span>Params<span class="token punctuation">)</span> S
        <span class="token operator">=&gt;</span> checkMethod<span class="token punctuation">(</span>F<span class="token punctuation">,</span> getTypes<span class="token punctuation">(</span>Ps<span class="token punctuation">)</span><span class="token operator">-</span>&gt;T<span class="token punctuation">,</span> C&apos;<span class="token punctuation">)</span>
           <span class="token operator">~&gt;</span> getTypes<span class="token punctuation">(</span>Ps<span class="token punctuation">)</span><span class="token operator">-</span>&gt;T F<span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">//       &lt;br/&gt;</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>inClass</span><span class="token punctuation">&gt;</span></span> C <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>inClass</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ctenvT</span><span class="token punctuation">&gt;</span></span> _ <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ctenvT</span><span class="token punctuation">&gt;</span></span> <span class="token comment">// to ensure we are in a class pass</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>className</span><span class="token punctuation">&gt;</span></span> C <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>className</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>baseClass</span><span class="token punctuation">&gt;</span></span> C&apos; <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>baseClass</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">//       &lt;br/&gt;</span>
       <span class="token punctuation">(</span><span class="token punctuation">.</span>Bag <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>task</span><span class="token punctuation">&gt;</span></span>
               <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> mkDecls<span class="token punctuation">(</span>Ps<span class="token punctuation">)</span> S <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
               <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>inClass</span><span class="token punctuation">&gt;</span></span> C <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>inClass</span><span class="token punctuation">&gt;</span></span>
               <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tenv</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tenv</span><span class="token punctuation">&gt;</span></span>
               <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>returnType</span><span class="token punctuation">&gt;</span></span> T <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>returnType</span><span class="token punctuation">&gt;</span></span>
             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>task</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>
</pre><h2 class="mume-header" id="assignment">Assignment</h2>

<p>A more concrete value is allowed to be assigned to a more abstract<br>
variable.  The operation <code>checkSubtype</code> is defined at the end<br>
of the module and it also works with pairs of lists of types.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> T<span class="token punctuation">:</span>Type <span class="token operator">=</span> T<span class="token string">&apos;:Type =&gt; checkSubtype(T&apos;</span><span class="token punctuation">,</span> T<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> T
</pre><h2 class="mume-header" id="method-invocation-and-return">Method invocation and return</h2>

<p>Methods can be applied on values of more concrete types than their<br>
arguments:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>Ts<span class="token punctuation">:</span>Types <span class="token operator">-</span>&gt; T<span class="token punctuation">:</span>Type<span class="token punctuation">)</span> <span class="token punctuation">(</span>Ts<span class="token string">&apos;:Types) =&gt; checkSubtype(Ts&apos;</span><span class="token punctuation">,</span>Ts<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> T
</pre><p>Similarly, we allow values of more concrete types to be returned by<br>
methods:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> return T<span class="token punctuation">:</span>Type<span class="token punctuation">;</span> <span class="token operator">=&gt;</span> checkSubtype<span class="token punctuation">(</span>T<span class="token punctuation">,</span>T&apos;<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> stmt <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>returnType</span><span class="token punctuation">&gt;</span></span> T&apos;<span class="token punctuation">:</span>Type <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>returnType</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="exceptions">Exceptions</h2>

<p>Exceptions can throw and catch values of any types.  Since unlike in Java<br>
KOOL&apos;s methods do not declare the exception types that they can throw,<br>
we cannot test the full type safety of exceptions.  Instead, we<br>
only check that the <code>try</code> and the <code>catch</code> statements<br>
type correctly.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> try block catch<span class="token punctuation">(</span>T<span class="token punctuation">:</span>Type X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">)</span> S <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>T X<span class="token punctuation">;</span> S<span class="token punctuation">}</span>
  <span class="token keyword keyword-rule">rule</span> throw _T<span class="token punctuation">:</span>Type <span class="token punctuation">;</span> <span class="token operator">=&gt;</span> stmt
</pre><h2 class="mume-header" id="spawn">Spawn</h2>

<p>The spawned cell needs to also be passed the parent&apos;s class.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token comment">// explain why</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> spawn S<span class="token punctuation">:</span>Block <span class="token operator">=&gt;</span> int <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tenv</span><span class="token punctuation">&gt;</span></span> Rho <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tenv</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>inClass</span><span class="token punctuation">&gt;</span></span> C <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>inClass</span><span class="token punctuation">&gt;</span></span>
       <span class="token punctuation">(</span><span class="token punctuation">.</span>Bag <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>task</span><span class="token punctuation">&gt;</span></span>
               <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> S <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
               <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tenv</span><span class="token punctuation">&gt;</span></span> Rho <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tenv</span><span class="token punctuation">&gt;</span></span>
               <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>inClass</span><span class="token punctuation">&gt;</span></span> C <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>inClass</span><span class="token punctuation">&gt;</span></span>
             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>task</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>
</pre><h2 class="mume-header" id="semantics-of-the-new-kool-constructs">Semantics of the new KOOL constructs</h2>

<h2 class="mume-header" id="class-declaration">Class declaration</h2>

<p>We process each class in the main task, adding the corresponding data<br>
into its <code>class</code> cell and also adding a class task for it.  We<br>
also perform some well-formedness checks on the class hierarchy.</p>
<p><strong>Initiate class processing</strong><br>
We create a class cell and a class task for each task.  Also, we start<br>
the class task with a check that the class it extends is declared<br>
(this delays the task until that class is processed using another<br>
instance of this rule).</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token comment">// There seems to be some error with the configuration concretization,</span>
<span class="token comment">// as the rule below does not work when rewriting . to both the task</span>
<span class="token comment">// and the class cells; I had to include two separate . rewrites</span>

<span class="token comment">// TODO: the following fails krun; see #2117</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>task</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> class C<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> extends C&apos;<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token punctuation">{</span> S<span class="token punctuation">:</span>Stmt <span class="token punctuation">}</span> <span class="token operator">=&gt;</span> stmt <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>task</span><span class="token punctuation">&gt;</span></span>
       <span class="token punctuation">(</span><span class="token punctuation">.</span>Bag <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>classData</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
               <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>className</span><span class="token punctuation">&gt;</span></span> C <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>className</span><span class="token punctuation">&gt;</span></span>
               <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>baseClass</span><span class="token punctuation">&gt;</span></span> C&apos; <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>baseClass</span><span class="token punctuation">&gt;</span></span>
             <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>classData</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>
<span class="token comment">//       &lt;br/&gt;</span>
       <span class="token punctuation">(</span><span class="token punctuation">.</span>Bag <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>task</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> checkType<span class="token punctuation">(</span>`class`<span class="token punctuation">(</span>C&apos;<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">~&gt;</span> S <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>inClass</span><span class="token punctuation">&gt;</span></span> C <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>inClass</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ctenvT</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ctenvT</span><span class="token punctuation">&gt;</span></span>
             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>task</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>

<span class="token comment">// You may want to try the thing below, but that failed, too</span>
<span class="token comment">/*
syntax Type ::= &quot;stmtStop&quot;

  rule &lt;tasks&gt;...
       &lt;task&gt; &lt;k&gt; class C:Id extends C&apos;:Id { S:Stmt } =&gt; stmtStop ...&lt;/k&gt; &lt;/task&gt;
       (.Bag =&gt; &lt;task&gt;
                &lt;k&gt; checkType(`class`(C&apos;)) ~&gt; S &lt;/k&gt;
                &lt;inClass&gt; C &lt;/inClass&gt;
                &lt;ctenvT&gt; .Map &lt;/ctenvT&gt;
             &lt;/task&gt;)
       ...&lt;/tasks&gt;
       &lt;classes&gt;...
       .Bag =&gt; &lt;classData&gt;...
               &lt;className&gt; C &lt;/className&gt;
               &lt;baseClass&gt; C&apos; &lt;/baseClass&gt;
             ...&lt;/classData&gt;
       ...&lt;/classes&gt;
//       &lt;br/&gt;
*/</span>
</pre><h2 class="mume-header" id="check-for-unique-class-names">Check for unique class names</h2>

<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>className</span><span class="token punctuation">&gt;</span></span> C <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>className</span><span class="token punctuation">&gt;</span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>className</span><span class="token punctuation">&gt;</span></span> C <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>className</span><span class="token punctuation">&gt;</span></span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>T</span><span class="token punctuation">&gt;</span></span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Bag<span class="token punctuation">)</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>output</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>List <span class="token operator">=&gt;</span> ListItem<span class="token punctuation">(</span><span class="token string">&quot;Class \&quot;&quot;</span> <span class="token operator">+</span><span class="token keyword keyword-String">String</span> Id2String<span class="token punctuation">(</span>C<span class="token punctuation">)</span>
                                  <span class="token operator">+</span><span class="token keyword keyword-String">String</span> <span class="token string">&quot;\&quot; declared twice!\n&quot;</span><span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>output</span><span class="token punctuation">&gt;</span></span>
</pre><p><strong>Check for cycles in class hierarchy</strong><br>
We check for cycles in the class hierarchy by transitively closing the<br>
class extends relation using the <code>extendsAll</code> cells, and<br>
checking that a class will never appear in its own <code>extendsAll</code><br>
cell.  The first rule below initiates the transitive closure of the<br>
superclass relation, the second transitively closes it, and the third<br>
checks for cycles.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>baseClass</span><span class="token punctuation">&gt;</span></span> C <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>baseClass</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>baseClasses</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Set <span class="token operator">=&gt;</span> SetItem<span class="token punctuation">(</span>C<span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>baseClasses</span><span class="token punctuation">&gt;</span></span>  <span class="token punctuation">[</span>priority<span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>classData</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>baseClasses</span><span class="token punctuation">&gt;</span></span> SetItem<span class="token punctuation">(</span>C<span class="token punctuation">)</span> Cs<span class="token punctuation">:</span>Set <span class="token punctuation">(</span><span class="token punctuation">.</span>Set <span class="token operator">=&gt;</span> SetItem<span class="token punctuation">(</span>C&apos;<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>baseClasses</span><span class="token punctuation">&gt;</span></span>
       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>classData</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>classData</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>className</span><span class="token punctuation">&gt;</span></span>C<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>className</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>baseClass</span><span class="token punctuation">&gt;</span></span>C&apos;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>baseClass</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>classData</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> notBool<span class="token punctuation">(</span>C&apos; in <span class="token punctuation">(</span>SetItem<span class="token punctuation">(</span>C<span class="token punctuation">)</span> Cs<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">[</span>priority<span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>className</span><span class="token punctuation">&gt;</span></span> C <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>className</span><span class="token punctuation">&gt;</span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>baseClasses</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> SetItem<span class="token punctuation">(</span>C<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>baseClasses</span><span class="token punctuation">&gt;</span></span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>T</span><span class="token punctuation">&gt;</span></span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Bag<span class="token punctuation">)</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>output</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>List <span class="token operator">=&gt;</span> ListItem<span class="token punctuation">(</span><span class="token string">&quot;Class \&quot;&quot;</span> <span class="token operator">+</span><span class="token keyword keyword-String">String</span> Id2String<span class="token punctuation">(</span>C<span class="token punctuation">)</span>
                                  <span class="token operator">+</span><span class="token keyword keyword-String">String</span> <span class="token string">&quot;\&quot; is in a cycle!\n&quot;</span><span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>output</span><span class="token punctuation">&gt;</span></span>
    <span class="token punctuation">[</span>priority<span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h2 class="mume-header" id="new">New</h2>

<p>To type <code>new</code> we only need to check that the class constructor<br>
can be called with arguments of the given types, so we initiate a call<br>
to the constructor method in the corresponding class.  If that<br>
succeeds, meaning that it types to <code>stmt</code>, then we discard the<br>
<code>stmt</code> type and produce instead the corresponding class type of<br>
the new object.  The auxiliary <code>discard</code> operation is defined<br>
also at the end of this module.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> new C<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">(</span>Ts<span class="token punctuation">:</span>Types<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> `class`<span class="token punctuation">(</span>C<span class="token punctuation">)</span> <span class="token punctuation">.</span> C <span class="token punctuation">(</span>Ts<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> discard <span class="token operator">~&gt;</span> `class`<span class="token punctuation">(</span>C<span class="token punctuation">)</span>
</pre><h2 class="mume-header" id="self-reference">Self reference</h2>

<p>The typing rule for <code>this</code> is straightforward: reduce to the<br>
current class type.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> this <span class="token operator">=&gt;</span> `class`<span class="token punctuation">(</span>C<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>inClass</span><span class="token punctuation">&gt;</span></span> C<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>inClass</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="super">Super</h2>

<p>Similarly, <code>super</code> types to the parent class type.<br>
Note that for typing concerns, super can be considered as an object<br>
(recall that this was not the case in the dynamic semantics).</p>
<pre data-role="codeBlock" data-info="k" class="language-k">   <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> super <span class="token operator">=&gt;</span> `class`<span class="token punctuation">(</span>C&apos;<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>inClass</span><span class="token punctuation">&gt;</span></span> C<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>inClass</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>className</span><span class="token punctuation">&gt;</span></span> C <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>className</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>baseClass</span><span class="token punctuation">&gt;</span></span> C&apos;<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>baseClass</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="object-member-access">Object member access</h2>

<p>There are several cases to consider here.  First, if we are in a class<br>
task, we should lookup the member into the temporary class type<br>
environemnt in cell <code>ctenvT</code>.  That is because we want to allow<br>
initialized field declarations in classes, such as <code>int x=10;</code>.<br>
This is desugared to a declaration of <code>x</code>, which is added to<br>
<code>ctenvT</code> during the class task processing, followed by an<br>
assignment of <code>x</code> to 10.  In order for the assignment to type<br>
check, we need to know that <code>x</code> has been declared with type<br>
<code>int</code>; this information can only be found in the<br>
<code>ctenvT</code> cell.  Second, we should redirect non-local variable<br>
lookups in method tasks to corresponding member accesses (the<br>
local variables are handled by the rule borrowed from SIMPLE).<br>
This is what the second rule below does.  Third, we should allow<br>
object member accesses as lvalues, which is done by the third rule<br>
below.  These last two rules therefore ensure that each necessary<br>
object member access is explicitly allowed for evaluation.  Recall<br>
from the annotated syntax module above that the member access<br>
operation is strict in the object.  That means that the object is<br>
expected to evaluate to a class type.  The next two rules below define<br>
the actual member lookup operation, moving the search to the<br>
superclass when the member is not found in the current class.  Note<br>
that this works because we create the class type environments<br>
atomically; thus, a class either has its complete type environment<br>
available, in which case these rules can safely apply, or its cell<br>
<code>ctenv</code> is not yet available, in which case these rules have to<br>
wait.  Finally, the sixth rule below reports an error when the<br>
<code>Object</code> class is reached.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=&gt;</span> T <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ctenvT</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> X <span class="token operator">|</span><span class="token operator">-</span>&gt; T <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ctenvT</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=&gt;</span> this <span class="token punctuation">.</span> X <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tenv</span><span class="token punctuation">&gt;</span></span> Rho <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tenv</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> notBool<span class="token punctuation">(</span>X in keys<span class="token punctuation">(</span>Rho<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment">// OLD approach:</span>
<span class="token comment">//  rule ltype(E:Exp . X:Id) =&gt; E . X</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> `class`<span class="token punctuation">(</span>C<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">)</span> <span class="token punctuation">.</span> X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=&gt;</span> T <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>className</span><span class="token punctuation">&gt;</span></span> C <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>className</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ctenv</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> X <span class="token operator">|</span><span class="token operator">-</span>&gt; T<span class="token punctuation">:</span>Type <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ctenv</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> `class`<span class="token punctuation">(</span>C1<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=&gt;</span> C2<span class="token punctuation">)</span> <span class="token punctuation">.</span> X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>className</span><span class="token punctuation">&gt;</span></span> C1 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>className</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>baseClass</span><span class="token punctuation">&gt;</span></span> C2<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>baseClass</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ctenv</span><span class="token punctuation">&gt;</span></span> Rho <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ctenv</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> notBool<span class="token punctuation">(</span>X in keys<span class="token punctuation">(</span>Rho<span class="token punctuation">)</span><span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> `class`<span class="token punctuation">(</span>Object<span class="token punctuation">)</span> <span class="token punctuation">.</span> X<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=&gt;</span> stuck<span class="token punctuation">(</span>`class`<span class="token punctuation">(</span>Object<span class="token punctuation">)</span> <span class="token punctuation">.</span> X<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>inClass</span><span class="token punctuation">&gt;</span></span> C<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>inClass</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">//      &lt;br/&gt;</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>output</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>List <span class="token operator">=&gt;</span> ListItem<span class="token punctuation">(</span><span class="token string">&quot;Member \&quot;&quot;</span> <span class="token operator">+</span><span class="token keyword keyword-String">String</span> Id2String<span class="token punctuation">(</span>X<span class="token punctuation">)</span>
                              <span class="token operator">+</span><span class="token keyword keyword-String">String</span> <span class="token string">&quot;\&quot; not declared! (see class \&quot;&quot;</span>
                              <span class="token operator">+</span><span class="token keyword keyword-String">String</span> Id2String<span class="token punctuation">(</span>C<span class="token punctuation">)</span> <span class="token operator">+</span><span class="token keyword keyword-String">String</span> <span class="token string">&quot;\&quot;)\n&quot;</span><span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>output</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="instance-of-and-casting">Instance of and casting</h2>

<p>As it is hard to check statically whether casting is always safe,<br>
the programmer is simply trusted from a typing perspective.  We only<br>
do some basic upcasting and downcasting checks, to reject casts which<br>
will absolutely fail.  However, dynamic semantics or implementations<br>
of the language need to insert runtime checks for downcasting to be safe.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> `class`<span class="token punctuation">(</span>_C1<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">)</span> instanceOf _C2<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=&gt;</span> bool
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>C<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">)</span> `class`<span class="token punctuation">(</span>C<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> `class`<span class="token punctuation">(</span>C<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span>C2<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">)</span> `class`<span class="token punctuation">(</span>C1<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> `class`<span class="token punctuation">(</span>C2<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>className</span><span class="token punctuation">&gt;</span></span> C1 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>className</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>baseClasses</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>SetItem<span class="token punctuation">(</span>C2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>baseClasses</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">// upcast</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span>C2<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">)</span> `class`<span class="token punctuation">(</span>C1<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> `class`<span class="token punctuation">(</span>C2<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>className</span><span class="token punctuation">&gt;</span></span> C2 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>className</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>baseClasses</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>SetItem<span class="token punctuation">(</span>C1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>baseClasses</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">// downcast</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span>C2<span class="token punctuation">)</span> `class`<span class="token punctuation">(</span>C1<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> stuck<span class="token punctuation">(</span><span class="token punctuation">(</span>C2<span class="token punctuation">)</span> `class`<span class="token punctuation">(</span>C1<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>classData</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>className</span><span class="token punctuation">&gt;</span></span> C1 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>className</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>baseClasses</span><span class="token punctuation">&gt;</span></span> S1 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>baseClasses</span><span class="token punctuation">&gt;</span></span>
       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>classData</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>classData</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>className</span><span class="token punctuation">&gt;</span></span> C2 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>className</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>baseClasses</span><span class="token punctuation">&gt;</span></span> S2 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>baseClasses</span><span class="token punctuation">&gt;</span></span>
       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>classData</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>output</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>List <span class="token operator">=&gt;</span> ListItem<span class="token punctuation">(</span><span class="token string">&quot;Classes \&quot;&quot;</span> <span class="token operator">+</span><span class="token keyword keyword-String">String</span> Id2String<span class="token punctuation">(</span>C1<span class="token punctuation">)</span>
                              <span class="token operator">+</span><span class="token keyword keyword-String">String</span> <span class="token string">&quot;\&quot; and \&quot;&quot;</span> <span class="token operator">+</span><span class="token keyword keyword-String">String</span> Id2String<span class="token punctuation">(</span>C2<span class="token punctuation">)</span>
                              <span class="token operator">+</span><span class="token keyword keyword-String">String</span> <span class="token string">&quot;\&quot; are incompatible!\n&quot;</span><span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>output</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> notBool<span class="token punctuation">(</span>C1 in S2<span class="token punctuation">)</span> andBool notBool<span class="token punctuation">(</span>C2 in S1<span class="token punctuation">)</span>
</pre><h2 class="mume-header" id="cleanup-tasks">Cleanup tasks</h2>

<p>Finally, we need to clean up the terminated tasks.  Each of the three<br>
types of tasks is handled differently.  The main task is replaced by a<br>
method task holding <code>new main();</code>, which will ensure that a<br>
<code>main</code> class with a <code>main()</code> method actually exists<br>
(first rule below).  A class task moves its temporary class type<br>
environment into its class&apos; cell, and then it dissolves itself (second<br>
rule).  A method task simply dissolves when terminated (third rule);<br>
the presence of the <code>tenv</code> cell in that rule ensures that that<br>
task is a method task.<br>
Finally, when all the tasks are cleaned up, we can also remove the<br>
<code>tasks</code> cell, issuing a corresponding message.  Note that<br>
checking for cycles or duplicate methods can still be performed after<br>
the <code>tasks</code> cell has been removed.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token comment">// discard main task when done, issuing a &quot;new main();&quot; command to</span>
<span class="token comment">// make sure that the class main and the method main() are declared.</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>task</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> stmt <span class="token operator">=&gt;</span> new Main<span class="token punctuation">(</span><span class="token punctuation">.</span>Exps<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
              <span class="token punctuation">(</span><span class="token punctuation">.</span>Bag <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tenv</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tenv</span><span class="token punctuation">&gt;</span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>returnType</span><span class="token punctuation">&gt;</span></span> void <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>returnType</span><span class="token punctuation">&gt;</span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>inClass</span><span class="token punctuation">&gt;</span></span> Main <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>inClass</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>task</span><span class="token punctuation">&gt;</span></span>

<span class="token comment">// discard class task when done, adding a ctenv in class</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>task</span><span class="token punctuation">&gt;</span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> stmt <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ctenvT</span><span class="token punctuation">&gt;</span></span> Rho <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ctenvT</span><span class="token punctuation">&gt;</span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>inClass</span><span class="token punctuation">&gt;</span></span> C<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>inClass</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>task</span><span class="token punctuation">&gt;</span></span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Bag<span class="token punctuation">)</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>className</span><span class="token punctuation">&gt;</span></span> C <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>className</span><span class="token punctuation">&gt;</span></span>
        <span class="token punctuation">(</span><span class="token punctuation">.</span>Bag <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ctenv</span><span class="token punctuation">&gt;</span></span> Rho <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ctenv</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>

<span class="token comment">// discard method task when done</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>task</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> stmt <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tenv</span><span class="token punctuation">&gt;</span></span> _ <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tenv</span><span class="token punctuation">&gt;</span></span>  <span class="token comment">// only to ensure that this is a method task</span>
       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>task</span><span class="token punctuation">&gt;</span></span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Bag

<span class="token comment">// cleanup tasks and output a success message when done</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tasks</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Bag <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tasks</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>T</span><span class="token punctuation">&gt;</span></span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Bag<span class="token punctuation">)</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>output</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>List <span class="token operator">=&gt;</span> ListItem<span class="token punctuation">(</span><span class="token string">&quot;Type checked!\n&quot;</span><span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>output</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="kool-specific-auxiliary-declarations-and-operations">KOOL-specific auxiliary declarations and operations</h2>

<h2 class="mume-header" id="subtype-checking">Subtype checking</h2>

<p>The subclass relation introduces a subtyping relation.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> checkSubtype<span class="token punctuation">(</span>Types<span class="token punctuation">,</span>Types<span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> checkSubtype<span class="token punctuation">(</span>T<span class="token punctuation">:</span>Type<span class="token punctuation">,</span> T<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> checkSubtype<span class="token punctuation">(</span>`class`<span class="token punctuation">(</span>C<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">)</span><span class="token punctuation">,</span> `class`<span class="token punctuation">(</span>C&apos;<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>className</span><span class="token punctuation">&gt;</span></span> C <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>className</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>baseClasses</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> SetItem<span class="token punctuation">(</span>C&apos;<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>baseClasses</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> checkSubtype<span class="token punctuation">(</span>Ts1<span class="token operator">-</span>&gt;T2<span class="token punctuation">,</span>Ts1<span class="token string">&apos;-&gt;T2&apos;</span><span class="token punctuation">)</span>
    <span class="token operator">=&gt;</span> checkSubtype<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>T2<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">:</span>Type<span class="token punctuation">,</span>Ts1<span class="token string">&apos;),((T2&apos;</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">:</span>Type<span class="token punctuation">,</span>Ts1<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment">// note that the following rule would be wrong!</span>
<span class="token comment">//  rule checkSubtype(T[],T&apos;[]) =&gt; checkSubtype(T,T&apos;)</span>

  <span class="token keyword keyword-rule">rule</span> checkSubtype<span class="token punctuation">(</span><span class="token punctuation">(</span>T<span class="token punctuation">:</span>Type<span class="token punctuation">,</span>Ts<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>T<span class="token string">&apos;:Type,Ts&apos;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token operator">=&gt;</span> checkSubtype<span class="token punctuation">(</span>T<span class="token punctuation">,</span>T<span class="token string">&apos;) ~&gt; checkSubtype(Ts,Ts&apos;</span><span class="token punctuation">)</span>
    <span class="token keyword keyword-requires">requires</span> Ts <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K <span class="token punctuation">.</span>Types

  <span class="token keyword keyword-rule">rule</span> checkSubtype<span class="token punctuation">(</span><span class="token punctuation">.</span>Types<span class="token punctuation">,</span><span class="token punctuation">.</span>Types<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K
  <span class="token keyword keyword-rule">rule</span> checkSubtype<span class="token punctuation">(</span><span class="token punctuation">.</span>Types<span class="token punctuation">,</span>void<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K
</pre><h2 class="mume-header" id="checking-well-formedness-of-types">Checking well-formedness of types</h2>

<p>Since now any <em><code>Id</code></em> can be used as the type of a class, we need to<br>
check that the types used in the program actually exists</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> checkType<span class="token punctuation">(</span>Types<span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> checkType<span class="token punctuation">(</span>T<span class="token punctuation">:</span>Type<span class="token punctuation">,</span>Ts<span class="token punctuation">:</span>Types<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> checkType<span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> checkType<span class="token punctuation">(</span>Ts<span class="token punctuation">)</span>
    <span class="token keyword keyword-requires">requires</span> Ts <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K <span class="token punctuation">.</span>Types
  <span class="token keyword keyword-rule">rule</span> checkType<span class="token punctuation">(</span><span class="token punctuation">.</span>Types<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K
  <span class="token keyword keyword-rule">rule</span> checkType<span class="token punctuation">(</span>int<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K
  <span class="token keyword keyword-rule">rule</span> checkType<span class="token punctuation">(</span>bool<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K
  <span class="token keyword keyword-rule">rule</span> checkType<span class="token punctuation">(</span>string<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K
  <span class="token keyword keyword-rule">rule</span> checkType<span class="token punctuation">(</span>void<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> checkType<span class="token punctuation">(</span>`class`<span class="token punctuation">(</span>C<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>className</span><span class="token punctuation">&gt;</span></span> C <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>className</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> checkType<span class="token punctuation">(</span>`class`<span class="token punctuation">(</span>Object<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K
  <span class="token keyword keyword-rule">rule</span> checkType<span class="token punctuation">(</span>Ts<span class="token punctuation">:</span>Types <span class="token operator">-</span>&gt; T<span class="token punctuation">:</span>Type<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> checkType<span class="token punctuation">(</span>T<span class="token punctuation">,</span>Ts<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> checkType<span class="token punctuation">(</span>T<span class="token punctuation">:</span>Type<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> checkType<span class="token punctuation">(</span>T<span class="token punctuation">)</span>
</pre><h2 class="mume-header" id="checking-correct-overiding-of-methods">Checking correct  overiding of methods</h2>

<p>The <code>checkMethod</code> operation below searches to see whether<br>
the current method overrides some other method in some superclass.<br>
If yes, then it issues an additional check that the new method&apos;s type<br>
is more concrete than the overridden method&apos;s.  The types <code>T</code> and <code>T&apos;</code><br>
below can only be function types.  See the definition of<br>
<code>checkSubtype</code> on function types at the end of this module (it<br>
is co-variant in the codomain and contra-variant in the domain).</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> checkMethod<span class="token punctuation">(</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span>Type<span class="token punctuation">,</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> checkMethod<span class="token punctuation">(</span>F<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span> T<span class="token punctuation">:</span>Type<span class="token punctuation">,</span> C<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> checkSubtype<span class="token punctuation">(</span>T<span class="token punctuation">,</span> T&apos;<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>className</span><span class="token punctuation">&gt;</span></span> C <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>className</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ctenv</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> F <span class="token operator">|</span><span class="token operator">-</span>&gt; T&apos;<span class="token punctuation">:</span>Type <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ctenv</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> checkMethod<span class="token punctuation">(</span>F<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span> _T<span class="token punctuation">:</span>Type<span class="token punctuation">,</span> <span class="token punctuation">(</span>C<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token operator">=&gt;</span> C&apos;<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>className</span><span class="token punctuation">&gt;</span></span> C <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>className</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>baseClass</span><span class="token punctuation">&gt;</span></span> C&apos;<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>baseClass</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ctenv</span><span class="token punctuation">&gt;</span></span> Rho <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ctenv</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword keyword-requires">requires</span> notBool<span class="token punctuation">(</span>F in keys<span class="token punctuation">(</span>Rho<span class="token punctuation">)</span><span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> checkMethod<span class="token punctuation">(</span>_<span class="token punctuation">:</span><span class="token keyword keyword-Id">Id</span><span class="token punctuation">,</span>_<span class="token punctuation">,</span>Object<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K
</pre><h2 class="mume-header" id="generic-operations-which-could-be-part-of-the-k-framework">Generic operations which could be part of the <strong>K</strong> framework</h2>

<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> stuck<span class="token punctuation">(</span>K<span class="token punctuation">)</span>

  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;discard&quot;</span>
  <span class="token keyword keyword-rule">rule</span> _<span class="token punctuation">:</span>KResult <span class="token operator">~&gt;</span> discard <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K

<span class="token keyword keyword-endmodule">endmodule</span>
</pre></div></div><div id="ebook-heading-part-9-fun-designing-functional-programming-languages" ebook-toc-level-3 heading="Part 9: FUN: Designing Functional Programming Languages"><div><h1 class="mume-header" id="fun-untyped-environment">FUN &#x2014; Untyped &#x2014; Environment</h1>

<p>Author: Grigore Ro&#x219;u (<a href="mailto:grosu@illinois.edu">grosu@illinois.edu</a>)<br>
Organization: University of Illinois at Urbana-Champaign</p>
<p>Author: Traian Florin &#x218;erb&#x103;nu&#x21B;&#x103; (<a href="mailto:traian.serbanuta@unibuc.ro">traian.serbanuta@unibuc.ro</a>)<br>
Organization: University of Bucharest</p>
<h2 class="mume-header" id="abstract">Abstract</h2>

<p>This is the <strong>K</strong> semantic definition of the untyped FUN language.<br>
FUN is a pedagogical and research language that captures the essence<br>
of the functional programming paradigm, extended with several features<br>
often encountered in functional programming languages.<br>
Like many functional languages, FUN is an expression language, that<br>
is, everything, including the main program, is an expression.<br>
Functions can be declared anywhere and are first class values in the<br>
language.<br>
FUN is call-by-value here, but it has been extended (as student<br>
homework assignments) with other parameter-passing styles.<br>
To make it more interesting and to highlight some of <strong>K</strong>&apos;s strengths,<br>
FUN includes the following features:</p>
<ul>
<li>
<p>The basic builtin data-types of integers, booleans and strings.</p>
</li>
<li>
<p>Builtin lists, which can hold any elements, including other lists.<br>
Lists are enclosed in square brackets and their elements are<br>
comma-separated; e.g., <code>[1,2,3]</code>.</p>
</li>
<li>
<p>User-defined data-types, by means of constructor terms.<br>
Constructor names start with a capital letter (while any other<br>
identifier in the language starts with a lowercase letter), and they<br>
can be followed by an arbitrary number of comma-separated arguments<br>
enclosed in parentheses; parentheses are not needed when the<br>
constructor takes no arguments.<br>
For example, <code>Pair(5,7)</code> is a constructor term holding two<br>
numbers, <code>Cons(1,Cons(2,Cons(3,Nil)))</code> is a list-like<br>
constructor term holding 3 elements, and<br>
<code>Tree(Tree(Leaf(1), Leaf(2)), Leaf(3))</code> is a tree-like<br>
constructor term holding 3 elements.<br>
In the untyped version of the FUN language, no type checking or<br>
inference is performed to ensure that the data constructors are used<br>
correctly.<br>
The execution will simply get stuck when they are misused.<br>
Moreover, since no type checking is performed, the data-types are not<br>
even declared in the untyped version of FUN.</p>
</li>
<li>
<p>Functions and <code>let</code>/<code>letrec</code> binders can take<br>
multiple space-separated arguments, but these are desugared to<br>
ones that only take one argument, by currying.  For example, the<br>
expressions</p>
<pre data-role="codeBlock" data-info class="language-"><code>fun x y -&gt; x y
let x y = y in x
</code></pre><p>are desugared, respectively, into the following expressions:</p>
<pre data-role="codeBlock" data-info class="language-"><code>fun x -&gt; fun y -&gt; x y
let x = fun y -&gt; y in x
</code></pre></li>
<li>
<p>Functions can be defined using pattern matching over the<br>
available data-types.  For example, the program</p>
<pre data-role="codeBlock" data-info class="language-"><code>letrec max = fun [h] -&gt; h
             |   [h|t] -&gt; let x = max t
                          in  if h &gt; x then h else x
in max [1, 3, 5, 2, 4, 0, -1, -5]
</code></pre><p>defines a function <code>max</code> that calculates the maximum element of<br>
a non-empty list, and the function</p>
<pre data-role="codeBlock" data-info class="language-"><code>letrec ack = fun Pair(0,n) -&gt; n + 1
             |   Pair(m,0) -&gt; ack Pair(m - 1, 1)
             |   Pair(m,n) -&gt; ack Pair(m - 1, ack Pair(m, n - 1))
in ack Pair(2,3)
</code></pre><p>calculates the Ackermann function applied to a particular pair of numbers.<br>
Patterns can be nested.  Patterns can currently only be used in function<br>
definitions, and not directly in <code>let</code>/<code>letrec</code> binders.<br>
For example, this is not allowed:</p>
<pre data-role="codeBlock" data-info class="language-"><code>letrec Pai(x,y) = Pair(1,2) in x+y
</code></pre><p>But this is allowed:</p>
<pre data-role="codeBlock" data-info class="language-"><code>let f Pair(x,y) = x+y in f Pair(1,2)
</code></pre><p>because it is first reduced to</p>
<pre data-role="codeBlock" data-info class="language-"><code>let f = fun Pair(x,y) -&gt; x+y in f Pair(1,2)
</code></pre><p>by uncurrying of the <code>let</code> binder, and pattern matching is<br>
allowed in function arguments.</p>
</li>
<li>
<p>We include a <code>callcc</code> construct, for two reasons: first,<br>
several functional languages support this construct; second, some<br>
semantic frameworks have difficulties defining it.  Not <strong>K</strong>.</p>
</li>
<li>
<p>Finally, we include mutables by means of referencing an<br>
expression, getting the reference of a variable, dereferencing and<br>
assignment.  We include these for the same reasons as above: there are<br>
languages which have them, and they are not easy to define in some<br>
semantic frameworks.</p>
</li>
</ul>
<p>Like in many other languages, some of FUN&apos;s constructs can be<br>
desugared into a smaller set of basic constructs.  We do that as usual,<br>
using macros, and then we only give semantics to the core constructs.</p>
<p><strong>Note:</strong><br>
We recommend the reader to first consult the dynamic semantics of the<br>
LAMBDA++ language in the first part of the K Tutorial.<br>
To keep the comments below small and focused, we will not re-explain<br>
functional or <strong>K</strong> features that have already been explained in there.</p>
<h2 class="mume-header" id="syntax">Syntax</h2>

<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token comment">//require &quot;modules/pattern-matching.k&quot;</span>

<span class="token keyword keyword-module">module</span> FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
  <span class="token keyword keyword-imports">imports</span> DOMAINS<span class="token operator">-</span>SYNTAX
</pre><p>FUN is an expression language.  The constructs below fall into<br>
several categories: names, arithmetic constructs, conventional<br>
functional constructs, patterns and pattern matching, data constructs,<br>
lists, references, and call-with-current-continuation (callcc).<br>
The arithmetic constructs are standard; they are present in almost all<br>
our <strong>K</strong> language definitions.  The meaning of FUN&apos;s constructs are<br>
discussed in more depth when we define their semantics in the next<br>
module.</p>
<h2 class="mume-header" id="the-syntactic-constructs">The Syntactic Constructs</h2>

<p>We start with the syntactic definition of FUN names.<br>
We have several categories of names: ones to be used for functions and<br>
variables, others to be used for data constructors, others for types and<br>
others for type variables.  We will introduce them as needed, starting<br>
with the former category.  We prefer the names of variables and functions<br>
to start with lower case letters.  We take the freedom to tacitly introduce<br>
syntactic lists/sequences for each nonterminal for which we need them:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Name                                      <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Names <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Name<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>                  <span class="token punctuation">[</span>overload<span class="token punctuation">(</span>exps<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><p>Expression constructs will be defined throughtout the syntax module.<br>
Below are the very basic ones, namely the builtins, the names, and the<br>
parentheses used as brackets for grouping.  Lists of expressions are<br>
declared strict, so all expressions in the list get evaluated whenever<br>
the list is on a position which can be evaluated:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span> <span class="token operator">|</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token operator">|</span> <span class="token keyword keyword-String">String</span> <span class="token operator">|</span> Name
               <span class="token operator">|</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span>                       <span class="token punctuation">[</span><span class="token class-name">bracket</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Exps  <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Exp<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>                   <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> overload<span class="token punctuation">(</span>exps<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Val
  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Val
  <span class="token keyword keyword-syntax">syntax</span> Exps <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Vals
  <span class="token keyword keyword-syntax">syntax</span> Vals <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Val<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>                    <span class="token punctuation">[</span>overload<span class="token punctuation">(</span>exps<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Bottom
  <span class="token keyword keyword-syntax">syntax</span> Bottoms <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Bottom<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>              <span class="token punctuation">[</span>overload<span class="token punctuation">(</span>exps<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><p>We next define the syntax of arithmetic constructs, together with<br>
their relative priorities and left-/non-associativities.  We also<br>
tag all these rules as members of a new group, &quot;arith&quot;, so we can more easily<br>
define global syntax priorities later (at the end of the syntax module).</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token class-name">left</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;*&quot;</span> Exp                       <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> group<span class="token punctuation">(</span>arith<span class="token punctuation">)</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;/&quot;</span> Exp                       <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> group<span class="token punctuation">(</span>arith<span class="token punctuation">)</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;%&quot;</span> Exp                       <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> group<span class="token punctuation">(</span>arith<span class="token punctuation">)</span><span class="token punctuation">]</span>
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;+&quot;</span> Exp                       <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> group<span class="token punctuation">(</span>arith<span class="token punctuation">)</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;^&quot;</span> Exp                       <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> group<span class="token punctuation">(</span>arith<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token comment">// left attribute should not be necessary; currently a parsing bug</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;-&quot;</span> Exp                       <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">prefer</span><span class="token punctuation">,</span> group<span class="token punctuation">(</span>arith<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token comment">// the &quot;prefer&quot; attribute above is to not parse x-1 as x(-1)</span>
<span class="token comment">// Due to some parsing problems, we currently cannot add unary minus:</span>
               <span class="token operator">|</span> <span class="token string">&quot;-&quot;</span> Exp                           <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> group<span class="token punctuation">(</span>arith<span class="token punctuation">)</span><span class="token punctuation">]</span>
               &gt; <span class="token class-name">non-assoc</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;&lt;&quot;</span> Exp                       <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> group<span class="token punctuation">(</span>arith<span class="token punctuation">)</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;&lt;=&quot;</span> Exp                      <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> group<span class="token punctuation">(</span>arith<span class="token punctuation">)</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;&gt;&quot;</span> Exp                       <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> group<span class="token punctuation">(</span>arith<span class="token punctuation">)</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;&gt;=&quot;</span> Exp                      <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> group<span class="token punctuation">(</span>arith<span class="token punctuation">)</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;==&quot;</span> Exp                      <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> group<span class="token punctuation">(</span>arith<span class="token punctuation">)</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;!=&quot;</span> Exp                      <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> group<span class="token punctuation">(</span>arith<span class="token punctuation">)</span><span class="token punctuation">]</span>
               &gt; <span class="token string">&quot;!&quot;</span> Exp                           <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> group<span class="token punctuation">(</span>arith<span class="token punctuation">)</span><span class="token punctuation">]</span>
               &gt; Exp <span class="token string">&quot;&amp;&amp;&quot;</span> Exp                      <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> group<span class="token punctuation">(</span>arith<span class="token punctuation">)</span><span class="token punctuation">]</span>
               &gt; Exp <span class="token string">&quot;||&quot;</span> Exp                      <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> group<span class="token punctuation">(</span>arith<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><p>The conditional construct has the expected evaluation strategy,<br>
stating that only the first argument is evaluate:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;if&quot;</span> Exp <span class="token string">&quot;then&quot;</span> Exp <span class="token string">&quot;else&quot;</span> Exp    <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><p>FUN&apos;s builtin lists are formed by enclosing comma-separated<br>
sequences of expressions (i.e., terms of sort <code>Exps</code>) in square<br>
brackets.  The list constructor <code>cons</code> adds a new element to the<br>
top of the list, <code>head</code> and <code>tail</code> get the first element<br>
and the tail sublist of a list if they exist, respectively, and get<br>
stuck otherwise, and <code>null??</code> tests whether a list is empty or<br>
not; syntactically, these are just expression constants.<br>
In function patterns, we are also going to allow patterns following the<br>
usual head/tail notation; for example, the pattern <code>[x_1,...,x_n|t]</code><br>
binds <code>x_1</code>, ..., <code>x_n</code> to the first elements of the matched list,<br>
and <code>t</code> to the list formed with the remaining elements.  We define list<br>
patterns as ordinary expression constructs, although we will make sure that<br>
we do not give them semantics if they appear in any other place then in a<br>
function case pattern.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;[&quot;</span> Exps <span class="token string">&quot;]&quot;</span>                             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">klabel</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;head&quot;</span> <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token string">&quot;tail&quot;</span> <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token string">&quot;null?&quot;</span> <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;[&quot;</span> Exps <span class="token string">&quot;|&quot;</span> Exp <span class="token string">&quot;]&quot;</span>
  <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;[&quot;</span> Vals <span class="token string">&quot;]&quot;</span>                             <span class="token punctuation">[</span><span class="token class-name">klabel</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Cons <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;cons&quot;</span>
  <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Cons
  <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Cons Val                                 <span class="token punctuation">[</span><span class="token class-name">klabel</span><span class="token punctuation">(</span>apply<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><p>Data constructors start with capital letters and they may or may<br>
not have arguments.  We need to use the attribute &quot;prefer&quot; to make<br>
sure that, e.g., <code>Cons(a)</code> parses as constructor <code>Cons</code> with<br>
argument <code>a</code>, and not as the expression <code>Cons</code> (because<br>
constructor names are also expressions) regarded as a function applied<br>
to the expression <code>a</code>.  Also, note that the constructor is strict<br>
in its second argument, because we want to evaluate its arguments but<br>
not the constuctor name itsef.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> ConstructorName                         <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> ConstructorName
               <span class="token operator">|</span> ConstructorName <span class="token string">&quot;(&quot;</span> Exps <span class="token string">&quot;)&quot;</span>    <span class="token punctuation">[</span><span class="token class-name">prefer</span><span class="token punctuation">,</span> <span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">klabel</span><span class="token punctuation">(</span>constructor<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> ConstructorName <span class="token string">&quot;(&quot;</span> Vals <span class="token string">&quot;)&quot;</span>    <span class="token punctuation">[</span><span class="token class-name">klabel</span><span class="token punctuation">(</span>constructor<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><p>A function is essentially a <code>|</code>-separated ordered<br>
sequence of cases, each case of the form <code>pattern -&gt; expression</code>,<br>
preceded by the language construct <code>fun</code>.  Patterns will be defined<br>
shortly, both for the builtin lists and for user-defined constructors.<br>
Recall that the syntax we define in <strong>K</strong> is not meant to serve as a<br>
ultimate parser for the defined language, but rather as a convenient<br>
notation for <strong>K</strong> abstract syntax trees, which we prefer when we write<br>
the semantic rules.  It is therefore often the case that we define a<br>
more ``generous&apos;&apos; syntax than we want to allow programs to use.<br>
We do it here, too.  Specifically, the syntax of <code>Cases</code><br>
below allows any expressions to appear as pattern.  This syntactic<br>
relaxation permits many wrong programs to be parsed, but that is not a<br>
problem because we are not going to give semantics to wrong combinations,<br>
so those programs will get stuck; moreover, our type inferencer will reject<br>
those programs anyway.  Function application is just concatenation of<br>
expressions, without worrying about type correctness.  Again, the type<br>
system will reject type-incorrect programs.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;fun&quot;</span> Cases
               <span class="token operator">|</span> Exp Exp                              <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> <span class="token class-name">klabel</span><span class="token punctuation">(</span>apply<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token comment">// NOTE: We would like eventually to also have Exp &quot;(&quot; Exps &quot;)</span>
  <span class="token keyword keyword-syntax">syntax</span> Case  <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Exp <span class="token string">&quot;-&gt;&quot;</span> Exp
  <span class="token keyword keyword-syntax">syntax</span> Cases <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Case<span class="token punctuation">,</span> <span class="token string">&quot;|&quot;</span><span class="token punctuation">}</span>
</pre><p>The <code>let</code> and <code>letrec</code> binders have the usual syntax<br>
and functional meaning.  We allow multiple <code>and</code>-separated bindings.<br>
Like for the function cases above, we allow a more generous syntax for<br>
the left-hand sides of bindings, noting that the semantics will get stuck<br>
on incorrect bindings and that the type system will reject those programs.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;let&quot;</span> Bindings <span class="token string">&quot;in&quot;</span> Exp
               <span class="token operator">|</span> <span class="token string">&quot;letrec&quot;</span> Bindings <span class="token string">&quot;in&quot;</span> Exp                 <span class="token punctuation">[</span><span class="token class-name">prefer</span><span class="token punctuation">]</span>
<span class="token comment">// The &quot;prefer&quot; attribute for letrec currently needed due to tool bug,</span>
<span class="token comment">// to make sure that &quot;letrec&quot; is not parsed as &quot;let rec&quot;.</span>
  <span class="token keyword keyword-syntax">syntax</span> Binding  <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Exp <span class="token string">&quot;=&quot;</span> Exp
  <span class="token keyword keyword-syntax">syntax</span> Bindings <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Binding<span class="token punctuation">,</span><span class="token string">&quot;and&quot;</span><span class="token punctuation">}</span>
</pre><p>References are first class values in FUN.  The construct <code>ref</code><br>
takes an expression, evaluates it, and then it stores the resulting value<br>
at a fresh location in the store and returns that reference.  Syntactically,<br>
<code>ref</code> is just an expression constant.  The construct <code>&amp;</code><br>
takes a name as argument and evaluates to a reference, namely the store<br>
reference where the variable passed as argument stores its value; this<br>
construct is a bit controversial and is further discussed in the<br>
environment-based semantics of the FUN language, where we desugar<br>
<code>ref</code> to it.  The construct <code>@</code> takes a reference<br>
and evaluates to the value stored there.  The construct <code>:=</code> takes<br>
two expressions, the first expected to evaluate to a reference; the value<br>
of its second argument will be stored at the location to which the first<br>
points (the old value is thus lost).  Finally, since expression evaluation<br>
now has side effects, it makes sense to also add a sequential composition<br>
construct, which is sequentially strict.  This evaluates to the value of<br>
its second argument; the value of the first argument is lost (which has<br>
therefore been evaluated only for its side effects.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;ref&quot;</span>                             <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;&amp;&quot;</span> Name
               <span class="token operator">|</span> <span class="token string">&quot;@&quot;</span> Exp                                     <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;:=&quot;</span> Exp                                <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;;&quot;</span> Exp                       <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">right</span><span class="token punctuation">]</span>
</pre><p>Call-with-current-continuation, named <code>callcc</code> in FUN, is a<br>
powerful control operator that originated in the Scheme programming<br>
language, but it now exists in many other functional languages.  It works<br>
by evaluating its argument, expected to evaluate to a function, and by<br>
passing the current continuation, or evaluation context (or computation,<br>
in <strong>K</strong> terminology), as a special value to it.  When/If this special value<br>
is invoked, the current context is discarded and replaced with the one<br>
held by the special value and the computation continues from there.<br>
It is like taking a snapshot of the execution context at some moment<br>
in time and then, when desired, being able to get back in time to that<br>
point.  If you like games, it is like saving the game now (so you can<br>
work on your homework!) and then continuing the game tomorrow or whenever<br>
you wish.  To issustrate the strength of <code>callcc</code>, we also<br>
allow exceptions in FUN by means of a conventional <code>try-catch</code><br>
construct, which will desugar to <code>callcc</code>.  We also need to<br>
introduce the special expression contant <code>throw</code>, but we need to<br>
use it as a function argument name in the desugaring macro, so we define<br>
it as a name instead of as an expression constant:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;try&quot;</span> Exp <span class="token string">&quot;catch&quot;</span> <span class="token string">&quot;(&quot;</span> Name <span class="token string">&quot;)&quot;</span> Exp <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;callcc&quot;</span>
  <span class="token keyword keyword-syntax">syntax</span> Name <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;throw&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
</pre><p>Finally, FUN also allows polymorphic datatype declarations.  These<br>
will be useful when we define the type system later on.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;datatype&quot;</span> Type <span class="token string">&quot;=&quot;</span> TypeCases Exp <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
<span class="token comment">// NOTE: In a future version of K, we want the datatype declaration</span>
<span class="token comment">// to be a construct by itself, but that is not possible currently</span>
<span class="token comment">// because K&apos;s parser wronly identifies the __ operation allowing</span>
<span class="token comment">// a declaration to appear in front of an expression with the function</span>
<span class="token comment">// application construct, giving ambiguous parsing errors.</span>
</pre><p>We next need to define the syntax of types and type cases that appear<br>
in datatype declarations.</p>
<p>Like in many functional languages, type parameters/variables in<br>
user-defined types are quoted identifiers.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> TypeVar                        <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> TypeVars <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>TypeVar<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span> <span class="token punctuation">[</span>overload<span class="token punctuation">(</span>types<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><p>Types can be basic types, function types, or user-defined<br>
parametric types.  In the dynamic semantics we are going to simply ignore<br>
all the type declations, so here the syntax of types below is only useful<br>
for generating the desired parser.  To avoid syntactic ambiguities with<br>
the arrow construct for function cases, we use the symbol <code>--&gt;</code> as<br>
a constructor for function types:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> TypeName <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Type <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;int&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;bool&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;string&quot;</span>
                <span class="token operator">|</span> Type <span class="token string">&quot;--&gt;&quot;</span> Type                            <span class="token punctuation">[</span><span class="token class-name">right</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;(&quot;</span> Type <span class="token string">&quot;)&quot;</span>                             <span class="token punctuation">[</span><span class="token class-name">bracket</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> TypeVar
                <span class="token operator">|</span> TypeName             <span class="token punctuation">[</span><span class="token class-name">klabel</span><span class="token punctuation">(</span>TypeName<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">avoid</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> Type TypeName   <span class="token punctuation">[</span><span class="token class-name">klabel</span><span class="token punctuation">(</span>Type<span class="token operator">-</span>TypeName<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">,</span> <span class="token class-name">macro</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;(&quot;</span> Types <span class="token string">&quot;)&quot;</span> TypeName                    <span class="token punctuation">[</span><span class="token class-name">prefer</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Types <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Type<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span> <span class="token punctuation">[</span>overload<span class="token punctuation">(</span>types<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Types <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> TypeVars

  <span class="token keyword keyword-syntax">syntax</span> TypeCase <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> ConstructorName
                    <span class="token operator">|</span> ConstructorName <span class="token string">&quot;(&quot;</span> Types <span class="token string">&quot;)&quot;</span>
  <span class="token keyword keyword-syntax">syntax</span> TypeCases <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>TypeCase<span class="token punctuation">,</span><span class="token string">&quot;|&quot;</span><span class="token punctuation">}</span>     <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>_<span class="token operator">|</span>TypeCase_<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h2 class="mume-header" id="additional-priorities">Additional Priorities</h2>

<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax priority">syntax priority</span> @__FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
                &gt; apply
                &gt; arith
                &gt; _<span class="token punctuation">:</span><span class="token operator">=</span>__FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
                &gt; let_in__FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
                  letrec_in__FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
                  if_then_else__FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
                &gt; _<span class="token punctuation">;</span>__FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
                &gt; fun__FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
                &gt; datatype_<span class="token operator">=</span>___FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>MACROS
  <span class="token keyword keyword-imports">imports</span> FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
</pre><h2 class="mume-header" id="desugaring-macros">Desugaring macros</h2>

<p>We desugar the list non-constructor operations to functions matching<br>
over list patterns.  In order to do that we need some new variables; for<br>
those, we follow the same convention like in the <strong>K</strong> tutorial, where we<br>
added them as new identifier constructs starting with the character <code>$</code>,<br>
so we can easily recognize them when we debug or trace the semantics.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Name <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;$h&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token string">&quot;$t&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> head <span class="token operator">=&gt;</span> fun <span class="token punctuation">[</span>$h<span class="token operator">|</span>$t<span class="token punctuation">]</span> <span class="token operator">-</span>&gt; $h
  <span class="token keyword keyword-rule">rule</span> tail <span class="token operator">=&gt;</span> fun <span class="token punctuation">[</span>$h<span class="token operator">|</span>$t<span class="token punctuation">]</span> <span class="token operator">-</span>&gt; $t
  <span class="token keyword keyword-rule">rule</span> null<span class="token operator">?</span> <span class="token operator">=&gt;</span> fun <span class="token punctuation">[</span><span class="token punctuation">.</span>Exps<span class="token punctuation">]</span> <span class="token operator">-</span>&gt; <span class="token boolean">true</span> <span class="token operator">|</span> <span class="token punctuation">[</span>$h<span class="token operator">|</span>$t<span class="token punctuation">]</span> <span class="token operator">-</span>&gt; <span class="token boolean">false</span>
</pre><p>Multiple-head list patterns desugar into successive one-head patterns:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">[</span>E1<span class="token punctuation">,</span>E2<span class="token punctuation">,</span>Es<span class="token punctuation">:</span>Exps<span class="token operator">|</span>T<span class="token punctuation">]</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span>E1<span class="token operator">|</span><span class="token punctuation">[</span>E2<span class="token punctuation">,</span>Es<span class="token operator">|</span>T<span class="token punctuation">]</span><span class="token punctuation">]</span>                   <span class="token punctuation">[</span>anywhere<span class="token punctuation">]</span>
</pre><p>Uncurrying of multiple arguments in functions and binders:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> P1 P2 <span class="token operator">-</span>&gt; E <span class="token operator">=&gt;</span> P1 <span class="token operator">-</span>&gt; fun P2 <span class="token operator">-</span>&gt; E                       <span class="token punctuation">[</span>anywhere<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> F P <span class="token operator">=</span> E <span class="token operator">=&gt;</span> F <span class="token operator">=</span> fun P <span class="token operator">-</span>&gt; E                             <span class="token punctuation">[</span>anywhere<span class="token punctuation">]</span>
</pre><p>We desugar the <code>try-catch</code> construct into callcc:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Name <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;$k&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token string">&quot;$v&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> try E catch<span class="token punctuation">(</span>X<span class="token punctuation">)</span> E&apos;
    <span class="token operator">=&gt;</span> callcc <span class="token punctuation">(</span>fun $k <span class="token operator">-</span>&gt; <span class="token punctuation">(</span>fun throw <span class="token operator">-</span>&gt; E<span class="token punctuation">)</span><span class="token punctuation">(</span>fun X <span class="token operator">-</span>&gt; $k E&apos;<span class="token punctuation">)</span><span class="token punctuation">)</span>
</pre><p>For uniformity, we reduce all types to their general form:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> `Type<span class="token operator">-</span>TypeName`<span class="token punctuation">(</span>T<span class="token punctuation">:</span>Type<span class="token punctuation">,</span> Tn<span class="token punctuation">:</span>TypeName<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> Tn
</pre><p>The dynamic semantics ignores all the type declarations:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> datatype _T <span class="token operator">=</span> _TCs E <span class="token operator">=&gt;</span> E

<span class="token keyword keyword-endmodule">endmodule</span>


<span class="token keyword keyword-module">module</span> FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
  <span class="token keyword keyword-imports">imports</span> BUILTIN<span class="token operator">-</span>ID<span class="token operator">-</span>TOKENS

  <span class="token keyword keyword-syntax">syntax</span> Name <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> r<span class="token string">&quot;[a-z][_a-zA-Z0-9]*&quot;</span>           <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">,</span> prec<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> #LowerId                        <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> ConstructorName <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> #UpperId             <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> TypeVar  <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> r<span class="token string">&quot;[&apos;][a-z][_a-zA-Z0-9]*&quot;</span>    <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> TypeName <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Name                        <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><h2 class="mume-header" id="semantics">Semantics</h2>

<p>The semantics below is environment-based.  A substitution-based<br>
definition of FUN is also available, but that drops the <code>&amp;</code><br>
construct as explained above.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> FUN<span class="token operator">-</span>UNTYPED
  <span class="token keyword keyword-imports">imports</span> FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
  <span class="token keyword keyword-imports">imports</span> FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>MACROS
  <span class="token keyword keyword-imports">imports</span> DOMAINS
  <span class="token comment">//imports PATTERN-MATCHING</span>
</pre><h2 class="mume-header" id="configuration">Configuration</h2>

<p>The <code>k</code>, <code>env</code>, and <code>store</code> cells are standard<br>
(see, for example, the definition of LAMBDA++ or IMP++ in the first<br>
part of the <strong>K</strong> tutorial).</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-configuration">configuration</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>T</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>yellow<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>green<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> $PGM<span class="token punctuation">:</span>Exp <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>violet<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>white<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>T</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="values-and-results">Values and results</h2>

<p>We only define integers, Booleans and strings as values here, but will<br>
add more values later.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span> <span class="token operator">|</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token operator">|</span> <span class="token keyword keyword-String">String</span>
  <span class="token keyword keyword-syntax">syntax</span> Vals <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Bottoms
  <span class="token keyword keyword-syntax">syntax</span> KResult <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Val
</pre><h2 class="mume-header" id="lookup">Lookup</h2>

<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> X<span class="token punctuation">:</span>Name <span class="token operator">=&gt;</span> V <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> X <span class="token operator">|</span><span class="token operator">-</span>&gt; L <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; V <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="arithmetic-expressions">Arithmetic expressions</h2>

<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">*</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">*</span><span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">/</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">/</span><span class="token keyword keyword-Int">Int</span> I2 <span class="token keyword keyword-requires">requires</span> I2 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K <span class="token number">0</span>
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">%</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">%</span><span class="token keyword keyword-Int">Int</span> I2 <span class="token keyword keyword-requires">requires</span> I2 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K <span class="token number">0</span>
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">+</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> S1 <span class="token operator">^</span> S2 <span class="token operator">=&gt;</span> S1 <span class="token operator">+</span><span class="token keyword keyword-String">String</span> S2
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">-</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> <span class="token operator">-</span> I <span class="token operator">=&gt;</span> <span class="token number">0</span> <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> I
  <span class="token keyword keyword-rule">rule</span> I1 &lt; I2 <span class="token operator">=&gt;</span> I1 &lt;<span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">&lt;=</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">&lt;=</span><span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> I1 &gt; I2 <span class="token operator">=&gt;</span> I1 &gt;<span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">&gt;=</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">&gt;=</span><span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> V1<span class="token punctuation">:</span>Val <span class="token operator">==</span> V2<span class="token punctuation">:</span>Val <span class="token operator">=&gt;</span> V1 <span class="token operator">==</span>K V2
  <span class="token keyword keyword-rule">rule</span> V1<span class="token punctuation">:</span>Val <span class="token operator">!=</span> V2<span class="token punctuation">:</span>Val <span class="token operator">=&gt;</span> V1 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K V2
  <span class="token keyword keyword-rule">rule</span> <span class="token operator">!</span> T <span class="token operator">=&gt;</span> notBool<span class="token punctuation">(</span>T<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">true</span>  <span class="token operator">&amp;&amp;</span> E <span class="token operator">=&gt;</span> E
  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">false</span> <span class="token operator">&amp;&amp;</span> _ <span class="token operator">=&gt;</span> <span class="token boolean">false</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">true</span>  <span class="token operator">||</span> _ <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">false</span> <span class="token operator">||</span> E <span class="token operator">=&gt;</span> E
</pre><h2 class="mume-header" id="conditional">Conditional</h2>

<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> if  <span class="token boolean">true</span> then E else _ <span class="token operator">=&gt;</span> E
  <span class="token keyword keyword-rule">rule</span> if <span class="token boolean">false</span> then _ else E <span class="token operator">=&gt;</span> E
</pre><h2 class="mume-header" id="lists">Lists</h2>

<p>We have already declared the syntactic list of expressions strict, so<br>
we can assume that all the elements that appear in a FUN list are<br>
evaluated.  The only thing left to do is to state that a list of<br>
values is a value itself, that is, that the list square-bracket<br>
construct is indeed a constructor, and to give the semantics of<br>
<code>cons</code>.  Since <code>cons</code> is a builtin function and is<br>
expected to take two arguments, we have to also state that<br>
<code>cons</code> itself is a value (specifically, a function/closure<br>
value, but we do not need that level of detail here), and also that<br>
<code>cons</code> applied to a value is a value (specifically, it would be<br>
a function/closure value that expects the second, list argument):</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> cons V<span class="token punctuation">:</span>Val <span class="token punctuation">[</span>Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">]</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span>V<span class="token punctuation">,</span>Vs<span class="token punctuation">]</span>
</pre><h2 class="mume-header" id="data-constructors">Data Constructors</h2>

<p>Constructors take values as arguments and produce other values:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> ConstructorName
</pre><h2 class="mume-header" id="functions-and-closures">Functions and Closures</h2>

<p>Like in the environment-based semantics of LAMBDA++ in the first part<br>
of the <strong>K</strong> tutorial, functions evaluate to closures.  A closure includes<br>
the current environment besides the function contents; the environment<br>
will be used at execution time to lookup all the variables that appear<br>
free in the function body (we want static scoping in FUN).</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> closure<span class="token punctuation">(</span>Map<span class="token punctuation">,</span>Cases<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> fun Cases <span class="token operator">=&gt;</span> closure<span class="token punctuation">(</span>Rho<span class="token punctuation">,</span>Cases<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Rho <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
</pre><p><strong>Note:</strong> The reader may want to get familiar with<br>
how the pre-defined pattern matching works before proceeding.<br>
The best way to do that is to consult<br>
<code>k/include/modules/pattern-matching.k</code>.</p>
<p>We distinguish two cases when the closure is applied.<br>
If the first pattern matches, then we pick the first case: switch to<br>
the closed environment, get the matching map and bind all its<br>
variables, and finally evaluate the function body of the first case,<br>
making sure that the environment is properly recovered afterwards.<br>
If the first pattern does not match, then we drop it and thus move on<br>
to the next one.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span><span class="token punctuation">.</span>K <span class="token operator">=&gt;</span> getMatching<span class="token punctuation">(</span>P<span class="token punctuation">,</span> V<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">~&gt;</span> closure<span class="token punctuation">(</span>_<span class="token punctuation">,</span> P<span class="token operator">-</span>&gt;_ <span class="token operator">|</span> _<span class="token punctuation">)</span> V<span class="token punctuation">:</span>Val
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> matchResult<span class="token punctuation">(</span>M<span class="token punctuation">:</span>Map<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> closure<span class="token punctuation">(</span>Rho<span class="token punctuation">,</span> _<span class="token operator">-</span>&gt;E <span class="token operator">|</span> _<span class="token punctuation">)</span> _
           <span class="token operator">=&gt;</span> bindMap<span class="token punctuation">(</span>M<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> E <span class="token operator">~&gt;</span> setEnv<span class="token punctuation">(</span>Rho&apos;<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Rho&apos; <span class="token operator">=&gt;</span> Rho <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>matchFailure <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> closure<span class="token punctuation">(</span>_<span class="token punctuation">,</span> <span class="token punctuation">(</span>_<span class="token operator">-</span>&gt;_ <span class="token operator">|</span> Cs<span class="token punctuation">:</span>Cases <span class="token operator">=&gt;</span> Cs<span class="token punctuation">)</span><span class="token punctuation">)</span> _
<span class="token comment">//  rule &lt;k&gt; closure(Rho, P-&gt;E | _) V:Val</span>
<span class="token comment">//           =&gt; bindMap(getMatching(P,V)) ~&gt; E ~&gt; setEnv(Rho&apos;) ...&lt;/k&gt;</span>
<span class="token comment">//       &lt;env&gt; Rho&apos; =&gt; Rho &lt;/env&gt;  when isMatching(P,V)</span>
<span class="token comment">//  rule closure(_, (P-&gt;_ | Cs:Cases =&gt; Cs)) V:Val  when notBool isMatching(P,V)</span>
</pre><h2 class="mume-header" id="let-and-letrec">Let and Letrec</h2>

<p>To highlight the similarities and differences between <code>let</code> and<br>
<code>letrec</code>, we prefer to give them direct semantics instead of<br>
to desugar them like in LAMBDA.  See the formal definitions of<br>
<code>bindTo</code>, <code>bind</code>, and <code>assignTo</code> at the end of<br>
this module.  Informally, <code>bindTo(Xs, Es)</code> first<br>
evaluates the expressions <code>Es</code> in <code>Exps</code> in the current<br>
environment (i.e., it is strict in its second argument), then it binds<br>
the variables in <code>Xs</code> in <code>Names</code> to new locations and adds<br>
those bindings to the environment, and finally writes the values<br>
previously obtained after evaluating the expressions <code>Es</code> to those<br>
new locations; <code>bind(Xs)</code> does only the bindings of<br>
<code>Xs</code> to new locations and adds those bindings to the environment;<br>
and <code>assignTo(Xs,Es)</code> evaluates the expressions<br>
<code>Es</code> in the current environment and then it writes the resulting<br>
values to the locations to which the variables <code>Xs</code> are already<br>
bound to in the environment.</p>
<p>Therefore, <code>let Xs = Es in E</code> first<br>
evaluates <code>Es</code> in the current environment, then adds new<br>
bindings for <code>Xs</code> to fresh locations in the environment, then<br>
writes the values of <code>Es</code> to those locations, and finally<br>
evaluates <code>E</code> in the new environment, making sure that the<br>
environment is properly recovered after the evaluation of <code>E</code>.<br>
On the other hand, <code>letrec</code> does the same things but in a<br>
different order: it first adds new bindings for <code>Xs</code> to fresh<br>
locations in the environment, then it evaluates <code>Es</code> in the new<br>
environment, then it writes the resulting values to their<br>
corresponding locations, and finally it evaluates <code>E</code> and<br>
recovers the environment.  The crucial difference is that the<br>
expressions <code>Es</code> now see the locations of the variables <code>Xs</code><br>
in the environment, so if they are functions, which is typically the<br>
case with <code>letrec</code>, their closures will encapsulate in their<br>
environments the bindings of all the bound variables, including<br>
themselves (thus, we may have a closure value stored at location<br>
<code>L</code>, whose environment contains a binding of the form<br>
<code>F &#x21A6; L</code>; this way, the closure can invoke<br>
itself).</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> let Bs in E
        <span class="token operator">=&gt;</span> bindTo<span class="token punctuation">(</span>names<span class="token punctuation">(</span>Bs<span class="token punctuation">)</span><span class="token punctuation">,</span>exps<span class="token punctuation">(</span>Bs<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">~&gt;</span> E <span class="token operator">~&gt;</span> setEnv<span class="token punctuation">(</span>Rho<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Rho <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> letrec Bs in E
        <span class="token operator">=&gt;</span> bind<span class="token punctuation">(</span>names<span class="token punctuation">(</span>Bs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">~&gt;</span>assignTo<span class="token punctuation">(</span>names<span class="token punctuation">(</span>Bs<span class="token punctuation">)</span><span class="token punctuation">,</span>exps<span class="token punctuation">(</span>Bs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">~&gt;</span>E<span class="token operator">~&gt;</span>setEnv<span class="token punctuation">(</span>Rho<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Rho <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
</pre><p>Recall that our syntax allows <code>let</code> and <code>letrec</code> to<br>
take any expression in place of its binding.  This allows us to use<br>
the already existing function application construct to bind names to<br>
functions, such as, e.g., <code>let x y = y in ...</code>.<br>
The desugaring macro in the syntax module uncurries such declarations,<br>
and then the semantic rules above only work when the remaining<br>
bindings are identifiers, so the semantics will get stuck on programs<br>
that misuse the <code>let</code> and <code>letrec</code> binders.</p>
<h2 class="mume-header" id="references">References</h2>

<p>The semantics of references is self-explanatory, except maybe for the<br>
desugaring rule of <code>ref</code>, which is further discussed.  Note<br>
that <code>&amp;X</code> grabs the location of <code>X</code> from the environment.<br>
Sequential composition, which is needed only to accumulate the<br>
side effects due to assignments, was strict in the first argument.<br>
Once evaluated, its first argument is simply discarded:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Name <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;$x&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> ref <span class="token operator">=&gt;</span> fun $x <span class="token operator">-</span>&gt; <span class="token operator">&amp;</span> $x
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token operator">&amp;</span> X <span class="token operator">=&gt;</span> L <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> X <span class="token operator">|</span><span class="token operator">-</span>&gt; L <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> @ L<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">=&gt;</span> V<span class="token punctuation">:</span>Val <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; V <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> L<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token operator">=</span> V<span class="token punctuation">:</span>Val <span class="token operator">=&gt;</span> V <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; <span class="token punctuation">(</span>_<span class="token operator">=&gt;</span>V<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> _V<span class="token punctuation">:</span>Val<span class="token punctuation">;</span> E <span class="token operator">=&gt;</span> E
</pre><p>The desugaring rule of <code>ref</code> (first rule above) works<br>
because <code>&amp;</code> takes a variable and returns its location (like in C).<br>
Note that some ``pure&apos;&apos; functional programming researchers strongly dislike<br>
the <code>&amp;</code> construct, but favor <code>ref</code>.  We refrain from having<br>
a personal opinion on this issue here, but support <code>&amp;</code> in the<br>
environment-based definition of FUN because it is, technically speaking,<br>
more powerful than <code>ref</code>.  From a language design perspective, it<br>
would be equally easy to drop <code>&amp;</code> and instead give a direct<br>
semantics to <code>ref</code>.  In fact, this is precisely what we do in the<br>
substitution-based definition of FUN, because there appears to be no way<br>
to give a substitution-based definition to the <code>&amp;</code> construct.</p>
<h2 class="mume-header" id="callcc">Callcc</h2>

<p>As we know it from the LAMBDA++ tutorial, call-with-current-continuation<br>
is quite easy to define in <strong>K</strong>.  We first need to define a special<br>
value wrapping an execution context, that is, an environment saying<br>
where the variables should be looked up, and a computation structure<br>
saying what is left to execute (in a substitution-based definition,<br>
this special value would be even simpler, as it would only need to<br>
wrap the computation structure---see, for example, the<br>
substitution-based semantics of LAMBDA++ in the the first part of the<br>
<strong>K</strong> tutorial, or the substitution-based definition of FUN).  Then<br>
<code>callcc</code> creates such a value containing the current<br>
environment and the current remaining computation, and passes it to<br>
its argument function.  When/If invoked, the special value replaces<br>
the current execution context with its own and continues the execution<br>
normally.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> cc<span class="token punctuation">(</span>Map<span class="token punctuation">,</span>K<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span>callcc V<span class="token punctuation">:</span>Val <span class="token operator">=&gt;</span> V cc<span class="token punctuation">(</span>Rho<span class="token punctuation">,</span>K<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">~&gt;</span> K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Rho <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> cc<span class="token punctuation">(</span>Rho<span class="token punctuation">,</span>K<span class="token punctuation">)</span> V<span class="token punctuation">:</span>Val <span class="token operator">~&gt;</span> _ <span class="token operator">=&gt;</span> V <span class="token operator">~&gt;</span> K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> _ <span class="token operator">=&gt;</span> Rho <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="auxiliary-operations">Auxiliary operations</h2>

<h2 class="mume-header" id="environment-recovery">Environment recovery</h2>

<p>The environment recovery operation is the same as for the LAMBDA++<br>
language in the <strong>K</strong> tutorial and many other languages provided with the<br>
<strong>K</strong> distribution.  The first ``anywhere&apos;&apos; rule below shows an elegant<br>
way to achieve the benefits of tail recursion in <strong>K</strong>.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> setEnv<span class="token punctuation">(</span>Map<span class="token punctuation">)</span>  <span class="token comment">// TODO: get rid of env</span>
  <span class="token comment">//rule (setEnv(_) =&gt; .) ~&gt; setEnv(_)  [anywhere]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> _<span class="token punctuation">:</span>Val <span class="token operator">~&gt;</span> <span class="token punctuation">(</span>setEnv<span class="token punctuation">(</span>Rho<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> _ <span class="token operator">=&gt;</span> Rho <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="bindto-bind-and-assignto"><code>bindTo</code>, <code>bind</code> and <code>assignTo</code></h2>

<p>The meaning of these operations has already been explained when we<br>
discussed the <code>let</code> and <code>letrec</code> language constructs<br>
above.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> bindTo<span class="token punctuation">(</span>Names<span class="token punctuation">,</span>Exps<span class="token punctuation">)</span>         <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
                 <span class="token operator">|</span> bindMap<span class="token punctuation">(</span>Map<span class="token punctuation">)</span>
                 <span class="token operator">|</span> bind<span class="token punctuation">(</span>Names<span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span><span class="token punctuation">.</span>K <span class="token operator">=&gt;</span> getMatchingAux<span class="token punctuation">(</span>Xs<span class="token punctuation">,</span>Vs<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">~&gt;</span> bindTo<span class="token punctuation">(</span>Xs<span class="token punctuation">:</span>Names<span class="token punctuation">,</span>Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> matchResult<span class="token punctuation">(</span>M<span class="token punctuation">:</span>Map<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> bindTo<span class="token punctuation">(</span>_<span class="token punctuation">:</span>Names<span class="token punctuation">,</span> _<span class="token punctuation">:</span>Vals<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> bindMap<span class="token punctuation">(</span>M<span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> bindMap<span class="token punctuation">(</span><span class="token punctuation">.</span>Map<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> bindMap<span class="token punctuation">(</span><span class="token punctuation">(</span>X<span class="token punctuation">:</span>Name <span class="token operator">|</span><span class="token operator">-</span>&gt; V<span class="token punctuation">:</span>Val <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Map<span class="token punctuation">)</span> _<span class="token punctuation">:</span>Map<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Rho <span class="token operator">=&gt;</span> Rho<span class="token punctuation">[</span>X &lt;<span class="token operator">-</span> <span class="token operator">!</span>L<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">]</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Map <span class="token operator">=&gt;</span> <span class="token operator">!</span>L <span class="token operator">|</span><span class="token operator">-</span>&gt; V <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> bind<span class="token punctuation">(</span><span class="token punctuation">.</span>Names<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> bind<span class="token punctuation">(</span>X<span class="token punctuation">:</span>Name<span class="token punctuation">,</span>Xs <span class="token operator">=&gt;</span> Xs<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Rho <span class="token operator">=&gt;</span> Rho<span class="token punctuation">[</span>X &lt;<span class="token operator">-</span> <span class="token operator">!</span>_L<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">]</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> assignTo<span class="token punctuation">(</span>Names<span class="token punctuation">,</span>Exps<span class="token punctuation">)</span>  <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> assignTo<span class="token punctuation">(</span><span class="token punctuation">.</span>Names<span class="token punctuation">,</span><span class="token punctuation">.</span>Vals<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> assignTo<span class="token punctuation">(</span><span class="token punctuation">(</span>X<span class="token punctuation">:</span>Name<span class="token punctuation">,</span>Xs <span class="token operator">=&gt;</span> Xs<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>V<span class="token punctuation">:</span>Val<span class="token punctuation">,</span>Vs<span class="token punctuation">:</span>Vals <span class="token operator">=&gt;</span> Vs<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> X <span class="token operator">|</span><span class="token operator">-</span>&gt; L <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Map <span class="token operator">=&gt;</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; V <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="getters">Getters</h2>

<p>The following auxiliary operations extract the list of identifiers<br>
and of expressions in a binding, respectively.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Names <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> names<span class="token punctuation">(</span>Bindings<span class="token punctuation">)</span>  <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> names<span class="token punctuation">(</span><span class="token punctuation">.</span>Bindings<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Names
  <span class="token keyword keyword-rule">rule</span> names<span class="token punctuation">(</span>X<span class="token punctuation">:</span>Name<span class="token operator">=</span>_ and Bs<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>X<span class="token punctuation">,</span>names<span class="token punctuation">(</span>Bs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">:</span>Names

  <span class="token keyword keyword-syntax">syntax</span> Exps <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> exps<span class="token punctuation">(</span>Bindings<span class="token punctuation">)</span>  <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> exps<span class="token punctuation">(</span><span class="token punctuation">.</span>Bindings<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Exps
  <span class="token keyword keyword-rule">rule</span> exps<span class="token punctuation">(</span>_<span class="token punctuation">:</span>Name<span class="token operator">=</span>E and Bs<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> E<span class="token punctuation">,</span>exps<span class="token punctuation">(</span>Bs<span class="token punctuation">)</span>

  <span class="token comment">/* Extra kore stuff */</span>
  <span class="token keyword keyword-syntax">syntax</span> KResult <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Vals
  <span class="token keyword keyword-syntax">syntax</span> Exps <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Names
  <span class="token keyword keyword-syntax">syntax</span> Names <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Bottoms

  <span class="token comment">/* Matching */</span>
  <span class="token keyword keyword-syntax">syntax</span> MatchResult <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> getMatching<span class="token punctuation">(</span>Exp<span class="token punctuation">,</span> Val<span class="token punctuation">)</span>                      <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
                       <span class="token operator">|</span> getMatchingAux<span class="token punctuation">(</span>Exps<span class="token punctuation">,</span> Vals<span class="token punctuation">)</span>                 <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
                       <span class="token operator">|</span> mergeMatching<span class="token punctuation">(</span>MatchResult<span class="token punctuation">,</span> MatchResult<span class="token punctuation">)</span>    <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
                       <span class="token operator">|</span> matchResult<span class="token punctuation">(</span>Map<span class="token punctuation">)</span>
                       <span class="token operator">|</span> <span class="token string">&quot;matchFailure&quot;</span>

  <span class="token keyword keyword-rule">rule</span> getMatching<span class="token punctuation">(</span>C<span class="token punctuation">:</span>ConstructorName<span class="token punctuation">(</span>Es<span class="token punctuation">:</span>Exps<span class="token punctuation">)</span><span class="token punctuation">,</span> C<span class="token punctuation">(</span>Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> getMatchingAux<span class="token punctuation">(</span>Es<span class="token punctuation">,</span> Vs<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> getMatching<span class="token punctuation">(</span><span class="token punctuation">[</span>Es<span class="token punctuation">:</span>Exps<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">]</span><span class="token punctuation">)</span>                   <span class="token operator">=&gt;</span> getMatchingAux<span class="token punctuation">(</span>Es<span class="token punctuation">,</span> Vs<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> getMatching<span class="token punctuation">(</span>C<span class="token punctuation">:</span>ConstructorName<span class="token punctuation">,</span> C<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> matchResult<span class="token punctuation">(</span><span class="token punctuation">.</span>Map<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> getMatching<span class="token punctuation">(</span>B<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span><span class="token punctuation">,</span> B<span class="token punctuation">)</span>            <span class="token operator">=&gt;</span> matchResult<span class="token punctuation">(</span><span class="token punctuation">.</span>Map<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> getMatching<span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> I<span class="token punctuation">)</span>             <span class="token operator">=&gt;</span> matchResult<span class="token punctuation">(</span><span class="token punctuation">.</span>Map<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> getMatching<span class="token punctuation">(</span>S<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span><span class="token punctuation">,</span> S<span class="token punctuation">)</span>          <span class="token operator">=&gt;</span> matchResult<span class="token punctuation">(</span><span class="token punctuation">.</span>Map<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> getMatching<span class="token punctuation">(</span>N<span class="token punctuation">:</span>Name<span class="token punctuation">,</span> V<span class="token punctuation">:</span>Val<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> matchResult<span class="token punctuation">(</span>N <span class="token operator">|</span><span class="token operator">-</span>&gt; V<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> getMatching<span class="token punctuation">(</span>_<span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> matchFailure        <span class="token punctuation">[</span>owise<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> getMatchingAux<span class="token punctuation">(</span><span class="token punctuation">(</span>E<span class="token punctuation">:</span>Exp<span class="token punctuation">,</span> Es<span class="token punctuation">:</span>Exps<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>V<span class="token punctuation">:</span>Val<span class="token punctuation">,</span> Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> mergeMatching<span class="token punctuation">(</span>getMatching<span class="token punctuation">(</span>E<span class="token punctuation">,</span> V<span class="token punctuation">)</span><span class="token punctuation">,</span> getMatchingAux<span class="token punctuation">(</span>Es<span class="token punctuation">,</span> Vs<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> getMatchingAux<span class="token punctuation">(</span><span class="token punctuation">.</span>Exps<span class="token punctuation">,</span> <span class="token punctuation">.</span>Vals<span class="token punctuation">)</span>                       <span class="token operator">=&gt;</span> matchResult<span class="token punctuation">(</span><span class="token punctuation">.</span>Map<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> getMatchingAux<span class="token punctuation">(</span>_<span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> matchFailure     <span class="token punctuation">[</span>owise<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> mergeMatching<span class="token punctuation">(</span>matchResult<span class="token punctuation">(</span>M1<span class="token punctuation">:</span>Map<span class="token punctuation">)</span><span class="token punctuation">,</span> matchResult<span class="token punctuation">(</span>M2<span class="token punctuation">:</span>Map<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> matchResult<span class="token punctuation">(</span>M1 M2<span class="token punctuation">)</span>
    <span class="token keyword keyword-requires">requires</span> intersectSet<span class="token punctuation">(</span>keys<span class="token punctuation">(</span>M1<span class="token punctuation">)</span><span class="token punctuation">,</span> keys<span class="token punctuation">(</span>M2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span>K <span class="token punctuation">.</span>Set
  <span class="token comment">//rule mergeMatching(_, _) =&gt; matchFailure      [owsie]</span>
  <span class="token keyword keyword-rule">rule</span> mergeMatching<span class="token punctuation">(</span>matchResult<span class="token punctuation">(</span>_<span class="token punctuation">:</span>Map<span class="token punctuation">)</span><span class="token punctuation">,</span> matchFailure<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> matchFailure
  <span class="token keyword keyword-rule">rule</span> mergeMatching<span class="token punctuation">(</span>matchFailure<span class="token punctuation">,</span> matchResult<span class="token punctuation">(</span>_<span class="token punctuation">:</span>Map<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> matchFailure
  <span class="token keyword keyword-rule">rule</span> mergeMatching<span class="token punctuation">(</span>matchFailure<span class="token punctuation">,</span> matchFailure<span class="token punctuation">)</span>       <span class="token operator">=&gt;</span> matchFailure
</pre><p>Besides the generic decomposition rules for patterns and values,<br>
we also want to allow <code>[head|tail]</code> matching for lists, so we add<br>
the following custom pattern decomposition rule:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> getMatching<span class="token punctuation">(</span><span class="token punctuation">[</span>H<span class="token punctuation">:</span>Exp <span class="token operator">|</span> T<span class="token punctuation">:</span>Exp<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>V<span class="token punctuation">:</span>Val<span class="token punctuation">,</span> Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token operator">=&gt;</span> getMatchingAux<span class="token punctuation">(</span><span class="token punctuation">(</span>H<span class="token punctuation">,</span> T<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>V<span class="token punctuation">,</span> <span class="token punctuation">[</span>Vs<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>Go to <a href="#ebook-heading-lesson-2-fun-untyped-substitution-based">Lesson 2, FUN untyped, Substitution-Based</a>.</p>
</div></div><div id="ebook-heading-lesson-1-fun-untyped-environment-based" ebook-toc-level-4 heading="Lesson 1, FUN untyped, Environment-Based"><div><h1 class="mume-header" id="fun-untyped-environment">FUN &#x2014; Untyped &#x2014; Environment</h1>

<p>Author: Grigore Ro&#x219;u (<a href="mailto:grosu@illinois.edu">grosu@illinois.edu</a>)<br>
Organization: University of Illinois at Urbana-Champaign</p>
<p>Author: Traian Florin &#x218;erb&#x103;nu&#x21B;&#x103; (<a href="mailto:traian.serbanuta@unibuc.ro">traian.serbanuta@unibuc.ro</a>)<br>
Organization: University of Bucharest</p>
<h2 class="mume-header" id="abstract">Abstract</h2>

<p>This is the <strong>K</strong> semantic definition of the untyped FUN language.<br>
FUN is a pedagogical and research language that captures the essence<br>
of the functional programming paradigm, extended with several features<br>
often encountered in functional programming languages.<br>
Like many functional languages, FUN is an expression language, that<br>
is, everything, including the main program, is an expression.<br>
Functions can be declared anywhere and are first class values in the<br>
language.<br>
FUN is call-by-value here, but it has been extended (as student<br>
homework assignments) with other parameter-passing styles.<br>
To make it more interesting and to highlight some of <strong>K</strong>&apos;s strengths,<br>
FUN includes the following features:</p>
<ul>
<li>
<p>The basic builtin data-types of integers, booleans and strings.</p>
</li>
<li>
<p>Builtin lists, which can hold any elements, including other lists.<br>
Lists are enclosed in square brackets and their elements are<br>
comma-separated; e.g., <code>[1,2,3]</code>.</p>
</li>
<li>
<p>User-defined data-types, by means of constructor terms.<br>
Constructor names start with a capital letter (while any other<br>
identifier in the language starts with a lowercase letter), and they<br>
can be followed by an arbitrary number of comma-separated arguments<br>
enclosed in parentheses; parentheses are not needed when the<br>
constructor takes no arguments.<br>
For example, <code>Pair(5,7)</code> is a constructor term holding two<br>
numbers, <code>Cons(1,Cons(2,Cons(3,Nil)))</code> is a list-like<br>
constructor term holding 3 elements, and<br>
<code>Tree(Tree(Leaf(1), Leaf(2)), Leaf(3))</code> is a tree-like<br>
constructor term holding 3 elements.<br>
In the untyped version of the FUN language, no type checking or<br>
inference is performed to ensure that the data constructors are used<br>
correctly.<br>
The execution will simply get stuck when they are misused.<br>
Moreover, since no type checking is performed, the data-types are not<br>
even declared in the untyped version of FUN.</p>
</li>
<li>
<p>Functions and <code>let</code>/<code>letrec</code> binders can take<br>
multiple space-separated arguments, but these are desugared to<br>
ones that only take one argument, by currying.  For example, the<br>
expressions</p>
<pre data-role="codeBlock" data-info class="language-"><code>fun x y -&gt; x y
let x y = y in x
</code></pre><p>are desugared, respectively, into the following expressions:</p>
<pre data-role="codeBlock" data-info class="language-"><code>fun x -&gt; fun y -&gt; x y
let x = fun y -&gt; y in x
</code></pre></li>
<li>
<p>Functions can be defined using pattern matching over the<br>
available data-types.  For example, the program</p>
<pre data-role="codeBlock" data-info class="language-"><code>letrec max = fun [h] -&gt; h
             |   [h|t] -&gt; let x = max t
                          in  if h &gt; x then h else x
in max [1, 3, 5, 2, 4, 0, -1, -5]
</code></pre><p>defines a function <code>max</code> that calculates the maximum element of<br>
a non-empty list, and the function</p>
<pre data-role="codeBlock" data-info class="language-"><code>letrec ack = fun Pair(0,n) -&gt; n + 1
             |   Pair(m,0) -&gt; ack Pair(m - 1, 1)
             |   Pair(m,n) -&gt; ack Pair(m - 1, ack Pair(m, n - 1))
in ack Pair(2,3)
</code></pre><p>calculates the Ackermann function applied to a particular pair of numbers.<br>
Patterns can be nested.  Patterns can currently only be used in function<br>
definitions, and not directly in <code>let</code>/<code>letrec</code> binders.<br>
For example, this is not allowed:</p>
<pre data-role="codeBlock" data-info class="language-"><code>letrec Pai(x,y) = Pair(1,2) in x+y
</code></pre><p>But this is allowed:</p>
<pre data-role="codeBlock" data-info class="language-"><code>let f Pair(x,y) = x+y in f Pair(1,2)
</code></pre><p>because it is first reduced to</p>
<pre data-role="codeBlock" data-info class="language-"><code>let f = fun Pair(x,y) -&gt; x+y in f Pair(1,2)
</code></pre><p>by uncurrying of the <code>let</code> binder, and pattern matching is<br>
allowed in function arguments.</p>
</li>
<li>
<p>We include a <code>callcc</code> construct, for two reasons: first,<br>
several functional languages support this construct; second, some<br>
semantic frameworks have difficulties defining it.  Not <strong>K</strong>.</p>
</li>
<li>
<p>Finally, we include mutables by means of referencing an<br>
expression, getting the reference of a variable, dereferencing and<br>
assignment.  We include these for the same reasons as above: there are<br>
languages which have them, and they are not easy to define in some<br>
semantic frameworks.</p>
</li>
</ul>
<p>Like in many other languages, some of FUN&apos;s constructs can be<br>
desugared into a smaller set of basic constructs.  We do that as usual,<br>
using macros, and then we only give semantics to the core constructs.</p>
<p><strong>Note:</strong><br>
We recommend the reader to first consult the dynamic semantics of the<br>
LAMBDA++ language in the first part of the K Tutorial.<br>
To keep the comments below small and focused, we will not re-explain<br>
functional or <strong>K</strong> features that have already been explained in there.</p>
<h2 class="mume-header" id="syntax">Syntax</h2>

<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token comment">//require &quot;modules/pattern-matching.k&quot;</span>

<span class="token keyword keyword-module">module</span> FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
  <span class="token keyword keyword-imports">imports</span> DOMAINS<span class="token operator">-</span>SYNTAX
</pre><p>FUN is an expression language.  The constructs below fall into<br>
several categories: names, arithmetic constructs, conventional<br>
functional constructs, patterns and pattern matching, data constructs,<br>
lists, references, and call-with-current-continuation (callcc).<br>
The arithmetic constructs are standard; they are present in almost all<br>
our <strong>K</strong> language definitions.  The meaning of FUN&apos;s constructs are<br>
discussed in more depth when we define their semantics in the next<br>
module.</p>
<h2 class="mume-header" id="the-syntactic-constructs">The Syntactic Constructs</h2>

<p>We start with the syntactic definition of FUN names.<br>
We have several categories of names: ones to be used for functions and<br>
variables, others to be used for data constructors, others for types and<br>
others for type variables.  We will introduce them as needed, starting<br>
with the former category.  We prefer the names of variables and functions<br>
to start with lower case letters.  We take the freedom to tacitly introduce<br>
syntactic lists/sequences for each nonterminal for which we need them:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Name                                      <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Names <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Name<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>                  <span class="token punctuation">[</span>overload<span class="token punctuation">(</span>exps<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><p>Expression constructs will be defined throughtout the syntax module.<br>
Below are the very basic ones, namely the builtins, the names, and the<br>
parentheses used as brackets for grouping.  Lists of expressions are<br>
declared strict, so all expressions in the list get evaluated whenever<br>
the list is on a position which can be evaluated:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span> <span class="token operator">|</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token operator">|</span> <span class="token keyword keyword-String">String</span> <span class="token operator">|</span> Name
               <span class="token operator">|</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span>                       <span class="token punctuation">[</span><span class="token class-name">bracket</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Exps  <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Exp<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>                   <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> overload<span class="token punctuation">(</span>exps<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Val
  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Val
  <span class="token keyword keyword-syntax">syntax</span> Exps <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Vals
  <span class="token keyword keyword-syntax">syntax</span> Vals <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Val<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>                    <span class="token punctuation">[</span>overload<span class="token punctuation">(</span>exps<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Bottom
  <span class="token keyword keyword-syntax">syntax</span> Bottoms <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Bottom<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>              <span class="token punctuation">[</span>overload<span class="token punctuation">(</span>exps<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><p>We next define the syntax of arithmetic constructs, together with<br>
their relative priorities and left-/non-associativities.  We also<br>
tag all these rules as members of a new group, &quot;arith&quot;, so we can more easily<br>
define global syntax priorities later (at the end of the syntax module).</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token class-name">left</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;*&quot;</span> Exp                       <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> group<span class="token punctuation">(</span>arith<span class="token punctuation">)</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;/&quot;</span> Exp                       <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> group<span class="token punctuation">(</span>arith<span class="token punctuation">)</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;%&quot;</span> Exp                       <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> group<span class="token punctuation">(</span>arith<span class="token punctuation">)</span><span class="token punctuation">]</span>
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;+&quot;</span> Exp                       <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> group<span class="token punctuation">(</span>arith<span class="token punctuation">)</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;^&quot;</span> Exp                       <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> group<span class="token punctuation">(</span>arith<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token comment">// left attribute should not be necessary; currently a parsing bug</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;-&quot;</span> Exp                       <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">prefer</span><span class="token punctuation">,</span> group<span class="token punctuation">(</span>arith<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token comment">// the &quot;prefer&quot; attribute above is to not parse x-1 as x(-1)</span>
<span class="token comment">// Due to some parsing problems, we currently cannot add unary minus:</span>
               <span class="token operator">|</span> <span class="token string">&quot;-&quot;</span> Exp                           <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> group<span class="token punctuation">(</span>arith<span class="token punctuation">)</span><span class="token punctuation">]</span>
               &gt; <span class="token class-name">non-assoc</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;&lt;&quot;</span> Exp                       <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> group<span class="token punctuation">(</span>arith<span class="token punctuation">)</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;&lt;=&quot;</span> Exp                      <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> group<span class="token punctuation">(</span>arith<span class="token punctuation">)</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;&gt;&quot;</span> Exp                       <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> group<span class="token punctuation">(</span>arith<span class="token punctuation">)</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;&gt;=&quot;</span> Exp                      <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> group<span class="token punctuation">(</span>arith<span class="token punctuation">)</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;==&quot;</span> Exp                      <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> group<span class="token punctuation">(</span>arith<span class="token punctuation">)</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;!=&quot;</span> Exp                      <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> group<span class="token punctuation">(</span>arith<span class="token punctuation">)</span><span class="token punctuation">]</span>
               &gt; <span class="token string">&quot;!&quot;</span> Exp                           <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> group<span class="token punctuation">(</span>arith<span class="token punctuation">)</span><span class="token punctuation">]</span>
               &gt; Exp <span class="token string">&quot;&amp;&amp;&quot;</span> Exp                      <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> group<span class="token punctuation">(</span>arith<span class="token punctuation">)</span><span class="token punctuation">]</span>
               &gt; Exp <span class="token string">&quot;||&quot;</span> Exp                      <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> group<span class="token punctuation">(</span>arith<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><p>The conditional construct has the expected evaluation strategy,<br>
stating that only the first argument is evaluate:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;if&quot;</span> Exp <span class="token string">&quot;then&quot;</span> Exp <span class="token string">&quot;else&quot;</span> Exp    <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><p>FUN&apos;s builtin lists are formed by enclosing comma-separated<br>
sequences of expressions (i.e., terms of sort <code>Exps</code>) in square<br>
brackets.  The list constructor <code>cons</code> adds a new element to the<br>
top of the list, <code>head</code> and <code>tail</code> get the first element<br>
and the tail sublist of a list if they exist, respectively, and get<br>
stuck otherwise, and <code>null??</code> tests whether a list is empty or<br>
not; syntactically, these are just expression constants.<br>
In function patterns, we are also going to allow patterns following the<br>
usual head/tail notation; for example, the pattern <code>[x_1,...,x_n|t]</code><br>
binds <code>x_1</code>, ..., <code>x_n</code> to the first elements of the matched list,<br>
and <code>t</code> to the list formed with the remaining elements.  We define list<br>
patterns as ordinary expression constructs, although we will make sure that<br>
we do not give them semantics if they appear in any other place then in a<br>
function case pattern.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;[&quot;</span> Exps <span class="token string">&quot;]&quot;</span>                             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">klabel</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;head&quot;</span> <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token string">&quot;tail&quot;</span> <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token string">&quot;null?&quot;</span> <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;[&quot;</span> Exps <span class="token string">&quot;|&quot;</span> Exp <span class="token string">&quot;]&quot;</span>
  <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;[&quot;</span> Vals <span class="token string">&quot;]&quot;</span>                             <span class="token punctuation">[</span><span class="token class-name">klabel</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Cons <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;cons&quot;</span>
  <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Cons
  <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Cons Val                                 <span class="token punctuation">[</span><span class="token class-name">klabel</span><span class="token punctuation">(</span>apply<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><p>Data constructors start with capital letters and they may or may<br>
not have arguments.  We need to use the attribute &quot;prefer&quot; to make<br>
sure that, e.g., <code>Cons(a)</code> parses as constructor <code>Cons</code> with<br>
argument <code>a</code>, and not as the expression <code>Cons</code> (because<br>
constructor names are also expressions) regarded as a function applied<br>
to the expression <code>a</code>.  Also, note that the constructor is strict<br>
in its second argument, because we want to evaluate its arguments but<br>
not the constuctor name itsef.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> ConstructorName                         <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> ConstructorName
               <span class="token operator">|</span> ConstructorName <span class="token string">&quot;(&quot;</span> Exps <span class="token string">&quot;)&quot;</span>    <span class="token punctuation">[</span><span class="token class-name">prefer</span><span class="token punctuation">,</span> <span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">klabel</span><span class="token punctuation">(</span>constructor<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> ConstructorName <span class="token string">&quot;(&quot;</span> Vals <span class="token string">&quot;)&quot;</span>    <span class="token punctuation">[</span><span class="token class-name">klabel</span><span class="token punctuation">(</span>constructor<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><p>A function is essentially a <code>|</code>-separated ordered<br>
sequence of cases, each case of the form <code>pattern -&gt; expression</code>,<br>
preceded by the language construct <code>fun</code>.  Patterns will be defined<br>
shortly, both for the builtin lists and for user-defined constructors.<br>
Recall that the syntax we define in <strong>K</strong> is not meant to serve as a<br>
ultimate parser for the defined language, but rather as a convenient<br>
notation for <strong>K</strong> abstract syntax trees, which we prefer when we write<br>
the semantic rules.  It is therefore often the case that we define a<br>
more ``generous&apos;&apos; syntax than we want to allow programs to use.<br>
We do it here, too.  Specifically, the syntax of <code>Cases</code><br>
below allows any expressions to appear as pattern.  This syntactic<br>
relaxation permits many wrong programs to be parsed, but that is not a<br>
problem because we are not going to give semantics to wrong combinations,<br>
so those programs will get stuck; moreover, our type inferencer will reject<br>
those programs anyway.  Function application is just concatenation of<br>
expressions, without worrying about type correctness.  Again, the type<br>
system will reject type-incorrect programs.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;fun&quot;</span> Cases
               <span class="token operator">|</span> Exp Exp                              <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> <span class="token class-name">klabel</span><span class="token punctuation">(</span>apply<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token comment">// NOTE: We would like eventually to also have Exp &quot;(&quot; Exps &quot;)</span>
  <span class="token keyword keyword-syntax">syntax</span> Case  <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Exp <span class="token string">&quot;-&gt;&quot;</span> Exp
  <span class="token keyword keyword-syntax">syntax</span> Cases <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Case<span class="token punctuation">,</span> <span class="token string">&quot;|&quot;</span><span class="token punctuation">}</span>
</pre><p>The <code>let</code> and <code>letrec</code> binders have the usual syntax<br>
and functional meaning.  We allow multiple <code>and</code>-separated bindings.<br>
Like for the function cases above, we allow a more generous syntax for<br>
the left-hand sides of bindings, noting that the semantics will get stuck<br>
on incorrect bindings and that the type system will reject those programs.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;let&quot;</span> Bindings <span class="token string">&quot;in&quot;</span> Exp
               <span class="token operator">|</span> <span class="token string">&quot;letrec&quot;</span> Bindings <span class="token string">&quot;in&quot;</span> Exp                 <span class="token punctuation">[</span><span class="token class-name">prefer</span><span class="token punctuation">]</span>
<span class="token comment">// The &quot;prefer&quot; attribute for letrec currently needed due to tool bug,</span>
<span class="token comment">// to make sure that &quot;letrec&quot; is not parsed as &quot;let rec&quot;.</span>
  <span class="token keyword keyword-syntax">syntax</span> Binding  <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Exp <span class="token string">&quot;=&quot;</span> Exp
  <span class="token keyword keyword-syntax">syntax</span> Bindings <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Binding<span class="token punctuation">,</span><span class="token string">&quot;and&quot;</span><span class="token punctuation">}</span>
</pre><p>References are first class values in FUN.  The construct <code>ref</code><br>
takes an expression, evaluates it, and then it stores the resulting value<br>
at a fresh location in the store and returns that reference.  Syntactically,<br>
<code>ref</code> is just an expression constant.  The construct <code>&amp;</code><br>
takes a name as argument and evaluates to a reference, namely the store<br>
reference where the variable passed as argument stores its value; this<br>
construct is a bit controversial and is further discussed in the<br>
environment-based semantics of the FUN language, where we desugar<br>
<code>ref</code> to it.  The construct <code>@</code> takes a reference<br>
and evaluates to the value stored there.  The construct <code>:=</code> takes<br>
two expressions, the first expected to evaluate to a reference; the value<br>
of its second argument will be stored at the location to which the first<br>
points (the old value is thus lost).  Finally, since expression evaluation<br>
now has side effects, it makes sense to also add a sequential composition<br>
construct, which is sequentially strict.  This evaluates to the value of<br>
its second argument; the value of the first argument is lost (which has<br>
therefore been evaluated only for its side effects.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;ref&quot;</span>                             <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;&amp;&quot;</span> Name
               <span class="token operator">|</span> <span class="token string">&quot;@&quot;</span> Exp                                     <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;:=&quot;</span> Exp                                <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;;&quot;</span> Exp                       <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">right</span><span class="token punctuation">]</span>
</pre><p>Call-with-current-continuation, named <code>callcc</code> in FUN, is a<br>
powerful control operator that originated in the Scheme programming<br>
language, but it now exists in many other functional languages.  It works<br>
by evaluating its argument, expected to evaluate to a function, and by<br>
passing the current continuation, or evaluation context (or computation,<br>
in <strong>K</strong> terminology), as a special value to it.  When/If this special value<br>
is invoked, the current context is discarded and replaced with the one<br>
held by the special value and the computation continues from there.<br>
It is like taking a snapshot of the execution context at some moment<br>
in time and then, when desired, being able to get back in time to that<br>
point.  If you like games, it is like saving the game now (so you can<br>
work on your homework!) and then continuing the game tomorrow or whenever<br>
you wish.  To issustrate the strength of <code>callcc</code>, we also<br>
allow exceptions in FUN by means of a conventional <code>try-catch</code><br>
construct, which will desugar to <code>callcc</code>.  We also need to<br>
introduce the special expression contant <code>throw</code>, but we need to<br>
use it as a function argument name in the desugaring macro, so we define<br>
it as a name instead of as an expression constant:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;try&quot;</span> Exp <span class="token string">&quot;catch&quot;</span> <span class="token string">&quot;(&quot;</span> Name <span class="token string">&quot;)&quot;</span> Exp <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;callcc&quot;</span>
  <span class="token keyword keyword-syntax">syntax</span> Name <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;throw&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
</pre><p>Finally, FUN also allows polymorphic datatype declarations.  These<br>
will be useful when we define the type system later on.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;datatype&quot;</span> Type <span class="token string">&quot;=&quot;</span> TypeCases Exp <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
<span class="token comment">// NOTE: In a future version of K, we want the datatype declaration</span>
<span class="token comment">// to be a construct by itself, but that is not possible currently</span>
<span class="token comment">// because K&apos;s parser wronly identifies the __ operation allowing</span>
<span class="token comment">// a declaration to appear in front of an expression with the function</span>
<span class="token comment">// application construct, giving ambiguous parsing errors.</span>
</pre><p>We next need to define the syntax of types and type cases that appear<br>
in datatype declarations.</p>
<p>Like in many functional languages, type parameters/variables in<br>
user-defined types are quoted identifiers.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> TypeVar                        <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> TypeVars <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>TypeVar<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span> <span class="token punctuation">[</span>overload<span class="token punctuation">(</span>types<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><p>Types can be basic types, function types, or user-defined<br>
parametric types.  In the dynamic semantics we are going to simply ignore<br>
all the type declations, so here the syntax of types below is only useful<br>
for generating the desired parser.  To avoid syntactic ambiguities with<br>
the arrow construct for function cases, we use the symbol <code>--&gt;</code> as<br>
a constructor for function types:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> TypeName <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Type <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;int&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;bool&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;string&quot;</span>
                <span class="token operator">|</span> Type <span class="token string">&quot;--&gt;&quot;</span> Type                            <span class="token punctuation">[</span><span class="token class-name">right</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;(&quot;</span> Type <span class="token string">&quot;)&quot;</span>                             <span class="token punctuation">[</span><span class="token class-name">bracket</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> TypeVar
                <span class="token operator">|</span> TypeName             <span class="token punctuation">[</span><span class="token class-name">klabel</span><span class="token punctuation">(</span>TypeName<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">avoid</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> Type TypeName   <span class="token punctuation">[</span><span class="token class-name">klabel</span><span class="token punctuation">(</span>Type<span class="token operator">-</span>TypeName<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">symbol</span><span class="token punctuation">,</span> <span class="token class-name">macro</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;(&quot;</span> Types <span class="token string">&quot;)&quot;</span> TypeName                    <span class="token punctuation">[</span><span class="token class-name">prefer</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Types <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Type<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span> <span class="token punctuation">[</span>overload<span class="token punctuation">(</span>types<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Types <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> TypeVars

  <span class="token keyword keyword-syntax">syntax</span> TypeCase <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> ConstructorName
                    <span class="token operator">|</span> ConstructorName <span class="token string">&quot;(&quot;</span> Types <span class="token string">&quot;)&quot;</span>
  <span class="token keyword keyword-syntax">syntax</span> TypeCases <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>TypeCase<span class="token punctuation">,</span><span class="token string">&quot;|&quot;</span><span class="token punctuation">}</span>     <span class="token punctuation">[</span><span class="token class-name">symbol</span><span class="token punctuation">(</span>_<span class="token operator">|</span>TypeCase_<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h2 class="mume-header" id="additional-priorities">Additional Priorities</h2>

<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax priority">syntax priority</span> @__FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
                &gt; apply
                &gt; arith
                &gt; _<span class="token punctuation">:</span><span class="token operator">=</span>__FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
                &gt; let_in__FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
                  letrec_in__FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
                  if_then_else__FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
                &gt; _<span class="token punctuation">;</span>__FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
                &gt; fun__FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
                &gt; datatype_<span class="token operator">=</span>___FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>MACROS
  <span class="token keyword keyword-imports">imports</span> FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
</pre><h2 class="mume-header" id="desugaring-macros">Desugaring macros</h2>

<p>We desugar the list non-constructor operations to functions matching<br>
over list patterns.  In order to do that we need some new variables; for<br>
those, we follow the same convention like in the <strong>K</strong> tutorial, where we<br>
added them as new identifier constructs starting with the character <code>$</code>,<br>
so we can easily recognize them when we debug or trace the semantics.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Name <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;$h&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token string">&quot;$t&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> head <span class="token operator">=&gt;</span> fun <span class="token punctuation">[</span>$h<span class="token operator">|</span>$t<span class="token punctuation">]</span> <span class="token operator">-</span>&gt; $h
  <span class="token keyword keyword-rule">rule</span> tail <span class="token operator">=&gt;</span> fun <span class="token punctuation">[</span>$h<span class="token operator">|</span>$t<span class="token punctuation">]</span> <span class="token operator">-</span>&gt; $t
  <span class="token keyword keyword-rule">rule</span> null<span class="token operator">?</span> <span class="token operator">=&gt;</span> fun <span class="token punctuation">[</span><span class="token punctuation">.</span>Exps<span class="token punctuation">]</span> <span class="token operator">-</span>&gt; <span class="token boolean">true</span> <span class="token operator">|</span> <span class="token punctuation">[</span>$h<span class="token operator">|</span>$t<span class="token punctuation">]</span> <span class="token operator">-</span>&gt; <span class="token boolean">false</span>
</pre><p>Multiple-head list patterns desugar into successive one-head patterns:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">[</span>E1<span class="token punctuation">,</span>E2<span class="token punctuation">,</span>Es<span class="token punctuation">:</span>Exps<span class="token operator">|</span>T<span class="token punctuation">]</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span>E1<span class="token operator">|</span><span class="token punctuation">[</span>E2<span class="token punctuation">,</span>Es<span class="token operator">|</span>T<span class="token punctuation">]</span><span class="token punctuation">]</span>                   <span class="token punctuation">[</span>anywhere<span class="token punctuation">]</span>
</pre><p>Uncurrying of multiple arguments in functions and binders:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> P1 P2 <span class="token operator">-</span>&gt; E <span class="token operator">=&gt;</span> P1 <span class="token operator">-</span>&gt; fun P2 <span class="token operator">-</span>&gt; E                       <span class="token punctuation">[</span>anywhere<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> F P <span class="token operator">=</span> E <span class="token operator">=&gt;</span> F <span class="token operator">=</span> fun P <span class="token operator">-</span>&gt; E                             <span class="token punctuation">[</span>anywhere<span class="token punctuation">]</span>
</pre><p>We desugar the <code>try-catch</code> construct into callcc:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Name <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;$k&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token string">&quot;$v&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> try E catch<span class="token punctuation">(</span>X<span class="token punctuation">)</span> E&apos;
    <span class="token operator">=&gt;</span> callcc <span class="token punctuation">(</span>fun $k <span class="token operator">-</span>&gt; <span class="token punctuation">(</span>fun throw <span class="token operator">-</span>&gt; E<span class="token punctuation">)</span><span class="token punctuation">(</span>fun X <span class="token operator">-</span>&gt; $k E&apos;<span class="token punctuation">)</span><span class="token punctuation">)</span>
</pre><p>For uniformity, we reduce all types to their general form:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> `Type<span class="token operator">-</span>TypeName`<span class="token punctuation">(</span>T<span class="token punctuation">:</span>Type<span class="token punctuation">,</span> Tn<span class="token punctuation">:</span>TypeName<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> Tn
</pre><p>The dynamic semantics ignores all the type declarations:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> datatype _T <span class="token operator">=</span> _TCs E <span class="token operator">=&gt;</span> E

<span class="token keyword keyword-endmodule">endmodule</span>


<span class="token keyword keyword-module">module</span> FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
  <span class="token keyword keyword-imports">imports</span> BUILTIN<span class="token operator">-</span>ID<span class="token operator">-</span>TOKENS

  <span class="token keyword keyword-syntax">syntax</span> Name <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> r<span class="token string">&quot;[a-z][_a-zA-Z0-9]*&quot;</span>           <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">,</span> prec<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> #LowerId                        <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> ConstructorName <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> #UpperId             <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> TypeVar  <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> r<span class="token string">&quot;[&apos;][a-z][_a-zA-Z0-9]*&quot;</span>    <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> TypeName <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Name                        <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><h2 class="mume-header" id="semantics">Semantics</h2>

<p>The semantics below is environment-based.  A substitution-based<br>
definition of FUN is also available, but that drops the <code>&amp;</code><br>
construct as explained above.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> FUN<span class="token operator">-</span>UNTYPED
  <span class="token keyword keyword-imports">imports</span> FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
  <span class="token keyword keyword-imports">imports</span> FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>MACROS
  <span class="token keyword keyword-imports">imports</span> DOMAINS
  <span class="token comment">//imports PATTERN-MATCHING</span>
</pre><h2 class="mume-header" id="configuration">Configuration</h2>

<p>The <code>k</code>, <code>env</code>, and <code>store</code> cells are standard<br>
(see, for example, the definition of LAMBDA++ or IMP++ in the first<br>
part of the <strong>K</strong> tutorial).</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-configuration">configuration</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>T</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>yellow<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>green<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> $PGM<span class="token punctuation">:</span>Exp <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>violet<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>white<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>T</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="values-and-results">Values and results</h2>

<p>We only define integers, Booleans and strings as values here, but will<br>
add more values later.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span> <span class="token operator">|</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token operator">|</span> <span class="token keyword keyword-String">String</span>
  <span class="token keyword keyword-syntax">syntax</span> Vals <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Bottoms
  <span class="token keyword keyword-syntax">syntax</span> KResult <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Val
</pre><h2 class="mume-header" id="lookup">Lookup</h2>

<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> X<span class="token punctuation">:</span>Name <span class="token operator">=&gt;</span> V <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> X <span class="token operator">|</span><span class="token operator">-</span>&gt; L <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; V <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="arithmetic-expressions">Arithmetic expressions</h2>

<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">*</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">*</span><span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">/</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">/</span><span class="token keyword keyword-Int">Int</span> I2 <span class="token keyword keyword-requires">requires</span> I2 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K <span class="token number">0</span>
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">%</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">%</span><span class="token keyword keyword-Int">Int</span> I2 <span class="token keyword keyword-requires">requires</span> I2 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K <span class="token number">0</span>
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">+</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> S1 <span class="token operator">^</span> S2 <span class="token operator">=&gt;</span> S1 <span class="token operator">+</span><span class="token keyword keyword-String">String</span> S2
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">-</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> <span class="token operator">-</span> I <span class="token operator">=&gt;</span> <span class="token number">0</span> <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> I
  <span class="token keyword keyword-rule">rule</span> I1 &lt; I2 <span class="token operator">=&gt;</span> I1 &lt;<span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">&lt;=</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">&lt;=</span><span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> I1 &gt; I2 <span class="token operator">=&gt;</span> I1 &gt;<span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">&gt;=</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">&gt;=</span><span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> V1<span class="token punctuation">:</span>Val <span class="token operator">==</span> V2<span class="token punctuation">:</span>Val <span class="token operator">=&gt;</span> V1 <span class="token operator">==</span>K V2
  <span class="token keyword keyword-rule">rule</span> V1<span class="token punctuation">:</span>Val <span class="token operator">!=</span> V2<span class="token punctuation">:</span>Val <span class="token operator">=&gt;</span> V1 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K V2
  <span class="token keyword keyword-rule">rule</span> <span class="token operator">!</span> T <span class="token operator">=&gt;</span> notBool<span class="token punctuation">(</span>T<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">true</span>  <span class="token operator">&amp;&amp;</span> E <span class="token operator">=&gt;</span> E
  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">false</span> <span class="token operator">&amp;&amp;</span> _ <span class="token operator">=&gt;</span> <span class="token boolean">false</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">true</span>  <span class="token operator">||</span> _ <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">false</span> <span class="token operator">||</span> E <span class="token operator">=&gt;</span> E
</pre><h2 class="mume-header" id="conditional">Conditional</h2>

<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> if  <span class="token boolean">true</span> then E else _ <span class="token operator">=&gt;</span> E
  <span class="token keyword keyword-rule">rule</span> if <span class="token boolean">false</span> then _ else E <span class="token operator">=&gt;</span> E
</pre><h2 class="mume-header" id="lists">Lists</h2>

<p>We have already declared the syntactic list of expressions strict, so<br>
we can assume that all the elements that appear in a FUN list are<br>
evaluated.  The only thing left to do is to state that a list of<br>
values is a value itself, that is, that the list square-bracket<br>
construct is indeed a constructor, and to give the semantics of<br>
<code>cons</code>.  Since <code>cons</code> is a builtin function and is<br>
expected to take two arguments, we have to also state that<br>
<code>cons</code> itself is a value (specifically, a function/closure<br>
value, but we do not need that level of detail here), and also that<br>
<code>cons</code> applied to a value is a value (specifically, it would be<br>
a function/closure value that expects the second, list argument):</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> cons V<span class="token punctuation">:</span>Val <span class="token punctuation">[</span>Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">]</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span>V<span class="token punctuation">,</span>Vs<span class="token punctuation">]</span>
</pre><h2 class="mume-header" id="data-constructors">Data Constructors</h2>

<p>Constructors take values as arguments and produce other values:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> ConstructorName
</pre><h2 class="mume-header" id="functions-and-closures">Functions and Closures</h2>

<p>Like in the environment-based semantics of LAMBDA++ in the first part<br>
of the <strong>K</strong> tutorial, functions evaluate to closures.  A closure includes<br>
the current environment besides the function contents; the environment<br>
will be used at execution time to lookup all the variables that appear<br>
free in the function body (we want static scoping in FUN).</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> closure<span class="token punctuation">(</span>Map<span class="token punctuation">,</span>Cases<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> fun Cases <span class="token operator">=&gt;</span> closure<span class="token punctuation">(</span>Rho<span class="token punctuation">,</span>Cases<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Rho <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
</pre><p><strong>Note:</strong> The reader may want to get familiar with<br>
how the pre-defined pattern matching works before proceeding.<br>
The best way to do that is to consult<br>
<code>k/include/modules/pattern-matching.k</code>.</p>
<p>We distinguish two cases when the closure is applied.<br>
If the first pattern matches, then we pick the first case: switch to<br>
the closed environment, get the matching map and bind all its<br>
variables, and finally evaluate the function body of the first case,<br>
making sure that the environment is properly recovered afterwards.<br>
If the first pattern does not match, then we drop it and thus move on<br>
to the next one.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span><span class="token punctuation">.</span>K <span class="token operator">=&gt;</span> getMatching<span class="token punctuation">(</span>P<span class="token punctuation">,</span> V<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">~&gt;</span> closure<span class="token punctuation">(</span>_<span class="token punctuation">,</span> P<span class="token operator">-</span>&gt;_ <span class="token operator">|</span> _<span class="token punctuation">)</span> V<span class="token punctuation">:</span>Val
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> matchResult<span class="token punctuation">(</span>M<span class="token punctuation">:</span>Map<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> closure<span class="token punctuation">(</span>Rho<span class="token punctuation">,</span> _<span class="token operator">-</span>&gt;E <span class="token operator">|</span> _<span class="token punctuation">)</span> _
           <span class="token operator">=&gt;</span> bindMap<span class="token punctuation">(</span>M<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> E <span class="token operator">~&gt;</span> setEnv<span class="token punctuation">(</span>Rho&apos;<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Rho&apos; <span class="token operator">=&gt;</span> Rho <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>matchFailure <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> closure<span class="token punctuation">(</span>_<span class="token punctuation">,</span> <span class="token punctuation">(</span>_<span class="token operator">-</span>&gt;_ <span class="token operator">|</span> Cs<span class="token punctuation">:</span>Cases <span class="token operator">=&gt;</span> Cs<span class="token punctuation">)</span><span class="token punctuation">)</span> _
<span class="token comment">//  rule &lt;k&gt; closure(Rho, P-&gt;E | _) V:Val</span>
<span class="token comment">//           =&gt; bindMap(getMatching(P,V)) ~&gt; E ~&gt; setEnv(Rho&apos;) ...&lt;/k&gt;</span>
<span class="token comment">//       &lt;env&gt; Rho&apos; =&gt; Rho &lt;/env&gt;  when isMatching(P,V)</span>
<span class="token comment">//  rule closure(_, (P-&gt;_ | Cs:Cases =&gt; Cs)) V:Val  when notBool isMatching(P,V)</span>
</pre><h2 class="mume-header" id="let-and-letrec">Let and Letrec</h2>

<p>To highlight the similarities and differences between <code>let</code> and<br>
<code>letrec</code>, we prefer to give them direct semantics instead of<br>
to desugar them like in LAMBDA.  See the formal definitions of<br>
<code>bindTo</code>, <code>bind</code>, and <code>assignTo</code> at the end of<br>
this module.  Informally, <code>bindTo(Xs, Es)</code> first<br>
evaluates the expressions <code>Es</code> in <code>Exps</code> in the current<br>
environment (i.e., it is strict in its second argument), then it binds<br>
the variables in <code>Xs</code> in <code>Names</code> to new locations and adds<br>
those bindings to the environment, and finally writes the values<br>
previously obtained after evaluating the expressions <code>Es</code> to those<br>
new locations; <code>bind(Xs)</code> does only the bindings of<br>
<code>Xs</code> to new locations and adds those bindings to the environment;<br>
and <code>assignTo(Xs,Es)</code> evaluates the expressions<br>
<code>Es</code> in the current environment and then it writes the resulting<br>
values to the locations to which the variables <code>Xs</code> are already<br>
bound to in the environment.</p>
<p>Therefore, <code>let Xs = Es in E</code> first<br>
evaluates <code>Es</code> in the current environment, then adds new<br>
bindings for <code>Xs</code> to fresh locations in the environment, then<br>
writes the values of <code>Es</code> to those locations, and finally<br>
evaluates <code>E</code> in the new environment, making sure that the<br>
environment is properly recovered after the evaluation of <code>E</code>.<br>
On the other hand, <code>letrec</code> does the same things but in a<br>
different order: it first adds new bindings for <code>Xs</code> to fresh<br>
locations in the environment, then it evaluates <code>Es</code> in the new<br>
environment, then it writes the resulting values to their<br>
corresponding locations, and finally it evaluates <code>E</code> and<br>
recovers the environment.  The crucial difference is that the<br>
expressions <code>Es</code> now see the locations of the variables <code>Xs</code><br>
in the environment, so if they are functions, which is typically the<br>
case with <code>letrec</code>, their closures will encapsulate in their<br>
environments the bindings of all the bound variables, including<br>
themselves (thus, we may have a closure value stored at location<br>
<code>L</code>, whose environment contains a binding of the form<br>
<code>F &#x21A6; L</code>; this way, the closure can invoke<br>
itself).</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> let Bs in E
        <span class="token operator">=&gt;</span> bindTo<span class="token punctuation">(</span>names<span class="token punctuation">(</span>Bs<span class="token punctuation">)</span><span class="token punctuation">,</span>exps<span class="token punctuation">(</span>Bs<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">~&gt;</span> E <span class="token operator">~&gt;</span> setEnv<span class="token punctuation">(</span>Rho<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Rho <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> letrec Bs in E
        <span class="token operator">=&gt;</span> bind<span class="token punctuation">(</span>names<span class="token punctuation">(</span>Bs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">~&gt;</span>assignTo<span class="token punctuation">(</span>names<span class="token punctuation">(</span>Bs<span class="token punctuation">)</span><span class="token punctuation">,</span>exps<span class="token punctuation">(</span>Bs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">~&gt;</span>E<span class="token operator">~&gt;</span>setEnv<span class="token punctuation">(</span>Rho<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Rho <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
</pre><p>Recall that our syntax allows <code>let</code> and <code>letrec</code> to<br>
take any expression in place of its binding.  This allows us to use<br>
the already existing function application construct to bind names to<br>
functions, such as, e.g., <code>let x y = y in ...</code>.<br>
The desugaring macro in the syntax module uncurries such declarations,<br>
and then the semantic rules above only work when the remaining<br>
bindings are identifiers, so the semantics will get stuck on programs<br>
that misuse the <code>let</code> and <code>letrec</code> binders.</p>
<h2 class="mume-header" id="references">References</h2>

<p>The semantics of references is self-explanatory, except maybe for the<br>
desugaring rule of <code>ref</code>, which is further discussed.  Note<br>
that <code>&amp;X</code> grabs the location of <code>X</code> from the environment.<br>
Sequential composition, which is needed only to accumulate the<br>
side effects due to assignments, was strict in the first argument.<br>
Once evaluated, its first argument is simply discarded:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Name <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;$x&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> ref <span class="token operator">=&gt;</span> fun $x <span class="token operator">-</span>&gt; <span class="token operator">&amp;</span> $x
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token operator">&amp;</span> X <span class="token operator">=&gt;</span> L <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> X <span class="token operator">|</span><span class="token operator">-</span>&gt; L <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> @ L<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">=&gt;</span> V<span class="token punctuation">:</span>Val <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; V <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> L<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token operator">=</span> V<span class="token punctuation">:</span>Val <span class="token operator">=&gt;</span> V <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; <span class="token punctuation">(</span>_<span class="token operator">=&gt;</span>V<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> _V<span class="token punctuation">:</span>Val<span class="token punctuation">;</span> E <span class="token operator">=&gt;</span> E
</pre><p>The desugaring rule of <code>ref</code> (first rule above) works<br>
because <code>&amp;</code> takes a variable and returns its location (like in C).<br>
Note that some ``pure&apos;&apos; functional programming researchers strongly dislike<br>
the <code>&amp;</code> construct, but favor <code>ref</code>.  We refrain from having<br>
a personal opinion on this issue here, but support <code>&amp;</code> in the<br>
environment-based definition of FUN because it is, technically speaking,<br>
more powerful than <code>ref</code>.  From a language design perspective, it<br>
would be equally easy to drop <code>&amp;</code> and instead give a direct<br>
semantics to <code>ref</code>.  In fact, this is precisely what we do in the<br>
substitution-based definition of FUN, because there appears to be no way<br>
to give a substitution-based definition to the <code>&amp;</code> construct.</p>
<h2 class="mume-header" id="callcc">Callcc</h2>

<p>As we know it from the LAMBDA++ tutorial, call-with-current-continuation<br>
is quite easy to define in <strong>K</strong>.  We first need to define a special<br>
value wrapping an execution context, that is, an environment saying<br>
where the variables should be looked up, and a computation structure<br>
saying what is left to execute (in a substitution-based definition,<br>
this special value would be even simpler, as it would only need to<br>
wrap the computation structure---see, for example, the<br>
substitution-based semantics of LAMBDA++ in the the first part of the<br>
<strong>K</strong> tutorial, or the substitution-based definition of FUN).  Then<br>
<code>callcc</code> creates such a value containing the current<br>
environment and the current remaining computation, and passes it to<br>
its argument function.  When/If invoked, the special value replaces<br>
the current execution context with its own and continues the execution<br>
normally.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> cc<span class="token punctuation">(</span>Map<span class="token punctuation">,</span>K<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span>callcc V<span class="token punctuation">:</span>Val <span class="token operator">=&gt;</span> V cc<span class="token punctuation">(</span>Rho<span class="token punctuation">,</span>K<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">~&gt;</span> K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Rho <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> cc<span class="token punctuation">(</span>Rho<span class="token punctuation">,</span>K<span class="token punctuation">)</span> V<span class="token punctuation">:</span>Val <span class="token operator">~&gt;</span> _ <span class="token operator">=&gt;</span> V <span class="token operator">~&gt;</span> K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> _ <span class="token operator">=&gt;</span> Rho <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="auxiliary-operations">Auxiliary operations</h2>

<h2 class="mume-header" id="environment-recovery">Environment recovery</h2>

<p>The environment recovery operation is the same as for the LAMBDA++<br>
language in the <strong>K</strong> tutorial and many other languages provided with the<br>
<strong>K</strong> distribution.  The first ``anywhere&apos;&apos; rule below shows an elegant<br>
way to achieve the benefits of tail recursion in <strong>K</strong>.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> setEnv<span class="token punctuation">(</span>Map<span class="token punctuation">)</span>  <span class="token comment">// TODO: get rid of env</span>
  <span class="token comment">//rule (setEnv(_) =&gt; .) ~&gt; setEnv(_)  [anywhere]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> _<span class="token punctuation">:</span>Val <span class="token operator">~&gt;</span> <span class="token punctuation">(</span>setEnv<span class="token punctuation">(</span>Rho<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> _ <span class="token operator">=&gt;</span> Rho <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="bindto-bind-and-assignto"><code>bindTo</code>, <code>bind</code> and <code>assignTo</code></h2>

<p>The meaning of these operations has already been explained when we<br>
discussed the <code>let</code> and <code>letrec</code> language constructs<br>
above.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> bindTo<span class="token punctuation">(</span>Names<span class="token punctuation">,</span>Exps<span class="token punctuation">)</span>         <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
                 <span class="token operator">|</span> bindMap<span class="token punctuation">(</span>Map<span class="token punctuation">)</span>
                 <span class="token operator">|</span> bind<span class="token punctuation">(</span>Names<span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span><span class="token punctuation">.</span>K <span class="token operator">=&gt;</span> getMatchingAux<span class="token punctuation">(</span>Xs<span class="token punctuation">,</span>Vs<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">~&gt;</span> bindTo<span class="token punctuation">(</span>Xs<span class="token punctuation">:</span>Names<span class="token punctuation">,</span>Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> matchResult<span class="token punctuation">(</span>M<span class="token punctuation">:</span>Map<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> bindTo<span class="token punctuation">(</span>_<span class="token punctuation">:</span>Names<span class="token punctuation">,</span> _<span class="token punctuation">:</span>Vals<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> bindMap<span class="token punctuation">(</span>M<span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> bindMap<span class="token punctuation">(</span><span class="token punctuation">.</span>Map<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> bindMap<span class="token punctuation">(</span><span class="token punctuation">(</span>X<span class="token punctuation">:</span>Name <span class="token operator">|</span><span class="token operator">-</span>&gt; V<span class="token punctuation">:</span>Val <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Map<span class="token punctuation">)</span> _<span class="token punctuation">:</span>Map<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Rho <span class="token operator">=&gt;</span> Rho<span class="token punctuation">[</span>X &lt;<span class="token operator">-</span> <span class="token operator">!</span>L<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">]</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Map <span class="token operator">=&gt;</span> <span class="token operator">!</span>L <span class="token operator">|</span><span class="token operator">-</span>&gt; V <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> bind<span class="token punctuation">(</span><span class="token punctuation">.</span>Names<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> bind<span class="token punctuation">(</span>X<span class="token punctuation">:</span>Name<span class="token punctuation">,</span>Xs <span class="token operator">=&gt;</span> Xs<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span> Rho <span class="token operator">=&gt;</span> Rho<span class="token punctuation">[</span>X &lt;<span class="token operator">-</span> <span class="token operator">!</span>_L<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">]</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-syntax">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> assignTo<span class="token punctuation">(</span>Names<span class="token punctuation">,</span>Exps<span class="token punctuation">)</span>  <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> assignTo<span class="token punctuation">(</span><span class="token punctuation">.</span>Names<span class="token punctuation">,</span><span class="token punctuation">.</span>Vals<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>K <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> assignTo<span class="token punctuation">(</span><span class="token punctuation">(</span>X<span class="token punctuation">:</span>Name<span class="token punctuation">,</span>Xs <span class="token operator">=&gt;</span> Xs<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>V<span class="token punctuation">:</span>Val<span class="token punctuation">,</span>Vs<span class="token punctuation">:</span>Vals <span class="token operator">=&gt;</span> Vs<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> X <span class="token operator">|</span><span class="token operator">-</span>&gt; L <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Map <span class="token operator">=&gt;</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; V <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="getters">Getters</h2>

<p>The following auxiliary operations extract the list of identifiers<br>
and of expressions in a binding, respectively.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Names <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> names<span class="token punctuation">(</span>Bindings<span class="token punctuation">)</span>  <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> names<span class="token punctuation">(</span><span class="token punctuation">.</span>Bindings<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Names
  <span class="token keyword keyword-rule">rule</span> names<span class="token punctuation">(</span>X<span class="token punctuation">:</span>Name<span class="token operator">=</span>_ and Bs<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>X<span class="token punctuation">,</span>names<span class="token punctuation">(</span>Bs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">:</span>Names

  <span class="token keyword keyword-syntax">syntax</span> Exps <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> exps<span class="token punctuation">(</span>Bindings<span class="token punctuation">)</span>  <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> exps<span class="token punctuation">(</span><span class="token punctuation">.</span>Bindings<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Exps
  <span class="token keyword keyword-rule">rule</span> exps<span class="token punctuation">(</span>_<span class="token punctuation">:</span>Name<span class="token operator">=</span>E and Bs<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> E<span class="token punctuation">,</span>exps<span class="token punctuation">(</span>Bs<span class="token punctuation">)</span>

  <span class="token comment">/* Extra kore stuff */</span>
  <span class="token keyword keyword-syntax">syntax</span> KResult <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Vals
  <span class="token keyword keyword-syntax">syntax</span> Exps <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Names
  <span class="token keyword keyword-syntax">syntax</span> Names <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Bottoms

  <span class="token comment">/* Matching */</span>
  <span class="token keyword keyword-syntax">syntax</span> MatchResult <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> getMatching<span class="token punctuation">(</span>Exp<span class="token punctuation">,</span> Val<span class="token punctuation">)</span>                      <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
                       <span class="token operator">|</span> getMatchingAux<span class="token punctuation">(</span>Exps<span class="token punctuation">,</span> Vals<span class="token punctuation">)</span>                 <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
                       <span class="token operator">|</span> mergeMatching<span class="token punctuation">(</span>MatchResult<span class="token punctuation">,</span> MatchResult<span class="token punctuation">)</span>    <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
                       <span class="token operator">|</span> matchResult<span class="token punctuation">(</span>Map<span class="token punctuation">)</span>
                       <span class="token operator">|</span> <span class="token string">&quot;matchFailure&quot;</span>

  <span class="token keyword keyword-rule">rule</span> getMatching<span class="token punctuation">(</span>C<span class="token punctuation">:</span>ConstructorName<span class="token punctuation">(</span>Es<span class="token punctuation">:</span>Exps<span class="token punctuation">)</span><span class="token punctuation">,</span> C<span class="token punctuation">(</span>Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> getMatchingAux<span class="token punctuation">(</span>Es<span class="token punctuation">,</span> Vs<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> getMatching<span class="token punctuation">(</span><span class="token punctuation">[</span>Es<span class="token punctuation">:</span>Exps<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">]</span><span class="token punctuation">)</span>                   <span class="token operator">=&gt;</span> getMatchingAux<span class="token punctuation">(</span>Es<span class="token punctuation">,</span> Vs<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> getMatching<span class="token punctuation">(</span>C<span class="token punctuation">:</span>ConstructorName<span class="token punctuation">,</span> C<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> matchResult<span class="token punctuation">(</span><span class="token punctuation">.</span>Map<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> getMatching<span class="token punctuation">(</span>B<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span><span class="token punctuation">,</span> B<span class="token punctuation">)</span>            <span class="token operator">=&gt;</span> matchResult<span class="token punctuation">(</span><span class="token punctuation">.</span>Map<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> getMatching<span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> I<span class="token punctuation">)</span>             <span class="token operator">=&gt;</span> matchResult<span class="token punctuation">(</span><span class="token punctuation">.</span>Map<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> getMatching<span class="token punctuation">(</span>S<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span><span class="token punctuation">,</span> S<span class="token punctuation">)</span>          <span class="token operator">=&gt;</span> matchResult<span class="token punctuation">(</span><span class="token punctuation">.</span>Map<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> getMatching<span class="token punctuation">(</span>N<span class="token punctuation">:</span>Name<span class="token punctuation">,</span> V<span class="token punctuation">:</span>Val<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> matchResult<span class="token punctuation">(</span>N <span class="token operator">|</span><span class="token operator">-</span>&gt; V<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> getMatching<span class="token punctuation">(</span>_<span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> matchFailure        <span class="token punctuation">[</span>owise<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> getMatchingAux<span class="token punctuation">(</span><span class="token punctuation">(</span>E<span class="token punctuation">:</span>Exp<span class="token punctuation">,</span> Es<span class="token punctuation">:</span>Exps<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>V<span class="token punctuation">:</span>Val<span class="token punctuation">,</span> Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> mergeMatching<span class="token punctuation">(</span>getMatching<span class="token punctuation">(</span>E<span class="token punctuation">,</span> V<span class="token punctuation">)</span><span class="token punctuation">,</span> getMatchingAux<span class="token punctuation">(</span>Es<span class="token punctuation">,</span> Vs<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> getMatchingAux<span class="token punctuation">(</span><span class="token punctuation">.</span>Exps<span class="token punctuation">,</span> <span class="token punctuation">.</span>Vals<span class="token punctuation">)</span>                       <span class="token operator">=&gt;</span> matchResult<span class="token punctuation">(</span><span class="token punctuation">.</span>Map<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> getMatchingAux<span class="token punctuation">(</span>_<span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> matchFailure     <span class="token punctuation">[</span>owise<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> mergeMatching<span class="token punctuation">(</span>matchResult<span class="token punctuation">(</span>M1<span class="token punctuation">:</span>Map<span class="token punctuation">)</span><span class="token punctuation">,</span> matchResult<span class="token punctuation">(</span>M2<span class="token punctuation">:</span>Map<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> matchResult<span class="token punctuation">(</span>M1 M2<span class="token punctuation">)</span>
    <span class="token keyword keyword-requires">requires</span> intersectSet<span class="token punctuation">(</span>keys<span class="token punctuation">(</span>M1<span class="token punctuation">)</span><span class="token punctuation">,</span> keys<span class="token punctuation">(</span>M2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span>K <span class="token punctuation">.</span>Set
  <span class="token comment">//rule mergeMatching(_, _) =&gt; matchFailure      [owsie]</span>
  <span class="token keyword keyword-rule">rule</span> mergeMatching<span class="token punctuation">(</span>matchResult<span class="token punctuation">(</span>_<span class="token punctuation">:</span>Map<span class="token punctuation">)</span><span class="token punctuation">,</span> matchFailure<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> matchFailure
  <span class="token keyword keyword-rule">rule</span> mergeMatching<span class="token punctuation">(</span>matchFailure<span class="token punctuation">,</span> matchResult<span class="token punctuation">(</span>_<span class="token punctuation">:</span>Map<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> matchFailure
  <span class="token keyword keyword-rule">rule</span> mergeMatching<span class="token punctuation">(</span>matchFailure<span class="token punctuation">,</span> matchFailure<span class="token punctuation">)</span>       <span class="token operator">=&gt;</span> matchFailure
</pre><p>Besides the generic decomposition rules for patterns and values,<br>
we also want to allow <code>[head|tail]</code> matching for lists, so we add<br>
the following custom pattern decomposition rule:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> getMatching<span class="token punctuation">(</span><span class="token punctuation">[</span>H<span class="token punctuation">:</span>Exp <span class="token operator">|</span> T<span class="token punctuation">:</span>Exp<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>V<span class="token punctuation">:</span>Val<span class="token punctuation">,</span> Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token operator">=&gt;</span> getMatchingAux<span class="token punctuation">(</span><span class="token punctuation">(</span>H<span class="token punctuation">,</span> T<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>V<span class="token punctuation">,</span> <span class="token punctuation">[</span>Vs<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><p>Go to <a href="#ebook-heading-lesson-2-fun-untyped-substitution-based">Lesson 2, FUN untyped, Substitution-Based</a>.</p>
</div></div><div id="ebook-heading-lesson-2-fun-untyped-substitution-based" ebook-toc-level-4 heading="Lesson 2, FUN untyped, Substitution-Based"><div><p>// NOTE: this definition is not up to date with the latest version of K, as it<br>
// uses both substitution and symbolic reasoning.<br>
// It is intended for documentation and academic purposes only.</p>
<h1 class="mume-header" id="fun-untyped-substitution">FUN &#x2014; Untyped &#x2014; Substitution</h1>

<p>Author: Grigore Ro&#x219;u (<a href="mailto:grosu@illinois.edu">grosu@illinois.edu</a>)<br>
Organization: University of Illinois at Urbana-Champaign</p>
<p>Author: Traian Florin &#x218;erb&#x103;nu&#x21B;&#x103; (<a href="mailto:traian.serbanuta@unibuc.ro">traian.serbanuta@unibuc.ro</a>)<br>
Organization: University of Bucharest</p>
<h2 class="mume-header" id="abstract">Abstract</h2>

<p>This is the substitution-based definition of FUN.  For additional<br>
explanations regarding the semantics of the various FUN constructs,<br>
the reader should consult the emvironment-based definition of FUN.</p>
<h2 class="mume-header" id="syntax">Syntax</h2>

<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-requires">requires</span> <span class="token string">&quot;substitution.md&quot;</span>
<span class="token comment">//requires &quot;modules/pattern-matching.k&quot;</span>

<span class="token keyword keyword-module">module</span> FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
  <span class="token keyword keyword-imports">imports</span> DOMAINS<span class="token operator">-</span>SYNTAX
</pre><h2 class="mume-header" id="the-syntactic-constructs">The Syntactic Constructs</h2>

<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Name
  <span class="token keyword keyword-syntax">syntax</span> Names <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Name<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>

  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span> <span class="token operator">|</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token operator">|</span> <span class="token keyword keyword-String">String</span> <span class="token operator">|</span> Name
               <span class="token operator">|</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span>                       <span class="token punctuation">[</span><span class="token class-name">bracket</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Exps  <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Exp<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>                   <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Val
  <span class="token keyword keyword-syntax">syntax</span> Vals <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Val<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>

  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token class-name">left</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;*&quot;</span> Exp                       <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> arith<span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;/&quot;</span> Exp                       <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> arith<span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;%&quot;</span> Exp                       <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> arith<span class="token punctuation">]</span>
               &gt; <span class="token class-name">left</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;+&quot;</span> Exp                       <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> arith<span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;^&quot;</span> Exp                       <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> arith<span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;-&quot;</span> Exp                       <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">prefer</span><span class="token punctuation">,</span> arith<span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;-&quot;</span> Exp                           <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> arith<span class="token punctuation">]</span>
               &gt; <span class="token class-name">non-assoc</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;&lt;&quot;</span> Exp                       <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> arith<span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;&lt;=&quot;</span> Exp                      <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> arith<span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;&gt;&quot;</span> Exp                       <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> arith<span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;&gt;=&quot;</span> Exp                      <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> arith<span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;==&quot;</span> Exp                      <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> arith<span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;!=&quot;</span> Exp                      <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> arith<span class="token punctuation">]</span>
               &gt; <span class="token string">&quot;!&quot;</span> Exp                           <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> arith<span class="token punctuation">]</span>
               &gt; Exp <span class="token string">&quot;&amp;&amp;&quot;</span> Exp                      <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> arith<span class="token punctuation">]</span>
               &gt; Exp <span class="token string">&quot;||&quot;</span> Exp                      <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> arith<span class="token punctuation">]</span>

  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;if&quot;</span> Exp <span class="token string">&quot;then&quot;</span> Exp <span class="token string">&quot;else&quot;</span> Exp    <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;[&quot;</span> Exps <span class="token string">&quot;]&quot;</span>                      <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;cons&quot;</span> <span class="token operator">|</span>  <span class="token string">&quot;head&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;tail&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;null?&quot;</span>
               <span class="token operator">|</span> <span class="token string">&quot;[&quot;</span> Exps <span class="token string">&quot;|&quot;</span> Exp <span class="token string">&quot;]&quot;</span>
  <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;[&quot;</span> Vals <span class="token string">&quot;]&quot;</span>

  <span class="token keyword keyword-syntax">syntax</span> ConstructorName
  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> ConstructorName
               <span class="token operator">|</span> ConstructorName <span class="token string">&quot;(&quot;</span> Exps <span class="token string">&quot;)&quot;</span>      <span class="token punctuation">[</span><span class="token class-name">prefer</span><span class="token punctuation">,</span> <span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> ConstructorName <span class="token string">&quot;(&quot;</span> Vals <span class="token string">&quot;)&quot;</span>

  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;fun&quot;</span> Cases
               <span class="token operator">|</span> Exp Exp                           <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Case  <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Exp <span class="token string">&quot;-&gt;&quot;</span> Exp                    <span class="token punctuation">[</span><span class="token class-name">binder</span><span class="token punctuation">]</span>
<span class="token comment">// NOTE: The binder attribute above is the only difference between this</span>
<span class="token comment">// module and the syntax module of environment-based FUN.  We need</span>
<span class="token comment">// to fix a bug in order to import modules and override the attributes</span>
<span class="token comment">// of operations.</span>
  <span class="token keyword keyword-syntax">syntax</span> Cases <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Case<span class="token punctuation">,</span> <span class="token string">&quot;|&quot;</span><span class="token punctuation">}</span>

  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;let&quot;</span> Bindings <span class="token string">&quot;in&quot;</span> Exp
               <span class="token operator">|</span> <span class="token string">&quot;letrec&quot;</span> Bindings <span class="token string">&quot;in&quot;</span> Exp                 <span class="token punctuation">[</span><span class="token class-name">prefer</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Binding  <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Exp <span class="token string">&quot;=&quot;</span> Exp
  <span class="token keyword keyword-syntax">syntax</span> Bindings <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Binding<span class="token punctuation">,</span><span class="token string">&quot;and&quot;</span><span class="token punctuation">}</span>

  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;ref&quot;</span>
               <span class="token operator">|</span> <span class="token string">&quot;&amp;&quot;</span> Name
               <span class="token operator">|</span> <span class="token string">&quot;@&quot;</span> Exp                           <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;:=&quot;</span> Exp                      <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;;&quot;</span> Exp                       <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">right</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;callcc&quot;</span>
               <span class="token operator">|</span> <span class="token string">&quot;try&quot;</span> Exp <span class="token string">&quot;catch&quot;</span> <span class="token string">&quot;(&quot;</span> Name <span class="token string">&quot;)&quot;</span> Exp
  <span class="token keyword keyword-syntax">syntax</span> Name <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;throw&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;datatype&quot;</span> Type <span class="token string">&quot;=&quot;</span> TypeCases Exp

  <span class="token keyword keyword-syntax">syntax</span> TypeVar
  <span class="token keyword keyword-syntax">syntax</span> TypeVars <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>TypeVar<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>

  <span class="token keyword keyword-syntax">syntax</span> TypeName
  <span class="token keyword keyword-syntax">syntax</span> Type <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;int&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;bool&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;string&quot;</span>
                <span class="token operator">|</span> Type <span class="token string">&quot;--&gt;&quot;</span> Type                            <span class="token punctuation">[</span><span class="token class-name">right</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;(&quot;</span> Type <span class="token string">&quot;)&quot;</span>                             <span class="token punctuation">[</span><span class="token class-name">bracket</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> TypeVar
                <span class="token operator">|</span> TypeName             <span class="token punctuation">[</span><span class="token class-name">klabel</span><span class="token punctuation">(</span>TypeName<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">avoid</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> Type TypeName   <span class="token punctuation">[</span><span class="token class-name">klabel</span><span class="token punctuation">(</span>Type<span class="token operator">-</span>TypeName<span class="token punctuation">)</span><span class="token punctuation">,</span> onlyLabel<span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;(&quot;</span> Types <span class="token string">&quot;)&quot;</span> TypeName                    <span class="token punctuation">[</span><span class="token class-name">prefer</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Types <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Type<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>
  <span class="token keyword keyword-syntax">syntax</span> Types <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> TypeVars

  <span class="token keyword keyword-syntax">syntax</span> TypeCase <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> ConstructorName
                    <span class="token operator">|</span> ConstructorName <span class="token string">&quot;(&quot;</span> Types <span class="token string">&quot;)&quot;</span>
  <span class="token keyword keyword-syntax">syntax</span> TypeCases <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>TypeCase<span class="token punctuation">,</span><span class="token string">&quot;|&quot;</span><span class="token punctuation">}</span>     <span class="token punctuation">[</span><span class="token class-name">klabel</span><span class="token punctuation">(</span>_<span class="token operator">|</span>TypeCase_<span class="token punctuation">)</span><span class="token punctuation">]</span>
</pre><h2 class="mume-header" id="additional-priorities">Additional Priorities</h2>

<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax priority">syntax priority</span> @__FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
                &gt; ___FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
                &gt; arith
                &gt; _<span class="token punctuation">:</span><span class="token operator">=</span>__FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
                &gt; let_in__FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
                  letrec_in__FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
                  if_then_else__FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
                &gt; _<span class="token punctuation">;</span>__FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
                &gt; fun__FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
                &gt; datatype_<span class="token operator">=</span>___FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>MACROS
  <span class="token keyword keyword-imports">imports</span> FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
</pre><h2 class="mume-header" id="desugaring-macros">Desugaring macros</h2>

<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> P1 P2 <span class="token operator">-</span>&gt; E <span class="token operator">=&gt;</span> P1 <span class="token operator">-</span>&gt; fun P2 <span class="token operator">-</span>&gt; E                       <span class="token punctuation">[</span><span class="token class-name">macro-rec</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> F P <span class="token operator">=</span> E <span class="token operator">=&gt;</span> F <span class="token operator">=</span> fun P <span class="token operator">-</span>&gt; E                             <span class="token punctuation">[</span><span class="token class-name">macro-rec</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">[</span>E1<span class="token punctuation">,</span>E2<span class="token punctuation">,</span>Es<span class="token punctuation">:</span>Exps<span class="token operator">|</span>T<span class="token punctuation">]</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span>E1<span class="token operator">|</span><span class="token punctuation">[</span>E2<span class="token punctuation">,</span>Es<span class="token operator">|</span>T<span class="token punctuation">]</span><span class="token punctuation">]</span>                   <span class="token punctuation">[</span><span class="token class-name">macro-rec</span><span class="token punctuation">]</span>

<span class="token comment">//  rule &apos;TypeName(Tn:TypeName) =&gt; (.TypeVars) Tn              [macro]</span>
  <span class="token keyword keyword-rule">rule</span> `Type<span class="token operator">-</span>TypeName`<span class="token punctuation">(</span>T<span class="token punctuation">:</span>Type<span class="token punctuation">,</span> Tn<span class="token punctuation">:</span>TypeName<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> Tn          <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-syntax">syntax</span> Name <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;$h&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;$t&quot;</span>
  <span class="token keyword keyword-rule">rule</span> head <span class="token operator">=&gt;</span> fun <span class="token punctuation">[</span>$h<span class="token operator">|</span>$t<span class="token punctuation">]</span> <span class="token operator">-</span>&gt; $h                             <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> tail <span class="token operator">=&gt;</span> fun <span class="token punctuation">[</span>$h<span class="token operator">|</span>$t<span class="token punctuation">]</span> <span class="token operator">-</span>&gt; $t                             <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> null<span class="token operator">?</span> <span class="token operator">=&gt;</span> fun <span class="token punctuation">[</span><span class="token punctuation">.</span>Exps<span class="token punctuation">]</span> <span class="token operator">-</span>&gt; <span class="token boolean">true</span> <span class="token operator">|</span> <span class="token punctuation">[</span>$h<span class="token operator">|</span>$t<span class="token punctuation">]</span> <span class="token operator">-</span>&gt; <span class="token boolean">false</span>       <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-syntax">syntax</span> Name <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;$k&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;$v&quot;</span>
  <span class="token keyword keyword-rule">rule</span> try E catch<span class="token punctuation">(</span>X<span class="token punctuation">)</span> E&apos;
    <span class="token operator">=&gt;</span> callcc <span class="token punctuation">(</span>fun $k <span class="token operator">-</span>&gt; <span class="token punctuation">(</span>fun throw <span class="token operator">-</span>&gt; E<span class="token punctuation">)</span><span class="token punctuation">(</span>fun X <span class="token operator">-</span>&gt; $k E&apos;<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> datatype _T <span class="token operator">=</span> _TCs E <span class="token operator">=&gt;</span> E                               <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
</pre><p>mu needed for letrec, but we put it here so we can also write<br>
programs with mu in them, which is particularly useful for testing.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;mu&quot;</span> Case

<span class="token keyword keyword-endmodule">endmodule</span>


<span class="token keyword keyword-module">module</span> FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
  <span class="token keyword keyword-imports">imports</span> BUILTIN<span class="token operator">-</span>ID<span class="token operator">-</span>TOKENS

  <span class="token keyword keyword-syntax">syntax</span> Name <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> r<span class="token string">&quot;[a-z][_a-zA-Z0-9]*&quot;</span>            <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">,</span> prec<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> #LowerId                         <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> ConstructorName <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> #UpperId              <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> TypeVar  <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> r<span class="token string">&quot;[&apos;][a-z][_a-zA-Z0-9]*&quot;</span>     <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> TypeName <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Name                         <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre><h2 class="mume-header" id="semantics">Semantics</h2>

<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-module">module</span> FUN<span class="token operator">-</span>UNTYPED
  <span class="token keyword keyword-imports">imports</span> FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
  <span class="token keyword keyword-imports">imports</span> FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>MACROS
  <span class="token keyword keyword-imports">imports</span> DOMAINS
  <span class="token keyword keyword-imports">imports</span> SUBSTITUTION
  <span class="token comment">//imports PATTERN-MATCHING</span>

  <span class="token keyword keyword-configuration">configuration</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>T</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>yellow<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>green<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> $PGM<span class="token punctuation">:</span>Exp <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>white<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>T</span><span class="token punctuation">&gt;</span></span>
</pre><p>Both Name and functions are values now:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword keyword-Int">Int</span> <span class="token operator">|</span> <span class="token keyword keyword-Bool">Bool</span> <span class="token operator">|</span> <span class="token keyword keyword-String">String</span> <span class="token operator">|</span> Name
  <span class="token keyword keyword-syntax">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Val
  <span class="token keyword keyword-syntax">syntax</span> Exps <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Vals
  <span class="token keyword keyword-syntax">syntax</span> KResult <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Val
  <span class="token keyword keyword-syntax">syntax</span> Exps <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Names
  <span class="token keyword keyword-syntax">syntax</span> Vals <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Names

  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">*</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">*</span><span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">/</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">/</span><span class="token keyword keyword-Int">Int</span> I2 when I2 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K <span class="token number">0</span>
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">%</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">%</span><span class="token keyword keyword-Int">Int</span> I2 when I2 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K <span class="token number">0</span>
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">+</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">+</span><span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> S1 <span class="token operator">^</span> S2 <span class="token operator">=&gt;</span> S1 <span class="token operator">+</span><span class="token keyword keyword-String">String</span> S2
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">-</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> <span class="token operator">-</span> I <span class="token operator">=&gt;</span> <span class="token number">0</span> <span class="token operator">-</span><span class="token keyword keyword-Int">Int</span> I
  <span class="token keyword keyword-rule">rule</span> I1 &lt; I2 <span class="token operator">=&gt;</span> I1 &lt;<span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">&lt;=</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">&lt;=</span><span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> I1 &gt; I2 <span class="token operator">=&gt;</span> I1 &gt;<span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> I1 <span class="token operator">&gt;=</span> I2 <span class="token operator">=&gt;</span> I1 <span class="token operator">&gt;=</span><span class="token keyword keyword-Int">Int</span> I2
  <span class="token keyword keyword-rule">rule</span> V1<span class="token punctuation">:</span>Val <span class="token operator">==</span> V2<span class="token punctuation">:</span>Val <span class="token operator">=&gt;</span> V1 <span class="token operator">==</span>K V2
  <span class="token keyword keyword-rule">rule</span> V1<span class="token punctuation">:</span>Val <span class="token operator">!=</span> V2<span class="token punctuation">:</span>Val <span class="token operator">=&gt;</span> V1 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K V2
  <span class="token keyword keyword-rule">rule</span> <span class="token operator">!</span> T <span class="token operator">=&gt;</span> notBool<span class="token punctuation">(</span>T<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">true</span>  <span class="token operator">&amp;&amp;</span> E <span class="token operator">=&gt;</span> E
  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">false</span> <span class="token operator">&amp;&amp;</span> _ <span class="token operator">=&gt;</span> <span class="token boolean">false</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">true</span>  <span class="token operator">||</span> _ <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token boolean">false</span> <span class="token operator">||</span> E <span class="token operator">=&gt;</span> E

  <span class="token keyword keyword-rule">rule</span> if  <span class="token boolean">true</span> then E else _ <span class="token operator">=&gt;</span> E
  <span class="token keyword keyword-rule">rule</span> if <span class="token boolean">false</span> then _ else E <span class="token operator">=&gt;</span> E

  <span class="token keyword keyword-rule">rule</span> isVal<span class="token punctuation">(</span>cons<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
  <span class="token keyword keyword-rule">rule</span> isVal<span class="token punctuation">(</span>cons _V<span class="token punctuation">:</span>Val<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
  <span class="token keyword keyword-rule">rule</span> cons V<span class="token punctuation">:</span>Val <span class="token punctuation">[</span>Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">]</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span>V<span class="token punctuation">,</span>Vs<span class="token punctuation">]</span>

  <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> ConstructorName

  <span class="token keyword keyword-rule">rule</span> isVal<span class="token punctuation">(</span>fun _<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
  <span class="token keyword keyword-syntax">syntax</span> KVar <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Name
  <span class="token keyword keyword-syntax">syntax</span> Name <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> freshName<span class="token punctuation">(</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span>    <span class="token punctuation">[</span>freshGenerator<span class="token punctuation">,</span> function<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> freshName<span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>#parseToken<span class="token punctuation">(</span><span class="token string">&quot;Name&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;#&quot;</span> <span class="token operator">+</span><span class="token keyword keyword-String">String</span> Int2String<span class="token punctuation">(</span>I<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">:</span>&gt;Name

  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span><span class="token punctuation">.</span> <span class="token operator">=&gt;</span> getMatching<span class="token punctuation">(</span>P<span class="token punctuation">,</span> V<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">~&gt;</span> <span class="token punctuation">(</span>fun P<span class="token operator">-</span>&gt;_ <span class="token operator">|</span> _<span class="token punctuation">)</span> V<span class="token punctuation">:</span>Val
  <span class="token keyword keyword-rule">rule</span> matchResult<span class="token punctuation">(</span>M<span class="token punctuation">:</span>Map<span class="token punctuation">)</span> <span class="token operator">~&gt;</span> <span class="token punctuation">(</span>fun _<span class="token operator">-</span>&gt;E <span class="token operator">|</span> _<span class="token punctuation">)</span> _ <span class="token operator">=&gt;</span> E<span class="token punctuation">[</span>M<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">(</span>matchFailure <span class="token operator">=&gt;</span> <span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token operator">~&gt;</span> <span class="token punctuation">(</span>fun <span class="token punctuation">(</span>_<span class="token operator">-</span>&gt;_ <span class="token operator">|</span> Cs<span class="token punctuation">:</span>Cases <span class="token operator">=&gt;</span> Cs<span class="token punctuation">)</span><span class="token punctuation">)</span> _
<span class="token comment">//  rule (fun P-&gt;E | _) V:Val =&gt; E[getMatching(P,V)]  when isMatching(P,V)</span>
<span class="token comment">//  rule (fun (P-&gt;_ | Cs:Cases =&gt; Cs)) V:Val  when notBool isMatching(P,V)</span>
</pre><p>We can reduce multiple bindings to one list binding, and then<br>
apply the usual desugaring of let into function application.<br>
It is important that the rule below is a macro, so let is eliminated<br>
immediately, otherwise it may interfere in ugly ways with substitution.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> let Bs in E <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fun <span class="token punctuation">[</span>names<span class="token punctuation">(</span>Bs<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">-</span>&gt; E<span class="token punctuation">)</span> <span class="token punctuation">[</span>exps<span class="token punctuation">(</span>Bs<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
</pre><p>We only give the semantics of one-binding letrec.<br>
Multipe bindings are left as an exercise.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token comment">// changed because of parsing error</span>
  <span class="token comment">//rule mu X:Name -&gt; E =&gt; E[(mu X -&gt; E) / X]</span>
  <span class="token keyword keyword-rule">rule</span> mu X<span class="token punctuation">:</span>Name <span class="token operator">-</span>&gt; E <span class="token operator">=&gt;</span> E<span class="token punctuation">[</span>X <span class="token operator">|</span><span class="token operator">-</span>&gt; <span class="token punctuation">(</span>mu X <span class="token operator">-</span>&gt; E<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> letrec F<span class="token punctuation">:</span>Name <span class="token operator">=</span> E in E<span class="token string">&apos; =&gt; let F = (mu F -&gt; E) in E&apos;</span>  <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
</pre><p>We cannot have <code>&amp;</code> anymore, but we can give direct<br>
semantics to <code>ref</code>.  We also have to declare <code>ref</code> to<br>
be a value, so that we will never heat on it.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token comment">//  rule &lt;k&gt; &amp; X =&gt; L ...&lt;/k&gt;  &lt;env&gt;... X |-&gt; L &lt;/env&gt;</span>
  <span class="token keyword keyword-rule">rule</span> isVal<span class="token punctuation">(</span>ref<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> ref V<span class="token punctuation">:</span>Val <span class="token operator">=&gt;</span> <span class="token operator">!</span>L<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Map <span class="token operator">=&gt;</span> <span class="token operator">!</span>L <span class="token operator">|</span><span class="token operator">-</span>&gt; V <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> @ L<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token operator">=&gt;</span> V<span class="token punctuation">:</span>Val <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; V <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> L<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span> <span class="token punctuation">:</span><span class="token operator">=</span> V<span class="token punctuation">:</span>Val <span class="token operator">=&gt;</span> V <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> L <span class="token operator">|</span><span class="token operator">-</span>&gt; <span class="token punctuation">(</span>_<span class="token operator">=&gt;</span>V<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>store</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> _V<span class="token punctuation">:</span>Val<span class="token punctuation">;</span> E <span class="token operator">=&gt;</span> E

  <span class="token keyword keyword-syntax">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> cc<span class="token punctuation">(</span>K<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> isVal<span class="token punctuation">(</span>callcc<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span>callcc V<span class="token punctuation">:</span>Val <span class="token operator">=&gt;</span> V cc<span class="token punctuation">(</span>K<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">~&gt;</span> K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> cc<span class="token punctuation">(</span>K<span class="token punctuation">)</span> V<span class="token punctuation">:</span>Val <span class="token operator">~&gt;</span> _ <span class="token operator">=&gt;</span> V <span class="token operator">~&gt;</span> K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
</pre><p>Auxiliary getters</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Names <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> names<span class="token punctuation">(</span>Bindings<span class="token punctuation">)</span>  <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> names<span class="token punctuation">(</span><span class="token punctuation">.</span>Bindings<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Names
  <span class="token keyword keyword-rule">rule</span> names<span class="token punctuation">(</span>X<span class="token punctuation">:</span>Name<span class="token operator">=</span>_ and Bs<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> X<span class="token punctuation">,</span>names<span class="token punctuation">(</span>Bs<span class="token punctuation">)</span>

  <span class="token keyword keyword-syntax">syntax</span> Exps <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> exps<span class="token punctuation">(</span>Bindings<span class="token punctuation">)</span>  <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> exps<span class="token punctuation">(</span><span class="token punctuation">.</span>Bindings<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>Exps
  <span class="token keyword keyword-rule">rule</span> exps<span class="token punctuation">(</span>_<span class="token punctuation">:</span>Name<span class="token operator">=</span>E and Bs<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> E<span class="token punctuation">,</span>exps<span class="token punctuation">(</span>Bs<span class="token punctuation">)</span>

  <span class="token comment">/* Extra kore stuff */</span>
  <span class="token keyword keyword-syntax">syntax</span> KResult <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Vals
  <span class="token keyword keyword-syntax">syntax</span> Exps <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Names

  <span class="token comment">/* Matching */</span>
  <span class="token keyword keyword-syntax">syntax</span> MatchResult <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> getMatching<span class="token punctuation">(</span>Exp<span class="token punctuation">,</span> Val<span class="token punctuation">)</span>                      <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
                       <span class="token operator">|</span> getMatchingAux<span class="token punctuation">(</span>Exps<span class="token punctuation">,</span> Vals<span class="token punctuation">)</span>                 <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
                       <span class="token operator">|</span> mergeMatching<span class="token punctuation">(</span>MatchResult<span class="token punctuation">,</span> MatchResult<span class="token punctuation">)</span>    <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
                       <span class="token operator">|</span> matchResult<span class="token punctuation">(</span>Map<span class="token punctuation">)</span>
                       <span class="token operator">|</span> <span class="token string">&quot;matchFailure&quot;</span>

  <span class="token keyword keyword-rule">rule</span> getMatching<span class="token punctuation">(</span>C<span class="token punctuation">:</span>ConstructorName<span class="token punctuation">(</span>Es<span class="token punctuation">:</span>Exps<span class="token punctuation">)</span><span class="token punctuation">,</span> C<span class="token punctuation">(</span>Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> getMatchingAux<span class="token punctuation">(</span>Es<span class="token punctuation">,</span> Vs<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> getMatching<span class="token punctuation">(</span><span class="token punctuation">[</span>Es<span class="token punctuation">:</span>Exps<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">]</span><span class="token punctuation">)</span>                   <span class="token operator">=&gt;</span> getMatchingAux<span class="token punctuation">(</span>Es<span class="token punctuation">,</span> Vs<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> getMatching<span class="token punctuation">(</span>C<span class="token punctuation">:</span>ConstructorName<span class="token punctuation">,</span> C<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> matchResult<span class="token punctuation">(</span><span class="token punctuation">.</span>Map<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> getMatching<span class="token punctuation">(</span>B<span class="token punctuation">:</span><span class="token keyword keyword-Bool">Bool</span><span class="token punctuation">,</span> B<span class="token punctuation">)</span>            <span class="token operator">=&gt;</span> matchResult<span class="token punctuation">(</span><span class="token punctuation">.</span>Map<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> getMatching<span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token keyword keyword-Int">Int</span><span class="token punctuation">,</span> I<span class="token punctuation">)</span>             <span class="token operator">=&gt;</span> matchResult<span class="token punctuation">(</span><span class="token punctuation">.</span>Map<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> getMatching<span class="token punctuation">(</span>S<span class="token punctuation">:</span><span class="token keyword keyword-String">String</span><span class="token punctuation">,</span> S<span class="token punctuation">)</span>          <span class="token operator">=&gt;</span> matchResult<span class="token punctuation">(</span><span class="token punctuation">.</span>Map<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> getMatching<span class="token punctuation">(</span>N<span class="token punctuation">:</span>Name<span class="token punctuation">,</span> V<span class="token punctuation">:</span>Val<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> matchResult<span class="token punctuation">(</span>N <span class="token operator">|</span><span class="token operator">-</span>&gt; V<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> getMatching<span class="token punctuation">(</span>_<span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> matchFailure        <span class="token punctuation">[</span>owise<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> getMatchingAux<span class="token punctuation">(</span><span class="token punctuation">(</span>E<span class="token punctuation">:</span>Exp<span class="token punctuation">,</span> Es<span class="token punctuation">:</span>Exps<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>V<span class="token punctuation">:</span>Val<span class="token punctuation">,</span> Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> mergeMatching<span class="token punctuation">(</span>getMatching<span class="token punctuation">(</span>E<span class="token punctuation">,</span> V<span class="token punctuation">)</span><span class="token punctuation">,</span> getMatchingAux<span class="token punctuation">(</span>Es<span class="token punctuation">,</span> Vs<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> getMatchingAux<span class="token punctuation">(</span><span class="token punctuation">.</span>Exps<span class="token punctuation">,</span> <span class="token punctuation">.</span>Vals<span class="token punctuation">)</span>                       <span class="token operator">=&gt;</span> matchResult<span class="token punctuation">(</span><span class="token punctuation">.</span>Map<span class="token punctuation">)</span>
  <span class="token keyword keyword-rule">rule</span> getMatchingAux<span class="token punctuation">(</span>_<span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> matchFailure     <span class="token punctuation">[</span>owise<span class="token punctuation">]</span>

  <span class="token keyword keyword-rule">rule</span> mergeMatching<span class="token punctuation">(</span>matchResult<span class="token punctuation">(</span>M1<span class="token punctuation">:</span>Map<span class="token punctuation">)</span><span class="token punctuation">,</span> matchResult<span class="token punctuation">(</span>M2<span class="token punctuation">:</span>Map<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> matchResult<span class="token punctuation">(</span>M1 M2<span class="token punctuation">)</span>
    <span class="token keyword keyword-requires">requires</span> intersectSet<span class="token punctuation">(</span>keys<span class="token punctuation">(</span>M1<span class="token punctuation">)</span><span class="token punctuation">,</span> keys<span class="token punctuation">(</span>M2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span>K <span class="token punctuation">.</span>Set
  <span class="token comment">//rule mergeMatching(_, _) =&gt; matchFailure      [owsie]</span>
  <span class="token keyword keyword-rule">rule</span> mergeMatching<span class="token punctuation">(</span>matchResult<span class="token punctuation">(</span>_<span class="token punctuation">:</span>Map<span class="token punctuation">)</span><span class="token punctuation">,</span> matchFailure<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> matchFailure
  <span class="token keyword keyword-rule">rule</span> mergeMatching<span class="token punctuation">(</span>matchFailure<span class="token punctuation">,</span> matchResult<span class="token punctuation">(</span>_<span class="token punctuation">:</span>Map<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> matchFailure
  <span class="token keyword keyword-rule">rule</span> mergeMatching<span class="token punctuation">(</span>matchFailure<span class="token punctuation">,</span> matchFailure<span class="token punctuation">)</span>       <span class="token operator">=&gt;</span> matchFailure
</pre><p>Besides the generic decomposition rules for patterns and values,<br>
we also want to allow <code>[head|tail]</code> matching for lists, so we add<br>
the following custom pattern decomposition rule:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> getMatching<span class="token punctuation">(</span><span class="token punctuation">[</span>H<span class="token punctuation">:</span>Exp <span class="token operator">|</span> T<span class="token punctuation">:</span>Exp<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>V<span class="token punctuation">:</span>Val<span class="token punctuation">,</span> Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token operator">=&gt;</span> getMatchingAux<span class="token punctuation">(</span><span class="token punctuation">(</span>H<span class="token punctuation">,</span> T<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>V<span class="token punctuation">,</span> <span class="token punctuation">[</span>Vs<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword keyword-endmodule">endmodule</span>
</pre></div></div><div id="ebook-heading-part-10-logik-designing-logic-programming-languages" ebook-toc-level-3 heading="Part 10: LOGIK: Designing Logic Programming Languages"><div><p>// NOTE: this definition is not runnable as is.<br>
// It is intended for documentation and academic purposes only.</p>
<h1 class="mume-header" id="logik">LOGIK</h1>

<p>Author: Grigore Ro&#x219;u (<a href="mailto:grosu@illinois.edu">grosu@illinois.edu</a>)<br>
Organization: University of Illinois at Urbana-Champaign</p>
<p>Author: Traian Florin &#x218;erb&#x103;nu&#x21B;&#x103; (<a href="mailto:traian.serbanuta@unibuc.ro">traian.serbanuta@unibuc.ro</a>)<br>
Organization: University of Bucharest</p>
<h2 class="mume-header" id="abstract">Abstract</h2>

<p>This is the <strong>K</strong> semantic definition of LOGIK, a trivial language<br>
capturing the essence of the logic programming paradigm.  In this<br>
definition, we explicitly focus on simplicity and mathematical<br>
clarity, not on advanced logic programming features or performance.<br>
Those are covered in the LOGIK++ extension under <code>examples/logik++</code>.</p>
<p>Specifically, a LOGIK program consists of a sequence of <strong>Horn clauses</strong><br>
of the form</p>
<pre data-role="codeBlock" data-info class="language-"><code>P :- P1, P2, ..., Pn .
</code></pre><p>followed by a <strong>query</strong> of the form</p>
<pre data-role="codeBlock" data-info class="language-"><code>?- Q1, Q2, ..., Qm .
</code></pre><p>where <code>P</code>, <code>P1</code>, <code>P2</code>, ..., <code>Pn</code>, <code>Q1</code>, <code>Q2</code>,<br>
..., <code>Qm</code> are <strong>literals</strong>.  The<br>
symbol <code>:-</code> is read &quot;if&quot;.  A literal has the form<br>
<code>p(T1,T2,...,Tk)</code>, where <code>p</code> is a <strong>predicate symbol</strong><br>
and where <code>T1,T2,...,Tk</code> are <strong>terms</strong>.  Terms are built as<br>
usual, with <strong>operation symbols</strong> and <strong>variables</strong>.  A common<br>
convention in logic programming languages, also adopted here, is that<br>
variables are capitalized and operation symbols are not.  Operations<br>
with zero arguments are called <strong>constants</strong> and are written without<br>
parentheses, that is, <code>c</code> instead of <code>c()</code>.  Horn<br>
clauses without conditions, called <strong>facts</strong>, are written<br>
without <code>:-</code>, that is, <code>P.</code> instead of <code>P :- .</code>.</p>
<p>For example, the LOGIK program below gives a few facts about a<br>
<code>parent</code> predicate, then several clauses defining some useful<br>
predicates including an <code>ancestor</code> predicate, and finally a<br>
query asking for those who both have ancestors and are ancestors<br>
themselves in the <code>parent</code> relation:</p>
<pre data-role="codeBlock" data-info class="language-"><code>parent(david,john).
parent(jim,david).
parent(steve,jim).
parent(nathan,steve).

grandparent(A,B):-
  parent(A,X),
  parent(X,B).

ancestor(A,B):-
  parent(A,X),
  parents(X,B).

parents(X,X).
parents(A,B):-
  ancestor(A,B).

both(X) :- ancestor(A,X), ancestor(X,B).

?- both(X).
</code></pre><p>Above, we only have constant operation symbols, so these and variables<br>
are the only terms that can be used in predicates.  As expected, the<br>
LOGIK program above will give us three solutions for <code>X</code>:<br>
<code>david</code>, <code>steve</code>, and <code>jim</code>.  If we inline the<br>
<code>both(X)</code> predicate in the query, that is, if we replace the<br>
query with <code>?- ancestor(A,X), ancestor(X,B).</code> then we get<br>
10 solutions, one for for each triple <code>A</code>, <code>X</code>, and<br>
<code>B</code> satisfying both predicates <code>ancestor(A,X)</code> and<br>
<code>ancestor(X,B)</code>.</p>
<p>As another example, the program below defines an <code>append</code><br>
predicate followed by a simple goal:</p>
<pre data-role="codeBlock" data-info class="language-"><code>append(nil,L,L).
append(cons(H,T),L,cons(H,Z)) :- append(T,L,Z).

?- append(cons(a,nil), cons(b,nil), V).
</code></pre><p>Besides the predicate symbol <code>append</code>, the program above also<br>
includes a constant symbol <code>nil</code> and a binary operation symbol<br>
<code>cons</code>.  Additionally, the query also includes two more<br>
constants, <code>a</code> and <code>b</code>.  The capitalized identifiers are<br>
all variables.  As expected, the LOGIK program above yields only one<br>
solution, namely <code>V = cons(a,cons(b,nil))</code>.  On the other hand,<br>
if we change the query to:</p>
<pre data-role="codeBlock" data-info class="language-"><code>?- append(L1, cons(a,L2), cons(a,cons(b,cons(a,nil)))).
</code></pre><p>then LOGIK yields two solutions: one where <code>L1</code> is<br>
<code>cons(a,cons(b,nil))</code> and <code>L2</code> is <code>nil</code>,<br>
and another where <code>L1</code> is <code>nil</code> and <code>L2</code> is<br>
<code>cons(a,cons(b,nil))</code>.</p>
<p>The programs above all generated <strong>ground solutions</strong>, that is,<br>
solutions where the query variables are mapped to ground terms (i.e.,<br>
terms without variables).  Let us now consider the following query:</p>
<pre data-role="codeBlock" data-info class="language-"><code>?- append(cons(a,nil), Y, Z).
</code></pre><p>There are obviously infinitely many ground solutions for the query<br>
above, e.g.,<br>
<code>Y = nil</code> and <code>Z = cons(a,nil)</code>,<br>
<code>Y = cons(a,nil)</code> and <code>Z = cons(a,cons(a,nil))</code>,<br>
<code>Y = cons(b,nil)</code> and <code>Z = cons(a,cons(b,nil))</code>,<br>
<code>Y = cons(c,cons(b,nil))</code> and <code>Z = cons(a,cons(c,cons(b,nil)))</code>,<br>
etc.  However, all the ground solutions for the query above can be<br>
elegantly characterized by the property that <code>Z</code> is bound to a list<br>
starting with <code>a</code> and followed by the list that <code>Y</code> is<br>
bound to.  This property can in fact be described as a <strong>symbolic solution</strong><br>
to the query: <code>Z = cons(a,Y)</code> or, equivalently,<br>
<code>Y = Symb</code> and <code>Z = cons(a,Symb)</code>.  It is possible to<br>
define a ``more general than&apos;&apos; relation on such symbolic solutions,<br>
in the sense that the more particular solution can be obtained as a<br>
specialization/substitution of the more general one, and then it can<br>
be shown that the above is the <strong>most general solution</strong> to the<br>
stated query.  Logic programming languages, including our LOGIK,<br>
attempt to always compute such most general solutions.</p>
<p>Logic programming languages are highly non-deterministic, in that<br>
several Horn clauses may be used at the same time, each possibly<br>
resulting in a different solution.  Implementations of logic<br>
programming languages consist of complex, optimized search and<br>
indexing algorithms, which we are not concerned with here.  Instead,<br>
we here take advantage of <strong>K</strong>&apos;s builtin support for search.<br>
Specifically, to find all the solutions of a LOGIK program, we have to<br>
use <code>krun</code> with the option <code>--search</code>.  However, note<br>
that some programs have infinitely many solutions which cannot relate<br>
to each other by the &quot;more general&quot; relation.  For example, the query</p>
<pre data-role="codeBlock" data-info class="language-"><code>?- append(L1, cons(a,L2), L3) .
</code></pre><p>To address such cases and terminate, logic programming languages allow<br>
the user to choose how many solutions to be computed and displayed.<br>
In LOGIK, we can use the <code>--bound</code> option of <code>krun</code> for<br>
this purpose.</p>
<p>Finally, note that some queries have no solution.  In some cases that<br>
is easy to detect by exhaustive analysis, such as for the following<br>
query:</p>
<pre data-role="codeBlock" data-info class="language-"><code>?- append(cons(a,L1), L2, cons(b,L3)).
</code></pre><p>Logic programming languages, including LOGIK, terminate in such cases<br>
and report a no solution answer.  However, there are cases where<br>
exhaustive analysis is not sufficient, such as for the query:</p>
<pre data-role="codeBlock" data-info class="language-"><code>?- append(cons(a,L), nil, L).
</code></pre><p>In such cases, logic programming languages do not terminate.  While<br>
one may devise techniques to detect non-termination in some cases,<br>
one cannot do it in general (same like for all Turing-complete<br>
languages).</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-requires">requires</span> <span class="token string">&quot;unification.k&quot;</span>

<span class="token keyword keyword-module">module</span> LOGIK<span class="token operator">-</span>COMMON
  <span class="token keyword keyword-imports">imports</span> DOMAINS<span class="token operator">-</span>SYNTAX
</pre><h2 class="mume-header" id="syntax">Syntax</h2>

<p>The syntax of LOGIK is straightforward: a program is a sequence of<br>
Horn clauses followed by a query:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Literal
  <span class="token keyword keyword-syntax">syntax</span> Term <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Literal <span class="token operator">|</span> Literal <span class="token string">&quot;(&quot;</span> Terms <span class="token string">&quot;)&quot;</span>
  <span class="token keyword keyword-syntax">syntax</span> Terms <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Term<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>
  <span class="token keyword keyword-syntax">syntax</span> Clause <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Term <span class="token string">&quot;:-&quot;</span> Terms <span class="token string">&quot;.&quot;</span> <span class="token operator">|</span> Term <span class="token string">&quot;.&quot;</span>
  <span class="token keyword keyword-syntax">syntax</span> Query <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;?-&quot;</span> Terms <span class="token string">&quot;.&quot;</span>
  <span class="token keyword keyword-syntax">syntax</span> Pgm <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Query <span class="token operator">|</span> Clause Pgm
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> LOGIK<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> LOGIK<span class="token operator">-</span>COMMON
  <span class="token keyword keyword-imports">imports</span> BUILTIN<span class="token operator">-</span>ID<span class="token operator">-</span>TOKENS
</pre><p>Variables and literals are defined as tokens following the conventions<br>
used in Prolog (variables start with _ or capital letter, while literals<br>
start with lower case letters):</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> #KVariable <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> r<span class="token string">&quot;[A-Z_][A-Za-z0-9_]*&quot;</span>   <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">,</span> prec<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
                      <span class="token operator">|</span> #UpperId                 <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Term <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> #KVariable <span class="token punctuation">[</span><span class="token class-name">klabel</span><span class="token punctuation">(</span>#SemanticCastToTerm<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Literal <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> r<span class="token string">&quot;[a-z][a-zA-Z0-9_]*&quot;</span>                 <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> #LowerId                              <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> LOGIK
  <span class="token keyword keyword-imports">imports</span> LOGIK<span class="token operator">-</span>COMMON
  <span class="token keyword keyword-imports">imports</span> DOMAINS
  <span class="token keyword keyword-imports">imports</span> UNIFICATION
</pre><p>Unification is at the core of logic programming.  Here we are<br>
going to use the predefined unification procedure (the same one we<br>
used in the type inferencers in Tutorial 5).</p>
<h2 class="mume-header" id="configuration">Configuration</h2>

<p>The configuration stores each clause in its own cell for easy access,<br>
and the most general unifier in a cell named <code>mgu</code>, same like<br>
the type inferencers.  The <code>k</code> cell holds the query and the<br>
<code>fresh</code> cell holds a fresh clause instance to be attempted on<br>
the next query item.  To more easily read the solutions, we add a<br>
second top-level cell, <code>solution</code>.  Both top cells are<br>
optional.  Indeed, we start with the main top cell and, when a<br>
solution is found, we move it into the <code>solution</code> cell and<br>
discard the main cell.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-configuration">configuration</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>T</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>yellow<span class="token punctuation">&quot;</span></span> <span class="token attr-name">multiplicity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>?<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>green<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> $PGM<span class="token punctuation">:</span>Pgm <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fresh</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>orange<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fresh</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>clauses</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>red<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>clause</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>pink<span class="token punctuation">&quot;</span></span> <span class="token attr-name">multiplicity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>*<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>clause</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>clauses</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mgu</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mgu</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>T</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>solution</span> <span class="token attr-name">multiplicity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>?<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>solution</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="pre-and-post-processing">Pre- and post-processing</h2>

<p>Before we launch the semantics, we first scan the given program and<br>
place each clause in its own cell, and then place the query in the<br>
<code>k</code> cell and initialize the mgu with the variables from the query.</p>
<p>Note that we put a fresh instance of the clause to avoid interference with<br>
the query variables.  By a &quot;fresh instance&quot; of a clause we mean one whose<br>
variables are renamed with fresh names; we need that in order to avoid<br>
undesired unification conflicts due to particular names chosen for<br>
variables in the original program, as well as conflicts due to<br>
subsequent uses of the same clause.  It is safe to rename the<br>
variables in a clause, because clauses are universally quantified in<br>
their variables.  This process of creating a fresh instance of a<br>
clause is similar to how we created fresh instances of type schemas in<br>
the higher-order type inferencer discussed in Tutorial 5.  Indeed, we<br>
can safely regard clauses as &quot;clause schemas&quot; comprising infinitely<br>
many instances, one for each context.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> C<span class="token punctuation">:</span>Clause Pgm <span class="token operator">=&gt;</span> Pgm <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token punctuation">(</span><span class="token punctuation">.</span>Bag <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>clause</span><span class="token punctuation">&gt;</span></span> #renameVariables<span class="token punctuation">(</span>C<span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>clause</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token operator">?</span><span class="token operator">-</span> Ls<span class="token punctuation">:</span>Terms<span class="token punctuation">.</span> <span class="token operator">=&gt;</span> Ls <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mgu</span><span class="token punctuation">&gt;</span></span> _ <span class="token operator">=&gt;</span> #variablesMap<span class="token punctuation">(</span>#variables<span class="token punctuation">(</span>Ls<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mgu</span><span class="token punctuation">&gt;</span></span>
</pre><p>We also sequentialize the goals for easier processing:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> L<span class="token punctuation">:</span>Term<span class="token punctuation">,</span> Ls<span class="token punctuation">:</span>Terms <span class="token operator">=&gt;</span> L <span class="token operator">~&gt;</span> Ls
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">.</span>Terms <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>
</pre><p>When all the goals are solved, indicated by the empty <code>k</code><br>
cell, the calculated most general unifier (mgu) is in the <code>mgu</code><br>
cell.  In that case, to ease reading of the final solution we move the<br>
mgu in the <code>solution</code> cell and delete the rest of the<br>
configuration:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mgu</span><span class="token punctuation">&gt;</span></span> Theta <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mgu</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>T</span><span class="token punctuation">&gt;</span></span>
  <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>solution</span><span class="token punctuation">&gt;</span></span> Theta <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>solution</span><span class="token punctuation">&gt;</span></span>
</pre><p>Since we are not interested in seeing the failed attempts to solve<br>
the query, we collapse all the error configurations into an empty<br>
configuration (recall that both top-level cells in the configuration<br>
were declared optional).  This way, if we see an empty configuration<br>
when we search for all solutions, we know that some attempts failed<br>
(but we do not know which ones).</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token comment">// this would be nice, but we need feedback from the external unifier</span>
<span class="token comment">// for this.</span>
<span class="token comment">//  rule &lt;T&gt;... &lt;mgu&gt; _:MguError &lt;/mgu&gt; ...&lt;/T&gt; =&gt; .</span>
</pre><h2 class="mume-header" id="semantics">Semantics</h2>

<p>Once all the infrastructure is in place, the actual semantics of LOGIK<br>
is quite simple.  All we have to do is to pick some (fresh instance of<br>
a) clause, then unify its conclusion with the first query literal, and<br>
then replace that literal with condition of the clause.  The intuition<br>
here is the following: to satisfy the first literal in the query, we<br>
need to find some instance of some clause that matches it, and then to<br>
similarly show that we can satisfy the conditions of that clause.<br>
Mathematically, this is an instance of the proof principle called<br>
<strong>resolution</strong>: if <code>p &#x2228; q</code> and <code>&#xAC; p &#x2228; r</code> hold, then so does<br>
<code>q &#x2228; r</code>.  We let it as an exercise to the reader to see how the two<br>
relate (hint: assume the negation of the goal together with all the<br>
clauses, and then derive <strong>false</strong>).</p>
<p>The following two rules are tightly connected and they together<br>
perform the following core task: pick a fresh instance of a clause<br>
which unifies with the first goal item, then add its conditions as new<br>
goals.</p>
<p>Pick a clause and generate a fresh instance of it when the<br>
<code>fresh</code> cell is empty:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fresh</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span> <span class="token operator">=&gt;</span> #renameVariables<span class="token punctuation">(</span>C<span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fresh</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>clause</span><span class="token punctuation">&gt;</span></span> C <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>clause</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> T<span class="token punctuation">:</span>Term <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-requires">requires</span> #unifiable<span class="token punctuation">(</span>T<span class="token punctuation">,</span>head<span class="token punctuation">(</span>C<span class="token punctuation">)</span><span class="token punctuation">)</span>

  <span class="token keyword keyword-syntax">syntax</span> Term <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> head<span class="token punctuation">(</span>Clause<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> head<span class="token punctuation">(</span>L<span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> L
  <span class="token keyword keyword-rule">rule</span> head<span class="token punctuation">(</span>L<span class="token punctuation">:</span><span class="token operator">-</span>_<span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> L
</pre><p>If the goal is unifiable with the fresh clause&apos;s head, replace the goal<br>
with the clause body, and empty the <code>fresh</code> cell (so that<br>
another clause can be chosen using the rule above):</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> L<span class="token punctuation">:</span>Term <span class="token operator">=&gt;</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fresh</span><span class="token punctuation">&gt;</span></span>  L<span class="token punctuation">:</span>Term <span class="token punctuation">.</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fresh</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> L<span class="token punctuation">:</span>Term <span class="token punctuation">:</span>KItem <span class="token operator">=&gt;</span> Ls <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fresh</span><span class="token punctuation">&gt;</span></span>  L<span class="token punctuation">:</span>Term <span class="token punctuation">:</span><span class="token operator">-</span> Ls<span class="token punctuation">:</span>Terms<span class="token punctuation">.</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fresh</span><span class="token punctuation">&gt;</span></span>
</pre><p>Note that there is no problem if a clause is chosen whose<br>
conclusion literal does not unify with the first goal literal.<br>
The search<br>
option of <code>krun</code> will systematically try all clauses, so no<br>
solution is missed.  Of course, the above is not the most efficient<br>
way to implement a logic programming language, but recall that our<br>
objective here was to present a simple and mathematically clean<br>
solution.  We encourage the interested reader to consult the LOGIK++<br>
language definition for a more efficient definition of a richer logic<br>
programming language.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-endmodule">endmodule</span>
</pre></div></div><div id="ebook-heading-lesson-1-logik" ebook-toc-level-4 heading="Lesson 1, LOGIK"><div><p>// NOTE: this definition is not runnable as is.<br>
// It is intended for documentation and academic purposes only.</p>
<h1 class="mume-header" id="logik">LOGIK</h1>

<p>Author: Grigore Ro&#x219;u (<a href="mailto:grosu@illinois.edu">grosu@illinois.edu</a>)<br>
Organization: University of Illinois at Urbana-Champaign</p>
<p>Author: Traian Florin &#x218;erb&#x103;nu&#x21B;&#x103; (<a href="mailto:traian.serbanuta@unibuc.ro">traian.serbanuta@unibuc.ro</a>)<br>
Organization: University of Bucharest</p>
<h2 class="mume-header" id="abstract">Abstract</h2>

<p>This is the <strong>K</strong> semantic definition of LOGIK, a trivial language<br>
capturing the essence of the logic programming paradigm.  In this<br>
definition, we explicitly focus on simplicity and mathematical<br>
clarity, not on advanced logic programming features or performance.<br>
Those are covered in the LOGIK++ extension under <code>examples/logik++</code>.</p>
<p>Specifically, a LOGIK program consists of a sequence of <strong>Horn clauses</strong><br>
of the form</p>
<pre data-role="codeBlock" data-info class="language-"><code>P :- P1, P2, ..., Pn .
</code></pre><p>followed by a <strong>query</strong> of the form</p>
<pre data-role="codeBlock" data-info class="language-"><code>?- Q1, Q2, ..., Qm .
</code></pre><p>where <code>P</code>, <code>P1</code>, <code>P2</code>, ..., <code>Pn</code>, <code>Q1</code>, <code>Q2</code>,<br>
..., <code>Qm</code> are <strong>literals</strong>.  The<br>
symbol <code>:-</code> is read &quot;if&quot;.  A literal has the form<br>
<code>p(T1,T2,...,Tk)</code>, where <code>p</code> is a <strong>predicate symbol</strong><br>
and where <code>T1,T2,...,Tk</code> are <strong>terms</strong>.  Terms are built as<br>
usual, with <strong>operation symbols</strong> and <strong>variables</strong>.  A common<br>
convention in logic programming languages, also adopted here, is that<br>
variables are capitalized and operation symbols are not.  Operations<br>
with zero arguments are called <strong>constants</strong> and are written without<br>
parentheses, that is, <code>c</code> instead of <code>c()</code>.  Horn<br>
clauses without conditions, called <strong>facts</strong>, are written<br>
without <code>:-</code>, that is, <code>P.</code> instead of <code>P :- .</code>.</p>
<p>For example, the LOGIK program below gives a few facts about a<br>
<code>parent</code> predicate, then several clauses defining some useful<br>
predicates including an <code>ancestor</code> predicate, and finally a<br>
query asking for those who both have ancestors and are ancestors<br>
themselves in the <code>parent</code> relation:</p>
<pre data-role="codeBlock" data-info class="language-"><code>parent(david,john).
parent(jim,david).
parent(steve,jim).
parent(nathan,steve).

grandparent(A,B):-
  parent(A,X),
  parent(X,B).

ancestor(A,B):-
  parent(A,X),
  parents(X,B).

parents(X,X).
parents(A,B):-
  ancestor(A,B).

both(X) :- ancestor(A,X), ancestor(X,B).

?- both(X).
</code></pre><p>Above, we only have constant operation symbols, so these and variables<br>
are the only terms that can be used in predicates.  As expected, the<br>
LOGIK program above will give us three solutions for <code>X</code>:<br>
<code>david</code>, <code>steve</code>, and <code>jim</code>.  If we inline the<br>
<code>both(X)</code> predicate in the query, that is, if we replace the<br>
query with <code>?- ancestor(A,X), ancestor(X,B).</code> then we get<br>
10 solutions, one for for each triple <code>A</code>, <code>X</code>, and<br>
<code>B</code> satisfying both predicates <code>ancestor(A,X)</code> and<br>
<code>ancestor(X,B)</code>.</p>
<p>As another example, the program below defines an <code>append</code><br>
predicate followed by a simple goal:</p>
<pre data-role="codeBlock" data-info class="language-"><code>append(nil,L,L).
append(cons(H,T),L,cons(H,Z)) :- append(T,L,Z).

?- append(cons(a,nil), cons(b,nil), V).
</code></pre><p>Besides the predicate symbol <code>append</code>, the program above also<br>
includes a constant symbol <code>nil</code> and a binary operation symbol<br>
<code>cons</code>.  Additionally, the query also includes two more<br>
constants, <code>a</code> and <code>b</code>.  The capitalized identifiers are<br>
all variables.  As expected, the LOGIK program above yields only one<br>
solution, namely <code>V = cons(a,cons(b,nil))</code>.  On the other hand,<br>
if we change the query to:</p>
<pre data-role="codeBlock" data-info class="language-"><code>?- append(L1, cons(a,L2), cons(a,cons(b,cons(a,nil)))).
</code></pre><p>then LOGIK yields two solutions: one where <code>L1</code> is<br>
<code>cons(a,cons(b,nil))</code> and <code>L2</code> is <code>nil</code>,<br>
and another where <code>L1</code> is <code>nil</code> and <code>L2</code> is<br>
<code>cons(a,cons(b,nil))</code>.</p>
<p>The programs above all generated <strong>ground solutions</strong>, that is,<br>
solutions where the query variables are mapped to ground terms (i.e.,<br>
terms without variables).  Let us now consider the following query:</p>
<pre data-role="codeBlock" data-info class="language-"><code>?- append(cons(a,nil), Y, Z).
</code></pre><p>There are obviously infinitely many ground solutions for the query<br>
above, e.g.,<br>
<code>Y = nil</code> and <code>Z = cons(a,nil)</code>,<br>
<code>Y = cons(a,nil)</code> and <code>Z = cons(a,cons(a,nil))</code>,<br>
<code>Y = cons(b,nil)</code> and <code>Z = cons(a,cons(b,nil))</code>,<br>
<code>Y = cons(c,cons(b,nil))</code> and <code>Z = cons(a,cons(c,cons(b,nil)))</code>,<br>
etc.  However, all the ground solutions for the query above can be<br>
elegantly characterized by the property that <code>Z</code> is bound to a list<br>
starting with <code>a</code> and followed by the list that <code>Y</code> is<br>
bound to.  This property can in fact be described as a <strong>symbolic solution</strong><br>
to the query: <code>Z = cons(a,Y)</code> or, equivalently,<br>
<code>Y = Symb</code> and <code>Z = cons(a,Symb)</code>.  It is possible to<br>
define a ``more general than&apos;&apos; relation on such symbolic solutions,<br>
in the sense that the more particular solution can be obtained as a<br>
specialization/substitution of the more general one, and then it can<br>
be shown that the above is the <strong>most general solution</strong> to the<br>
stated query.  Logic programming languages, including our LOGIK,<br>
attempt to always compute such most general solutions.</p>
<p>Logic programming languages are highly non-deterministic, in that<br>
several Horn clauses may be used at the same time, each possibly<br>
resulting in a different solution.  Implementations of logic<br>
programming languages consist of complex, optimized search and<br>
indexing algorithms, which we are not concerned with here.  Instead,<br>
we here take advantage of <strong>K</strong>&apos;s builtin support for search.<br>
Specifically, to find all the solutions of a LOGIK program, we have to<br>
use <code>krun</code> with the option <code>--search</code>.  However, note<br>
that some programs have infinitely many solutions which cannot relate<br>
to each other by the &quot;more general&quot; relation.  For example, the query</p>
<pre data-role="codeBlock" data-info class="language-"><code>?- append(L1, cons(a,L2), L3) .
</code></pre><p>To address such cases and terminate, logic programming languages allow<br>
the user to choose how many solutions to be computed and displayed.<br>
In LOGIK, we can use the <code>--bound</code> option of <code>krun</code> for<br>
this purpose.</p>
<p>Finally, note that some queries have no solution.  In some cases that<br>
is easy to detect by exhaustive analysis, such as for the following<br>
query:</p>
<pre data-role="codeBlock" data-info class="language-"><code>?- append(cons(a,L1), L2, cons(b,L3)).
</code></pre><p>Logic programming languages, including LOGIK, terminate in such cases<br>
and report a no solution answer.  However, there are cases where<br>
exhaustive analysis is not sufficient, such as for the query:</p>
<pre data-role="codeBlock" data-info class="language-"><code>?- append(cons(a,L), nil, L).
</code></pre><p>In such cases, logic programming languages do not terminate.  While<br>
one may devise techniques to detect non-termination in some cases,<br>
one cannot do it in general (same like for all Turing-complete<br>
languages).</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-requires">requires</span> <span class="token string">&quot;unification.k&quot;</span>

<span class="token keyword keyword-module">module</span> LOGIK<span class="token operator">-</span>COMMON
  <span class="token keyword keyword-imports">imports</span> DOMAINS<span class="token operator">-</span>SYNTAX
</pre><h2 class="mume-header" id="syntax">Syntax</h2>

<p>The syntax of LOGIK is straightforward: a program is a sequence of<br>
Horn clauses followed by a query:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> Literal
  <span class="token keyword keyword-syntax">syntax</span> Term <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Literal <span class="token operator">|</span> Literal <span class="token string">&quot;(&quot;</span> Terms <span class="token string">&quot;)&quot;</span>
  <span class="token keyword keyword-syntax">syntax</span> Terms <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Term<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>
  <span class="token keyword keyword-syntax">syntax</span> Clause <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Term <span class="token string">&quot;:-&quot;</span> Terms <span class="token string">&quot;.&quot;</span> <span class="token operator">|</span> Term <span class="token string">&quot;.&quot;</span>
  <span class="token keyword keyword-syntax">syntax</span> Query <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;?-&quot;</span> Terms <span class="token string">&quot;.&quot;</span>
  <span class="token keyword keyword-syntax">syntax</span> Pgm <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Query <span class="token operator">|</span> Clause Pgm
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> LOGIK<span class="token operator">-</span>SYNTAX
  <span class="token keyword keyword-imports">imports</span> LOGIK<span class="token operator">-</span>COMMON
  <span class="token keyword keyword-imports">imports</span> BUILTIN<span class="token operator">-</span>ID<span class="token operator">-</span>TOKENS
</pre><p>Variables and literals are defined as tokens following the conventions<br>
used in Prolog (variables start with _ or capital letter, while literals<br>
start with lower case letters):</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-syntax">syntax</span> #KVariable <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> r<span class="token string">&quot;[A-Z_][A-Za-z0-9_]*&quot;</span>   <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">,</span> prec<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
                      <span class="token operator">|</span> #UpperId                 <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Term <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> #KVariable <span class="token punctuation">[</span><span class="token class-name">klabel</span><span class="token punctuation">(</span>#SemanticCastToTerm<span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword keyword-syntax">syntax</span> Literal <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> r<span class="token string">&quot;[a-z][a-zA-Z0-9_]*&quot;</span>                 <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
                   <span class="token operator">|</span> #LowerId                              <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
<span class="token keyword keyword-endmodule">endmodule</span>

<span class="token keyword keyword-module">module</span> LOGIK
  <span class="token keyword keyword-imports">imports</span> LOGIK<span class="token operator">-</span>COMMON
  <span class="token keyword keyword-imports">imports</span> DOMAINS
  <span class="token keyword keyword-imports">imports</span> UNIFICATION
</pre><p>Unification is at the core of logic programming.  Here we are<br>
going to use the predefined unification procedure (the same one we<br>
used in the type inferencers in Tutorial 5).</p>
<h2 class="mume-header" id="configuration">Configuration</h2>

<p>The configuration stores each clause in its own cell for easy access,<br>
and the most general unifier in a cell named <code>mgu</code>, same like<br>
the type inferencers.  The <code>k</code> cell holds the query and the<br>
<code>fresh</code> cell holds a fresh clause instance to be attempted on<br>
the next query item.  To more easily read the solutions, we add a<br>
second top-level cell, <code>solution</code>.  Both top cells are<br>
optional.  Indeed, we start with the main top cell and, when a<br>
solution is found, we move it into the <code>solution</code> cell and<br>
discard the main cell.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-configuration">configuration</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>T</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>yellow<span class="token punctuation">&quot;</span></span> <span class="token attr-name">multiplicity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>?<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>green<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> $PGM<span class="token punctuation">:</span>Pgm <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fresh</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>orange<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fresh</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>clauses</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>red<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>clause</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>pink<span class="token punctuation">&quot;</span></span> <span class="token attr-name">multiplicity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>*<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>clause</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>clauses</span><span class="token punctuation">&gt;</span></span>
                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mgu</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mgu</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>T</span><span class="token punctuation">&gt;</span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>solution</span> <span class="token attr-name">multiplicity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>?<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span>K <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>solution</span><span class="token punctuation">&gt;</span></span>
</pre><h2 class="mume-header" id="pre-and-post-processing">Pre- and post-processing</h2>

<p>Before we launch the semantics, we first scan the given program and<br>
place each clause in its own cell, and then place the query in the<br>
<code>k</code> cell and initialize the mgu with the variables from the query.</p>
<p>Note that we put a fresh instance of the clause to avoid interference with<br>
the query variables.  By a &quot;fresh instance&quot; of a clause we mean one whose<br>
variables are renamed with fresh names; we need that in order to avoid<br>
undesired unification conflicts due to particular names chosen for<br>
variables in the original program, as well as conflicts due to<br>
subsequent uses of the same clause.  It is safe to rename the<br>
variables in a clause, because clauses are universally quantified in<br>
their variables.  This process of creating a fresh instance of a<br>
clause is similar to how we created fresh instances of type schemas in<br>
the higher-order type inferencer discussed in Tutorial 5.  Indeed, we<br>
can safely regard clauses as &quot;clause schemas&quot; comprising infinitely<br>
many instances, one for each context.</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> C<span class="token punctuation">:</span>Clause Pgm <span class="token operator">=&gt;</span> Pgm <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token punctuation">(</span><span class="token punctuation">.</span>Bag <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>clause</span><span class="token punctuation">&gt;</span></span> #renameVariables<span class="token punctuation">(</span>C<span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>clause</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token operator">?</span><span class="token operator">-</span> Ls<span class="token punctuation">:</span>Terms<span class="token punctuation">.</span> <span class="token operator">=&gt;</span> Ls <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mgu</span><span class="token punctuation">&gt;</span></span> _ <span class="token operator">=&gt;</span> #variablesMap<span class="token punctuation">(</span>#variables<span class="token punctuation">(</span>Ls<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mgu</span><span class="token punctuation">&gt;</span></span>
</pre><p>We also sequentialize the goals for easier processing:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> L<span class="token punctuation">:</span>Term<span class="token punctuation">,</span> Ls<span class="token punctuation">:</span>Terms <span class="token operator">=&gt;</span> L <span class="token operator">~&gt;</span> Ls
  <span class="token keyword keyword-rule">rule</span> <span class="token punctuation">.</span>Terms <span class="token operator">=&gt;</span> <span class="token punctuation">.</span>
</pre><p>When all the goals are solved, indicated by the empty <code>k</code><br>
cell, the calculated most general unifier (mgu) is in the <code>mgu</code><br>
cell.  In that case, to ease reading of the final solution we move the<br>
mgu in the <code>solution</code> cell and delete the rest of the<br>
configuration:</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mgu</span><span class="token punctuation">&gt;</span></span> Theta <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mgu</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>T</span><span class="token punctuation">&gt;</span></span>
  <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>solution</span><span class="token punctuation">&gt;</span></span> Theta <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>solution</span><span class="token punctuation">&gt;</span></span>
</pre><p>Since we are not interested in seeing the failed attempts to solve<br>
the query, we collapse all the error configurations into an empty<br>
configuration (recall that both top-level cells in the configuration<br>
were declared optional).  This way, if we see an empty configuration<br>
when we search for all solutions, we know that some attempts failed<br>
(but we do not know which ones).</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token comment">// this would be nice, but we need feedback from the external unifier</span>
<span class="token comment">// for this.</span>
<span class="token comment">//  rule &lt;T&gt;... &lt;mgu&gt; _:MguError &lt;/mgu&gt; ...&lt;/T&gt; =&gt; .</span>
</pre><h2 class="mume-header" id="semantics">Semantics</h2>

<p>Once all the infrastructure is in place, the actual semantics of LOGIK<br>
is quite simple.  All we have to do is to pick some (fresh instance of<br>
a) clause, then unify its conclusion with the first query literal, and<br>
then replace that literal with condition of the clause.  The intuition<br>
here is the following: to satisfy the first literal in the query, we<br>
need to find some instance of some clause that matches it, and then to<br>
similarly show that we can satisfy the conditions of that clause.<br>
Mathematically, this is an instance of the proof principle called<br>
<strong>resolution</strong>: if <code>p &#x2228; q</code> and <code>&#xAC; p &#x2228; r</code> hold, then so does<br>
<code>q &#x2228; r</code>.  We let it as an exercise to the reader to see how the two<br>
relate (hint: assume the negation of the goal together with all the<br>
clauses, and then derive <strong>false</strong>).</p>
<p>The following two rules are tightly connected and they together<br>
perform the following core task: pick a fresh instance of a clause<br>
which unifies with the first goal item, then add its conditions as new<br>
goals.</p>
<p>Pick a clause and generate a fresh instance of it when the<br>
<code>fresh</code> cell is empty:</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fresh</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span> <span class="token operator">=&gt;</span> #renameVariables<span class="token punctuation">(</span>C<span class="token punctuation">)</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fresh</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>clause</span><span class="token punctuation">&gt;</span></span> C <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>clause</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> T<span class="token punctuation">:</span>Term <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
  <span class="token keyword keyword-requires">requires</span> #unifiable<span class="token punctuation">(</span>T<span class="token punctuation">,</span>head<span class="token punctuation">(</span>C<span class="token punctuation">)</span><span class="token punctuation">)</span>

  <span class="token keyword keyword-syntax">syntax</span> Term <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> head<span class="token punctuation">(</span>Clause<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword keyword-rule">rule</span> head<span class="token punctuation">(</span>L<span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> L
  <span class="token keyword keyword-rule">rule</span> head<span class="token punctuation">(</span>L<span class="token punctuation">:</span><span class="token operator">-</span>_<span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> L
</pre><p>If the goal is unifiable with the fresh clause&apos;s head, replace the goal<br>
with the clause body, and empty the <code>fresh</code> cell (so that<br>
another clause can be chosen using the rule above):</p>
<pre data-role="codeBlock" data-info="k" class="language-k">  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> L<span class="token punctuation">:</span>Term <span class="token operator">=&gt;</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fresh</span><span class="token punctuation">&gt;</span></span>  L<span class="token punctuation">:</span>Term <span class="token punctuation">.</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fresh</span><span class="token punctuation">&gt;</span></span>

  <span class="token keyword keyword-rule">rule</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>k</span><span class="token punctuation">&gt;</span></span> L<span class="token punctuation">:</span>Term <span class="token punctuation">:</span>KItem <span class="token operator">=&gt;</span> Ls <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>k</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fresh</span><span class="token punctuation">&gt;</span></span>  L<span class="token punctuation">:</span>Term <span class="token punctuation">:</span><span class="token operator">-</span> Ls<span class="token punctuation">:</span>Terms<span class="token punctuation">.</span> <span class="token operator">=&gt;</span> <span class="token punctuation">.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fresh</span><span class="token punctuation">&gt;</span></span>
</pre><p>Note that there is no problem if a clause is chosen whose<br>
conclusion literal does not unify with the first goal literal.<br>
The search<br>
option of <code>krun</code> will systematically try all clauses, so no<br>
solution is missed.  Of course, the above is not the most efficient<br>
way to implement a logic programming language, but recall that our<br>
objective here was to present a simple and mathematically clean<br>
solution.  We encourage the interested reader to consult the LOGIK++<br>
language definition for a more efficient definition of a richer logic<br>
programming language.</p>
<pre data-role="codeBlock" data-info="k" class="language-k"><span class="token keyword keyword-endmodule">endmodule</span>
</pre></div></div><div id="ebook-heading-projects-using-k" ebook-toc-level-1 heading="Projects using K"><div><h1 class="mume-header" id="projects-using-k">Projects using K</h1>

<p>A list of projects using the K framework. If you are working on something interesting, and you want to share it with the community,<br>
let us know on our <a href="https://kframework.org/#support">socials</a>, and we will feature you on this list.</p>
<br>
<h2 class="mume-header" id="featured">Featured</h2>

<br>
<ul>
<li>
<p><strong><a href="https://github.com/runtimeverification/avm-semantics">KAVM (Feb 2022 - Present)</a></strong></p>
<p>The Algorand Virtual Machine and TEAL Semantics in K<br>
KAVM leverages the K Framework to empower Algorand smart contracts&apos; developers<br>
with property-based testing and formal verification.</p>
</li>
<li>
<p><strong><a href="https://github.com/runtimeverification/plutus-core-semantics">KPlutus (2016 - Present)</a></strong></p>
<p>The K Semantics of Plutus-Core</p>
</li>
<li>
<p><strong><a href="https://gitlab.com/semantiko/K-semantics">Dedukti (Mar 2021 - Present)</a></strong></p>
<p>This project aims to translate real K semantics into Dedukti.</p>
</li>
<li>
<p><strong><a href="https://github.com/kframework/wasm-semantics">KWasm (Aug 2015 - Present)</a></strong></p>
<p>KWasm is the K semantics of <a href="https://webassembly.github.io/spec/">WebAssembly</a>.<br>
WebAssembly is a low-level (but simple and streamlined) assembly language that was originally developed to provide a fast execution engine for browser-based tools.<br>
More recently, it has been used in several blockchain smart-contract platforms as the underlying language for executing financial agreements.<br>
KWasm has been used for measuring coverage of test-suites over Wasm code and verifying programs which are compiled to Wasm.</p>
</li>
<li>
<p><strong><a href="https://jellopaper.org/">KEVM (Sep 2017 - Present)</a></strong></p>
<p>KEVM is the K semantics of the <a href="https://ethereum.org/en/developers/docs/evm/">Ethereum Virtual Machine</a>.<br>
It passes all the Ethereum Test Suite, and is used for verifying EVM programs.</p>
</li>
<li>
<p><strong><a href="https://ielelang.org/">IELE (Oct 2016 - Present)</a></strong></p>
<p>IELE is the underlying VM integrated into the <a href="https://cardano.org/">Cardano</a> blockchain.<br>
IELE is a register-based VM (inspired by LLVM), which attempts to avoid many of the missteps in design present in EVM.</p>
</li>
<li>
<p><strong><a href="https://runtimeverification.github.io/michelson-semantics">K-Michelson (Oct 2019 - Present)</a></strong></p>
<p>K-Michelson is the K semantics of <a href="https://www.michelson.org/">Michelson blockchain programming language</a>, which powers the <a href="https://tezos.com/">Tezos blockchain</a>.<br>
KMichelson provides additional testing tools for developers, including a unit-testing framework which is extendable to symbolic property testing.</p>
</li>
<li>
<p><strong><a href="https://github.com/kframework/c-semantics">C (Jul 2010 - Present)</a></strong></p>
<p>The K semantics of the <a href="https://en.wikipedia.org/wiki/C_(programming_language)">C programming language</a> specifies the translation, linking, and execution semantics of the C language according to the official C standard.<br>
It has been used to build tools like RV-Match, which detects undefined behaviors in users programs by running their test-suites through the C semantics.</p>
</li>
</ul>
<h2 class="mume-header" id="archived">Archived</h2>

<ul>
<li><a href="https://github.com/kframework/llvm-semantics">llvm (2011-2018)</a></li>
<li><a href="https://github.com/kframework/python-semantics">python (2012-2013)</a></li>
<li><a href="https://github.com/kframework/java-semantics">java (2012-2016)</a></li>
<li><a href="https://github.com/kframework/ocaml-semantics">ocaml (2012-2013)</a></li>
<li><a href="https://github.com/kframework/javascript-semantics">javascript (2013-2015)</a></li>
<li><a href="https://github.com/kframework/aadl-semantics">aadl (2013-2013)</a></li>
<li><a href="https://github.com/kframework/alk-semantics">alk (2013-2014)</a></li>
<li><a href="https://github.com/kframework/cink-semantics">cink (2013-2015)</a></li>
<li><a href="https://github.com/kframework/jvm-semantics">jvm (2013-2014)</a></li>
<li><a href="https://github.com/kframework/modelink-semantics">modelink (2013-2013)</a></li>
<li><a href="https://github.com/kframework/javacard-semantics">javacard (2014-2014)</a></li>
<li><a href="https://github.com/kframework/orc-semantics">orc (2016-2017)</a></li>
<li><a href="https://github.com/kframework/haskell-core-semantics">haskell core (2016-2017)</a></li>
<li><a href="https://github.com/kframework/X86-64-semantics">X86-64 (2017-2020)</a></li>
<li><a href="https://github.com/kframework/vyper-semantics">vyper (2017-2018)</a></li>
<li><a href="https://github.com/runtimeverification/erc20-semantics">erc20 (2017-2018)</a></li>
<li><a href="https://github.com/kframework/solidity-semantics">solidity (2018-2019)</a></li>
<li><a href="https://github.com/kframework/eei-semantics">eei (2018-2019)</a></li>
<li><a href="https://github.com/runtimeverification/erc777-semantics">erc777 (2018-2018)</a></li>
<li><a href="https://github.com/kframework/k-in-k">k (2018-2020)</a></li>
<li><a href="https://github.com/ethereum/yul-semantics">yul (2019-2019)</a></li>
<li><a href="https://github.com/kframework/ewasm-semantics">KEwasm (2019-2020)</a></li>
<li><a href="https://github.com/Formal-Systems-Laboratory/hybrid-programs-semantics">hybrid programs (2020-2020)</a></li>
<li><a href="https://github.com/kframework/boogie-semantics">Boogie (2020)</a></li>
<li><a href="https://github.com/runtimeverification/elrond-semantics">Elrond (2020-2021)</a></li>
<li><a href="https://github.com/kframework/p4-semantics">P4 (2016-2021)</a></li>
<li><a href="https://github.com/bbyalcinkaya/k-javalette">K-Javalette (2022)</a></li>
<li><a href="https://github.com/wkyml/K-ST">K-ST (2023)</a></li>
</ul>
</div></div></body></html>
    </div>
  </body>
</html>
