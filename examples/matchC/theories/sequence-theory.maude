mod MATHEMATICAL-SEQUENCE-BUILTIN-MODULE is
  inc MATHEMATICAL-INT-BUILTIN-MODULE + PL-STRING .

  sorts PESeq FESeq FreeSeq NeSeq Seq Seq++ NeSeq++ . 
  subsort NeSeq < Seq .
  subsort NeSeq++ Seq < Seq++ .
  subsort PESeq FESeq FreeSeq NeSeq < NeSeq++ .
  subsort PESeq < PEMathObj .
  subsort FESeq < FEMathObj .
  subsort FreeSeq < FreeMathObj .
  subsort Seq < MathObj .
  subsort Seq++ < MathObj++ .
 
  op ?Seq : Nat -> PESeq .
  op !Seq : Nat -> FESeq .
  op !Seq : String -> FESeq .
  op FreeSeq : Nat -> FreeSeq .
  op FreeSeq : String -> FreeSeq .
  op skolem : Nat PESeq -> FreeSeq [ditto] .
  op co-skolem : Nat FreeSeq -> FESeq [ditto] .

  op epsilon : -> Seq .
  op `[_`] : List{MathObj++} -> NeSeq++ .
  ---op `[_`] : PEMathObj -> PESeq [ditto] .
  ---op `[_`] : FEMathObj -> FESeq [ditto] .
  ---op `[_`] : FreeMathObj -> FreeSeq [ditto] .
  op `[_`] : MathObj -> NeSeq [ditto] .
  op `[_`] : MathObj++ -> NeSeq++ [ditto] .
  op _@_ : Seq++ Seq++ -> Seq++ [assoc id: epsilon] .
  op _@_ : NeSeq++ Seq++ -> NeSeq++ [ditto] .
  op _@_ : Seq++ NeSeq++ -> NeSeq++ [ditto] .
  ---op _@_ : PESeq PESeq -> PESeq [ditto] .
  ---op _@_ : FESeq FESeq -> FESeq [ditto] .
  ---op _@_ : FreeSeq FreeSeq -> FreeSeq [ditto] .
  op _@_ : Seq Seq -> Seq [ditto] .
  op _@_ : NeSeq Seq -> NeSeq [ditto] .
  op _@_ : Seq NeSeq -> NeSeq [ditto] .
  op _@_ : NeSeq Seq++ -> NeSeq++ [ditto] .
  op _@_ : Seq++ NeSeq -> NeSeq++ [ditto] .
  op _@_ : NeSeq++ Seq -> NeSeq++ [ditto] .
  op _@_ : Seq NeSeq++ -> NeSeq++ [ditto] .
  op _@_ : Seq++ Seq -> Seq++ [ditto] .
  op _@_ : Seq Seq++ -> Seq++ [ditto] .
  op _@_ : NeSeq++ NeSeq -> NeSeq++ [ditto] .
  op _@_ : NeSeq NeSeq++ -> NeSeq++ [ditto] . 

  op rev : Seq++ -> NeSeq++ .
  op len : Seq++ -> Int++ .
  op maximum : Seq++ -> Int++ .
  op hd : Seq++ -> MathObj++ .
  op find : MathObj++ Seq++ -> AtomFormula .
  op contain : Seq++ Int++ -> AtomFormula .


  var N : Nat .
  var I J : Int++ .
  var Obj Obj1 Obj2 : MathObj++ .
  var ObjList ObjList1 ObjList2 : List{MathObj++} .
  var A A1 A2 : Seq++ .
  var NeA NeA1 NeA2 : NeSeq++ .
  var B : Seq . 
  var NeB : NeSeq . 

  eq [Obj1, Obj2, ObjList] = [Obj1] @ [Obj2] @ [ObjList] .
  eq [.List{MathObj++}] = epsilon .
  eq [Obj] @ A === epsilon = FalseFormula .
  eq A @ [Obj] === epsilon = FalseFormula .
  eq NeA1 @ NeA2 === epsilon = NeA1 === epsilon /\ NeA2 === epsilon .
  eq NeA @ A1 === NeA @ A2 = A1 === A2 .
  eq A1 @ NeA === A2 @ NeA = A1 === A2  .
  eq [Obj1] @ A1 === [Obj2] @ A2 = Obj1 === Obj2 /\ A1 === A2 .
  eq A1 @ [Obj1] === A2 @ [Obj2] = Obj1 === Obj2 /\ A1 === A2 .


  eq rev(NeA1 @ NeA2) = rev(NeA2) @ rev(NeA1) .
  eq rev([Obj]) = [Obj] .
  eq rev(epsilon) = epsilon .
  eq len(NeA1 @ NeA2) = len(NeA1) +Int len(NeA2) .
  eq len([Obj]) = 1 .
  eq len(epsilon) = 0 .
  
  eq hd(NeA1 @ NeA2) = hd(NeA1) .
  eq hd([Obj]) = Obj .

  eq find(Obj, NeA1 @ NeA2) = find(Obj, NeA1) \/ find(Obj, NeA2) .
  eq find([Obj1] , Obj2) = (Obj1 === Obj2) .
  eq find(epsilon , Obj) = FalseFormula .

  eq contain(NeA1 @ NeA2 , I) = contain(NeA1 , I) \/ contain(NeA2 , I) .
  eq contain([J] , I) = (I === J) .
  eq contain(epsilon , I) = FalseFormula .

  eq rev(rev(A)) = A .
  eq rev(A1) === rev(A2) = A1 === A2 .
  eq rev(A) === epsilon = A === epsilon .
  eq len(A) === 0 = A === epsilon .
  eq @(len(A) >=Int 0) = TrueFormula . 
  eq @((-Int len(A)) >=Int 0) = A === epsilon .
  eq len(rev(A)) = len(A) .
  eq len(A) === len(A1) /\ A === A1 @ A2 = A === A1 /\ A2 === epsilon .
  eq len(A) === len(A2) /\ A === A1 @ A2 = A === A2 /\ A1 === epsilon .

 ceq len(NeA1) === N /\ NeA1 @ NeA2 === NeB @ B
   = len(NeA1) === N /\ NeA1 === NeB /\ NeA2 === B
  if len(NeB) ==Bool N .
endm

