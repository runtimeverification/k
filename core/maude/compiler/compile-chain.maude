mod COMPILE-ONESHOT is
 including MANY-MODULES-META 
+ ADD-EVAL-META 
+ RESOLVE-BINDER-META
+ RESOLVE-DITTO-META + COMPLETE-K-SORTS-META + ANONYMOUS-CONSTANTS-META 
--- + SANITY-CHECKS-META 
+ REMOVE-PARSER-META 
+ SYNTAX-PREDICATES-META 
--- + MISSING-SUBSORTS-META 
+ BLOCKING-INPUT-META 
+ DEFAULT-TERMS-META 
+ CONTEXT-TRANSFORMERS-META 
+ OPEN-CELLS-META 
+ ANONYMOUS-VARIABLES-META 
+ MAKE-K-RULES-META 
--- + REMOVE-SUBLISTS-META
--- + LISTS-TO-WRAPPERS-META 
--- + SYNTAX-TO-K-META 
---+ ADD-KPROPER-META 
---+ LISTS-TO-K-META
+ SUBSORTS-TO-WRAPPERS-META 
+ HOMOGENOUS-ARGUMENTS-META 
+ MAKE-ALL-LABELS-META 
+ STRICTOPS2CXT-META 
+ STRICTCXT2EQS-META 
+ RESOLVE-HOOKS-META 
--- + RESULT-PREDICATES-META 
--- + ID-TO-STRING-META 
+ PARSE-METADATA .

  op compile : Module QidList AttrSet ~> Module .
  eq compile(M, nil, AS) = M .
  eq compile(M, Q QIL, AS) = compile(compile1(M,Q, AS), QIL, AS) .

  op compile1 : Module Qid AttrSet ~> Module .
  eq compile1(M, 'MANY-MODULES, AS) = compileMANY-MODULES(M, AS) .
  eq compile1(M, 'REMOVE-PARSER, AS) = compileREMOVE-PARSER(M, AS) .
  eq compile1(M, 'ADD-EVAL, AS) = compileADD-EVAL(M, AS) .
  eq compile1(M, 'RESOLVE-DITTO, AS) = compileRESOLVE-DITTO(M, AS) .
  eq compile1(M, 'RESOLVE-BINDER, AS) = compileRESOLVE-BINDER(M, AS) .
  eq compile1(M, 'COMPLETE-K-SORTS, AS) = compileCOMPLETE-K-SORTS(M, AS) .
  eq compile1(M, 'ANONYMOUS-CONSTANTS, AS) = compileANONYMOUS-CONSTANTS(M, AS) . 
---  eq compile1(M, 'SANITY-CHECKS, AS) = compileSANITY-CHECKS(M, AS) . 
 
---  eq compile1(M, 'MISSING-SUBSORTS, AS) = compileMISSING-SUBSORTS(M, AS) . 
  eq compile1(M, 'SYNTAX-PREDICATES, AS) = compileSYNTAX-PREDICATES(M, AS) . 
  eq compile1(M, 'BLOCKING-INPUT, AS) = compileBLOCKING-INPUT(M, AS) . 
  eq compile1(M, 'DEFAULT-TERMS, AS) = compileDEFAULT-TERMS(M, AS) . 
  eq compile1(M, 'CONTEXT-TRANSFORMERS, AS) = compileCONTEXT-TRANSFORMERS(M, AS) . 
  eq compile1(M, 'OPEN-CELLS, AS) = compileOPEN-CELLS(M, AS) . 
  eq compile1(M, 'ANONYMOUS-VARIABLES, AS) = compileANONYMOUS-VARIABLES(M, AS) . 
  eq compile1(M, 'MAKE-K-RULES, AS) = compileMAKE-K-RULES(M, AS) . 
---  eq compile1(M, 'REMOVE-SUBLISTS, AS) = compileREMOVE-SUBLISTS(M, AS) . 
---  eq compile1(M, 'LISTS-TO-WRAPPERS, AS) = compileLISTS-TO-WRAPPERS(M, AS) . 
---  eq compile1(M, 'SYNTAX-TO-K, AS) = compileSYNTAX-TO-K(M, AS) . 
---  eq compile1(M, 'ADD-KPROPER, AS) = compileADD-KPROPER(M, AS) . 
---  eq compile1(M, 'LISTS-TO-K, AS) = compileLISTS-TO-K(M, AS) . 
  eq compile1(M, 'SUBSORTS-TO-WRAPPERS, AS) = compileSUBSORTS-TO-WRAPPERS(M, AS) . 
  eq compile1(M, 'HOMOGENOUS-ARGUMENTS, AS) = compileHOMOGENOUS-ARGUMENTS(M, AS) . 
  eq compile1(M, 'MAKE-ALL-LABELS, AS) = compileMAKE-ALL-LABELS(M, AS) . 
  eq compile1(M, 'STRICTOPS2CXT, AS) = compileSTRICTOPS2CXT(M, AS) . 
  eq compile1(M, 'STRICTCXT2EQS, AS) = compileSTRICTCXT2EQS(M, AS) . 
  eq compile1(M, 'RESOLVE-HOOKS, AS) = compileRESOLVE-HOOKS(M, AS) . 
---  eq compile1(M, 'ID-TO-STRING, AS) = compileID-TO-STRING(M, AS) . 
---  eq compile1(M, 'RESULT-PREDICATES, AS) = compileRESULT-PREDICATES(M, AS) . 

  op allSteps : -> QidList .
  eq allSteps = 
'MANY-MODULES 
'ADD-EVAL 
'RESOLVE-DITTO 
'RESOLVE-BINDER    
'COMPLETE-K-SORTS 
'ANONYMOUS-CONSTANTS
'ANONYMOUS-VARIABLES 
--- 'SANITY-CHECKS 
'REMOVE-PARSER 
'SYNTAX-PREDICATES
'SUBSORTS-TO-WRAPPERS   
'HOMOGENOUS-ARGUMENTS  

'MAKE-ALL-LABELS 
'STRICTOPS2CXT 
--- 'ID-TO-STRING 
---'RESULT-PREDICATES
'BLOCKING-INPUT

'DEFAULT-TERMS 
'CONTEXT-TRANSFORMERS 
'OPEN-CELLS 
'MAKE-K-RULES 
'STRICTCXT2EQS 
'RESOLVE-HOOKS 
.

  op compile : Module AttrSet ~> Module .  
  eq compile(M, AS) = compile(M, allSteps, AS) .

  op partialCompile : Module Qid AttrSet ~> Module .
  eq partialCompile(M,Q, AS) = compile(M, upTo(allSteps,Q), AS) .
  
  op partialCompile : Qid Qid AttrSet ~> Module .
  eq partialCompile(Q, Q', AS) = partialCompile(upModule(Q, false), Q', AS) .

  var M : Module . var Q Q' : Qid . var QIL : QidList .  var AS : AttrSet .
endm

fmod COMPILE-META is
  including META-LEVEL .
  including META-MODULE-EXTRAS .
  including STRING-EXTRAS .
  including MODULE-META-PRETTY-PRINT .
---  including PURE-MODULE-META-PRETTY-PRINT .
---  including XML-MODULE-META-PRETTY-PRINT .
  including PARSE-METADATA .
  including COMPILATION-ATTRS .

  op wrapper : Qid -> Module .
  eq wrapper(Q) = (mod 'MKKR is including Q . 
                    sorts none . none none none none none endm) [print "Got to " Q] .
  op error : -> [Module] .

  op compile : Qid AttrSet ~> Module .
  eq compile(Q, AS) = compile(upModule(Q, false), AS) [print "compiling module " Q " with attributes " AS] .
  eq compile(Q, AS:[AttrSet]) = errorM(none, "Could not parse compilation attributes", '`[`]:K, "", upModule(Q, false)) [print "Could not parse compilation attributes: " AS:[AttrSet]] .

  op pcompile : Qid Qid AttrSet ~> Module .
  eq pcompile(Q, Q', AS) = partialCompile(upModule(Q, false), Q', AS) .

  op getPhaseName : Qid ~> QidList .
  eq getPhaseName('MANY-MODULES) 
   = 'flattening 'entire 'definition 'in 'a 'single 'module .
  eq getPhaseName('REMOVE-PARSER) 
   = tokenize("removing extra parser stuff") .
  eq getPhaseName('ADD-EVAL) 
   = tokenize("adding the eval function") .
  eq getPhaseName('RESOLVE-DITTO) 
   = 'Updating 'metadata 'information 'for 'ditto 'operations .
  eq getPhaseName('RESOLVE-BINDER) 
   = 'Updating 'metadata 'information 'for 'ditto 'operations .
  eq getPhaseName('COMPLETE-K-SORTS) 
   = tokenize("subsorting (almost) everything to K") .
  eq getPhaseName('ANONYMOUS-CONSTANTS) 
   = tokenize("transforming Anonymous constants into variables") .
---  eq getPhaseName('SANITY-CHECKS)
---   = tokenize("checking each (sub)term parses to a sort") .
  eq getPhaseName('SYNTAX-PREDICATES)
   = tokenize("creating predicates for syntax sorts") .
  eq getPhaseName('MISSING-SUBSORTS)
   = tokenize("(almost) transitively closing the subsorts") .
  eq getPhaseName('BLOCKING-INPUT)
   = tokenize("generating request equations for istream cells.") .
  eq getPhaseName('DEFAULT-TERMS)
   = tokenize("filling missing information in the right hand side.") .
  eq getPhaseName('CONTEXT-TRANSFORMERS)
   = tokenize("applying Context Transformers") .
  eq getPhaseName('OPEN-CELLS)
   = tokenize("transforming open cells to normal cells through anonymous variables") .
  eq getPhaseName('ANONYMOUS-VARIABLES)
   = tokenize( "resolving Anonymous Variables") .
  eq getPhaseName( 'MAKE-K-RULES)
   = tokenize("generating Maude rules from K rules") .
  eq getPhaseName('REMOVE-SUBLISTS)
   = tokenize("removing subsorted lists") .
  eq getPhaseName('LISTS-TO-WRAPPERS)
   = tokenize( "wrapping Syntax lists into K") .
  eq getPhaseName('SYNTAX-TO-K)
   = tokenize("merging syntax sorts into K") .
  eq getPhaseName('ADD-KPROPER)
   = tokenize("adding the KProper Sort") .
  eq getPhaseName('LISTS-TO-K)
   = tokenize("merging lists sorts into K") .
  eq getPhaseName('RESULT-PREDICATES)
   = tokenize("removing KResults and KHybrid by using predicates") .
  eq getPhaseName('SUBSORTS-TO-WRAPPERS)
   = tokenize("transforming subsorted builtins into injections") .
  eq getPhaseName('HOMOGENOUS-ARGUMENTS)
   = tokenize("wrapping non-K arguments") .
  eq getPhaseName( 'MAKE-ALL-LABELS )
   = tokenize( "reducing all K constructs to K labels" ) .
  eq getPhaseName('STRICTOPS2CXT) 
   = tokenize("generating Strictness Axioms") .
  eq getPhaseName('STRICTCXT2EQS)
   = tokenize("generating Strictness Equations") .
  eq getPhaseName('RESOLVE-HOOKS)
   = tokenize("generating equations for Hooks") .
---  eq getPhaseName('ID-TO-STRING)
---   = tokenize("generating equations for Id2String") .

  op allSteps : -> QidList .
  eq allSteps = 
'MANY-MODULES 
'ADD-EVAL 
'RESOLVE-DITTO 
'RESOLVE-BINDER 
'COMPLETE-K-SORTS 
'ANONYMOUS-CONSTANTS 
'ANONYMOUS-VARIABLES 
'REMOVE-PARSER 
--- 'SANITY-CHECKS 
'BLOCKING-INPUT
'SYNTAX-PREDICATES
--- 'SYNTAX-TO-K 
'SUBSORTS-TO-WRAPPERS
'HOMOGENOUS-ARGUMENTS  
'MAKE-ALL-LABELS 

'STRICTOPS2CXT 
--- 'ID-TO-STRING 
--- 'RESULT-PREDICATES

'DEFAULT-TERMS 
'CONTEXT-TRANSFORMERS 
'OPEN-CELLS 
'MAKE-K-RULES 
'STRICTCXT2EQS 
'RESOLVE-HOOKS 
.
  
  op compile : Module AttrSet ~> Module .  
  eq compile(M, AS) = compile(M, allSteps, AS) .
  eq compile(upModule(Q, B:Bool), AS) = moduleError('`[ 'ERROR '`] '\s 'Module '\r Q '\o  'could 'not 'be 'found) .
  
  op partialCompile : Module Qid AttrSet ~> Module .
  eq partialCompile(M,Q, AS) = compile(M, upTo(allSteps,Q), AS) .
  
  op compile : Module QidList AttrSet ~> Module .
  eq compile(M,nil, AS) = M [print "Final module: " M] .
  eq compile(M, Q QIL, AS) =  $compile(M, Q, 
    downTerm(getTerm(
             metaRewrite(wrapper(qid(string(Q) + "-META")),
                        qid("compile" + string(Q))[upTerm(M),upTerm(AS)], unbounded)), error)
     , QIL, AS) [print "applying transformation " Q " on module " M] .
  
  op $compile : Module Qid Module QidList AttrSet ~> Module .
  eq $compile(M, Q, moduleError(QIL), QIL', AS) = moduleError(QIL) .
  eq $compile(M, Q, errorM(AS, Str, Trm, Cxt, M'), QIL', AS')
   = moduleError('`[ 'ERROR '`] tokenize(Str) '\n '\s '\r 'Term: '\o eMetaPrettyPrint(M,Trm) '\n '\s '\r 'Context: '\o tokenize(Cxt) '\n 'Location: tokenize(getLocation(AS)) '\n '\s 'Compilation 'phase: '\r Q '\o '`[ 'ENDERROR '`]) .
  eq $compile(M, Q, M', QIL, AS)  = if M' :: Module and-then wellFormed(M') then compile(M', QIL, AS) else generateError(M,Q,M') fi [owise] .

---  op purePrint : [Module] -> QidList .
---  eq purePrint(M) = pureEMetaPrettyPrint(setRls(setEqs(M,none),none), M) .
---  op xmlPrint : [Module] -> QidList .
---  eq xmlPrint(M) = xml-eMetaPrettyPrint(setRls(setEqs(M,none),none), M) .
  op print : [Module] -> QidList .
  eq print(M) = eMetaPrettyPrint(setRls(setEqs(M,none),none), M) .
  op generateError : Module Qid [Module] -> [Module] .
  eq generateError(M, Q, M') = moduleError('`[ 'ERROR '`] 'Error 'while getPhaseName(Q) '`( 'module Q '`)  '`[ 'ENDERROR '`] '\n
   'To 'reproduce 'load 'k-prelude 'and 'then 'the 'generated 'module. '\n
   print(M) 
) [print "not well formed module " M'].

  var Q Q' : Qid . var QIL QIL' : QidList . var M : Module .  var M' : [Module] .  var Trm : Term .  var Cxt : String . 
  var AS AS' : AttrSet .  var Str : String .
endfm

mod COMPILE-LOOP is
  including LOOP-MODE + COMPILE-META + META-LEVEL-EXTRAS .
  op compile : -> System .
  op idle : -> State .
  var Q Q' : Qid . var QIL QIL' : QidList . var FM : Module .
  eq compile = [nil, idle, 
 'Usage: 'compile '<ModuleName> '. ] .

  op error : -> [Module] .
  var Str : String . var M FM' : Module . var OPDS : OpDeclSet .  

  op compile : Qid -> [Module] .
  eq compile(Q) = compile(Q, supercools(none) transitions(none) superheats(none) anywheres(none)) .

  eq print(moduleError(QIL)) = QIL .
---  eq purePrint(moduleError(QIL)) = QIL .
---  eq xmlPrint(moduleError(QIL)) = QIL .
  rl ['compile Q 'transitions QStr 'superheats QComp 'supercools QSuper 'anywheres QFun 'defineds QDef QIL, idle, QIL'] 
   => [QIL, idle, print(compile(Q, transitions(metadataQParse(QStr)) superheats(metadataQParse(QComp)) supercools(metadataQParse(QSuper)) anywheres(metadataQParse(QFun)) defineds(metadataQParse(QDef))))] [print QStr QComp QSuper QFun QDef] .
  rl ['pcompile Q Q' QIL, idle, QIL'] 
   => [QIL, idle, print(pcompile(Q,Q', transitions(none) superheats(none) supercools(none) anywheres(none) defineds(none)))] .

  op metadataQParse : Qid -> AttrSet .
  eq metadataQParse(Q) = metadataParse(substr(string(Q),1,_-_(length(string(Q)),2))) .

  rl ['pcompile Q Q' QIL, idle, QIL'] 
   => [QIL, idle, print(pcompile(Q,Q', transitions(pair("transition","")) superheats(pair("superheat","")) supercools(pair("supercool","")) anywheres(pair("function","")pair("predicate","")pair("anywhere","")) defineds(pair("function","")pair("predicate","")pair("defined",""))) )] .

---  rl ['purify Q QIL, idle, QIL'] 
---   => [QIL, idle, purePrint(extractModule(pcompile(Q,'RESULT-PREDICATES,  transitions(pair("transition","")) superheats(pair("superheat","")) supercools(pair("supercool",""))),'PURE-K-TECHNIQUE))] .

---  rl ['xcompile Q Q' 'transitions QStr 'superheats QComp 'supercools QSuper 'anywheres QFun QIL, idle, QIL']
---  => [QIL, idle, xmlPrint(pcompile(Q, Q', transitions(metadataQParse(QStr)) superheats(metadataQParse(QComp)) supercools(metadataQParse(QSuper)) anywheres(metadataQParse(QFun))))] .


  var AS : AttrSet .  var QStr QComp QSuper QFun QDef : Qid .
endm
