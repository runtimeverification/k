***(
    Formal semantics of case statements, as layed out in the Expressions section of the Haskell Report
***)

mod HASKELL-CASE-SEMANTICS is
    including HASKELL-SYNTAX .
    including HASKELL-SYNTAX-UTILS .
    vars Loc1 Loc2 Loc3 Loc4 Loc5 : SrcLoc .
    vars Binds1 Binds2 Binds3 Decls1 Decls2 Decls3 : Binds .
    vars Pat1 Pat2 Pat3 Underscore : Pat .



***(
(a)	case e of { alts } = (\v -> case v of { alts }) e
	where v is a new variable
***)

***(
(b)	case v of { p1 match1;  ... ; pn matchn }
	=  case v of { p1 match1 ;
	                _  -> ... case v of {
	                           pn matchn ;
	                           _  -> error "No match" }...}
	 where each matchi has the form:
	  | gi,1  -> ei,1 ; ... ; | gi,mi -> ei,mi where { declsi }
***)

***(
(c)	case v of { p | g1 -> e1 ; ...
	             | gn -> en where { decls }
	            _     -> e' }
	= case e' of
	  {y ->  (where y is a new variable)
	   case v of {
	         p -> let { decls } in
                case () of {
                  () | gs1 -> e1;
                  _ -> ... case () of {
                             () | gsn -> en;
                             _ -> y } ... }
	         _ -> y }}
***)

***(
(d)	case v of { ~p -> e; _ -> e' }
	= (\x1 ... xn -> e ) (case v of { p-> x1 }) ... (case v of { p -> xn})
	where x1, ..., xn are all the variables in p
***)

***(
(e)	case v of { x@p -> e; _ -> e' }
	=  case v of { p -> ( \ x -> e ) v ; _ -> e' }
Pending questions:
  - Again with the _, currently assume it to be any pattern
  - Again with Binds, again generalized

AST:  (Case (Var (UnQual (Ident "v"))) ((:)(Alt (SrcLoc "tests/case-e.hs" 2 26) (PAsPat (Ident "x") (PVar (Ident "p"))) (UnGuardedAlt (Var (UnQual (Ident "e")))) (BDecls ([]))) ((:)(Alt (SrcLoc "tests/case-e.hs" 2 36) PWildCard (UnGuardedAlt (Var (UnQual (Ident "e'")))) (BDecls ([]))) ([]))))
   ===
     (Case (Var (UnQual (Ident "v"))) ((:)(Alt (SrcLoc "tests/case-e.hs" 3 26) (PVar (Ident "p")) (UnGuardedAlt (App (Paren (Lambda (SrcLoc "tests/case-e.hs" 3 33) ((:)(PVar (Ident "x")) ([])) (Var (UnQual (Ident "e"))))) (Var (UnQual (Ident "v"))))) (BDecls ([]))) ((:)(Alt (SrcLoc "tests/case-e.hs" 3 48) PWildCard (UnGuardedAlt (Var (UnQual (Ident "e'")))) (BDecls ([]))) ([]))))

more-general: (Case (Var V:QName) ((:)(Alt Loc1 (PAsPat X:Name (PVar P:Name)) (UnGuardedAlt (Var E:QName)) Binds1) ((:)(Alt Loc2 Underscore (UnGuardedAlt (Var EPrime:QName)) Binds2) [])))
   ===
     (Case (Var V:QName) ((:)(Alt Loc1 (PVar P:Name) (UnGuardedAlt (App (Paren (Lambda Loc2 ((:)(PVar X:Name) []) (Var (UnQual E:QName)))) (Var (UnQual V:QName)))) Binds1) ((:)(Alt Loc2 Underscore (UnGuardedAlt (Var EPrime:QName))Binds2) [])))

***)

    eq Case (Var V:QName) ((:)(Alt Loc1 (PAsPat X:Name (PVar P:Name)) (UnGuardedAlt (Var E:QName)) Binds1) ((:)(Alt Loc2 Underscore (UnGuardedAlt (Var EPrime:QName)) Binds2) []))
     = Case (Var V:QName) ((:)(Alt Loc1 (PVar P:Name) (UnGuardedAlt (App (Paren (Lambda Loc2 ((:)(PVar X:Name) []) (Var (UnQual E:QName)))) (Var (UnQual V:QName)))) Binds1) ((:)(Alt Loc2 Underscore (UnGuardedAlt (Var EPrime:QName)) Binds2) [])) .



***(
(f)	case v of { _ -> e; _ -> e' } = e
Pending Questions:
  - I think the second _ just means some pattern, while the first must be an actual underscore
  - I'm keeping the binds general

AST: (Case (Var (UnQual (Ident "v"))) ((:)(Alt (SrcLoc "tests/case-f.hs" 2 26) PWildCard (UnGuardedAlt (Var (UnQual (Ident "e")))) (BDecls ([]))) ((:)(Alt (SrcLoc "tests/case-f.hs" 2 34) PWildCard (UnGuardedAlt (Var (UnQual (Ident "e'")))) (BDecls ([]))) ([]))))
   ===
    (Var (UnQual (Ident "e")))

more-general: (Case (Var V:QName) ((:)(Alt Loc1 UnderscoreLit:Pat (UnGuardedAlt E:Exp) Binds1) ((:)(Alt Loc2 Underscore (UnGuardedAlt EPrime:Exp) Binds2) [])))
    ===
    E:Exp

***)

    eq Case (Var V:QName) ((:)(Alt Loc1 PWildCard (UnGuardedAlt E:Exp) Binds1) ((:)(Alt Loc2 Underscore (UnGuardedAlt EPrime:Exp) Binds2) []))
     = E:Exp .

***(
(g)	case v of { K p1  ...pn -> e; _ -> e' }
	= case v of {
	     K x1 ...xn -> case x1 of {
	                    p1 -> ... case xn of { pn -> e ; _ -> e' } ...
	                    _  -> e' }
	     _ -> e' }
	at least one of p1, ..., pn is not a variable; x1, ..., xn are new variables
***)

***(
(h)	case v of { k -> e; _ -> e' } = if (v==k) then e else e'
	where k is a numeric, character, or string literal .
***)


***(
(i)	case v of { x -> e; _ -> e' } = case v of { x -> e }

Pending questions:
  - Is the _ able to be any pattern, or must this only apply when an underscore is present?
    Currently, I say it can be any pattern, as I think that's the intent.
  - The parser gives us Binds in Alts. I don't know why. Currently I generalize them

AST: (Case (Var (UnQual (Ident "v"))) ((:)(Alt (SrcLoc "tests/case-i.hs" 2 23) (PVar (Ident "x")) (UnGuardedAlt (Var (UnQual (Ident "e")))) (BDecls ([]))) ((:)(Alt (SrcLoc "tests/case-i.hs" 2 31) PWildCard (UnGuardedAlt (Var (UnQual (Ident "e'")))) (BDecls ([]))) ([]))))
   ===
     (Case (Var (UnQual (Ident "v"))) ((:)(Alt (SrcLoc "tests/case-i.hs" 3 26) (PVar (Ident "x")) (UnGuardedAlt (Var (UnQual (Ident "e")))) (BDecls ([]))) ([])))


minus-srcLoc: (Case (Var (UnQual (Ident "v"))) ((:)(Alt (Loc1) (PVar (Ident "x")) (UnGuardedAlt (Var (UnQual (Ident "e")))) (BDecls ([]))) ((:)(Alt (Loc2) PWildCard (UnGuardedAlt (Var (UnQual (Ident "e'")))) (BDecls ([]))) ([]))))
   ===
     (Case (Var (UnQual (Ident "v"))) ((:)(Alt (Loc1) (PVar (Ident "x")) (UnGuardedAlt (Var (UnQual (Ident "e")))) (BDecls ([]))) ([])))


more-general: (Case (Var (V:QName)) ((:)(Alt (Loc1) (PVar (X:Name)) (UnGuardedAlt (E:Exp)) (BDecls ([]))) ((:)(Alt (Loc2) (Underscore) (UnGuardedAlt (EPrime:Exp)) (BDecls ([]))) ([]))))
   ===
     (Case (Var (V)) ((:)(Alt (Loc1) (PVar (X)) (UnGuardedAlt (E)) (BDecls ([]))) ([])))

minus-bdecls: (Case (Var (V:QName)) ((:)(Alt (Loc1) (PVar (X:Name)) (UnGuardedAlt (E:Exp)) (Binds1)) ((:)(Alt (Loc2) (Underscore) (UnGuardedAlt (EPrime:Exp)) (Binds2)) ([]))))
   ===
     (Case (Var (V)) ((:)(Alt (Loc1) (PVar (X)) (UnGuardedAlt (E)) (B1)) ([])))

final: Case (Var V:QName) ((:)(Alt Loc1 (PVar X:Name) (UnGuardedAlt E:Exp) Binds1) ((:)(Alt Loc2 Underscore (UnGuardedAlt EPrime:Exp) Binds2) []))
   ===
     Case (Var V:QName) ((:)(Alt Loc1 (PVar X:Name) (UnGuardedAlt E:Exp) Binds1) []) .

***)

    eq Case (Var V:QName) ((:)(Alt Loc1 (PVar X:Name) (UnGuardedAlt E:Exp) Binds1) ((:)(Alt Loc2 Underscore (UnGuardedAlt EPrime:Exp) Binds2) []))
     = Case (Var V:QName) ((:)(Alt Loc1 (PVar X:Name) (UnGuardedAlt E:Exp) Binds1) []) .

***(
(j)	case v of { x -> e } = ( \ x -> e ) v

Pending Questions:
  - I'm keeping the Binds general

AST: (Case (Var (UnQual (Ident "v"))) ((:)(Alt (SrcLoc "tests/case-j.hs" 2 26) (PVar (Ident "x")) (UnGuardedAlt (Var (UnQual (Ident "e")))) (BDecls ([]))) ([])))
   ===
     (App (Paren (Lambda (SrcLoc "tests/case-j.hs" 3 16) ((:)(PVar (Ident "x")) ([])) (Var (UnQual (Ident "e"))))) (Var (UnQual (Ident "v"))))

more-general:  (Case (Var V:QName) ((:)(Alt Loc1 (PVar X:Name) (UnGuardedAlt E:Exp) Binds1) []))
   ===
     (App (Paren (Lambda Loc1 ((:)(PVar X:Name) []) E:Exp)) (Var V:QName))
***)

    eq (Case (Var V:QName) ((:)(Alt Loc1 (PVar X:Name) (UnGuardedAlt E:Exp) Binds1) []))
     = (App (Paren (Lambda Loc1 ((:)(PVar X:Name) []) E:Exp)) (Var V:QName)) .

***(
(k)	case N v of { N p -> e; _ -> e' }
	= case v of { p -> e; _ -> e' }
	where N is a newtype constructor

Pending questions:
  - I'm keeping the _ as a literal underscore
Note: We'll need to use K for this one, as the AST doesn't know that N is a newtype constructor

***)

***(
(l)	case _|_ of { N p -> e; _ -> e' } = case _|_ of { p -> e }
	where N is a newtype constructor
Pending questions:
  - I have no idea what bottom means in the context of dynamic semantics
Note: We'll need to use K for this one, as the AST doesn't know that N is a newtype constructor

***)

***(
(m)	case  v  of {  K  { f1  =  p1  ,  f2  =  p2  ,  ... } ->  e ; _ ->  e'  }
	=  case e' of {
	   y ->
	    case  v  of {
	      K  {  f1  =  p1  } ->
	            case  v  of { K  { f2  =  p2  ,  ...  } ->  e ; _ ->  y  };
	            _ ->  y  }}
	where f1, f2, ... are fields of constructor K; y is a new variable
***)

***(
(n)	case  v  of {  K  { f  =  p } ->  e ; _ ->  e'  }
	= case  v  of {
	     K p1 ... pn  ->  e ; _ ->  e'  }
	where pi is p if f labels the ith component of K, _ otherwise
Note: Will have to use K in order to know about the "K" constructor
***)

***(
(o)	case  v  of {  K  {} ->  e ; _ ->  e'  }
	= case  v  of {
	     K _ ... _ ->  e ; _ ->  e'  }
Note: Will have to use K in order to know the arity of the "K" constructor
***)

***(
(p)	case (K' e1 ... em) of { K x1 ... xn -> e; _ -> e' } = e'
	where K and K' are distinct data constructors of arity n and m, respectively
Pending questions:
  - I think the underscore has to be a literal underscore
  - Generalizing Binds

AST: (Case (Paren (App (App (App (Con (UnQual (Ident "K'"))) (Lit (Int 1))) (Lit (Int 2))) (Lit (Int 3)))) ((:)(Alt (SrcLoc "tests/case-p.hs" 4 35) (PApp (UnQual (Ident "K")) ((:)(PVar (Ident "x1")) ((:)(PVar (Ident "x2")) ((:)(PVar (Ident "x3")) ([]))))) (UnGuardedAlt (Var (UnQual (Ident "e")))) (BDecls ([]))) ((:)(Alt (SrcLoc "tests/case-p.hs" 4 52) PWildCard (UnGuardedAlt (Var (UnQual (Ident "e'")))) (BDecls ([]))) ([]))))
   ===
     (Var (UnQual (Ident "e'")))

more-general: (Case KPrime:Exp ((:)(Alt Loc1 K:Pat (UnGuardedAlt E:Exp) Binds1) ((:)(Alt Loc2 PWildCard (UnGuardedAlt EPrime:Exp) Binds2) [])))
   ===
     EPrime:Exp
   if not sameConstructor(KPrime:Exp, K:Pat)
***)

    ceq Case KPrime:Exp ((:)(Alt Loc1 K:Pat (UnGuardedAlt E:Exp) Binds1) ((:)(Alt Loc2 PWildCard (UnGuardedAlt EPrime:Exp) Binds2) []))
      = EPrime:Exp
     if notBool sameConstructor(KPrime:Exp, K:Pat) .

***(
(q)	case (K e1 ... en) of { K x1 ... xn -> e; _ -> e' }
	= (\x1 ... xn -> e) e1 ... en
	where K is a data constructor of arity n

***)

***(
(r)
	case _|_ of { K x1 ... xn -> e; _ -> e' } = _|_
	where K is a data constructor of arity n
Pending Questions:
  - I'm unsure of what bottom here would mean in a dynamic semantics

***)

***(
(s) 	case () of { () | g1, ..., gn -> e; _ -> e' }
	= case () of {
	    () | g1 -> ... case () of {
	                   () | gn -> e;
	                   _ -> e' } ...
	    _ -> e' }
	where y is a new variable
***)

***(
(t) 	case () of { () | p <- e0 -> e; _ -> e' }
	= case e0 of { p -> e; _ -> e' }
Pending Questions:
  - I'm unsure of the _ here, so I'll have it be literal
  - I generalize BDecls
AST: (Case (Con (Special UnitCon)) ((:)(Alt (SrcLoc "tests/case-t.hs" 4 27) (PApp (Special UnitCon) ([])) (GuardedAlts ((:)(GuardedAlt (SrcLoc "tests/case-t.hs" 4 30) ((:)(Generator (SrcLoc "tests/case-t.hs" 4 32) (PApp (UnQual (Ident "Pat")) ((:)(PVar (Ident "pat")) ([]))) (Var (UnQual (Ident "e0")))) ([])) (Var (UnQual (Ident "e")))) ([]))) (BDecls ([]))) ((:)(Alt (SrcLoc "tests/case-t.hs" 4 52) PWildCard (UnGuardedAlt (Var (UnQual (Ident "e'")))) (BDecls ([]))) ([]))))
   ===
     (Case (Var (UnQual (Ident "e0"))) ((:)(Alt (SrcLoc "tests/case-t.hs" 5 27) (PApp (UnQual (Ident "Pat")) ((:)(PVar (Ident "pat")) ([]))) (UnGuardedAlt (Var (UnQual (Ident "e")))) (BDecls ([]))) ((:)(Alt (SrcLoc "tests/case-t.hs" 5 41) PWildCard (UnGuardedAlt (Var (UnQual (Ident "e'")))) (BDecls ([]))) ([]))))

more-general: Case (Con (Special UnitCon)) ((:)(Alt Loc1 (PApp (Special UnitCon) []) (GuardedAlts ((:)(GuardedAlt Loc2 ((:)(Generator Loc3 Pat1 E0:Exp) []) E:Exp) [])) Binds1) ((:)(Alt Loc4 PWildCard (UnGuardedAlt EPrime:Exp) Binds2) []))
   ===
     Case E0:Exp ((:)(Alt Loc1 Pat1 (UnGuardedAlt E:Exp) Binds1) ((:)(Alt Loc4 PWildCard (UnGuardedAlt EPrime:Exp) Binds2) []))

***)

    eq Case (Con (Special UnitCon)) ((:)(Alt Loc1 (PApp (Special UnitCon) []) (GuardedAlts ((:)(GuardedAlt Loc2 ((:)(Generator Loc3 Pat1 E0:Exp) []) E:Exp) [])) Binds1) ((:)(Alt Loc4 PWildCard (UnGuardedAlt EPrime:Exp) Binds2) []))
     = Case E0:Exp ((:)(Alt Loc1 Pat1 (UnGuardedAlt E:Exp) Binds1) ((:)(Alt Loc4 PWildCard (UnGuardedAlt EPrime:Exp) Binds2) [])) .


***(
(u) 	case () of { () | let decls -> e; _ -> e' }
	= let decls in e

Pending questions:
  - I think the _ could be generalized to any pattern
  - generalizing Binds

AST: (Case (Con (Special UnitCon)) ((:)(Alt (SrcLoc "tests/case-u.hs" 3 27) (PApp (Special UnitCon) ([])) (GuardedAlts ((:)(GuardedAlt (SrcLoc "tests/case-u.hs" 3 30) ((:)(LetStmt (BDecls ((:)(PatBind (SrcLoc "tests/case-u.hs" 3 36) (PVar (Ident "x1")) Nothing (UnGuardedRhs (Var (UnQual (Ident "a")))) (BDecls ([]))) ([])))) ([])) (Var (UnQual (Ident "e")))) ([]))) (BDecls ([]))) ((:)(Alt (SrcLoc "tests/case-u.hs" 3 49) PWildCard (UnGuardedAlt (Var (UnQual (Ident "e'")))) (BDecls ([]))) ([]))))
   ===
     (Let (BDecls ((:)(PatBind (SrcLoc "tests/case-u.hs" 4 18) (PVar (Ident "x1")) Nothing (UnGuardedRhs (Var (UnQual (Ident "a")))) (BDecls ([]))) ([]))) (Var (UnQual (Ident "e"))))

more-general: Case (Con (Special UnitCon)) ((:)(Alt Loc1 (PApp (Special UnitCon) []) (GuardedAlts ((:)(GuardedAlt Loc2 ((:)(LetStmt Decls1) []) E:Exp) [])) Binds1) ((:)(Alt Loc3 Underscore (UnGuardedAlt EPrime:Exp) Binds2) []))
   ===
     Let Decls1 E:Exp
***)

    eq Case (Con (Special UnitCon)) ((:)(Alt Loc1 (PApp (Special UnitCon) []) (GuardedAlts ((:)(GuardedAlt Loc2 ((:)(LetStmt Decls1) []) E:Exp) [])) Binds1) ((:)(Alt Loc3 Underscore (UnGuardedAlt EPrime:Exp) Binds2) []))
     = Let Decls1 E:Exp .


***(
(v) 	case () of { () | e0 -> e; _ -> e' }
	= if e0 then e else e'

Pending Questions:
  - This time I'm assuming the _ is a literal underscore
  - Again, I'm keeping the Binds general

AST: (Case (Con (Special UnitCon)) ((:)(Alt (SrcLoc "tests/case-v.hs" 2 27) (PApp (Special UnitCon) ([])) (GuardedAlts ((:)(GuardedAlt (SrcLoc "tests/case-v.hs" 2 30) ((:)(Qualifier (Var (UnQual (Ident "e0")))) ([])) (Var (UnQual (Ident "e")))) ([]))) (BDecls ([]))) ((:)(Alt (SrcLoc "tests/case-v.hs" 2 42) PWildCard (UnGuardedAlt (Var (UnQual (Ident "e'")))) (BDecls ([]))) ([]))))
   ===
     (If (Var (UnQual (Ident "e0"))) (Var (UnQual (Ident "e"))) (Var (UnQual (Ident "e'"))))

more-general: (Case (Con (Special UnitCon)) ((:)(Alt Loc1 (PApp (Special UnitCon) []) (GuardedAlts ((:)(GuardedAlt Loc2 ((:)(Qualifier E0:Exp) []) E:Exp) [])) Binds1) ((:)(Alt Loc3 PWildCard (UnGuardedAlt EPrime:Exp) Binds2) [])))
   ===
     (If E0:Exp E:Exp EPrime:Exp)
***)

    eq Case (Con (Special UnitCon)) ((:)(Alt Loc1 (PApp (Special UnitCon) []) (GuardedAlts ((:)(GuardedAlt Loc2 ((:)(Qualifier E0:Exp) []) E:Exp) [])) Binds1) ((:)(Alt Loc3 PWildCard (UnGuardedAlt EPrime:Exp) Binds2) []))
     = If E0:Exp E:Exp EPrime:Exp .


endm