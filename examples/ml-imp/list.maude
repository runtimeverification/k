mod LIST-HP is inc CONFIG + MATHEMATICAL-INT-SEQUENCE .
  var N : Nat .
  var P P' P1 P2 Q Q' Q1 Q2 I I' : Int++ .
  var Alpha Beta : IntSeq++ .
  var H : Map .
  var K : K .
  var Phi : Formula .
  var NtPhi : NtFormula .
  var Cfg : BagItem .
  var CfgItems : Bag .
  
  ops node next : -> KLabel .

  op list : -> KLabel .

*** Definition of Lists ***
 ceq < config >
       < k > derive(P') ~> K </ k >
       < heap > list(P)(Alpha) H </ heap >
       < form > Phi </ form >
       < newSym > N </ newSym >
       CfgItems
     </ config >
   = < config >
       < k > derive(P') ~> K </ k >
       < heap > H </ heap > 
       < form > Phi /\ (P === 0) /\ (Alpha === epsilon) </ form >
       < newSym > N </ newSym >
       CfgItems
     </ config >
     < config >
       < k > K </ k >
       < heap >
         P |-> ?Int(N) : node
         (P +Int 1) |-> ?Int(N +Int 1) : next
         list(?Int(N +Int 1))(?IntSeq(N +Int 2))
         H
       </ heap >
       < form >
         Phi /\ ~(P === 0) /\
         (Alpha === ?Int(N) :: ?IntSeq(N +Int 2))
       </ form >
       < newSym > N +Int 3 </ newSym >
       CfgItems
     </ config >
  if VALID(Phi ===> P' === P \/ P' === P +Int 1) .

  eq < heap > list(0)(Alpha) H </ heap > < form > Phi </ form >
   = < heap > H </ heap > < form > Phi /\ Alpha === epsilon </ form > .

  rl < config >
       < heap >
         P |-> I : node
         (P +Int 1) |-> 0 : next
         H
       </ heap >
       CfgItems
     </ config >
     =heap=> Cfg
  => < config > < heap > list(P)(I) H </ heap > CfgItems </ config >
     =heap=> Cfg .

  rl < config >
       < heap >
         P |-> I : node
         (P +Int 1) |-> P' : next
         list(P')(Alpha)
         H
       </ heap >
       CfgItems
     </ config >
     =heap=> Cfg
  => < config > < heap > list(P)(I :: Alpha) H </ heap > CfgItems </ config >
     =heap=> Cfg .

***(
  op lseg : -> HeapPatternName .

*** Definition of List Segments ***
 ceq <config> <k> derive(P') ~> Rest </k> <heap> lseg(P,Q)(Alpha) ** H </heap> <form> Phi </form> <newSym> N </newSym> Cfg </config>
   = <config> <k> derive(P') ~> Rest </k> <heap> H </heap> <form> Phi /\ (P === Q) /\ (Alpha === epsilon) </form> <newSym> N </newSym> Cfg </config>
     <config> <k> Rest </k> <heap> P |-> ?Int(N) : node ** (P +Int 1) |-> ?Int(N +Int 1) : next ** lseg(?Int(N +Int 1),Q)(?IntSeq(N +Int 2)) ** H </heap>
              <form> Phi /\ ~(P === Q) /\ (Alpha === ?Int(N) :: ?IntSeq(N +Int 2)) </form> <newSym> N +Int 3 </newSym> Cfg </config>
    if VALID(Phi ===> P' === P \/ P' === P +Int 1) .

  eq <heap> lseg(P,P)(Alpha) ** H </heap> <form> Phi </form> = <heap> H </heap> <form> Phi /\ Alpha === epsilon </form> .

  eq <heap> lseg(P,0)(Alpha) ** H </heap> = <heap> list(P)(Alpha) ** H </heap> .

  rl <config> <heap> P |-> I : node ** (P +Int 1) |-> Q : next ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> lseg(P,Q)(I) ** H </heap> Cfg </config> =heap=> CFG .

  rl <config> <heap> lseg(P,P')(Alpha) ** lseg(P',Q)(Beta) ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> lseg(P,Q)(Alpha :: Beta) ** H </heap> Cfg </config> =heap=> CFG .

  rl <config> <heap> lseg(P,P')(Alpha) ** list(P')(Beta) ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> list(P)(Alpha :: Beta) ** H </heap> Cfg </config> =heap=> CFG .


  ops dlist dlseg : -> HeapPatternName .

---  eq dlist(P,Q)(Alpha) = dlseg(P,Q)(0,0,Alpha) .
---  eq dlist(P)(Alpha) = dlseg(P,0)(0,0,Alpha) .

*** Definition of Double Linked List Segments ***
--- First equation tells how to derive a list segment , so it applies the equivalence in the paper from left to right by need.
 ceq <config> <k> derive(P') ~> Rest </k> <heap> dlseg(P,Q)(P1,Q1,Alpha) ** H </heap> <form> Phi </form> <newSym> N </newSym> Cfg </config>
   = <config> <k> derive(P') ~> Rest </k> <heap> H </heap> <form> Phi /\ (P === P1) /\ (Q === Q1) /\ (Alpha === epsilon) </form> <newSym> N </newSym> Cfg </config>
     <config> <k> Rest </k> <heap> P |-> ?Int(N) : node ** (P +Int 1) |-> ?Int(N +Int 1) : next ** (P +Int 2) |-> Q1 : prev ** dlseg(?Int(N +Int 1),Q)(P1,P,?IntSeq(N +Int 2)) ** H </heap>
              <form> Phi /\ ~(P === P1) /\ ~(Q === Q1) /\ (Alpha === ?Int(N) :: ?IntSeq(N +Int 2)) </form> <newSym> N +Int 3 </newSym> Cfg </config>
    if VALID(Phi ===> P' === P \/ P' === P +Int 1 \/ P' === P +Int 2) .
 ceq <config> <k> derive(Q') ~> Rest </k> <heap> dlseg(P,Q)(P1,Q1,Alpha) ** H </heap> <form> Phi </form> <newSym> N </newSym> Cfg </config>
   = <config> <k> derive(Q') ~> Rest </k> <heap> H </heap> <form> Phi /\ (P === P1) /\ (Q === Q1) /\ (Alpha === epsilon) </form> <newSym> N </newSym> Cfg </config>
     <config> <k> Rest </k> <heap> Q |-> ?Int(N) : node ** (P +Int 1) |-> P1 : next ** (P +Int 2) |-> ?Int(N +Int 1) : prev ** dlseg(P,?Int(N +Int 1))(Q,Q1,?IntSeq(N +Int 2)) ** H </heap>
              <form> Phi /\ ~(P === P1) /\ ~(Q === Q1) /\ (Alpha === ?IntSeq(N +Int 2) :: ?Int(N)) </form> <newSym> N +Int 3 </newSym> Cfg </config>
    if VALID(Phi ===> Q' === Q \/ Q' === Q +Int 1 \/ Q' === Q +Int 2) .

  eq <heap> dlseg(P,Q)(P,Q1,Alpha) ** H </heap> <form> Phi </form> = <heap> H </heap> <form> Phi /\ (Q === Q1) /\ Alpha === epsilon </form> .
  eq <heap> dlseg(P,Q)(P1,Q,Alpha) ** H </heap> <form> Phi </form> = <heap> H </heap> <form> Phi /\ (P === P1) /\ Alpha === epsilon </form> .

  rl <config> <heap> P |-> I : node ** (P +Int 1) |-> Q1 : next ** (P +Int 2) |-> Q2 : prev ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> dlseg(P,P)(Q1,Q2,I) ** H </heap> Cfg </config> =heap=> CFG .

  rl <config> <heap> dlseg(P,Q')(P',P1,Alpha) ** dlseg(P',Q)(Q1,Q',Beta) ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> dlseg(P,Q)(Q1,P1,Alpha :: Beta) ** H </heap> Cfg </config> =heap=> CFG .
***)
endm

