mod STRICTCXT2EQS is
  including K-SORTS .
  including K-META-OPS .
  including STRICT-ATTRS .
  including K-STRICTNESS-OPS .
  including META-TERM-EXTRAS .
  including STRING-EXTRAS .
  including META-MODULE-EXTRAS .
  including META-K-MODULE .
  including META-K-CONTEXTS .
  including META-K-COOL .
  including META-K-RULES .
  including METADATA-EXTRAS .
  including COMPILATION-ATTRS .
  including META-K-WRAPPERS .
  var T T1 T2 Trm : Term . var Ct : Constant . var V : Variable .
  var Trl Trl' : TermList .  var Cond : TermList .  var Cnd : Condition .
  var Sort S : Sort .  var Ss Ss' : SortSet .
  var AS AS' AS'' : AttrSet . var A : Attr .
  var MAS MAS' : MembAxSet . var Mb : MembAx .
  var Eqs Eqs' : EquationSet . var Rls Rls' : RuleSet . var Q : Qid .
  vars Type Type' Ty : Type .  var OPDS : OpDeclSet . var KCS : KContextSplit .
  sort MASEqsPair . var Str : String .

  op defaultHeatEqs : SortSet AttrSet -> EquationSet .
  eq defaultHeatEqs(Ss, superheats(AS) AS') = defaultHeatEqs(Ss) .
  eq defaultHeatEqs(Ss, AS') = none [owise] .

  op defaultHeatEqs : SortSet -> EquationSet .
  eq defaultHeatEqs(S ; Ss)
   = (eq kWrap(S, kApply(heatLabel,(kApply(redexLabel,(mkVariable(K,K),mkVariable('NKs,NeKList))),mkVariable('Ks,KList))))
       = kWrap(S, kApply(heatLabel,(mkVariable('NKs,NeKList),mkVariable('Ks,KList))))
      [owise] .)
     (eq kWrap(S, kApply(heatLabel,(kApply(redexLabel, mkVariable(K,K)),mkVariable('Ks,KList),kApply(heatedLabel,mkVariable('Ks',KList)))))
       = kWrap(S, kApply(heatLabel,(mkVariable('Ks,KList),kApply(heatedLabel,(mkVariable('Ks',KList), mkVariable(K,K))))))
     [owise] .)
     defaultHeatEqs(Ss)
  .
  eq defaultHeatEqs(none) = none .

  op defaultCoolEqs : SortSet AttrSet -> EquationSet .
  eq defaultCoolEqs(Ss, AS supercools(AS')) = defaultCoolEqs(Ss) .
  eq defaultCoolEqs(Ss, AS) = none [owise] .  

  op defaultCoolEqs : SortSet -> EquationSet .
  eq defaultCoolEqs(S ; Ss)
   = 
   (eq mkCell(cool(S), mkVariable('K,K)) 
       = mkCell(S, kra(kApply(coolLabel,nilK),mkVariable('K,K))) 
      [metadata(pair("supercool","start"))] .)
     (eq mkCell(S, kApply(coolLabel,mkVariable('zk,K))) = mkCell(S, mkVariable('zk,K))
      [metadata(pair("supercool","end"))] .) 
     (eq kWrap(S, kra(kApply(coolLabel,mkVariable('zk,K)),mkVariable('Next,KItem)))
       = kWrap(S, kApply(coolLabel,kra(mkVariable('zk,K),mkVariable('Next,KItem))))
      [owise metadata(pair("supercool", "next"))] .) 
     defaultCoolEqs(Ss) .
  eq defaultCoolEqs(none) 
   =  none .


  op {_,_,_} : MembAxSet EquationSet RuleSet -> MASEqsPair [ctor] .

  op findHeatingAttr : MembAxSet AttrSet Bool MembAxSet ~> MembAxSet .
  op $findHeatingAttr : MembAx MembAxSet AttrSet Bool MembAxSet ~> MembAxSet [strat (1 0)] .
  op parseMetadata : Term Type AttrSet Condition ~> MembAx .

  eq findHeatingAttr(Mb MAS, AS, B, MAS') 
   = $findHeatingAttr( parseMetadata(getTerm(Mb),getType(Mb), getAttrs(Mb), getCond(Mb)), MAS, AS, B, MAS') .
  eq findHeatingAttr(none, AS, true, MAS) = MAS .

  eq parseMetadata(Trm, Ty, AS metadata(Str), Cnd) = parseMetadata(Trm, Ty, AS metadataParse(Str), Cnd) .
  eq $findHeatingAttr( parseMetadata(Trm, Ty, AS, Cnd), MAS, AS', B, MAS' )
   = findHeatingAttr(MAS, AS', B or-else hasHeatingTag(AS, AS'), MAS' plugMb(Trm, Ty, AS, Cnd)) .

  op hasHeatingTag : AttrSet AttrSet -> Bool .
  eq hasHeatingTag(A AS, AS' superheats(A AS'')) = true .
  eq hasHeatingTag(AS, AS' superheats(pair("default","") AS'')) = true .
  eq hasHeatingTag(AS, AS') = false [owise] .


  var B : Bool .


  op strictCxt2eqs : Module MembAxSet AttrSet ~> MASEqsPair .
  eq strictCxt2eqs(M,MAS, AS) = strictCxt2eqs(M, findHeatingAttr(MAS, AS, false, none), none, none, AS) .
  op strictCxt2eqs : Module MembAxSet EquationSet RuleSet AttrSet ~> MASEqsPair . 

  eq strictCxt2eqs(M, findHeatingAttr(none, AS, false, MAS), none, none, superheats(AS') AS'')
   = strictCxt2eqs(M, MAS, none, none, AS'') .
 ceq strictCxt2eqs(M, Mb MAS, Eqs, Rls, AS)
   = strictCxt2eq(M, MAS, Eqs, Rls, pReplaceCxt(T,1),pReplaceCxt(T,2), getAttrs(KCS), getCondition(KCS), AS)
  if KCS := splitKContext(Mb) /\ T := getContents(KCS) .
  eq strictCxt2eqs(M, MAS,Eqs, Rls, AS) = {MAS,Eqs, Rls} [owise] . 

  op strictCxt2eq : Module MembAxSet EquationSet RuleSet Term Term AttrSet TermList AttrSet ~> MASEqsPair .
  eq strictCxt2eq(M, MAS, Eqs, Rls, T1, T2, kstrict(nil,Q) AS, Cond, AS') 
   = strictCxt2eqs(M, MAS, Eqs coolingEqs(M, T1, T2, Q, AS, AS'), Rls, heating(M, T1, T2, Q, Cond, AS, AS'), AS') .

  eq strictCxt2eq(M, MAS, Eqs, Rls, T1, T2, AS, Cond, AS')
   = strictCxt2eq(M, MAS, Eqs, Rls, T1, T2, kstrict(nil,klabel) AS, Cond, AS') [owise] .

  op strictCxt2eqs : Module MembAxSet EquationSet RuleSet MASEqsPair AttrSet ~> MASEqsPair . 
  eq strictCxt2eqs(M, MAS, Eqs, Rls, {none, Eqs', Rls'}, AS)
   = strictCxt2eqs(M, MAS, Eqs Eqs', Rls Rls', AS) [print "Eqs: " Eqs' " and Rls: " Rls'] .
   
  
  op heating : Module Term Term Qid TermList AttrSet AttrSet -> MASEqsPair .
 ceq heating(M, T1, T2, Q, Cond, AS, AS')
   = {none, heatEqs(Q, T1[hole <- mkVariable('Kcxt,K)], kra(mkVariable('Kcxt,K), freezeTerm(M, T1)), makeKCondition(andBool(strictCond(mkVariable('Kcxt,K),Q),Cond[hole <- mkVariable('Kcxt,K)])), AS, AS',"normal"), none} if T2 = hole .
  eq heating(M, T1, T2, Q, Cond, AS, AS')
   = {none, 
    (eq T2[hole <- T2[hole <- mkVariable('KCxt,K)]] = T2[hole <- mkVariable('KCxt,K)] [metadata(pair("heating","idem"))] .)
    heatEqs(Q, T1[hole <- kra(mkVariable('Kcxt1,KItem),mkVariable('Kcxt2,KItem),mkVariable('Kcxt3,K))], kra(mkVariable('Kcxt1,KItem),mkVariable('Kcxt2,KItem),mkVariable('Kcxt3,K),  freezeTerm(M, T1)),  makeKCondition(andBool(strictCond(kra(mkVariable('Kcxt1,KItem),mkVariable('Kcxt2,KItem),mkVariable('Kcxt3,K)),Q),Cond[hole <- kra(mkVariable('Kcxt1,KItem),mkVariable('Kcxt2,KItem),mkVariable('Kcxt3,K))])), AS, AS',"normal")
    heatEqs(Q, T1[hole <- mkVariable('Kcxt,KItem)], kra(T2[hole <- mkVariable('Kcxt,KItem)], freezeTerm(M, T1)), makeKCondition(andBool(strictCond(mkVariable('Kcxt,KItem),Q),Cond[hole <- mkVariable('Kcxt,KItem)])), AS, AS',"wrapped"), none} [owise] .


  op heatSuffix : -> TermList .
  eq heatSuffix = mkVariable('Rest1,K) .

  op coolingEqs : Module Term Term Qid AttrSet AttrSet -> EquationSet .
  eq coolingEqs(M, T1, T2, Q, AS, supercools(AS') AS'')
   = coolingEqs(M, T1, T2, Q, AS) 
     (eq kWrap(Q, kra(kApply(coolLabel,mkVariable('Kcxt,K)), freezeTerm(M, T1)))
        = kWrap(Q, kApply(coolLabel,T1[hole <- mkVariable('Kcxt,K)]))
      [metadata(AS pair("supercool",""))] .) .
  eq coolingEqs(M, T1, T2, Q, AS, AS') = coolingEqs(M, T1, T2, Q, AS) [owise print "no supercool because " AS'] .
   
  op coolingEqs : Module Term Term Qid AttrSet -> EquationSet .
  eq coolingEqs(M, T1, T2, Q, AS)
   =  (ceq kWrap(Q, kra(mkVariable('Kcxt,KItem), freezeTerm(M, T1)))
         = kWrap(Q, T1[hole <- mkVariable('Kcxt,KItem)])
        if strictCondTerm(mkVariable('Kcxt,KItem),Q) = bool2K(trueCt)
       [metadata(AS pair("cooling",""))] .) 
     placeHolder(Q) .

  op heatEqs : Qid Term Term Condition AttrSet AttrSet String -> EquationSet .
  eq heatEqs(Q, T1, T2, Cnd, AS, AS' superheats(AS''), Str)
   = $heatEqs(Q, T1, T2, Cnd, AS, AS' superheats(AS''), Str)
     superHeat(Q, T1, T2, Cnd, AS, AS' superheats(AS''), Str) .
  eq heatEqs(Q, T1, T2, Cnd, AS, AS', Str)
   = $heatEqs(Q, T1, T2, Cnd, AS, AS', Str) [owise] .

  op superHeat : Qid Term Term Condition AttrSet AttrSet String -> EquationSet .
  eq superHeat(Q, T1, T2, Cnd, AS A, AS' superheats(A AS''), Str) =
     (ceq kWrap(Q, kApply(heatLabel, (kApply(redexLabel,(kra(T1,mkVariable('RestHeat,K)),mkVariable('LHeat,KList))), mkVariable('AnyHeat2,KList))))
        = kWrap(Q, kApply(heatLabel, (kApply(redexLabel,(kra(T1,mkVariable('RestHeat,K)),mkVariable('LHeat,KList),kApply(redexLabel,kra(T2,mkVariable('RestHeat,K))))), mkVariable('AnyHeat2,KList)))) 
       if  Cnd /\ '_inList`{K`}_[kApply(redexLabel,kra(T2,mkVariable('RestHeat,K))), mkVariable('LHeat,KList)] = falseCt
     [metadata(AS pair("superheat", Str))] .) .
  eq superHeat(Q, T1, T2, Cnd, AS, AS', Str) 
   = (ceq kWrap(Q, kApply(heatLabel, (kApply(redexLabel, kra(T1,mkVariable('RestHeat,K))), mkVariable('AnyHeat2,KList))))
        = kWrap(Q, kApply(heatLabel, (kApply(redexLabel,kra(T2,mkVariable('RestHeat,K))), mkVariable('AnyHeat2,KList))))
       if Cnd
     [metadata(AS pair("superheat", "nonNd" + Str))] .) 
  [owise] .


  op $heatEqs : Qid Term Term Condition AttrSet AttrSet String -> EquationSet .
  eq $heatEqs(Q, T1, T2, Cnd, AS A, AS' superheats(A AS''), Str)
   = (ceq kWrap(Q, T1)
        = kWrap(Q, kApply(heatLabel,(kApply(redexLabel,T1),kApply(heatedLabel, empty))))
       if Cnd 
      [metadata(AS A pair("superheat","start" + Str))] .) .
  eq $heatEqs(Q, T1, T2, Cnd, AS, AS' superheats(pair("default","") AS''), Str)
   = (ceq kWrap(Q, T1)
        = kWrap(Q, kApply(heatLabel,(kApply(redexLabel,T1),kApply(heatedLabel, empty))))
       if Cnd
      [metadata(AS pair("default","") pair("superheat","start" + Str))] .) 
  [owise] .
  eq $heatEqs(Q, T1, T2, Cnd, AS, AS', Str)
   = (ceq kWrap(Q, T1)
        = kWrap(Q, T2)
      if Cnd
      [metadata(AS pair("heating",Str))] .) [owise] .

  op freezeTerm : Module Term -> Term .
  eq freezeTerm(M, T) = kApply(
   freezeLabel(mkFrozenTerms(T)),
   freezeVariables(M, removeHole(noDuplicates(getVars(T))))) .

  op mkFrozenTerms_ : TermList ~> TermList .
  eq mkFrozenTerms(empty) = empty .
  eq mkFrozenTerms(Q[Trl],Trl') = Q[mkFrozenTerms(Trl)],mkFrozenTerms(Trl') .
  eq mkFrozenTerms(Ct,Trl) = Ct,mkFrozenTerms(Trl) .
  eq mkFrozenTerms(V,Trl) = metaVariable(V),mkFrozenTerms(Trl) .

  op freezeVariables : Module TermList ~> TermList .
  op freezeVariable : Module Variable ~> Variable .
  eq freezeVariables(M, (V,Trl)) 
   = (freezeVariable(M, V),freezeVariables(M, Trl)) .
  eq freezeVariables(M, empty) = empty .

  eq freezeVariable(M, V) = freezeVariable(V,makeK(M,V, getType(V))) .

  op makeK : Module Variable Type ~> Term . 
  eq makeK(M, V, Type) = makeK(M, V, Type, sortLeq(M, Type, KList)) .

  op makeK : Module Variable Type Bool ~> Term . 
  eq makeK(M, V, Type, true) = V .
  eq makeK(M, V, Type, B:[Bool]) 
   = kApply(findWrapper(M, Type)[V],empty) .


  op strictCondTerm : Term Qid ~> Term .
  eq strictCondTerm(T, Q) = kApply(resultLabel(Q),T) .

  op strictCond : Term Qid ~> Term .
  eq strictCond(T, Q)
   = neqK(strictCondTerm(T,Q),bool2K(trueCt)) .
  

  op strictCxt2eqs : Qid Qid Module Module SortSet AttrSet ~> Module .
  var Syntax StrictEqs : Qid . var M Flat : Module .

 ceq strictCxt2eqs(Syntax,StrictEqs,M,Flat, Ss, AS supercools(AS')) 
   = strictCxt2eqs(Syntax, qid(substr(string(Syntax),length("#SUPERCOOL-"), length(string(Syntax)))),
                   strictCxt2eqs(Flat, getMbs(M), AS supercools(AS')), Ss, AS supercools(AS'), getSorts(Flat)) 
  if substr(string(Syntax),0,length("#SUPERCOOL-")) = "#SUPERCOOL-" [print "generate supercool equations" AS'] . 
  eq strictCxt2eqs(Syntax,StrictEqs,M,Flat, Ss, AS supercools(AS')) 
   = strictCxt2eqs(Syntax,StrictEqs,strictCxt2eqs(Flat, getMbs(M), AS), Ss, AS,getSorts(Flat)) [owise print "don't generate supercool eqs: " AS'] . 

  op strictCxt2eqs : Qid Qid MASEqsPair SortSet AttrSet SortSet ~> Module .
  eq strictCxt2eqs(Syntax, StrictEqs, {MAS,Eqs, Rls}, Ss, AS, Ss') 
   = addOps(declareResultLabels(Eqs) declareVarPlaceHolders(Ss' \ KSentence )--- coolOps
,setMbs(addRls(Rls, addEqs(defaultCoolEqs(Ss, AS) defaultHeatEqs(Ss, AS), 
        addEqs(generateResultEquations(Eqs), addImports((including Syntax . including 'K-STRICTNESS .), setName(emptySModule, StrictEqs))))), MAS)) [print "Syntax: " Syntax "StrictEqs: " StrictEqs] .


  op placeHolder : Qid -> Equation .


  op declareResultLabels : EquationSet -> OpDeclSet .
  eq declareResultLabels(placeHolder(Q) Eqs) = (op getName(resultLabel(Q)) : nil -> KLabel [none] .) declareResultLabels(Eqs) .
  eq declareResultLabels(Eqs) = none [owise] .

  op declareVarPlaceHolders : SortSet ~> OpDeclSet .
  eq declareVarPlaceHolders(none) = none .
  eq declareVarPlaceHolders(S ; Ss') 
   = (op metaVariableSy(S) : String -> S [metadata("generated=()")] .) 
     (op frozenVariableSy(S) : String -> KLabel [metadata("generated=()")] .) 
     declareVarPlaceHolders(Ss') .

  op generateResultEquations : EquationSet -> EquationSet .
  eq generateResultEquations(placeHolder(Q) Eqs)
   = generateResultEquations(Eqs) (eq kApply(resultLabel(Q), (mkVariable('K1,K),mkVariable('K2,K), mkVariable('L,KList))) = andBool(kApply(resultLabel(Q), (mkVariable('K1,K))), kApply(resultLabel(Q), (mkVariable('K2,K), mkVariable('L,KList)))) [none] .) (eq kApply(resultLabel(Q), nilKList) = bool2K(trueCt) [none] .) .
---(
   = generateResultEquations(Eqs) (eq kApply(resultLabel(Q),mkVariable('L,KList)) = bool2K(falseCt) [owise] .) .
---)
  eq generateResultEquations(Eqs) = Eqs [owise] .



--- HOLE rules
---  eq 'HOLE.K =  kApply(freezeLabel(mkFrozenTerms(hole)),empty) .

endm

