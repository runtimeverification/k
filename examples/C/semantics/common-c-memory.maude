mod COMMON-MEMORY-INCLUDE is
	including COMMON-INCLUDE .
	
	op extractBytesFromMem : Nat Nat -> K . --- loc, size in bytes
endm

mod COMMON-SEMANTICS-READING is
	including COMMON-MEMORY-INCLUDE .
	
	op extractBitsFromMem : Nat Nat -> K . --- loc, size in bits
	op extractByteFromMem : Nat -> K .
	op extractBitsFromList : K Nat Nat -> K [metadata "strict(1)"] . --- data, offset in bits, size in bits
	op getBitOffset : Nat -> Nat .
	eq getBitOffset(? +Nat bito(M:Nat)) = M:Nat .
	eq getBitOffset(?) = 0 [owise] .
	
	--- mb rule
		--- < k > extractBitsFromList(dataList((functionObject(X:Id, T:Type, K:K))), 0, N:Nat) => functionObject(X:Id, T:Type, K:K) ...</ k >
		--- if N:Nat ==Bool numBitsPerByte
		--- : KSentence [metadata "structural"] .
	op extractBitsFromList : K Nat Nat List{K} -> K .
	eq extractBitsFromList(dataList(L:List{K}), N:Nat, M:Nat) = extractBitsFromList(dataList(L:List{K}), N:Nat, M:Nat, .List{K}) .
	mb rule
		< k > extractBitsFromList(dataList((piece(N:Nat, Len:Nat),, L:List{K})), 0, NumBits:Nat, Done:List{K})
			=> extractBitsFromList(dataList(L:List{K}), 0, absInt(NumBits:Nat -Int Len:Nat), (Done:List{K},, piece(N:Nat, Len:Nat)))
		...</ k >
		if Len:Nat <=Nat NumBits:Nat
		: KSentence [metadata "structural"] .
	mb rule
		< k > extractBitsFromList(?, 0, 0, Done:List{K}) => dataList(Done:List{K}) ...</ k >
		: KSentence [metadata "structural"] .
	
	op read : K K K -> K .
	mb context read(?, ?, value(`[HOLE`]:K)) : KSentence .
	ceq read(Loc:Nat, T:Type) = read(Loc:Nat, T:Type, value(bitSizeofType(T:Type))) 
		if notBool(hasFunctionType(T:Type)) .
	
	--- FIXME should check types
	mb rule
		< k > read(Loc:Nat, functionType(?, ?)) => extractByteFromMem(Loc:Nat) ...</ k >
		: KSentence [metadata "structural"] .
		
	mb rule
		< k > read(Loc:Nat, T:Type, bitSize:Nat) => concretize(T:Type, extractBitsFromMem(Loc:Nat, bitSize:Nat)) ...</ k >
		: KSentence [metadata "structural"] .
		
	op joinIntegerBytes : Type List{K} -> K .
	ceq concretize(T:Type, dataList(L:List{K})) = joinIntegerBytes(T:Type, L:List{K})
		if hasIntegerType(T:Type) andBool isConcreteList(L:List{K}) .
		
	--- FIXME assuming bytes?
	op joinIntegerBytes : Type List{K} Nat -> K .
	eq joinIntegerBytes(T:Type, L:List{K}) = joinIntegerBytes(T:Type, L:List{K}, 0) .
	eq joinIntegerBytes(T:Type, (L:List{K},, piece(N:Nat, Len:Nat)), M:Nat)
		= joinIntegerBytes(T:Type, L:List{K}, ((M:Nat <<Nat Len:Nat) |Nat N:Nat)) .
	eq joinIntegerBytes(T:Type, .List{K}, N:Nat) = interpret(T:Type, N:Nat) . 
		
	op isConcreteList : List{K} -> Bool .
	op isConcreteNumber : Nat -> Bool .
	ceq isConcreteList((N:Nat,, L:List{K})) = isConcreteList(L:List{K})
		if isConcreteNumber(N:Nat) .
	eq isConcreteList(.List{K}) = true .
	eq isConcreteNumber(sym(?) +Nat ?) = false .
	eq isConcreteNumber(bito(?) +Nat ?) = false .
	eq isConcreteNumber(?) = true [owise] .
	
	
	--- eq interpret(T:Type, functionObject(X:Id, T:Type, K:K)) = functionObject(X:Id, T:Type, K:K) .
	
	op floorLoc : Nat -> Nat . --- loc with possible bit offset returning base byte
	eq floorLoc(sym(N:Nat) +Nat bito(M:Nat) +Nat R:Nat) = sym(N:Nat) +Nat R:Nat .
	eq floorLoc(sym(N:Nat) +Nat R:Nat) = sym(N:Nat) +Nat R:Nat [owise] .
	
	mb rule
		< k > extractBitsFromMem(Loc:Nat, Size:Nat) => extractBitsFromList(extractBytesFromMem(floorLoc(Loc:Nat), bitsToBytes(Size:Nat)), getBitOffset(Loc:Nat), Size:Nat) ...</ k >
		: KSentence [metadata "structural"] .
	
	mb context extractBytesFromMem-aux(?, ?, (?,, `[HOLE`]:K,, ?)) : KSentence .
	--- this next op should use Nats, but the context doesn't allow it.  See issue 54
	op extractBytesFromMem-aux : K K List{K} -> K . --- loc, size in bytes, aux list
	
	mb rule
		< k > extractBytesFromMem(Loc:Nat, Size:Nat) => extractBytesFromMem-aux(Loc:Nat, Size:Nat, .List{K}) ...</ k >
		: KSentence [metadata "structural"] .
		
	mb rule
		< k > extractBytesFromMem-aux(Loc:Nat, sNat(Size:Nat), Aux:List{K})
			=> extractBytesFromMem-aux(sNat(Loc:Nat), Size:Nat, (Aux:List{K},, extractByteFromMem(Loc:Nat)))
		...</ k >
		: KSentence [metadata "structural"] .
		
	---op combineData : List{KResult} -> K .

	---eq combineData(functionObject(X:Id, T:Type, K:K)) = functionObject(X:Id, T:Type, K:K) .
	
	op values : List{K} -> List{K} .
	eq values((tv(K:K, bignum),, L:List{KResult})) = (K:K,, values(L:List{KResult})) .
	eq values(.List{K}) = .List{K} .
	mb rule
		< k > extractBytesFromMem-aux(?, 0, Aux:List{KResult}) => dataList(values(Aux:List{KResult})) ...</ k >
		: KSentence [metadata "structural"] .
	
	--- FIXME overly rough?
	eq unknown >>Nat ? = unknown .
	eq ? &Nat unknown = unknown .
	
	op rawData : BaseValue Nat -> KResult .
	--- FIXME make sure it's a byte
	mb rule
		< k > extractByteFromMem(sym(Block:Nat) +Nat Offset:Nat) => V:K ...</ k >
		< mem >... Block:Nat |-> memblock(Size:Nat, (? Offset:Nat |-> V:K)) ...</ mem >
		< locsWrittenTo > Locs:Bag </ locsWrittenTo >
		if notBool(sym(Block:Nat) +Nat Offset:Nat) in Locs:Bag
		: KSentence [metadata "structural"] .
	mb rule
		< k > extractByteFromMem(sym(Block:Nat) +Nat Offset:Nat) => piece(unknown, numBitsPerByte) ...</ k >
		< mem >... Block:Nat |-> memblock(Size:Nat, (M:Map => M:Map[piece(unknown, numBitsPerByte) / Offset:Nat])) ...</ mem >
		< locsWrittenTo > Locs:Bag </ locsWrittenTo >
		if notBool(sym(Block:Nat) +Nat Offset:Nat) in Locs:Bag
		andBool notBool($hasMapping(M:Map, Offset:Nat))
		: KSentence [metadata "structural"] .
endm

mod COMMON-SEMANTICS-WRITING is
	including COMMON-MEMORY-INCLUDE .
	mb context alloc(?, value(`[HOLE`]:K)) : KSentence .

	eq allocateType(Loc:Nat, T:Type) = alloc(Loc:Nat, value(byteSizeofType(T:Type))) .
	
	mb rule
		< k > alloc(sym(Block:Nat) +Nat 0, Len:Nat) => (.).K ...</ k >
		< mem >... (.).Map => Block:Nat |-> memblock(Len:Nat, (.).Map) ...</ mem >
		: KSentence [metadata "structural"] .
		
	op writeBytes : Nat K -> K [metadata "strict(2)"] .
	op writeBitfield : Nat Type K -> K [metadata "strict(3)"] .
	op isByteLoc : Nat -> Bool .
	op splitBytes : Value -> K .
	op calculateNewBytes : Nat K K -> K [metadata "strict(3)"] .
	
	op write : K Value K -> K [metadata "strict(2)"] .
	ceq write(K:K, tv(V:K, T:Type)) = write(K:K, tv(V:K, T:Type), value(bitSizeofType(T:Type))) 
		if notBool(hasFunctionType(T:Type)) .
	--- FIXME should check types
	mb rule
		< k > write(Loc:Nat, tv(V:K, functionType(?, ?))) => writeByte(Loc:Nat, V:K) ...</ k >
		: KSentence [metadata "structural"] .	
	mb context write(?, ?, value(`[HOLE`])) : KSentence . 
	mb rule
		< k > write(Loc:Nat, tv(V:K, T:Type), bitSize:Nat)
			=> writeBytes(Loc:Nat, splitBytes(tv(V:K, T:Type)))
		...</ k >
		if bitSize:Nat %Nat numBitsPerByte ==Bool 0
		andBool isByteLoc(Loc:Nat)
		: KSentence [metadata "structural"] .
		
	op bitoffset : Nat -> Nat .
	eq bitoffset(? +Nat bito(N:Nat)) = N:Nat .
	eq bitoffset(?) = 0 [owise] .
	mb rule
		< k > write(Loc:Nat, tv(N:Nat, T:Type), bitSize:Nat)
			=> writeBitfield(Loc:Nat, T:Type, calculateNewBytes(bitoffset(Loc:Nat), piece(N:Nat, bitSize:Nat), extractBytesFromMem(Loc:Nat, bitsToBytes(bitSize:Nat))))
		...</ k >
		if bitSize:Nat %Nat numBitsPerByte =/=Bool 0
		orBool notBool(isByteLoc(Loc:Nat))
		: KSentence [metadata "structural"] .
		
	op explodeToBits : List{K} -> List{K} .
	op calculateNewBytes-aux : Nat K K -> K .
	eq calculateNewBytes(Len:Nat, N:Nat, dataList(L:List{K})) = calculateNewBytes-aux(Len:Nat, dataList(explodeToBits(N:Nat)), dataList(explodeToBits(L:List{K}))) .
	
	--- op explodeToBits : List{K} -> List{K} .
	eq explodeToBits((K:K,, L:NeList{K})) = (explodeToBits(K:K),, explodeToBits(L:NeList{K})) .
	eq explodeToBits(piece(N:Nat, sNat(Len:Nat)))
		= (piece(N:Nat &Nat 1, 1),, explodeToBits(piece(N:Nat >>Nat 1, Len:Nat))) .
	eq explodeToBits(piece(N:Nat, 0)) = .List{K} .
	eq explodeToBits(.List{K}) = .List{K} .
	
	op clearBits : Nat Nat Nat -> Nat .
	--- eq clearBits(N:Nat, Low:Nat, High:Nat) = 
		
	op writeByte : Nat K -> K .
	mb rule
		< k > writeBytes(sym(Block:Nat) +Nat Offset:Nat, dataList((V:K,, L:List{K})))
			=> writeByte(sym(Block:Nat) +Nat Offset:Nat, V:K)
			~> writeBytes(sym(Block:Nat) +Nat sNat(Offset:Nat), dataList(L:List{K}))
		...</ k >
		: KSentence [metadata "structural"] .
	mb rule
		< k > writeByte(sym(Block:Nat) +Nat Offset:Nat, V:K) => . ...</ k >
		< mem >... Block:Nat |-> memblock(Len:Nat, (M:Map => M:Map[V:K / Offset:Nat])) ...</ mem >
		if Offset:Nat <Nat Len:Nat
		: KSentence [metadata "structural"] .
	mb rule
		< k > writeBytes(?, dataList(.List{K})) => . ...</ k >
		: KSentence [metadata "structural"] .
		
	--- eq splitBytes(tv(functionObject(X:Id, T:Type, Body:K), T:Type)) = dataList(functionObject(X:Id, T:Type, Body:K)) .
	
	
	mb rule splitBytes(tv(I:Int, T:Type)) => splitIntegerBytes(I:Int, T:Type, value(byteSizeofType(T:Type)))
		if hasIntegerType(T:Type)
		: KSentence .
	
	op splitIntegerBytes : K K K -> K .
	op splitIntegerBytes : K K K List{K} -> K .
	mb context splitIntegerBytes(?, ?, value(`[HOLE`]:K)) : KSentence .
	eq splitIntegerBytes(I:Int, T:Type, Len:Nat) = splitIntegerBytes(I:Int, T:Type, Len:Nat, .List{K}) .
	eq splitIntegerBytes(I:Int, T:Type, sNat(Len:Nat), L:List{K})
		= splitIntegerBytes(I:Int >>Int numBitsPerByte, T:Type, Len:Nat, (L:List{K},, lowestByte(I:Int, T:Type))) .
	eq splitIntegerBytes(I:Int, T:Type, 0, L:List{K})
		= dataList(L:List{K}) .
	
	
	op lowestByte : Int Type -> K .
	ceq lowestByte(I:Int, T:Type) = piece(I:Int &Int byteMaskSet, numBitsPerByte)
		if hasIntegerType(T:Type) .
	
	op byteMaskSet : -> Nat .
	--- FIXME why does this parse?
	eq byteMaskSet = (2 ^Nat numBitsPerByte) -Int 1 .
		
	eq isByteLoc(? +Nat bito(?)) = false .
	eq isByteLoc(?) = true [owise] .
endm

mod COMMON-C-MEMORY-MISC is
	including COMMON-MEMORY-INCLUDE .

	--- mb rule
		--- < k > [allocWithDefault(loc(Block:Nat, ?), tv(Len:Nat, ?), N:Nat) => .K] ...</ k >
		--- < mem >... [.Map => Block:Nat |-> memblock(Len:Nat, (0 to Len:Nat) |-> piece(N:Nat, numBitsPerByte))] ...</ mem >
		--- : KSentence [metadata "structural"] .
		
	--- FIXME far too simple
	--- mb [storeAtLoc]: rule
		--- < k > write(sym(Block:Nat) +Nat Offset:Nat, tv(V:Value, T:Type)) => (.).K ...</ k >
		--- < mem >... Block:Nat |-> memblock(Len:Nat, (M:Map => M:Map[V:Value / Offset:Nat])) ...</ mem >
		--- if bitSizeofType(T:Type) <=Int (Len:Nat -Int Offset:Nat) *Int numBitsPerByte
		--- : KSentence [metadata "structural"] .
		
	--- op mapValue : Map -> Value .
	--- op updateMap : Map Nat Value -> K .
	--- op setMapAtBlock : Nat K -> K [metadata "strict(2)"] . 
	--- mb [storeAtLoc]: rule
		--- < k > write(sym(Block:Nat) +Nat Offset:Nat, tv(V:BaseValue, T:Type)) 
			--- => setMapAtBlock(Block:Nat, updateMap(M:Map, Offset:Nat, tv(V:BaseValue, T:Type))) ...</ k >
		--- < mem >... Block:Nat |-> memblock(Len:Nat, M:Map) ...</ mem >
		--- if bitSizeofType(T:Type) <=Int (Len:Nat -Int Offset:Nat) *Int numBitsPerByte
		--- : KSentence [metadata "structural"] .
		
	--- mb [append-existing]: rule
		--- < k > [append(loc(Block:Nat, Offset:Nat), Len:Nat, V:Value) => store V:Value atLoc loc(Block:Nat, Offset:Nat)] ...</ k >
		--- < mem >... Block:Nat |-> [memblock(OldLen:Nat, M:Map) => memblock(OldLen:Nat +Nat Len:Nat, M:Map)] ...</ mem >
		--- : KSentence [metadata "structural"] .
	--- mb [append-new]: rule
		--- < k > [append(loc(Block:Nat, Offset:Nat), Len:Nat, V:Value) => storeNew V:Value atLoc loc(Block:Nat, Offset:Nat)] ...</ k >
		--- < mem > M:Map </ mem >
		--- if notBool($hasMapping(M:Map, Block:Nat))
		--- : KSentence [metadata "structural"] .
	
	--- mb [store-scalar]: rule
		--- < k > [store tv(V:BaseValue, T:Type) atLoc Loc:Nat => 
		--- putInMem(Loc:Nat, tv(V:BaseValue, T:Type), T:Type, sizeofType(T:Type))] ...</ k >
		--- : KSentence [metadata "structural"] .
	--- mb [store-composite]: rule
		--- < k > [store atv(V:List{K}, T:Type) atLoc Loc:Nat => 
		--- putBytesInMem(Loc:Nat, V:List{K}, T:Type, sizeofType(T:Type))] ...</ k >
		--- : KSentence [metadata "structural"] .
		
	
	mb [storeNew]: rule
		< k > storeNew tv(V:K, T:Type) atLoc Loc:Nat => alloc(Loc:Nat, value(byteSizeofType(T:Type))) ~> write(Loc:Nat, tv(V:K, T:Type)) ...</ k >
		: KSentence [metadata "structural"] .
		
	--- mb [store-N-New]: rule
		--- < k > [store Len:Nat New tv(N:Nat, ?) atLoc Loc:Nat => allocWithDefault(Loc:Nat, Len:Nat, N:Nat)] ...</ k >
		--- : KSentence [metadata "structural"] .

	
	--- c99 6.5:2 If a side effect on a scalar object is unsequenced relative to either a different side effect on the same scalar object or a value computation using the value of the same scalar object, the behavior is undefined. If there are multiple allowable orderings of the subexpressions of an expression, the behavior is undefined if such an unsequenced side effect occurs in any of the orderings
	--- i take this to mean that if i write to a location twice or read from a location after being written to, then it is a problem

	
	--- --- fixme 
	--- eq piece(1 &Nat unknown(N:Nat), 1),,piece(1 &Nat unknown(N:Nat) >>Nat 1, 1),,piece(1 &Nat unknown(N:Nat) >>Nat 1 >>Nat 1, 1),,piece(1 &Nat unknown(N:Nat) >>Nat 1 >>Nat 1 >>Nat 1, 1),,piece(1 &Nat unknown(N:Nat) >>Nat 1 >>Nat 1 >>Nat 1 >>Nat 1, 1),,piece(1 &Nat unknown(N:Nat) >>Nat 1 >>Nat 1 >>Nat 1 >>Nat 1 >>Nat 1, 1),,piece(1 &Nat unknown(N:Nat) >>Nat 1 >>Nat 1 >>Nat 1 >>Nat 1 >>Nat 1 >>Nat 1, 1),,piece(1 &Nat unknown(N:Nat) >>Nat 1 >>Nat 1 >>Nat 1 >>Nat 1 >>Nat 1 >>Nat 1 >>Nat 1, 1) = piece(unknown(N:Nat), 8) .
		
	--- --- fixme it's interesting we need this.  what do the rules say about when string allocation happens?
	--- op dontCountWrite : Nat -> K .
	--- mb rule
		--- < k > [dontCountWrite(Loc:Nat) => .K] ...</ k >
		--- < locsWrittenTo >... [BagItem(Loc:Nat) => .Bag] ...</ locsWrittenTo >
		--- : KSentence [metadata "structural"] .
		
	--- --- fixme allocString is a misnomer, this actually writes the string to already-allocated memory	
	--- mb [alloc-string]: rule
		--- < k > [allocString(Loc:Nat, S:String) => putByteInMem(Loc:Nat, charToAscii(firstChar(S:String))) ~> dontCountWrite(Loc:Nat) ~> allocString(sNat(Loc:Nat), butFirstChar(S:String))] ...</ k >
		--- if lengthString(S:String) >Int 0
		--- : KSentence [metadata "structural"] .
	--- mb [alloc-empty-string]: rule
		--- < k > [allocString(Loc:Nat, "") => putByteInMem(Loc:Nat, 0)] ...</ k >
		--- : KSentence [metadata "structural"] .
		
	--- --- fixme not enough, need more rules
	--- --- fixme is this backwards?
	--- mb rule
		--- < k > [putBytesInMem(Loc:Nat, (piece(N:Nat, BitLen:Nat),, piece(N':Nat, 1),, L:List{K}), T:Type, tv(sNat(Len:Nat), J:Type)) 
		--- => putBytesInMem(Loc:Nat, (piece((N':Nat <<Nat BitLen:Nat) |Nat N:Nat, sNat(BitLen:Nat)),, L:List{K}), T:Type, tv(sNat(Len:Nat), J:Type))] ...</ k >
		--- if BitLen:Nat <Nat 8
		--- : KSentence [metadata "structural"] .

	--- mb rule
		--- < k > [putBytesInMem(loc(Block:Nat, Offset:Nat), (piece(N:Nat, 8),, L:List{K}), T:Type, tv(sNat(Len:Nat), J:Type)) => putBytesInMem(loc(Block:Nat, sNat(Offset:Nat)), (L:List{K}), T:Type, tv(Len:Nat, J:Type))] ...</ k >
		--- < mem >... Block:Nat |-> memblock(?, [M:Map => M:Map[piece(N:Nat, numBitsPerByte) / Offset:Nat]]) ...</ mem >
		--- < locsWrittenTo > Locs:Bag [.Bag => BagItem(loc(Block:Nat, Offset:Nat))] </ locsWrittenTo >
		--- if notBool(loc(Block:Nat, Offset:Nat) in Locs:Bag)
		--- : KSentence [metadata "structural"] .
	--- mb rule
		--- < k > [putBytesInMem(loc(Block:Nat, Offset:Nat), (F:Float,, L:List{K}), T:Type, tv(sNat(Len:Nat), J:Type)) => putBytesInMem(loc(Block:Nat, sNat(Offset:Nat)), (L:List{K}), T:Type, tv(Len:Nat, J:Type))] ...</ k >
		--- < mem >... Block:Nat |-> memblock(?, [M:Map => M:Map[F:Float / Offset:Nat]]) ...</ mem >
		--- < locsWrittenTo > Locs:Bag [.Bag => BagItem(loc(Block:Nat, Offset:Nat))] </ locsWrittenTo >
		--- if notBool(loc(Block:Nat, Offset:Nat) in Locs:Bag)
		--- : KSentence [metadata "structural"] .
	--- --- fixme
	--- mb rule
		--- < k > [putBytesInMem(loc(Block:Nat, Offset:Nat), (loc(N:Nat, M:Nat),, L:List{K}), T:Type, tv(sNat(Len:Nat), J:Type)) => putBytesInMem(loc(Block:Nat, sNat(Offset:Nat)), (L:List{K}), T:Type, tv(Len:Nat, J:Type))] ...</ k >
		--- < mem >... Block:Nat |-> memblock(?, [M:Map => M:Map[loc(N:Nat, M:Nat) / Offset:Nat]]) ...</ mem >
		--- < locsWrittenTo > Locs:Bag [.Bag => BagItem(loc(Block:Nat, Offset:Nat))] </ locsWrittenTo >
		--- if notBool(loc(Block:Nat, Offset:Nat) in Locs:Bag)
		--- : KSentence [metadata "structural"] .
		
	--- mb rule
		--- < k > [putBytesInMem(Loc:Nat, .List{K}, T:Type, tv(0, ?)) => .K] ...</ k >
		--- : KSentence [metadata "structural"] .
	
	--- op putByteInMem : Nat BaseValue -> K .
	--- op putBitInMem : BaseValue BaseValue -> K .
	--- mb rule
		--- < k > [putInMem(?, ?, ?, tv(0, ?)) => .K] ...</ k >
		--- : KSentence [metadata "structural"] .
		
	--- --- fixme: fixes the type of function types so they are equivalent
	--- mb rule
		--- < k > [putInMem(Loc:Nat, tv(N:Int, pointerType(functionType(T:Type, L:List{K}))), pointerType(functionType(T:Type, L':List{K})), tv(Len:Nat, J:Type)) 
		--- => putInMem(Loc:Nat, tv(N:Int, pointerType(functionType(T:Type, L':List{K}))), pointerType(functionType(T:Type, L':List{K})), tv(Len:Nat, J:Type))] ...</ k >
		--- if L:List{K} =/=Bool L':List{K}
		--- : KSentence [metadata "structural"] .
		
	--- op isLocation : K -> Bool .
	--- eq isLocation(loc(?, ?)) = true .
	--- eq isLocation(bitloc(?, ?, ?)) = true .
	--- eq isLocation(K:K) = false [owise] .
	--- --- needs to make sure not a bitfield
	--- mb rule
		--- < k > [putInMem(loc(Block:Nat, Offset:Nat), tv(N:Int, T:Type), T:Type, tv(sNat(Len:Nat), J:Type)) 
		--- => putByteInMem(loc(Block:Nat, Offset:Nat), ((N:Int %Int 256) +Int 256) %Int 256) ~> putInMem(loc(Block:Nat, sNat(Offset:Nat)), tv(N:Int >>Int 8, T:Type), T:Type, tv(Len:Nat, J:Type))] ...</ k >
		--- if notBool(isLocation(N:Int))
		--- : KSentence [metadata "structural"] .
		
	--- --- fixme can now check oob
	--- mb rule
		--- < k > [putInMem(loc(Block:Nat, Offset:Nat), tv(F:Float, T:Type), T:Type, tv(sNat(Len:Nat), J:Type)) => .K] ...</ k >
		--- < mem >... Block:Nat |-> memblock(?, [M:Map => M:Map[F:Float / Offset:Nat]]) ...</ mem >
		--- < locsWrittenTo > Locs:Bag [.Bag => BagItem(loc(Block:Nat, Offset:Nat))] </ locsWrittenTo >
		--- if notBool(loc(Block:Nat, Offset:Nat) in Locs:Bag)
		--- andBool (
			--- (T:Type ==Bool double)
			--- orBool T:Type ==Bool float
			--- orBool T:Type ==Bool long-double
		--- )
		--- : KSentence [metadata "structural"] .
		
	--- --- fixme: put pointer in memory
	--- mb rule
		--- < k > putInMem(?, [tv(loc(0, 0), T:Type) => tv(0, T:Type)], ?, ?) ...</ k >
		--- : KSentence [metadata "structural"] .
	--- mb rule
		--- < k > [putInMem(loc(Block:Nat, Offset:Nat), tv(loc(Block':Nat, Offset':Nat), T:Type), T:Type, tv(sNat(Len:Nat), J:Type)) => .K] ...</ k >
		--- < mem >... Block:Nat |-> memblock(?, [M:Map => M:Map[loc(Block':Nat, Offset':Nat) / Offset:Nat]]) ...</ mem >
		--- < locsWrittenTo > Locs:Bag [.Bag => BagItem(loc(Block:Nat, Offset:Nat))] </ locsWrittenTo >
		--- if notBool(loc(Block:Nat, Offset:Nat) in Locs:Bag)
		--- andBool notBool(Block':Nat ==Bool 0 andBool Offset':Nat ==Bool 0)
		--- : KSentence [metadata "structural"] .
		
	--- mb rule
		--- < k > [putInMem(bitloc(Block:Nat, Base:Nat, Offset:Nat), tv(N:Int, T:Type), T:Type, tv(sNat(Len:Nat), J:Type))
		--- => putBitInMem(bitloc(Block:Nat, Base:Nat, Offset:Nat), ((N:Int %Int 2) +Int 2) %Int 2) ~> 
		--- putInMem(bitloc(Block:Nat, Base:Nat, sNat(Offset:Nat)), tv(N:Int >>Int 1, T:Type), T:Type, tv(Len:Nat, J:Type))] ...</ k >
		--- if (Offset:Nat <Nat 8)
		--- : KSentence [metadata "structural"] .
	--- mb rule 
		--- < k > [putInMem(bitloc(Block:Nat, Base:Nat, 8), tv(N:Int, T:Type), T:Type, tv(sNat(Len:Nat), J:Type)) 
		--- => putInMem(bitloc(Block:Nat, sNat(Base:Nat), 0), tv(N:Int, T:Type), T:Type, tv(sNat(Len:Nat), J:Type))] ...</ k >
		--- : KSentence [metadata "structural"] .
	
	--- mb rule
		--- < k > [putByteInMem(loc(Block:Nat, Offset:Nat), N:Nat) => .K] ...</ k >
		--- < mem >... Block:Nat |-> memblock(Len:Nat, [M:Map => M:Map[piece(N:Nat, 8) / Offset:Nat]]) ...</ mem >
		--- < locsWrittenTo > Locs:Bag [.Bag => BagItem(loc(Block:Nat, Offset:Nat))] </ locsWrittenTo >
		--- if notBool(loc(Block:Nat, Offset:Nat) in Locs:Bag)
		--- : KSentence [metadata "structural"] .
	--- --- this helps be fast, but is unsafe
	--- --- mb rule
		--- --- < k > [putByteInMem(Loc:Nat, N:Nat) => .K] ...</ k >
		--- --- < mem > [M:Map => M:Map[piece(N:Nat, 8) / Loc:Nat]] </ mem >
		--- --- : KSentence [metadata "structural"] .
	--- --- fixme need better fidelity; shouldn't zero out bits
	--- --- fixme also need to handle the case where it's already unknown
	--- mb rule 
		--- < k > putBitInMem(bitloc(Block:Nat, Base:Nat, ?), ?) ...</ k >
		--- < mem >... Block:Nat |-> memblock(?, [M:Map => M:Map[piece(0, numBitsPerByte) / Base:Nat]]) ...</ mem >
		--- if notBool($hasMapping(M:Map, Base:Nat))
		--- : KSentence [metadata "structural"] .
	--- op known : Nat -> Bool .
	--- eq known(unknown(?)) = false .
	--- eq known(?) = true [owise] .
	--- --- fixme not handling undefined writing twice in a sequence point 
	--- mb rule
		--- < k > [putBitInMem(bitloc(Block:Nat, Base:Nat, Offset:Nat), N:Nat) => .K] ...</ k >
		--- < mem >... Block:Nat |-> memblock(?, 
			--- (? Base:Nat |-> [piece(Old:Nat, 8) => 
				--- piece((Old:Nat &Nat ((1 <<Nat Offset:Nat) xorNat 255)) |Nat (N:Nat <<Nat Offset:Nat), 8)
			--- ])
		--- ) ...</ mem >
		--- if known(Old:Nat)
		--- : KSentence [metadata "structural"] .
endm

mod COMMON-C-MEMORY is
	including COMMON-MEMORY-INCLUDE .
	including COMMON-C-MEMORY-MISC .
	including COMMON-SEMANTICS-WRITING .
	including COMMON-SEMANTICS-READING .
endm
