mod COMMON-MEMORY-INCLUDE is
	including COMMON-INCLUDE .
	
	op extractBytesFromMem : Nat Nat -> K . --- loc, size in bytes
	
	op encodedPointer : Int -> Nat .
endm

mod COMMON-SEMANTICS-READING is
	including COMMON-MEMORY-INCLUDE .
	
	op extractBitsFromMem : Nat Nat -> K . --- loc, size in bits
	op extractByteFromMem : Nat -> K .
	op getBitOffset : Nat -> Nat .
	eq getBitOffset(? +Nat bito(M:Nat)) = M:Nat .
	eq getBitOffset(?) = 0 [owise] .
	
	--- mb rule
		--- < k > extractBitsFromList(dataList((functionObject(X:Id, T:Type, K:K))), 0, N:Nat) => functionObject(X:Id, T:Type, K:K) ...</ k >
		--- if N:Nat ==Bool numBitsPerByte
		--- : KSentence [metadata "structural"] .
		
	op extractBitsFromList : K Nat Nat List{K} -> K . --- datalist, offset into list, number of bits to extract, accumulator
	eq extractBitsFromList(dataList(L:List{K}), N:Nat, M:Nat) = extractBitsFromList(dataList(L:List{K}), N:Nat, M:Nat, .List{K}) .
	mb rule
		< k > extractBitsFromList(dataList((piece(?, Len:Nat),, L:List{K})), Offset:Nat, NumBits:Nat, .List{K})
			=> extractBitsFromList(dataList(L:List{K}), absInt(Offset:Nat -Int 1), NumBits:Nat, .List{K})
		...</ k >
		if byteoffset(Offset:Nat) =/=Bool 0
		andBool Len:Nat >=Nat numBitsPerByte
		: KSentence [metadata "structural"] .
	mb rule
		< k > extractBitsFromList(dataList((piece(N:Nat, Len:Nat),, L:List{K})), 0, NumBits:Nat, Done:List{K})
			=> extractBitsFromList(dataList(L:List{K}), 0, absInt(NumBits:Nat -Int Len:Nat), (Done:List{K},, piece(N:Nat, Len:Nat)))
		...</ k >
		if Len:Nat <=Nat NumBits:Nat
		: KSentence [metadata "structural"] .

	mb rule
		< k > extractBitsFromList(dataList((piece(N:Nat, Len:Nat),, L:List{K})), 0, NumBits:Nat, Done:List{K})
			=> extractBitsFromList(dataList((piece(N:Nat >>Nat 1, absInt(Len:Nat -Int 1)),, piece(N:Nat &Nat 1, 1),, L:List{K})), 0, NumBits:Nat, Done:List{K})
		...</ k >
		if Len:Nat >Nat NumBits:Nat
		andBool Len:Nat >Nat 1
		: KSentence [metadata "structural"] .
	--- mb rule
		--- < k > extractBitsFromList(dataList((encodedPointer(N:Nat),, L:List{K})), 0, NumBits:Nat, Done:List{K})
			--- => extractBitsFromList(dataList(L:List{K}), 0, absInt(NumBits:Nat -Int cfg:ptrsize), (Done:List{K},, encodedPointer(N:Nat)))
		--- ...</ k >
		--- if cfg:ptrsize <=Nat NumBits:Nat
		--- : KSentence [metadata "structural"] .
	mb rule
		< k > extractBitsFromList(?, 0, 0, Done:List{K}) => dataList(Done:List{K}) ...</ k >
		: KSentence [metadata "structural"] .
	
	op read : K K K -> K .
	mb context read(?, ?, value(`[HOLE`]:K)) : KSentence .
	ceq read(Loc:Nat, T:Type) = read(Loc:Nat, T:Type, value(bitSizeofType(T:Type))) 
		if notBool(hasFunctionType(T:Type)) .
	
	--- FIXME should check types
	mb rule
		< k > read(Loc:Nat, functionType(?, ?)) => extractByteFromMem(Loc:Nat) ...</ k >
		: KSentence [metadata "structural"] .
		
	mb rule
		< k > read(Loc:Nat, T:Type, bitSize:Nat) => concretize(T:Type, extractBitsFromMem(Loc:Nat, bitSize:Nat)) ...</ k >
		: KSentence [metadata "structural"] .
		
	op joinIntegerBytes : Type List{K} -> K .
	ceq concretize(T:Type, dataList(L:List{K})) = joinIntegerBytes(T:Type, L:List{K})
		if hasIntegerType(T:Type) andBool isConcreteList(L:List{K}) .
		
	--- fixme should also check sizes are appropriate
	--- fixme very unsafe as is.  doesn't care if other bytes were overwritten
	ceq concretize(pointerType(T:Type), dataList((piece(encodedPointer(N:Nat), Len:Nat),, L:List{K}))) 
		= tv(N:Nat, pointerType(T:Type))
		if Len:Nat ==Bool numBitsPerByte
		andBool lengthList{K}(L:List{K}) ==Bool cfg:ptrsize -Int 1 .
	ceq concretize(pointerType(T:Type), dataList((piece(N:Nat, Len:Nat),, L:List{K}))) 
		= tv(N:Nat, pointerType(T:Type))
		if N:Nat ==Bool NULL
		andBool Len:Nat ==Bool numBitsPerByte
		andBool lengthList{K}(L:List{K}) ==Bool cfg:ptrsize -Int 1 .
		
	eq concretize(structType(S:Id), dataList(L:List{K})) = tv(L:List{K}, structType(S:Id)) .
		
		
	--- FIXME assuming bytes?
	op joinIntegerBytes : Type List{K} Nat -> K .
	eq joinIntegerBytes(T:Type, L:List{K}) = joinIntegerBytes(T:Type, L:List{K}, 0) .
	eq joinIntegerBytes(T:Type, (L:List{K},, piece(N:Nat, Len:Nat)), M:Nat)
		= joinIntegerBytes(T:Type, L:List{K}, ((M:Nat <<Nat Len:Nat) |Nat N:Nat)) .
	--- eq joinIntegerBytes(T:Type, (L:List{K},, piece(N:Nat, Len:Nat)), M:Nat)
		--- = joinIntegerBytes(T:Type, L:List{K}, M:Nat bit:: piece(N:Nat, Len:Nat)) .
	eq joinIntegerBytes(T:Type, .List{K}, N:Nat) = interpret(T:Type, N:Nat) . 
		
	op isConcreteList : List{K} -> Bool .
	op isConcreteNumber : Nat -> Bool .
	ceq isConcreteList((N:Nat,, L:List{K})) = isConcreteList(L:List{K})
		if isConcreteNumber(N:Nat) .
	eq isConcreteList(.List{K}) = true .
	eq isConcreteNumber(sym(?) +Nat ?) = false .
	eq isConcreteNumber(bito(?) +Nat ?) = false .
	eq isConcreteNumber(?) = true [owise] .
	
	
	--- eq interpret(T:Type, functionObject(X:Id, T:Type, K:K)) = functionObject(X:Id, T:Type, K:K) .
	
	op floorLoc : Nat -> Nat . --- loc with possible bit offset returning base byte
	eq floorLoc(sym(N:Nat) +Nat bito(M:Nat) +Nat R:Nat) = sym(N:Nat) +Nat R:Nat .
	eq floorLoc(sym(N:Nat) +Nat R:Nat) = sym(N:Nat) +Nat R:Nat [owise] .
	
	mb rule
		< k > extractBitsFromMem(Loc:Nat, Size:Nat) => extractBitsFromList(extractBytesFromMem(floorLoc(Loc:Nat), bitsToBytes(Size:Nat)), getBitOffset(Loc:Nat), Size:Nat) ...</ k >
		: KSentence [metadata "structural"] .
	
	mb context extractBytesFromMem-aux(?, ?, (?,, `[HOLE`]:K,, ?)) : KSentence .
	--- this next op should use Nats, but the context doesn't allow it.  See issue 54
	op extractBytesFromMem-aux : K K List{K} -> K . --- loc, size in bytes, aux list
	
	mb rule
		< k > extractBytesFromMem(Loc:Nat, Size:Nat) => extractBytesFromMem-aux(Loc:Nat, Size:Nat, .List{K}) ...</ k >
		: KSentence [metadata "structural"] .
		
	mb rule
		< k > extractBytesFromMem-aux(Loc:Nat, sNat(Size:Nat), Aux:List{K})
			=> extractBytesFromMem-aux(sNat(Loc:Nat), Size:Nat, (Aux:List{K},, extractByteFromMem(Loc:Nat)))
		...</ k >
		: KSentence [metadata "structural"] .
		
	---op combineData : List{KResult} -> K .

	---eq combineData(functionObject(X:Id, T:Type, K:K)) = functionObject(X:Id, T:Type, K:K) .
	***(
explodeToBits(values((
('tv).KResultLabel(kList("wklist_")(BaseValue piece(unknown, 8)(.List{K})),,BaseType unsigned-long-long-int(.List{K}))
,,('tv).KResultLabel(kList("wklist_")(BaseValue piece(unknown, 8)(.List{K})),,BaseType unsigned-long-long-int(.List{K}))
,,('tv).KResultLabel(kList("wklist_")(BaseValue piece(unknown, 8)(.List{K})),,BaseType unsigned-long-long-int(.List{K}))
,,('tv).KResultLabel(kList("wklist_")(BaseValue piece(unknown, 8)(.List{K})),,BaseType unsigned-long-long-int(.List{K})))))
	***)

	op values : List{K} -> List{K} .
	eq values((tv(K:K, ?),, L:List{KResult})) = (K:K,, values(L:List{KResult})) .
	eq values(.List{K}) = .List{K} .
	mb rule
		< k > extractBytesFromMem-aux(?, 0, Aux:List{KResult}) => dataList(values(Aux:List{KResult})) ...</ k >
		: KSentence [metadata "structural"] .
	
	op rawData : BaseValue Nat -> KResult .
	--- FIXME make sure it's a byte
	mb rule
		< k > extractByteFromMem(sym(Block:Nat) +Nat Offset:Nat) => V:K ...</ k >
		< mem >... Block:Nat |-> memblock(Size:Nat, (? Offset:Nat |-> V:K)) ...</ mem >
		< locsWrittenTo > Locs:Bag </ locsWrittenTo >
		if notBool(sym(Block:Nat) +Nat Offset:Nat) in Locs:Bag
		andBool Offset:Nat <Nat Size:Nat
		: KSentence [metadata "structural"] .
	mb rule
		< k > extractByteFromMem(sym(Block:Nat) +Nat Offset:Nat) => piece(unknown(numBitsPerByte), numBitsPerByte) ...</ k >
		< mem >... Block:Nat |-> memblock(Size:Nat, (M:Map => M:Map[piece(unknown(numBitsPerByte), numBitsPerByte) / Offset:Nat])) ...</ mem >
		< locsWrittenTo > Locs:Bag </ locsWrittenTo >
		if notBool(sym(Block:Nat) +Nat Offset:Nat) in Locs:Bag
		andBool notBool($hasMapping(M:Map, Offset:Nat))
		andBool Offset:Nat <Nat Size:Nat
		: KSentence [metadata "structural"] .
endm

mod COMMON-SEMANTICS-WRITING is
	including COMMON-MEMORY-INCLUDE .
	mb context alloc(?, value(`[HOLE`]:K)) : KSentence .

	eq allocateType(Loc:Nat, T:Type) = alloc(Loc:Nat, value(byteSizeofType(T:Type))) .
	
	mb rule
		< k > alloc(sym(Block:Nat) +Nat 0, Len:Nat) => (.).K ...</ k >
		< mem >... (.).Map => Block:Nat |-> memblock(Len:Nat, (.).Map) ...</ mem >
		: KSentence [metadata "structural"] .
		
	op writeBytes : Nat K -> K [metadata "strict(2)"] .
	op writeBitfield : Nat Type K -> K [metadata "strict(3)"] .
	op isByteLoc : Nat -> Bool .
	op splitBytes : Value -> K .
	op calculateNewBytes : Nat K K -> K [metadata "strict(3)"] .
	
	op write : K Value K -> K [metadata "strict(2)"] .
	ceq write(K:K, tv(V:K, T:Type)) = write(K:K, tv(V:K, T:Type), value(bitSizeofType(T:Type))) 
		if notBool(hasFunctionType(T:Type)) .
	--- FIXME should check types
	mb rule
		< k > write(Loc:Nat, tv(V:K, functionType(?, ?))) => writeByte(Loc:Nat, V:K) ...</ k >
		: KSentence [metadata "structural"] .	
	mb context write(?, ?, value(`[HOLE`])) : KSentence . 
	mb rule
		< k > write(Loc:Nat, tv(V:K, T:Type), bitSize:Nat)
			=> writeBytes(Loc:Nat, splitBytes(tv(V:K, T:Type)))
		...</ k >
		if bitSize:Nat %Nat numBitsPerByte ==Bool 0
		andBool isByteLoc(Loc:Nat)
		: KSentence [metadata "structural"] .
		

	eq bitoffset(? +Nat bito(N:Nat)) = N:Nat .
	eq bitoffset(?) = 0 [owise] .
	

	eq byteoffset(N:Nat +Nat bito(?)) = N:Nat .
	eq byteoffset(N:Nat) = N:Nat [owise] .
	mb rule
		< k > write(Loc:Nat, tv(N:Nat, T:Type), bitSize:Nat)
			=> writeBitfield(Loc:Nat, T:Type, calculateNewBytes(bitoffset(Loc:Nat), piece(N:Nat, bitSize:Nat), extractBytesFromMem(Loc:Nat, bitsToBytes(bitSize:Nat))))
		...</ k >
		if bitSize:Nat %Nat numBitsPerByte =/=Bool 0
		orBool notBool(isByteLoc(Loc:Nat))
		: KSentence [metadata "structural"] .
		
	mb rule
		< k > writeBitfield(Loc:Nat, T:Type, dataList(L:List{K}))
			=> writeBytes(byteoffset(Loc:Nat), dataList(L:List{K}))
		...</ k >
		: KSentence [metadata "structural"] .
		
	op explodeToBits : List{K} -> List{K} .
	op calculateNewBytes-aux : Nat K K List{K} -> K .
	eq calculateNewBytes(Len:Nat, N:Nat, dataList(L:List{K})) = calculateNewBytes-aux(Len:Nat, dataList(explodeToBits(N:Nat)), dataList(explodeToBits(L:List{K})), .List{K}) .
	
	op joinBitsToBytes : List{K} -> K .
	op joinBitsToBytes-aux : K K -> K .
	
	eq calculateNewBytes-aux(0, dataList((piece(N:Nat, 1),, L:List{K})), dataList((piece(?, 1),, L':List{K})), Result:List{K}) = calculateNewBytes-aux(0, dataList(L:List{K}), dataList(L':List{K}), (Result:List{K},, piece(N:Nat, 1))) .
	eq calculateNewBytes-aux(0, dataList(.List{K}), dataList(L:List{K}), Result:List{K}) = joinBitsToBytes((Result:List{K},, L:List{K})) .
	
	eq joinBitsToBytes(L:List{K}) = joinBitsToBytes-aux(dataList(L:List{K}), dataList(.List{K})) .
	ceq joinBitsToBytes-aux(dataList((piece(N:Nat, Len:Nat),, piece(M:Nat, 1),, L:List{K})), dataList(R:List{K}))
		= joinBitsToBytes-aux(dataList((piece((N:Nat <<Nat 1) |Nat M:Nat, sNat(Len:Nat)),, L:List{K})), dataList(R:List{K}))
		if Len:Nat <Nat numBitsPerByte .
	--- ceq joinBitsToBytes-aux(dataList((piece(N:Nat, Len:Nat),, piece(M:Nat, 1),, L:List{K})), dataList(R:List{K}))
		--- = joinBitsToBytes-aux(dataList((piece(N:Nat, Len:Nat) bit:: piece(M:Nat, 1),, L:List{K})), dataList(R:List{K}))
		--- if Len:Nat <Nat numBitsPerByte .
	ceq joinBitsToBytes-aux(dataList((piece(N:Nat, Len:Nat),, L:List{K})), dataList(R:List{K}))
		= joinBitsToBytes-aux(dataList(L:List{K}), dataList((R:List{K},, piece(N:Nat, Len:Nat))))
		if Len:Nat ==Bool numBitsPerByte .
	eq joinBitsToBytes-aux(dataList(.List{K}), dataList(R:List{K}))
		= dataList(R:List{K}) .
	
	--- op explodeToBits : List{K} -> List{K} .
	eq explodeToBits((K:K,, L:NeList{K})) = (explodeToBits(K:K),, explodeToBits(L:NeList{K})) .
	eq explodeToBits(piece(N:Nat, sNat(Len:Nat)))
		= (explodeToBits(piece(N:Nat >>Nat 1, Len:Nat)),, piece(N:Nat &Nat 1, 1)) .
	eq explodeToBits(piece(N:Nat, 0)) = .List{K} .
	eq explodeToBits(.List{K}) = .List{K} .
	--- cmenew eq explodeToBits(piece(N:Nat, 0)) = .List{K} .
	
	op clearBits : Nat Nat Nat -> Nat .
	--- eq clearBits(N:Nat, Low:Nat, High:Nat) = 
		
	op writeByte : Nat K -> K .
	mb rule
		< k > writeBytes(sym(Block:Nat) +Nat Offset:Nat, dataList((V:K,, L:List{K})))
			=> writeByte(sym(Block:Nat) +Nat Offset:Nat, V:K)
			~> writeBytes(sym(Block:Nat) +Nat sNat(Offset:Nat), dataList(L:List{K}))
		...</ k >
		: KSentence [metadata "structural"] .
	mb rule
		< k > writeByte(sym(Block:Nat) +Nat Offset:Nat, V:K) => . ...</ k >
		< mem >... Block:Nat |-> memblock(Len:Nat, (M:Map => M:Map[V:K / Offset:Nat])) ...</ mem >
		if Offset:Nat <Nat Len:Nat
		: KSentence [metadata "structural"] .
	mb rule
		< k > writeBytes(?, dataList(.List{K})) => . ...</ k >
		: KSentence [metadata "structural"] .
		
	--- eq splitBytes(tv(functionObject(X:Id, T:Type, Body:K), T:Type)) = dataList(functionObject(X:Id, T:Type, Body:K)) .
	
	
	mb rule splitBytes(tv(I:Int, T:Type)) => splitIntegerBytes(I:Int, T:Type, value(byteSizeofType(T:Type)))
		if hasIntegerType(T:Type)
		: KSentence .
	mb rule splitBytes(tv(I:Int, pointerType(T:Type))) => splitPointerBytes(I:Int, pointerType(T:Type), value(byteSizeofType(pointerType(T:Type))))
		: KSentence .
	
	op splitIntegerBytes : K K K -> K .
	op splitIntegerBytes : K K K List{K} -> K .
	mb context splitIntegerBytes(?, ?, value(`[HOLE`]:K)) : KSentence .
	eq splitIntegerBytes(I:Int, T:Type, Len:Nat) = splitIntegerBytes(I:Int, T:Type, Len:Nat, .List{K}) .
	eq splitIntegerBytes(I:Int, T:Type, sNat(Len:Nat), L:List{K})
		= splitIntegerBytes(I:Int >>Int numBitsPerByte, T:Type, Len:Nat, (L:List{K},, lowestByte(I:Int, T:Type))) .
	eq splitIntegerBytes(I:Int, T:Type, 0, L:List{K})
		= dataList(L:List{K}) .
		
	op splitPointerBytes : K K K -> K .
	op splitPointerBytes : K K K List{K} -> K .
	mb context splitPointerBytes(?, ?, value(`[HOLE`]:K)) : KSentence .
	ceq splitPointerBytes(I:Int, T:Type, sNat(Len:Nat)) 
		= splitPointerBytes(I:Int, T:Type, Len:Nat, piece(encodedPointer(I:Int), numBitsPerByte))
		if I:Int =/=Bool NULL .
	ceq splitPointerBytes(I:Int, T:Type, sNat(Len:Nat)) 
		= splitPointerBytes(I:Int, T:Type, Len:Nat, piece(NULL, numBitsPerByte))
		if I:Int ==Bool NULL .
	eq splitPointerBytes(I:Int, T:Type, sNat(Len:Nat), L:List{K}) = splitPointerBytes(I:Int, T:Type, Len:Nat, (L:List{K},, piece(unknown(numBitsPerByte), numBitsPerByte))) .
	eq splitPointerBytes(I:Int, T:Type, 0, L:List{K}) 
		= dataList(L:List{K}) .
	
	op lowestByte : Int Type -> K .
	ceq lowestByte(I:Int, T:Type) = piece(I:Int &Int byteMaskSet, numBitsPerByte)
		if hasIntegerType(T:Type) .
	
	op byteMaskSet : -> Nat .
	--- FIXME why does this parse?
	eq byteMaskSet = (2 ^Nat numBitsPerByte) -Int 1 .
		
	eq isByteLoc(? +Nat bito(?)) = false .
	eq isByteLoc(?) = true [owise] .
endm

mod COMMON-C-MEMORY-MISC is
	including COMMON-MEMORY-INCLUDE .

	--- mb rule
		--- < k > [allocWithDefault(loc(Block:Nat, ?), tv(Len:Nat, ?), N:Nat) => .K] ...</ k >
		--- < mem >... [.Map => Block:Nat |-> memblock(Len:Nat, (0 to Len:Nat) |-> piece(N:Nat, numBitsPerByte))] ...</ mem >
		--- : KSentence [metadata "structural"] .
		
	--- FIXME far too simple
	--- mb [storeAtLoc]: rule
		--- < k > write(sym(Block:Nat) +Nat Offset:Nat, tv(V:Value, T:Type)) => (.).K ...</ k >
		--- < mem >... Block:Nat |-> memblock(Len:Nat, (M:Map => M:Map[V:Value / Offset:Nat])) ...</ mem >
		--- if bitSizeofType(T:Type) <=Int (Len:Nat -Int Offset:Nat) *Int numBitsPerByte
		--- : KSentence [metadata "structural"] .
		
	--- op mapValue : Map -> Value .
	--- op updateMap : Map Nat Value -> K .
	--- op setMapAtBlock : Nat K -> K [metadata "strict(2)"] . 
	--- mb [storeAtLoc]: rule
		--- < k > write(sym(Block:Nat) +Nat Offset:Nat, tv(V:BaseValue, T:Type)) 
			--- => setMapAtBlock(Block:Nat, updateMap(M:Map, Offset:Nat, tv(V:BaseValue, T:Type))) ...</ k >
		--- < mem >... Block:Nat |-> memblock(Len:Nat, M:Map) ...</ mem >
		--- if bitSizeofType(T:Type) <=Int (Len:Nat -Int Offset:Nat) *Int numBitsPerByte
		--- : KSentence [metadata "structural"] .
		
	--- mb [append-existing]: rule
		--- < k > [append(loc(Block:Nat, Offset:Nat), Len:Nat, V:Value) => store V:Value atLoc loc(Block:Nat, Offset:Nat)] ...</ k >
		--- < mem >... Block:Nat |-> [memblock(OldLen:Nat, M:Map) => memblock(OldLen:Nat +Nat Len:Nat, M:Map)] ...</ mem >
		--- : KSentence [metadata "structural"] .
	--- mb [append-new]: rule
		--- < k > [append(loc(Block:Nat, Offset:Nat), Len:Nat, V:Value) => storeNew V:Value atLoc loc(Block:Nat, Offset:Nat)] ...</ k >
		--- < mem > M:Map </ mem >
		--- if notBool($hasMapping(M:Map, Block:Nat))
		--- : KSentence [metadata "structural"] .
	
	--- mb [store-scalar]: rule
		--- < k > [store tv(V:BaseValue, T:Type) atLoc Loc:Nat => 
		--- putInMem(Loc:Nat, tv(V:BaseValue, T:Type), T:Type, sizeofType(T:Type))] ...</ k >
		--- : KSentence [metadata "structural"] .
	--- mb [store-composite]: rule
		--- < k > [store atv(V:List{K}, T:Type) atLoc Loc:Nat => 
		--- putBytesInMem(Loc:Nat, V:List{K}, T:Type, sizeofType(T:Type))] ...</ k >
		--- : KSentence [metadata "structural"] .
		
	
	mb [storeNew]: rule
		< k > storeNew tv(V:K, T:Type) atLoc Loc:Nat => alloc(Loc:Nat, value(byteSizeofType(T:Type))) ~> write(Loc:Nat, tv(V:K, T:Type)) ...</ k >
		: KSentence [metadata "structural"] .
		
	--- mb [store-N-New]: rule
		--- < k > [store Len:Nat New tv(N:Nat, ?) atLoc Loc:Nat => allocWithDefault(Loc:Nat, Len:Nat, N:Nat)] ...</ k >
		--- : KSentence [metadata "structural"] .

	
	--- c99 6.5:2 If a side effect on a scalar object is unsequenced relative to either a different side effect on the same scalar object or a value computation using the value of the same scalar object, the behavior is undefined. If there are multiple allowable orderings of the subexpressions of an expression, the behavior is undefined if such an unsequenced side effect occurs in any of the orderings
	--- i take this to mean that if i write to a location twice or read from a location after being written to, then it is a problem

	
	--- --- fixme 
	--- eq piece(1 &Nat unknown(N:Nat), 1),,piece(1 &Nat unknown(N:Nat) >>Nat 1, 1),,piece(1 &Nat unknown(N:Nat) >>Nat 1 >>Nat 1, 1),,piece(1 &Nat unknown(N:Nat) >>Nat 1 >>Nat 1 >>Nat 1, 1),,piece(1 &Nat unknown(N:Nat) >>Nat 1 >>Nat 1 >>Nat 1 >>Nat 1, 1),,piece(1 &Nat unknown(N:Nat) >>Nat 1 >>Nat 1 >>Nat 1 >>Nat 1 >>Nat 1, 1),,piece(1 &Nat unknown(N:Nat) >>Nat 1 >>Nat 1 >>Nat 1 >>Nat 1 >>Nat 1 >>Nat 1, 1),,piece(1 &Nat unknown(N:Nat) >>Nat 1 >>Nat 1 >>Nat 1 >>Nat 1 >>Nat 1 >>Nat 1 >>Nat 1, 1) = piece(unknown(N:Nat), 8) .
		
	--- --- fixme it's interesting we need this.  what do the rules say about when string allocation happens?
	--- op dontCountWrite : Nat -> K .
	--- mb rule
		--- < k > [dontCountWrite(Loc:Nat) => .K] ...</ k >
		--- < locsWrittenTo >... [BagItem(Loc:Nat) => .Bag] ...</ locsWrittenTo >
		--- : KSentence [metadata "structural"] .
		
	op writeString : Nat String -> K .
	mb [alloc-string]: rule
		< k > allocString(Loc:Nat, S:String)
			=> allocateType(Loc:Nat, arrayType(char, lengthString(S:String)))
			~> writeString(Loc:Nat, S:String)
		...</ k >
		: KSentence [metadata "structural"] .
		
	mb [write-string]: rule
		< k > writeString(Loc:Nat, S:String)
			=> *(tv(Loc:Nat, pointerType(char))) := tv(charToAscii(firstChar(S:String)), char)
			~> discard
			~> writeString(sNat(Loc:Nat), butFirstChar(S:String))
		...</ k >
		if S:String =/=Bool ""
		: KSentence [metadata "structural"] .
		
	mb [write-empty-string]: rule
		< k > writeString(Loc:Nat, "") 
			=> (.).K --- *(tv(Loc:Nat, pointerType(char))) := tv(0, char) 
			--- ~> discard
		...</ k >
		: KSentence [metadata "structural"] .
	--- mb [alloc-string]: rule
		--- < k > [allocString(Loc:Nat, S:String) => putByteInMem(Loc:Nat, charToAscii(firstChar(S:String))) ~> dontCountWrite(Loc:Nat) ~> allocString(sNat(Loc:Nat), butFirstChar(S:String))] ...</ k >
		--- if lengthString(S:String) >Int 0
		--- : KSentence [metadata "structural"] .
	
		
	--- --- fixme not enough, need more rules
	--- --- fixme is this backwards?
	--- mb rule
		--- < k > [putBytesInMem(Loc:Nat, (piece(N:Nat, BitLen:Nat),, piece(N':Nat, 1),, L:List{K}), T:Type, tv(sNat(Len:Nat), J:Type)) 
		--- => putBytesInMem(Loc:Nat, (piece((N':Nat <<Nat BitLen:Nat) |Nat N:Nat, sNat(BitLen:Nat)),, L:List{K}), T:Type, tv(sNat(Len:Nat), J:Type))] ...</ k >
		--- if BitLen:Nat <Nat 8
		--- : KSentence [metadata "structural"] .

	--- mb rule
		--- < k > [putBytesInMem(loc(Block:Nat, Offset:Nat), (piece(N:Nat, 8),, L:List{K}), T:Type, tv(sNat(Len:Nat), J:Type)) => putBytesInMem(loc(Block:Nat, sNat(Offset:Nat)), (L:List{K}), T:Type, tv(Len:Nat, J:Type))] ...</ k >
		--- < mem >... Block:Nat |-> memblock(?, [M:Map => M:Map[piece(N:Nat, numBitsPerByte) / Offset:Nat]]) ...</ mem >
		--- < locsWrittenTo > Locs:Bag [.Bag => BagItem(loc(Block:Nat, Offset:Nat))] </ locsWrittenTo >
		--- if notBool(loc(Block:Nat, Offset:Nat) in Locs:Bag)
		--- : KSentence [metadata "structural"] .
	--- mb rule
		--- < k > [putBytesInMem(loc(Block:Nat, Offset:Nat), (F:Float,, L:List{K}), T:Type, tv(sNat(Len:Nat), J:Type)) => putBytesInMem(loc(Block:Nat, sNat(Offset:Nat)), (L:List{K}), T:Type, tv(Len:Nat, J:Type))] ...</ k >
		--- < mem >... Block:Nat |-> memblock(?, [M:Map => M:Map[F:Float / Offset:Nat]]) ...</ mem >
		--- < locsWrittenTo > Locs:Bag [.Bag => BagItem(loc(Block:Nat, Offset:Nat))] </ locsWrittenTo >
		--- if notBool(loc(Block:Nat, Offset:Nat) in Locs:Bag)
		--- : KSentence [metadata "structural"] .
	--- --- fixme
	--- mb rule
		--- < k > [putBytesInMem(loc(Block:Nat, Offset:Nat), (loc(N:Nat, M:Nat),, L:List{K}), T:Type, tv(sNat(Len:Nat), J:Type)) => putBytesInMem(loc(Block:Nat, sNat(Offset:Nat)), (L:List{K}), T:Type, tv(Len:Nat, J:Type))] ...</ k >
		--- < mem >... Block:Nat |-> memblock(?, [M:Map => M:Map[loc(N:Nat, M:Nat) / Offset:Nat]]) ...</ mem >
		--- < locsWrittenTo > Locs:Bag [.Bag => BagItem(loc(Block:Nat, Offset:Nat))] </ locsWrittenTo >
		--- if notBool(loc(Block:Nat, Offset:Nat) in Locs:Bag)
		--- : KSentence [metadata "structural"] .
		
	--- mb rule
		--- < k > [putBytesInMem(Loc:Nat, .List{K}, T:Type, tv(0, ?)) => .K] ...</ k >
		--- : KSentence [metadata "structural"] .
	
	--- op putByteInMem : Nat BaseValue -> K .
	--- op putBitInMem : BaseValue BaseValue -> K .
	--- mb rule
		--- < k > [putInMem(?, ?, ?, tv(0, ?)) => .K] ...</ k >
		--- : KSentence [metadata "structural"] .
		
	--- --- fixme: fixes the type of function types so they are equivalent
	--- mb rule
		--- < k > [putInMem(Loc:Nat, tv(N:Int, pointerType(functionType(T:Type, L:List{K}))), pointerType(functionType(T:Type, L':List{K})), tv(Len:Nat, J:Type)) 
		--- => putInMem(Loc:Nat, tv(N:Int, pointerType(functionType(T:Type, L':List{K}))), pointerType(functionType(T:Type, L':List{K})), tv(Len:Nat, J:Type))] ...</ k >
		--- if L:List{K} =/=Bool L':List{K}
		--- : KSentence [metadata "structural"] .
		
	--- op isLocation : K -> Bool .
	--- eq isLocation(loc(?, ?)) = true .
	--- eq isLocation(bitloc(?, ?, ?)) = true .
	--- eq isLocation(K:K) = false [owise] .
	--- --- needs to make sure not a bitfield
	--- mb rule
		--- < k > [putInMem(loc(Block:Nat, Offset:Nat), tv(N:Int, T:Type), T:Type, tv(sNat(Len:Nat), J:Type)) 
		--- => putByteInMem(loc(Block:Nat, Offset:Nat), ((N:Int %Int 256) +Int 256) %Int 256) ~> putInMem(loc(Block:Nat, sNat(Offset:Nat)), tv(N:Int >>Int 8, T:Type), T:Type, tv(Len:Nat, J:Type))] ...</ k >
		--- if notBool(isLocation(N:Int))
		--- : KSentence [metadata "structural"] .
		
	--- --- fixme can now check oob
	--- mb rule
		--- < k > [putInMem(loc(Block:Nat, Offset:Nat), tv(F:Float, T:Type), T:Type, tv(sNat(Len:Nat), J:Type)) => .K] ...</ k >
		--- < mem >... Block:Nat |-> memblock(?, [M:Map => M:Map[F:Float / Offset:Nat]]) ...</ mem >
		--- < locsWrittenTo > Locs:Bag [.Bag => BagItem(loc(Block:Nat, Offset:Nat))] </ locsWrittenTo >
		--- if notBool(loc(Block:Nat, Offset:Nat) in Locs:Bag)
		--- andBool (
			--- (T:Type ==Bool double)
			--- orBool T:Type ==Bool float
			--- orBool T:Type ==Bool long-double
		--- )
		--- : KSentence [metadata "structural"] .
		
	--- --- fixme: put pointer in memory
	--- mb rule
		--- < k > putInMem(?, [tv(loc(0, 0), T:Type) => tv(0, T:Type)], ?, ?) ...</ k >
		--- : KSentence [metadata "structural"] .
	--- mb rule
		--- < k > [putInMem(loc(Block:Nat, Offset:Nat), tv(loc(Block':Nat, Offset':Nat), T:Type), T:Type, tv(sNat(Len:Nat), J:Type)) => .K] ...</ k >
		--- < mem >... Block:Nat |-> memblock(?, [M:Map => M:Map[loc(Block':Nat, Offset':Nat) / Offset:Nat]]) ...</ mem >
		--- < locsWrittenTo > Locs:Bag [.Bag => BagItem(loc(Block:Nat, Offset:Nat))] </ locsWrittenTo >
		--- if notBool(loc(Block:Nat, Offset:Nat) in Locs:Bag)
		--- andBool notBool(Block':Nat ==Bool 0 andBool Offset':Nat ==Bool 0)
		--- : KSentence [metadata "structural"] .
		
	--- mb rule
		--- < k > [putInMem(bitloc(Block:Nat, Base:Nat, Offset:Nat), tv(N:Int, T:Type), T:Type, tv(sNat(Len:Nat), J:Type))
		--- => putBitInMem(bitloc(Block:Nat, Base:Nat, Offset:Nat), ((N:Int %Int 2) +Int 2) %Int 2) ~> 
		--- putInMem(bitloc(Block:Nat, Base:Nat, sNat(Offset:Nat)), tv(N:Int >>Int 1, T:Type), T:Type, tv(Len:Nat, J:Type))] ...</ k >
		--- if (Offset:Nat <Nat 8)
		--- : KSentence [metadata "structural"] .
	--- mb rule 
		--- < k > [putInMem(bitloc(Block:Nat, Base:Nat, 8), tv(N:Int, T:Type), T:Type, tv(sNat(Len:Nat), J:Type)) 
		--- => putInMem(bitloc(Block:Nat, sNat(Base:Nat), 0), tv(N:Int, T:Type), T:Type, tv(sNat(Len:Nat), J:Type))] ...</ k >
		--- : KSentence [metadata "structural"] .
	
	--- mb rule
		--- < k > [putByteInMem(loc(Block:Nat, Offset:Nat), N:Nat) => .K] ...</ k >
		--- < mem >... Block:Nat |-> memblock(Len:Nat, [M:Map => M:Map[piece(N:Nat, 8) / Offset:Nat]]) ...</ mem >
		--- < locsWrittenTo > Locs:Bag [.Bag => BagItem(loc(Block:Nat, Offset:Nat))] </ locsWrittenTo >
		--- if notBool(loc(Block:Nat, Offset:Nat) in Locs:Bag)
		--- : KSentence [metadata "structural"] .
	--- --- this helps be fast, but is unsafe
	--- --- mb rule
		--- --- < k > [putByteInMem(Loc:Nat, N:Nat) => .K] ...</ k >
		--- --- < mem > [M:Map => M:Map[piece(N:Nat, 8) / Loc:Nat]] </ mem >
		--- --- : KSentence [metadata "structural"] .
	--- --- fixme need better fidelity; shouldn't zero out bits
	--- --- fixme also need to handle the case where it's already unknown
	--- mb rule 
		--- < k > putBitInMem(bitloc(Block:Nat, Base:Nat, ?), ?) ...</ k >
		--- < mem >... Block:Nat |-> memblock(?, [M:Map => M:Map[piece(0, numBitsPerByte) / Base:Nat]]) ...</ mem >
		--- if notBool($hasMapping(M:Map, Base:Nat))
		--- : KSentence [metadata "structural"] .
	--- op known : Nat -> Bool .
	--- eq known(unknown(?)) = false .
	--- eq known(?) = true [owise] .
	--- --- fixme not handling undefined writing twice in a sequence point 
	--- mb rule
		--- < k > [putBitInMem(bitloc(Block:Nat, Base:Nat, Offset:Nat), N:Nat) => .K] ...</ k >
		--- < mem >... Block:Nat |-> memblock(?, 
			--- (? Base:Nat |-> [piece(Old:Nat, 8) => 
				--- piece((Old:Nat &Nat ((1 <<Nat Offset:Nat) xorNat 255)) |Nat (N:Nat <<Nat Offset:Nat), 8)
			--- ])
		--- ) ...</ mem >
		--- if known(Old:Nat)
		--- : KSentence [metadata "structural"] .
endm

mod COMMON-C-MEMORY is
	including COMMON-MEMORY-INCLUDE .
	including COMMON-C-MEMORY-MISC .
	including COMMON-SEMANTICS-WRITING .
	including COMMON-SEMANTICS-READING .
endm
