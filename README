# Overview

K is an executable semantic framework in which programming languages, calculi,
as well as type systems or formal analysis tools can be defined making use of
configurations, computations and rules.

* *Configurations* organize the system/program state in units called cells,
which are labeled and can be nested.  * *Computations* carry "computational
meaning" as special nested list structures sequentializing computational tasks,
such as fragments of program; in particular, computations extend the original
language or calculus syntax.  * *K (rewrite) rules* generalize conventional
rewrite rules by making it explicit which parts of the term they read-only,
write-only, or do not care about. This distinction makes K a suitable framework
for defining truly concurrent languages or calculi even in the presence of
sharing.

Since computations can be handled like any other terms in a rewriting
environment, that is, they can be matched, moved from one place to another in
the original term, modified, or even deleted, K is particularly suitable for
defining control-intensive language features such as abrupt termination,
exceptions, call/cc, concurrency, etc.

## The K Prototype

The k-framework.googlecode project, also called the "K prototype" from here on,
is a prototype implementation of the K Framework written in Maude and using
Maude to give a rewriting executable semantics to K definitions.

The K prototype is developed by a joint team of faculty and students from
University of Illinois at Urbana-Champaign (the FSL group, led by professor
Grigore Rosu), and University Alexandru Ioan Cuza, Iasi, Romania (the FMSE
group, led by professor Dorel Lucanu).

A current list of the people involved in the project and their specific roles
can be accessed at http://code.google.com/p/k-framework/people/list.


# Installation

For detailed installation instructions, please see the INSTALL file. 

As the tool is still under active development, it is recommended that you
install K directly from the svn repository and update it regularly executing

  svn up && make

from the base directory to benefit of the latest fixes and features.


# Usage

The languages defined so far using the K framework can be found in the examples
directory. For example, the directory

 examples/languages/research/simple 

contains 2 directories, namely "untyped" containing the definition of the
untyped version of the language, and "typed" which in turn contains three
directories with definitions: "static", for the static semantics, i.e., the type
checker; "dynamic", for the dynamically typed version of simple; and
"dynamic-typed-locations" which is a variant of dynamic, in which the type
information is maintained in the environment.

We encourage you to contribute with examples to our distribution.  Please see
examples/README for instructions on how to do it.

## When writing new definitions

It is recommended that the name of the main module of a definition is the
capitalized version of the name of the file containing it.

When adding new rules to a definition, keep in mind the following important
restrictions: (1) avoid defining multiple constructs with the same name, except
for the case below; (2) in rules, any construct should be applied on terms of
the syntactic types the construct was declared to accept (that is, no subterm
appearing in any rule should parse to a kind); if desired, overload the
operations to extend their range.

To compile a definition: execute the `kompile` script passing as parameter the
name of the file containing the main module.  If the compilation succeeds, the
output would be placed in name-of-the-file-compiled.maude. Currently, the script
has only been tested on Unix-like systems, including MacOSX.

Recommendations on running the script: * The Maude executable should be on the
path and should be named `maude`; moreover, the environment variable `MAUDE_LIB`
should point to the location where `prelude.maude` resides * The `kompile`
script should also be on the path * The `kompile` script should not be moved
from the `core` directory * The `kompile` script should be run from the
directory where the definition resides.

Assuming the above suggestions were followed, to compile the untyped version of
the simple language mentioned above, execute

  kompile simple-untyped

in the `examples/research/simple/untyped` directory.


# How It Works

We recommend the K overview paper

  An overview of the K semantic framework Grigore Rosu, Traian-Florin Serbanuta
Journal of Logic and Algebraic Programming, Volume 79(6), pp 397-434. 2010
http://dx.doi.org/10.1016/j.jlap.2010.03.012

for a broader understanding of K.  Here we only discuss how our current K
prototype works, reminding the reader important facts about K in general on a
by-need basis.

In order to actually interpret or analyze programs using a semantics written in
K, there needs to be a way to give the programs to the tool.  Currently, the
tool uses the syntax module of a definition to generate a parser for that
definition which can be used to parse programs and turn them into their
corresponding K AST format.  We briefly outline the process below.

(For examples, see the language examples in the /examples directory; in
particular, /examples/languages/research/simple/untyped is familiar and
well-documented.)

## Parsing Programs

You may prefer to first define the syntax and then the semantics.  That is how
most of the languages in the examples directory are defined.  This reduces
ambiguities in the parser and therefore might be able to parse more programs.
For example, suppose that we want to define a language LANGUAGE and that we have
already defined its syntax in a module LANGUAGE-SYNTAX.  Before even attempting
to define the semantics, it is a good idea to test the syntax by parsing a large
variety of programs.

In the examples provided with the tool, programs are in general kept into a
`programs` directory in the directory containing the syntax definition.  Their
extension is usually an indicator of the definition they belong to.  For
example, the /examples/languages/research/simple/untyped/programs contains
programs for the simple-untyped definition, among which `factorial.simple` looks
like this:

      var x; function f(y) { var t=1; for i = 1 to y do t = t*i; return t; }
function main() { x = 5; write(f(x)); }

If you would like to know more about how to get an external parser to work with
K, please contact us at info@k-framework.org .

As explained in the overview paper mentioned above, the entire language syntax
is automatically included as constructors for the builtin sort K of computation
structures, or simply just computations.  Recall (see the same paper) that
syntax plays no special role in K; that is, the application of the semantic
rules takes into account only the structure of the configuration, and not how
the particular current program or fragment of program is parsed.  That means, in
particular, that the distinction between concrete/abstract syntax and its
representation as computations of sort K is irrelevant in the theory of K.
However, it becomes quite relevant in implementations of K tools, because we
want to use the defined language syntax as much as possible in the semantics,
which means that we need to combine a parser for the defined language with a
parser for K in order to parse the semantic rules, which is a non-trivial
engineering endeavor.

In our current implementation of K, the internal representation of the syntactic
terms follows the simple abstract-syntax-tree (AST) syntax:

  K ::= KLabel(List{K})

List{K} is a non-terminal standing for lists of K terms separated by
double-comma ",," (we chose double-comma to avoid conflicts with user-defined
language syntax, for example comma).  We use ".List{K}" for the unit of List{K}.
This way, from an internal representation point of view, a language syntax is
nothing but a finite set of KLabel constants.  The `kast` program can be used to
parse a program and see its K ast form.  By running

  kast -lang simple-untyped programs/factorial.simple

one obtains the folowing internal representation of the above program:

  '__('var_;('_`,_(# #id_("x")(.List{K}),,'.List`{","`}(.List{K}))),,
'__('function_`(_`)_(# #id_("f")(.List{K}),,'_`,_(# #id_("y")(.List{K}),,
'.List`{","`}(.List{K})),,'`{_`}('__('var_;('_`,_('_=_(# #id_("t")(.List{K}),,
  # 1(.List{K})),,'.List`{","`}(.List{K}))),,'__('`{_`}('__('var_;('_`,_(
  # #id_("i")(.List{K}),,'.List`{","`}(.List{K}))),,'__('_;('_=_(# #id_("i")(
  .List{K}),,# 1(.List{K}))),,'while_do_('_<=_(# #id_("i")(.List{K}),,
  # #id_("y")(.List{K})),,'`{_`}('__('_;('_=_(# #id_("t")(.List{K}),,'_*_(
  # #id_("t")(.List{K}),,# #id_("i")(.List{K})))),,'_;('_=_(# #id_("i")(
  .List{K}),,'_+_(# #id_("i")(.List{K}),,# 1(.List{K})))))))))),,'return_;(
  # #id_("t")(.List{K})))))),,'function_`(_`)_(# #id_("main")(.List{K}),,
  '.List`{","`}(.List{K}),,'`{_`}('__('_;('_=_(# #id_("x")(.List{K}),,# 5(
.List{K}))),,'write`(_`);('_`(_`)(# #id_("f")(.List{K}),,'_`,_('_`(_`)(
  # #id_("f")(.List{K}),,'_`,_(# #id_("x")(.List{K}),,'.List`{","`}(
  .List{K}))),,'.List`{","`}(.List{K})))))))))

Our current implementation allows you to use either concrete syntax or abstract
syntax (as above) in your semantic rules.  We typically prefer the concrete
syntax, but you may need to use the abstract syntax instead when your syntax
confuses our current (simplistic) parser.  

## Running Programs

The `krun` tool can be used to execute programs, or explore their behaviors.
What the `krun` tool basically does is (1) to put the internal representation of
the program in the initial configuration described in the definition; (2) to
call the rewrite engine to execute the program b rewriting the thus obtained
initial configuration; and (3) to post-process the output of the rewrite engine
and display it in a more appealing format.

The idea now is that we can use the K tool to compile LANGUAGE, and then use
`krun` to execute the program using the semantics.  To run our sample program
`factorial`, all we need to do is something like this:

  $ kompile simple-untyped.k $ krun programs/factorial.simple 120


If, instead, one wants to search for all possible final states which could be
obtained upon running the program, then one would need to use the command

  $ krun programs/factorial.simple

And we get the result:

  Solution 1, state 891: Final:Bag --> < T > < out > ListItem(Int 120(.List{K}))
</ out > ... </ T >

  No more solutions.  states: 28416 rewrites: 224454 in 3093ms cpu (3095ms real)
(72555 rewrites/second)

Similarly, if you want to model check a non-deterministic or concurrent program,
then you can use Maude's builtin LTL model-checker.  In order to do that, you
need to define state predicates (or better say configuration predicates).  This
is a bit technical but it follows Maude's approach ad literam, so we do not
explain it here.  The reader is refered to Maude's manual for more information
on how to use its LTL model-checker, and again to simple/untyped for an example
(showing how to model-check Dekker's algorithm).

Important note: when defining programming languages with concurrency and/or with
constructs evaluating their arguments in non-deterministic order, the
state-space to be searched can be huge.  To reduce the state-space, you can
limit the amount of non-determinism by saying explicitly which rules you want to
count as transitions, which operations should start superheating the
computation, and which should cool down the computation to enable a different
expression to be scheduled for evaluation.  This is done by associating tags to
rules or operations, and then kompiling the definition with certain options
stating which tags count as transitions and which as non-deterministic steps.
See, again, the simple/untyped example (the Makefile shows the kompile options).


# Reporting Issues/Bugs/Feature requests

Please report issues here: http://k-framework.googlecode.com, under "issues".
Simply post your test case and briefly explain your problem.  If you have write
permissions to our repository, please also add a test case to the repository
yourself using the directions in "tests/issues/README" (do this in addition to
posting an issue, because you need the issue number).
