load a.out
--- load ../../../model-checker
mod MODEL-CHECK-TEST is
	including C-program-linked .
	including PL-MODEL-CHECKER .
	op modelBag : -> Bag .
	eq modelBag = eval(linked-program, String "a.out"(.List{K}), "") .
	op Start : -> Model-Checker-State .
	op state : Bag -> Model-Checker-State .
	eq Start = state(modelBag) .
	
	op set : Id -> Prop .
	eq state(
		B0:Bag
		< T > 
			B1:Bag
			< genv > 
				M0:Map
				Id X:Id(.List{K}) |-> Loc:K
			</ genv >
			< mem > 
				M1:Map  
				Loc:K |-> Rat piece(1, 8)(.List{K})
			</ mem >
		</ T >	
	) |= set(X:Id) = true .
	
	op enabled : Id -> Prop .
	eq state(
		B0:Bag
		< T > 
			B1:Bag
			< threads >
				B2:Bag
				< thread >
					B3:Bag
					< k > 'Apply('Closure(Id X:Id(.List{K}),, K0:K,, K1:K),, K3:K) ~> K:K </ k >
				</ thread >
			</ threads >
		</ T >
	) |= enabled(X:Id) = true .
	--- 'Apply('Closure(Id critical2(.List{K}),, K0:K,, K1:K),, K3:K) ~> K:K
	
	op finishWith : Nat -> Prop .
	eq state(
		B0:Bag
		< resultValue > 'tv(Rat N:Nat(.List{K}),, Base-Type int(.List{K})) </ resultValue >	
	) |= finishWith(N:Nat) = true .

endm
---search modelBag =>! B:Bag . --- mutual exclusion and no deadlock
--- red modelCheck(Start, <> (set(done1) /\ set(done2))) .
--- red modelCheck(Start, <> (set(done1) )) .
--- red modelCheck(Start, <> enabled(critical)) .
 ---red modelCheck(Start, <> enabled(dekker1)) .
red modelCheck(Start, [] ~ (enabled(critical1) /\ enabled(critical2))) .
--- red modelCheck(Start, [] ~ (enabled(dekker1) /\ enabled(dekker2))) .
---red modelCheck(Start, (<> enabled(task1) /\ <> enabled(task2))) .
--- red modelCheck(Start, <> finishWith(10)) .
---red modelCheck(Start, (<> enabled(dekker1) /\ <> enabled(dekker2)) -> (<> enabled(critical1) /\ <> enabled(critical2))) .



q



***(
< threads > 
  < thread > 
   < k > ('Apply).KProperLabel(('Closure).KResultLabel(Id task1(.List{K}),,(
    'functionType).KResultLabel(Base-Type void(.List{K}),,kList("wklist_")((
    'typedParameterList).KResultLabel(kList("wklist_")(.List{K})))),,(
    'Block).KProperLabel(('_;).KProperLabel(('Apply).KProperLabel(Id printf(
    .List{K}),,('_.`,._).KHybridLabel(String "Starting task1\n"(.List{K})))) ~>
    ('_;).KProperLabel(('Apply).KProperLabel(Id dekker1(.List{K}),,(
    '_.`,._).KHybridLabel(.List{K}))) ~> ('_;).KProperLabel((
    '_:=_).KProperLabel(Id done1(.List{K}),,Rat 1(.List{K}))) ~> (
    'return`;).KProperLabel(.List{K}))),,('_.`,._).KHybridLabel(.List{K})) ~>
    freezer("(_;).KProperLabel(`[HOLE`]:K)")(.List{K}) </ k > 
   < currentFunction > Id main(.List{K}) </ currentFunction > 
   < callStack > .List </ callStack > 
   < loopStack > .List </ loopStack > 
   < locals > range(157, 161) range(161, 165) range(165, 169) </ locals > 
   < env > 
   
   
   
  < thread > 
   < k > ('Apply).KProperLabel(('Closure).KResultLabel(Id task2(.List{K}),,(
    'functionType).KResultLabel(Base-Type void(.List{K}),,kList("wklist_")((
    'typedParameterList).KResultLabel(kList("wklist_")(.List{K})))),,(
    'Block).KProperLabel(('_;).KProperLabel(('Apply).KProperLabel(Id printf(
    .List{K}),,('_.`,._).KHybridLabel(String "Starting task2\n"(.List{K})))) ~>
    ('_;).KProperLabel(('Apply).KProperLabel(Id dekker2(.List{K}),,(
    '_.`,._).KHybridLabel(.List{K}))) ~> ('_;).KProperLabel((
    '_:=_).KProperLabel(Id done2(.List{K}),,Rat 1(.List{K}))) ~> (
    'return`;).KProperLabel(.List{K}))),,('_.`,._).KHybridLabel(.List{K})) ~>
    freezer("(_;).KProperLabel(`[HOLE`]:K)")(.List{K}) </ k > 
   < currentFunction > Id main(.List{K}) </ currentFunction > 
   < callStack > .List </ callStack > 
   < loopStack > .List </ loopStack > 
   < locals > range(157, 161) range(161, 165) range(165, 169) </ locals > 
   < env > 
 ***)