mod COMMON-SEMANTICS-EXPRESSIONS-INCLUDE is
	including COMMON-INCLUDE .
	op assign : K K -> K .
endm

mod COMMON-SEMANTICS-BOOLEAN is
	including COMMON-INCLUDE .
	
	mb rule
		< k > tv(0, ?) || E:Expression => sequencePoint ~> E:Expression ? tv(1, int) : tv(0, int) ...</ k >
		: KSentence [metadata "structural"] .
	mb rule
		< k > tv(N:Nat, ?) || E:Expression => sequencePoint ~> tv(1, int) ...</ k >
		if N:Nat =/=Bool 0
		: KSentence [metadata "structural"] .
		
	mb rule
		< k > tv(0, ?) && E:Expression => sequencePoint ~> tv(0, int) ...</ k >
		: KSentence [metadata "structural"] .
	mb rule
		< k > tv(N:Nat, ?) && E:Expression => sequencePoint ~> E:Expression ? tv(1, int) : tv(0, int)  ...</ k >
		if N:Nat =/=Bool 0
		: KSentence [metadata "structural"] .
	
	--- FIXME the types of these results are wrong.  The correct behavior is quite complicated.  see 6.5.15
	mb rule
		< k > tv(N:Nat, ?) ? E1:Expression : E2:Expression => sequencePoint ~> E1:Expression ...</ k >
		if N:Nat =/=Bool 0
		: KSentence [metadata "structural"] .
		
	mb rule
		< k > tv(0, ?) ? E1:Expression : E2:Expression => sequencePoint ~> E2:Expression ...</ k >
		: KSentence [metadata "structural"] .
	
	mb rule !(tv(V:BaseValue, ?)) => tv(0, int)
		if V:BaseValue =/=Bool 0
		: KSentence [metadata "structural"] .
	mb rule !(tv(V:BaseValue, ?)) => tv(1, int)
		if (V:BaseValue ==Bool 0)
		: KSentence [metadata "structural"] .
		
	
	--- mb rule [!(tv(F:Float, T:Type)) => if (F:Float ==Bool 0.0) then tv(1, int) else tv(0, int) fi] : KSentence [metadata "structural"] .
		
endm

mod COMMON-SEMANTICS-SIZEOF is
	including COMMON-INCLUDE .
	
	eq sizeofType(T:Type) = cast(cfg:sizeut, byteSizeofType(T:Type)) .
	op byteSizeofTypeAux : K -> K [metadata "strict"] .
	eq byteSizeofType(T:Type) = byteSizeofTypeAux(bitSizeofType(T:Type)) .
	ceq byteSizeofTypeAux(tv(N:Nat, T:Type)) = tv(bitsToBytes(N:Nat), T:Type)
		if T:Type ==Bool cfg:largestUnsigned .


	
	--- tv(byteSizeofType(T:Type), cfg:sizeut) .
	
	mb rule
		< k > SizeofExpression(E:Expression) => sizeofType(typeof(E:Expression)) ...</ k >
		: KSentence [metadata "structural"] .
	mb rule
		< k > SizeofType(T:Type, K:K) => sizeofType(DeclType(T:Type, K:K)) ...</ k >
		: KSentence [metadata "structural"] .
		
	--- mb rule
		--- < k > sizeofExp(E:Expression) => sizeofType(typeof(E:Expression)) ...</ k >
		--- : KSentence [metadata "structural"] .
	
	op bitSizeofList : List{Type} -> K .
	eq bitSizeofList(T:Type :: L:List{Type}) = bitSizeofType(T:Type) + bitSizeofList(L:List{Type}) .
	eq bitSizeofList(Nil) = 0 .
	
	op maxBitSizeofList : List{Type} -> K .
	op maxBitSizeofList-aux : List{Type} Nat -> K .
	eq maxBitSizeofList(L:List{Type}) = maxBitSizeofList-aux(L:List{Type}, 0) .
	mb rule
		< k > maxBitSizeofList-aux(T:Type :: L:List{Type}, N:Nat) 
			=> bitSizeofType(T:Type) ~> maxBitSizeofList-aux(L:List{Type}, N:Nat) 
		...</ k >
		: KSentence .
	mb rule
		< k > (tv(N':Nat, ?) => .) ~> maxBitSizeofList-aux(L:List{Type}, (N:Nat => maxNat(N:Nat, N':Nat))) ...</ k >
		: KSentence .
	mb rule
		< k > maxBitSizeofList-aux(Nil, N:Nat) => N:Nat ...</ k >
		: KSentence .
	
	eq bitSizeofType(arrayType(T:Type, N:Nat)) = bitSizeofType(T:Type) * N:Nat .
	eq bitSizeofType(flexibleArrayType(T:Type)) = 0 .
	eq bitSizeofType(functionType(?, ?)) = numBitsPerByte .
	eq bitSizeofType(T:BaseType) = numBits(T:BaseType) .
	eq bitSizeofType(pointerType(?)) = cfg:ptrsize *Nat numBitsPerByte .
	eq bitSizeofType(typedDeclaration(T:Type, ?)) = bitSizeofType(T:Type) .
	eq bitSizeofType(bitfieldType(?, N:Nat)) = N:Nat .
	eq bitSizeofType(qualifiedType(T:Type, ?)) = bitSizeofType(T:Type) .
	mb rule
		< k > bitSizeofType(structType(X:Id)) => bitSizeofList(L:List{Type}) ...</ k >
		< structs >... X:Id |-> L:List{Type} ...</ structs >
		: KSentence .
	mb rule
		< k > bitSizeofType(unionType(X:Id)) => maxBitSizeofList(L:List{Type}) ...</ k >
		< structs >... X:Id |-> L:List{Type} ...</ structs >
		: KSentence .

	--- mb rule 
		--- sizeofType(bitfieldType(T:Type, N:Nat)) => N:Nat /Rat 8
		--- : KSentence [metadata "structural"] .
	--- fixme not really, but used for allocating functions
	
	
	--- ---C99 6.2.6.1:26 ... Each unqualified type has several qualified versions of its type,40) corresponding to the combinations of one, two, or all three of the const, volatile, and restrict qualifiers. The qualified or unqualified versions of a type are distinct types that belong to the same type category and have the same representation and alignment requirements. ...
	--- eq sizeofType(qualifiedType(T:Type, ?)) = sizeofType(T:Type) .	

	--- --- fixme 6.4.4.2 and other
	--- mb [sizeof-struct]: rule
		--- < k > [sizeofType(structType(X:Id)) => calcStructSize(L:List{KResult})] ...</ k >
		--- < structs >... struct(X:Id) |-> L:List{KResult} ...</ structs >
	--- : KSentence [metadata "structural"] .
	--- mb [sizeof-union]: rule
		--- < k > [sizeofType(unionType(X:Id)) => calcUnionSize(L:List{KResult})] ...</ k >
		--- < structs >... union(X:Id) |-> L:List{KResult} ...</ structs >
	--- : KSentence [metadata "structural"] .
	--- mb [sizeof-enum]: rule
		--- < k > [sizeofType(enumType(X:Id)) => tv(1, cfg:sizeut)] ...</ k >
	--- : KSentence [metadata "structural"] .
endm

mod COMMON-SEMANTICS-IDENTIFIERS is
	including COMMON-SEMANTICS-EXPRESSIONS-INCLUDE .
	
	--- 6.3.2.2 Except when it is the operand of the sizeof operator, the unary & operator, the ++ operator, the -- operator, or the left operand of the . operator or an assignment operator, an lvalue that does not have an array type is converted to the value stored in the designated object (and is no longer an lvalue).


	--- generic lookup
	mb [lookup]: rule
		< k > X:Id => read(Loc:Nat, T:Type) ...</ k >
		< env >... X:Id |-> Loc:Nat ...</ env >
		< types >... X:Id |-> T:Type ...</ types >
		if notBool(hasArrayType(T:Type)) andBool notBool(hasFunctionType(T:Type))
		: KSentence [metadata "structural"] . --- nondet
		
	---C99 6.3.2.1:3 Except when it is the operand of the sizeof operator or the unary & operator, or is a string literal used to initialize an array, an expression that has type "array of type" is converted to an expression with type "pointer to type" that points to the initial element of the array object and is not an lvalue. If the array object has register storage class, the behavior is undefined.
	mb [lookup-array]: rule
		< k > X:Id => tv(Loc:Nat, pointerType(T:Type)) ...</ k >
		< env >... X:Id |-> Loc:Nat ...</ env >
		< types >... X:Id |-> arrayType(T:Type, ?) ...</ types >
		: KSentence [metadata "structural"] .
		
	---C99 6.3.2.1:4 A function designator is an expression that has function type.  Except when it is the operand of the sizeof operator or the unary & operator, a function designator with type "function returning T" is converted to an expression that has type "pointer to a function returning T"
	mb [lookup-closure]: rule
		< k > X:Id => tv(Loc:Nat, pointerType(functionType(T:Type, L:List{Type}))) ...</ k >
		< env >... X:Id |-> Loc:Nat ...</ env >
		< types >... X:Id |-> functionType(T:Type, L:List{Type}) ...</ types >
		: KSentence [metadata "structural"] .
endm

mod COMMON-SEMANTICS-FUNCTION-CALLS is
	including COMMON-SEMANTICS-EXPRESSIONS-INCLUDE .

	--- mb context application(?, (?,, `[HOLE`]:K,, ?)) : KSentence .
	--- ---mb context application(`[HOLE`]:K, ?) : KSentence .
	
	--- mb rule
		--- < k > [Apply(E:Expression, L:List{Expression}) => application(E:Expression, getList{K}(L:List{Expression}))] ...</ k >
		--- : KSentence [metadata "structural"] .
	
	
	--- mb [function-application-pre]: rule
		--- < k > Call(tv(Loc:Nat, pointerType(T:Type)), L:List{C}) => application(read(Loc:Nat, T:Type), L:List{C}) ...</ k >
		--- if hasFunctionType(T:Type)
		--- : KSentence [metadata "computational rule"] .
	mb [function-application-pre]: rule
		< k > Call(tv(Loc:Nat, pointerType(T:Type)), L:List{C}) => application(readFunction(Loc:Nat), L:List{C}) ...</ k >
		if hasFunctionType(T:Type)
		: KSentence [metadata "computational rule"] .	

	
	--- --- fixme this is needed until we can pass a list of results to bind
	--- --- mb context bind((?,, `[HOLE`]:K,, ?), ?) : KSentence .
	--- --- needs to be done before call
	op populateFromGlobal : -> K .
	--- fixme: this must be a rule because of the rules associated with declaring local and bound variables
	mb [populateFromGlobal]: rule
		< k > populateFromGlobal => (.).K ...</ k >
		< genv > G:Map </ genv > < env > ? => G:Map </ env >
		< gtypes > GT:Map </ gtypes > < types > ? => GT:Map </ types >
		< gstructs > GS:Map </ gstructs > < structs > ? => GS:Map </ structs >
		: KSentence [metadata "structural"] .
		
	mb [function-application]: rule
		(< control >
			< k > application(functionObject(X:Id, functionType(R:Type, P:List{Type}), B:K), L:List{C}) ~> K:K </ k >
		C:Bag
		</ control >
		=>
		< control >
			< k > sequencePoint ~> populateFromGlobal ~> bind(L:List{C}, P:List{Type}) ~> B:K ~> Return(NothingExpression) </ k >
			< currentFunction > X:Id </ currentFunction >
		...</ control >)
		< callStack > (.).List => List(< stackFrame > C:Bag < continuation > K:K </ continuation > </ stackFrame >) ...</ callStack >
		: KSentence [metadata "computational rule"] . --- nondet
endm

mod COMMON-SEMANTICS-ARRAY-SUBSCRIPTING is
	including COMMON-SEMANTICS-EXPRESSIONS-INCLUDE .
	--- can't be done everywhere because same syntax as in declarations
	mb rule < k > E1:Expression[E2:Expression] => *(E1:Expression + E2:Expression) ...</ k > : KSentence [metadata "structural"] .
endm

mod COMMON-SEMANTICS-LITERALS is
	including COMMON-SEMANTICS-EXPRESSIONS-INCLUDE .
	
	--- +1 for terminating 0
	--- alloc(Loc:Nat, lengthString(S:String) +Nat 1) ~> 
	mb [const-string-notfound]: rule
		< k > (. => allocString(Loc:Nat, S:String +String "\0"))
			~> StringLiteral(S:String)
		...</ k >
		< nextLoc > Loc:Nat => inc(Loc:Nat) </ nextLoc >
		< statics > M:Map (. => S:String |-> tv(Loc:Nat, arrayType(char, lengthString(S:String) +Nat 1))) </ statics >
		if notBool($hasMapping(M:Map, S:String))
		: KSentence [metadata "structural"] .
		
	--- fixme should make type const
	mb [const-string-found]: rule
		< k > StringLiteral(S:String) => tv(N:Nat, pointerType(T:Type)) ...</ k >
		< statics >... S:String |-> tv(N:Nat, arrayType(T:Type, ?)) ...</ statics >
		: KSentence [metadata "structural"] .
	
	---c99 6.4.4.1:5 The type of an integer constant is the first of the corresponding list in which its value can be represented.
***(
											Octal or Hexadecimal 
Suffix			Decimal Constant			Constant
------------------------------------------------------------------
none			int							int
				long int					unsigned int
				long long int				long int
											unsigned long int
											long long int
											unsigned long long int
------------------------------------------------------------------
u or U			unsigned int 				unsigned int
				unsigned long int 			unsigned long int
				unsigned long long int 		unsigned long long int
------------------------------------------------------------------
l or L			long int 					long int
				long long int 				unsigned long int
											long long int
											unsigned long long int
------------------------------------------------------------------
Both u or U		unsigned long int 			unsigned long int
and l or L 		unsigned long long int 		unsigned long long int
------------------------------------------------------------------
ll or LL 		long long int				long long int
											unsigned long long int
------------------------------------------------------------------
Both u or U		unsigned long long int 		unsigned long long int
and ll or LL
------------------------------------------------------------------
***)
	---c99 6.4.4.1:6 If an integer constant cannot be represented by any type in its list, it may have an extended integer type, if the extended integer type can represent its value. If all of the types in the list for the constant are signed, the extended integer type shall be signed. If all of the types in the list for the constant are unsigned, the extended integer type shall be unsigned. If the list contains both signed and unsigned types, the extended integer type may be signed or unsigned. If an integer constant cannot be represented by any type in its list and has no extended integer type, then the integer constant has no type.
	---c99 6.2.5:4 ... There may also be impleme
	
	--- c1x 6.4.4.4:10
	eq CharLiteral(N:Nat) = tv(N:Nat, int) .
	eq IntLiteral(V:Value) = V:Value .
	eq FloatLiteral(V:Value) = V:Value .
	eq Constant(V:Value) = V:Value .
	--- mb rule < k > N:Nat => tv(N:Nat, bignum) ...</ k > : KSentence . --- for internal computations
	mb rule < k > N:Nat => tv(N:Nat, cfg:largestUnsigned) ...</ k > : KSentence . --- for internal computations
	
	--- op createLiteralValue : K -> K .
	--- eq Constant(K:K) = createLiteralValue(K:K) .
	
	mb rule NoSuffix(DecimalConstant(I:Int)) => 
		if ((I:Int <=Int max(int)) andBool (I:Int >=Int min(int))) then tv(I:Int, int) else
		if ((I:Int <=Int max(long-int)) andBool (I:Int >=Int min(long-int))) then tv(I:Int, long-int) else
		if ((I:Int <=Int max(long-long-int)) andBool (I:Int >=Int min(long-long-int))) then tv(I:Int, long-long-int) else 
			tv(I:Int, no-type)
		fi fi fi
		: KSentence [metadata "structural"] .
		
	op simplifyForHex : String -> String .
	ceq simplifyForHex(S:String) = simplifyForHex(butFirstChar(S:String))
		if firstChar(S:String) ==Bool "0"
		andBool lengthString(S:String) >Nat 1 .
	ceq simplifyForHex(S:String) = S:String
		if firstChar(S:String) =/=Bool "0" 
		orBool lengthString(S:String) ==Bool 1 .
		
	eq HexConstant(S:String) = HexConstant(String2Rat(simplifyForHex(S:String), 16)) .
	mb rule NoSuffix(HexConstant(I:Int)) =>
		if ((I:Int <=Int max(int)) andBool (I:Int >=Int min(int))) then tv(I:Int, int) else
		if ((I:Int <=Int max(unsigned-int)) andBool (I:Int >=Int min(unsigned-int))) then tv(I:Int, unsigned-int) else
		if ((I:Int <=Int max(long-int)) andBool (I:Int >=Int min(long-int))) then tv(I:Int, long-int) else
		if ((I:Int <=Int max(unsigned-long-int)) andBool (I:Int >=Int min(unsigned-long-int))) then tv(I:Int, unsigned-long-int) else
		if ((I:Int <=Int max(long-long-int)) andBool (I:Int >=Int min(long-long-int))) then tv(I:Int, long-long-int) else 
		if ((I:Int <=Int max(unsigned-long-long-int)) andBool (I:Int >=Int min(unsigned-long-long-int))) then tv(I:Int, long-long-int) else
			tv(I:Int, no-type)
		fi fi fi fi fi fi
		: KSentence [metadata "structural"] .
		
	mb rule U(DecimalConstant(I:Int)) => 
		if ((I:Int <=Int max(unsigned-int)) andBool (I:Int >=Int min(unsigned-int))) then tv(I:Int, unsigned-int) else
		if ((I:Int <=Int max(unsigned-long-int)) andBool (I:Int >=Int min(unsigned-long-int))) then tv(I:Int, unsigned-long-int) else
		if ((I:Int <=Int max(unsigned-long-long-int)) andBool (I:Int >=Int min(unsigned-long-long-int))) then tv(I:Int, unsigned-long-long-int) else 
			tv(I:Int, no-type)
		fi fi fi
		: KSentence [metadata "structural"] .
	mb rule L(DecimalConstant(I:Int)) => 
		if ((I:Int <=Int max(long-int)) andBool (I:Int >=Int min(long-int))) then tv(I:Int, long-int) else
		if ((I:Int <=Int max(long-long-int)) andBool (I:Int >=Int min(long-long-int))) then tv(I:Int, long-long-int) else
			tv(I:Int, no-type)
		fi fi
		: KSentence [metadata "structural"] .
	mb rule UL(DecimalConstant(I:Int)) => 
		if ((I:Int <=Int max(unsigned-long-int)) andBool (I:Int >=Int min(unsigned-long-int))) then tv(I:Int, unsigned-long-int) else
		if ((I:Int <=Int max(unsigned-long-long-int)) andBool (I:Int >=Int min(unsigned-long-long-int))) then tv(I:Int, unsigned-long-long-int) else
			tv(I:Int, no-type)
		fi fi		
		: KSentence [metadata "structural"] .
	mb rule LL(DecimalConstant(I:Int)) => 
		if ((I:Int <=Int max(long-long-int)) andBool (I:Int >=Int min(long-long-int))) then tv(I:Int, long-long-int) else
			tv(I:Int, no-type)
		fi
		: KSentence [metadata "structural"] .
	mb rule ULL(DecimalConstant(I:Int)) => 
		if ((I:Int <=Int max(unsigned-long-long-int)) andBool (I:Int >=Int min(unsigned-long-long-int))) then tv(I:Int, unsigned-long-long-int) else
			tv(I:Int, no-type)
		fi
		: KSentence [metadata "structural"] .
		
		
	---C99 6.4.4.2:4 An unsuffixed floating constant has type double. If suffixed by the letter f or F, it has type float. If suffixed by the letter l or L, it has type long double.
	mb rule NoSuffix(FloatConstant(F:Float)) => tv(F:Float, double)
		: KSentence [metadata "structural"] .
	mb rule L(FloatConstant(F:Float)) => tv(F:Float, long-double)
		: KSentence [metadata "structural"] .
	mb rule F(FloatConstant(F:Float)) => tv(F:Float, float)
		: KSentence [metadata "structural"] .

endm

mod COMMON-SEMANTICS-ASSIGNMENT is
	including COMMON-SEMANTICS-EXPRESSIONS-INCLUDE .
	
	mb context assign(*([HOLE]), ?) : KSentence .
	mb context assign(?, [HOLE]) : KSentence .
	
	mb [for-assignment]: rule < k > E1:Expression := E2:Expression => assign(*(&(E1:Expression)),  E2:Expression) ...</ k > : KSentence [metadata "structural"] .
	
	--- --- simplify compound assignments (if E1 op= E2, need to ensure E1 only gets evaluated once to be correct)
	--- --- fixme, should not cause side effects to happen twice.  maybe match tv() on lhs
	--- --- 6.5.16
	op compoundAssignment : KLabel K K -> K [metadata "strict(2 3)"] .
	mb rule
		L:KLabel(E1:Expression,, E2:Expression) => compoundAssignment(L:KLabel, &(E1:Expression), E2:Expression)
		if Set(
			l('_*=_),, l('_/=_),, l('_%=_),, l('_+=_),, l('_-=_),, 
			l('_<<=_),, l('_>>=_),, l('_&=_),, l('_^=_),, l('_|=_)
		) contains l(L:KLabel)
		: KSentence [metadata "structural"] .
	
	op getInnerOperator : KLabel -> KLabel .
	mb rule
		< k > compoundAssignment(L:KLabel, V:Value, V':Value) 
			=> *(V:Value) := getInnerOperator(L:KLabel)(*(V:Value),, V':Value) 
		...</ k >
		: KSentence [metadata "structural"] .
		
	eq getInnerOperator('_*=_) = '_*_ .
	eq getInnerOperator('_/=_) = '_/_ .
	eq getInnerOperator('_%=_) = '_%_ .
	eq getInnerOperator('_+=_) = '_+_ .
	eq getInnerOperator('_-=_) = '_-_ .
	
	eq getInnerOperator('_<<=_) = '_<<_ .
	eq getInnerOperator('_>>=_) = '_>>_ .
	eq getInnerOperator('_&=_) = '_&_ .
	eq getInnerOperator('_^=_) = '_^_ .
	eq getInnerOperator('_|=_) = '_|_ .
	
	mb [assign]: rule
		< k > assign(*(tv(Loc:Nat, pointerType(T:Type))), tv(V:List{K}, T:Type)) 
			=> write(Loc:Nat, tv(V:List{K}, T:Type))
			~> tv(V:List{K}, T:Type)
		...</ k >
		: KSentence [metadata "structural"] .
	--- C99 6.5.16.1:2 In simple assignment (=), the value of the right operand is converted to the type of the assignment expression and replaces the value stored in the object designated by the left operand
	mb rule
		< k > assign(*(tv(Loc:Nat, pointerType(T:Type))), (tv(V:List{K}, T':Type) => cast(T:Type, tv(V:List{K}, T':Type))))
		...</ k >
		if T:Type =/=Bool T':Type
		andBool notBool hasArrayType(T:Type)
		: KSentence [metadata "structural"] .
	mb rule
		< k > assign(*(tv(Loc:Nat, pointerType((arrayType(T:Type, ?) => pointerType(T:Type))))), ?)
		...</ k >
		: KSentence [metadata "structural"] .
		
	--- mb [assign-bitfield]: rule
		--- < k > [assign(Deref(tv(bitloc(Block:Nat, N:Nat, O:Nat), pointerType(bitfieldType(T:Type, Len:Nat)))), tv(V:Int, T:Type)) 
		--- => putInMem(bitloc(Block:Nat, N:Nat, O:Nat), tv(V:Int, T:Type), T:Type, tv(Len:Nat, cfg:sizeut)) ~> tv(V:Int, T:Type)] ...</ k >
		--- : KSentence [metadata "structural"] .

	--- --- fixme this is to get around L:List{K} not comparing equal
	--- mb [assign-fp]: rule
		--- < k > [assign(Deref(tv(Loc:Nat, pointerType(pointerType(functionType(T:Type, L:List{K}))))), tv(V:Int, pointerType(functionType(T:Type, L':List{K})))) 
		--- => putInMem(Loc:Nat, tv(V:Int, pointerType(functionType(T:Type, L:List{K}))), pointerType(functionType(T:Type, L:List{K})), sizeofType(pointerType(functionType(T:Type, L:List{K})))) ~> tv(V:Int, pointerType(functionType(T:Type, L:List{K})))] ...</ k >
		--- : KSentence [metadata "structural"] .
		
	--- --- fixme floats might have requirements
	--- mb [assign-double]: rule
		--- < k > [assign(Deref(tv(loc(Block:Nat, Offset:Nat), pointerType(double))), tv(V:Float, double)) 
		--- => tv(V:Float, double)] ...</ k >
		--- < mem >... Block:Nat |-> memblock(?, [M:Map => M:Map[V:Float / Offset:Nat]]) ...</ mem > 
		--- : KSentence [metadata "structural"] .
	--- --- fixme
	--- mb [assign-float]: rule
		--- < k > [assign(Deref(tv(loc(Block:Nat, Offset:Nat), pointerType(float))), tv(V:Float, float)) 
		--- => tv(V:Float, float)] ...</ k >
		--- < mem >... Block:Nat |-> memblock(?, [M:Map => M:Map[V:Float / Offset:Nat]]) ...</ mem > 
		--- : KSentence [metadata "structural"] .
	--- --- fixme
	--- mb [assign-long-double]: rule
		--- < k > [assign(Deref(tv(loc(Block:Nat, Offset:Nat), pointerType(long-double))), tv(V:Float, long-double)) 
		--- => tv(V:Float, long-double)] ...</ k >
		--- < mem >... Block:Nat |-> memblock(?, [M:Map => M:Map[V:Float / Offset:Nat]]) ...</ mem > 
		--- : KSentence [metadata "structural"] .
		
	--- mb [assign-struct]: rule
		--- < k > [assign(Deref(tv(Loc:Nat, pointerType(T:Type))), atv(L:List{K}, T:Type))
		--- => 
		--- putBytesInMem(Loc:Nat, L:List{K}, T:Type, sizeofType(T:Type)) ~> atv(L:List{K},T:Type)] ...</ k >
		--- : KSentence [metadata "structural"] .
endm

mod COMMON-SEMANTICS-BITWISE is
	including COMMON-SEMANTICS-EXPRESSIONS-INCLUDE .
	
	--- --- c99 6.5.7:3 The integer promotions are performed on each of the operands. The type of the result is that of the promoted left operand. If the value of the right operand is negative or is greater than or equal to the width of the promoted left operand, the behavior is undefined.
	--- mb rule [tv(I:Int, T:Type) << tv(N:Nat, T':Type) => leftShiftInterpret(T:Type, I:Int <<Int N:Nat, tv(I:Int, T:Type))] 
		--- if hasIntegerType(T:Type)
		--- andBool hasIntegerType(T':Type)
		--- andBool N:Nat <Int numBits(T:Type)
		--- : KSentence [metadata "structural"] .
	--- mb rule [tv(I:Int, T:Type) >> tv(N:Nat, T':Type) => rightShiftInterpret(T:Type, I:Int >>Int N:Nat)] 
		--- if hasIntegerType(T:Type)
		--- andBool hasIntegerType(T':Type)
		--- andBool N:Nat <Int numBits(T:Type)
		--- : KSentence [metadata "structural"] .
		
	--- --- fixme As best I can tell, these bitwise operations cannot overflow.  I can't figure out where in the standard it says this though.
	--- --- fixme result will be heated and may turn into a different kind of value
	
	--- --- mb rule [tv(I1:Int, T:Type) | tv(I2:Int, T:Type) => cast(T:Type, I1:Int |Int I2:Int)] 
		--- --- if hasIntegerType(T:Type)
		--- --- : KSentence [metadata "structural"] .
	--- --- mb rule [tv(I1:Int, T:Type) &binop tv(I2:Int, T:Type) => cast(T:Type, I1:Int &Int I2:Int)] 
		--- --- if hasIntegerType(T:Type)
		--- --- : KSentence [metadata "structural"] .
	--- --- mb rule [~ tv(I:Int, T:Type) => cast(T:Type, ~Int I:Int)] 
		--- --- if hasIntegerType(T:Type)
		--- --- : KSentence [metadata "structural"] .
	--- --- mb rule [tv(I1:Int, T:Type) ^ tv(I2:Int, T:Type) => cast(T:Type, I1:Int xorInt I2:Int)] 
		--- --- if hasIntegerType(T:Type)
		--- --- : KSentence [metadata "structural"] .
		
	--- --- mb rule [tv(I1:Int, T:Type) | tv(I2:Int, T:Type) => tv(I1:Int |Int I2:Int, T:Type)] 
		--- --- if hasIntegerType(T:Type)
		--- --- : KSentence [metadata "structural"] .
	--- --- mb rule [tv(I1:Int, T:Type) &binop tv(I2:Int, T:Type) => tv(I1:Int &Int I2:Int, T:Type)] 
		--- --- if hasIntegerType(T:Type)
		--- --- : KSentence [metadata "structural"] .
	--- --- mb rule [~ tv(I:Int, T:Type) => tv(~Int I:Int, T:Type)] 
		--- --- if hasIntegerType(T:Type)
		--- --- : KSentence [metadata "structural"] .
	--- --- mb rule [tv(I1:Int, T:Type) ^ tv(I2:Int, T:Type) => tv(I1:Int xorInt I2:Int, T:Type)] 
		--- --- if hasIntegerType(T:Type)
		--- --- : KSentence [metadata "structural"] .
		
	--- mb rule [tv(I1:Int, T:Type) | tv(I2:Int, T:Type) => arithInterpret(T:Type, I1:Int |Int I2:Int)] 
		--- if hasIntegerType(T:Type)
		--- : KSentence [metadata "structural"] .
	--- mb rule [tv(I1:Int, T:Type) &binop tv(I2:Int, T:Type) => arithInterpret(T:Type, I1:Int &Int I2:Int)] 
		--- if hasIntegerType(T:Type)
		--- : KSentence [metadata "structural"] .
	--- mb rule [~ tv(I:Int, T:Type) => arithInterpret(T:Type, ~Int I:Int)] 
		--- if hasIntegerType(T:Type)
		--- : KSentence [metadata "structural"] .
	--- mb rule [tv(I1:Int, T:Type) ^ tv(I2:Int, T:Type) => arithInterpret(T:Type, I1:Int xorInt I2:Int)] 
		--- if hasIntegerType(T:Type)
		--- : KSentence [metadata "structural"] .
endm

mod COMMON-SEMANTICS-BOOLEAN-ARITHMETIC is
	including COMMON-SEMANTICS-EXPRESSIONS-INCLUDE .
	
	--- FIXME should also be promoting these
	mb rule tv(I1:Int, T:Type) < tv(I2:Int, T:Type) => if (I1:Int <Int I2:Int) then tv(1, int) else tv(0, int) fi : KSentence [metadata "structural"] .
	mb rule tv(I1:Int, T:Type) <= tv(I2:Int, T:Type) => if (I1:Int <=Int I2:Int) then tv(1, int) else tv(0, int) fi : KSentence [metadata "structural"] .
	mb rule tv(I1:Int, T:Type) > tv(I2:Int, T:Type) => if (I1:Int >Int I2:Int) then tv(1, int) else tv(0, int) fi : KSentence [metadata "structural"] .
	mb rule tv(I1:Int, T:Type) >= tv(I2:Int, T:Type) => if (I1:Int >=Int I2:Int) then tv(1, int) else tv(0, int) fi : KSentence [metadata "structural"] .
	mb rule tv(I1:Int, T:Type) == tv(I2:Int, T:Type) => if (I1:Int ==Bool I2:Int) then tv(1, int) else tv(0, int) fi : KSentence [metadata "structural"] .
	mb rule tv(I1:Int, T:Type) != tv(I2:Int, T:Type) => if (I1:Int =/=Bool I2:Int) then tv(1, int) else tv(0, int) fi : KSentence [metadata "structural"] .
	
	--- fixme could check 6.5.8:2
	mb rule tv(I1:Int, T:Type) < tv(I2:Int, T':Type) => if (I1:Int <Int I2:Int) then tv(1, int) else tv(0, int) fi 
	if hasPointerType(T:Type) andBool hasPointerType(T':Type)
	: KSentence [metadata "structural"] .
	mb rule tv(I1:Int, T:Type) <= tv(I2:Int, T':Type) => if (I1:Int <=Int I2:Int) then tv(1, int) else tv(0, int) fi 
	if hasPointerType(T:Type) andBool hasPointerType(T':Type)
	: KSentence [metadata "structural"] .
	mb rule tv(I1:Int, T:Type) > tv(I2:Int, T':Type) => if (I1:Int >Int I2:Int) then tv(1, int) else tv(0, int) fi 
	if hasPointerType(T:Type) andBool hasPointerType(T':Type)
	: KSentence [metadata "structural"] .
	mb rule tv(I1:Int, T:Type) >= tv(I2:Int, T':Type) => if (I1:Int >=Int I2:Int) then tv(1, int) else tv(0, int) fi 
	if hasPointerType(T:Type) andBool hasPointerType(T':Type)
	: KSentence [metadata "structural"] .
	mb rule tv(I1:Int, T:Type) == tv(I2:Int, T':Type) => if (I1:Int ==Bool I2:Int) then tv(1, int) else tv(0, int) fi 
	if hasPointerType(T:Type) andBool hasPointerType(T':Type)
	: KSentence [metadata "structural"] .
	mb rule tv(I1:Int, T:Type) != tv(I2:Int, T':Type) => if (I1:Int =/=Bool I2:Int) then tv(1, int) else tv(0, int) fi
	if hasPointerType(T:Type) andBool hasPointerType(T':Type)
	: KSentence [metadata "structural"] .

	--- floats
	mb rule tv(F1:Float, T:Type) < tv(F2:Float, T:Type) => if (F1:Float <Float F2:Float) then tv(1, int) else tv(0, int) fi : KSentence [metadata "structural"] .
	mb rule tv(F1:Float, T:Type) <= tv(F2:Float, T:Type) => if (F1:Float <=Float F2:Float) then tv(1, int) else tv(0, int) fi : KSentence [metadata "structural"] .
	mb rule tv(F1:Float, T:Type) > tv(F2:Float, T:Type) => if (F1:Float >Float F2:Float) then tv(1, int) else tv(0, int) fi : KSentence [metadata "structural"] .
	mb rule tv(F1:Float, T:Type) >= tv(F2:Float, T:Type) => if (F1:Float >=Float F2:Float) then tv(1, int) else tv(0, int) fi : KSentence [metadata "structural"] .
	mb rule tv(F1:Float, T:Type) == tv(F2:Float, T:Type) => if (F1:Float ==Bool F2:Float) then tv(1, int) else tv(0, int) fi : KSentence [metadata "structural"] .
	mb rule tv(F1:Float, T:Type) != tv(F2:Float, T:Type) => if (F1:Float =/=Bool F2:Float) then tv(1, int) else tv(0, int) fi : KSentence [metadata "structural"] .
endm

mod COMMON-SEMANTICS-ARITHMETIC is
	including COMMON-SEMANTICS-EXPRESSIONS-INCLUDE .
		
	--- FIXME needs to check offset > 0 
	mb rule < k > tv(Loc:Nat, pointerType(T':Type)) + tv(I2:Int, T:Type)
				=> cast(pointerType(T':Type), cast(pointerType(unsigned-char), tv(Loc:Nat, pointerType(T':Type))) + (tv(I2:Int, T:Type) * sizeofType(T':Type)))
		...</ k >
		if hasIntegerType(T:Type)
		andBool T':Type =/=Bool void
		andBool T':Type =/=Bool unsigned-char
		: KSentence [metadata "structural"] .
		
	mb rule < k > tv(Loc:Nat, pointerType(unsigned-char)) + tv(I2:Int, T:Type) 
			=> tv(Loc:Nat +Int I2:Int, pointerType(unsigned-char))
		...</ k >
		if hasIntegerType(T:Type)
		: KSentence [metadata "structural"] .
					
	--- op computePointerDifference : Int Int K -> K [metadata "strict(3)"] .
	--- mb [start-pointer-difference]: rule [tv(I1:Int, pointerType(T:Type)) - tv(I2:Int, pointerType(T:Type)) 
		--- => computePointerDifference(I1:Int, I2:Int, sizeofType(T:Type))]
		--- : KSentence [metadata "structural"] .
	--- mb [pointer-difference]: rule [computePointerDifference(loc(Block:Nat, Offset1:Nat), loc(Block:Nat, Offset2:Nat), tv(Size:Nat, ?))
		--- => tv(_-Int_(Offset1:Nat, Offset2:Nat) /Int Size:Nat, cfg:ptrdiffut)]
		--- if _-Int_(Offset1:Nat, Offset2:Nat) %Int Size:Nat ==Bool 0
		--- : KSentence [metadata "structural"] .	
		
	--- fixme these need to be promoted BEFORE doing arithmetic
	mb rule - tv(I:Int, T:Type) => arithInterpret(T:Type, (-Int I:Int))
		if hasIntegerType(T:Type) andBool rank(T:Type) >=Int rank(int)
		: KSentence [metadata "structural"] .
		
	mb rule tv(I1:Int, T:Type) + tv(I2:Int, T:Type) => arithInterpret(T:Type, (I1:Int +Int I2:Int))
		if hasIntegerType(T:Type) andBool rank(T:Type) >=Int rank(int)
		: KSentence [metadata "structural"] .
	mb rule _-_(tv(I1:Int, T:Type), tv(I2:Int, T:Type)) => arithInterpret(T:Type, _-Int_(I1:Int,I2:Int))
		if hasIntegerType(T:Type) andBool rank(T:Type) >=Int rank(int)
		: KSentence [metadata "structural"] .
	mb rule tv(I1:Int, T:Type) * tv(I2:Int, T:Type) => arithInterpret(T:Type, I1:Int *Int I2:Int)
		if hasIntegerType(T:Type) andBool rank(T:Type) >=Int rank(int)
		: KSentence [metadata "structural"] .
	mb rule tv(I1:Int, T:Type) / tv(I2:Int, T:Type) => arithInterpret(T:Type, I1:Int /Int I2:Int) 
		if hasIntegerType(T:Type) andBool rank(T:Type) >=Int rank(int)
		andBool I2:Int =/=Bool 0
		: KSentence [metadata "structural"] .
	mb rule tv(I1:Int, T:Type) % tv(I2:Int, T:Type) => arithInterpret(T:Type, I1:Int %Int I2:Int) 
		if hasIntegerType(T:Type) andBool rank(T:Type) >=Int rank(int)
		andBool I2:Int =/=Bool 0
		: KSentence [metadata "structural"] .
	mb rule - tv(I1:Int, T:Type) => arithInterpret(T:Type, -Int_(I1:Int))
		if hasIntegerType(T:Type) andBool rank(T:Type) >=Int rank(int)
		: KSentence [metadata "structural"] .
	
	--- floats
	--- fixme
	mb rule tv(F1:Float, T:Type) + tv(F2:Float, T:Type) => arithInterpret(T:Type, F1:Float +Float F2:Float) 
		: KSentence [metadata "structural"] .
	mb rule _-_(tv(F1:Float, T:Type), tv(F2:Float, T:Type)) => arithInterpret(T:Type, _-Float_(F1:Float, F2:Float))
		: KSentence [metadata "structural"] .
	mb rule tv(F1:Float, T:Type) * tv(F2:Float, T:Type) => arithInterpret(T:Type, F1:Float *Float F2:Float) 
		: KSentence [metadata "structural"] .
	mb rule tv(F1:Float, T:Type) / tv(F2:Float, T:Type) => arithInterpret(T:Type, F1:Float /Float F2:Float) 
		: KSentence [metadata "structural"] .
	mb rule - tv(F:Float, T:Type) => arithInterpret(T:Type, -Float_(F:Float))
		: KSentence [metadata "structural"] .
		
endm

mod COMMON-SEMANTICS-MEMBERS is 
	including COMMON-SEMANTICS-EXPRESSIONS-INCLUDE .
	
	mb [arrow-struct]: rule
		< k > tv(Base:Int, pointerType(structType(S:Id))) -> F:Id 
			=> *(tv(Base:Int, pointerType(structType(S:Id)))) . F:Id 
		...</ k >
		: KSentence [metadata "structural"] .
	--- mb [arrow-union]: rule
		--- < k > [tv(Base:Int, pointerType(unionType(S:Id))) -> X:Id => Deref(tv(Base:Int, pointerType(unionType(S:Id)))) . X:Id] ...</ k >
		--- : KSentence [metadata "structural"] .

	op toEval : K -> K .
	op toEval-aux : K K -> K [metadata "strict(2)"] .
	
	mb rule
		< k > K:K . F:Id => toEval(K:K . F:Id) ...</ k >
		: KSentence [metadata "structural"] .
	mb rule
		< k > toEval(K:K) => toEval-aux(K:K, typeof(K:K))  ...</ k >
		: KSentence [metadata "structural"] .
		
	mb rule
		< k > toEval-aux(K:K, arrayType(T:Type, N:Nat)) => &(K:K) ...</ k >
		: KSentence [metadata "structural"] .
	op toEval-value : K -> K .
	mb context toEval-value(`[HOLE`]:K . ?) : KSentence .
	mb rule
		< k > toEval-aux(K:K, T:Type) => toEval-value(K:K) ...</ k >
		if notBool hasArrayType(T:Type)
		: KSentence [metadata "structural"] .	
	mb rule
		< k > toEval-value(tv(L:List{K}, T:Type) . F:Id)
			=> extractField(L:List{K}, T:Type, F:Id) 
		...</ k >
		: KSentence [metadata "structural"] .	

	--- mb rule
		--- < k > toEval-aux(tv(L:List{K}, structType(S:Id)) . F:Id, T:Type)
			--- => extractField(L:List{K}, T:Type, F:Id) 
		--- ...</ k >
		--- --- if notBool hasArrayType(T:Type)
		--- : KSentence [metadata "structural"] .		
		
	--- mb rule
		--- < k > toEval-aux(V:Value . F:Id, T:Type) => K:K ...</ k >
		--- if notBool hasArrayType(T:Type)
		--- : KSentence [metadata "structural"] .

	--- op dot-aux : K Id K -> K [metadata "strict(3)"] .
	--- mb rule
		--- < k > [(E:Expression . F:Id) => dot-aux(E:Expression, F:Id, typeof(E:Expression . F:Id))] ...</ k >
		--- : KSentence [metadata "structural"] .
	--- mb rule
		--- < k > [dot-aux(E:Expression, F:Id, arrayType(?, ?)) => &(E:Expression . F:Id)] ...</ k >
		--- : KSentence [metadata "structural"] .
	--- mb rule
		--- < k > [dot-aux(E:Expression, F:Id, T:Base-Type) => E:Expression ~> dot-aux(HOLE, F:Id, T:Base-Type)] ...</ k >
		--- : KSentence [metadata "structural"] .
	--- mb rule
		--- < k > [dot-aux(E:Expression, F:Id, pointerType(T:Type)) => E:Expression ~> dot-aux(HOLE, F:Id, pointerType(T:Type))] ...</ k >
		--- : KSentence [metadata "structural"] .
	--- --- fixme is this right?  not tested
	--- mb rule
		--- < k > [dot-aux(E:Expression, F:Id, structType(X:Id)) => E:Expression ~> dot-aux(HOLE, F:Id, structType(X:Id))] ...</ k >
		--- : KSentence [metadata "structural"] .
	--- mb rule
		--- < k > [dot-aux(E:Expression, F:Id, unionType(X:Id)) => E:Expression ~> dot-aux(HOLE, F:Id, unionType(X:Id))] ...</ k >
		--- : KSentence [metadata "structural"] .
	--- mb rule
		--- < k > [dot-aux(E:Expression, F:Id, bitfieldType(T:Type, N:Nat)) => E:Expression ~> dot-aux(HOLE, F:Id, bitfieldType(T:Type, N:Nat))] ...</ k >
		--- : KSentence [metadata "structural"] .
		
	--- mb rule
		--- < k > [atv(L:List{K}, T:Type) ~> dot-aux(HOLE, F:Id, ?) => extractField(L:List{K}, T:Type, F:Id)] ...</ k >
		--- : KSentence [metadata "structural"] .	
					
	--- ---C99 6.5.2.3:4 86) If &E is a valid pointer expression (where & is the "address-of" operator, which generates a pointer to its operand), the expression (&E)->MOS is the same as E.MOS.
		
  	--- ---C99 6.5.2.3:4 86) If &E is a valid pointer expression (where & is the "address-of" operator, which generates a pointer to its operand), the expression (&E)->MOS is the same as E.MOS.
endm

mod COMMON-SEMANTICS-DEREFERENCE is
	including COMMON-SEMANTICS-EXPRESSIONS-INCLUDE .
	
	---C99 6.5.3.2:4 The unary * operator denotes indirection. If the operand points to a function, the result is a function designator; if it points to an object, the result is an lvalue designating the object. If the operand has type "pointer to type", the result has type "type". If an invalid value has been assigned to the pointer, the behavior of the unary * operator is undefined.
	--- also see 6.3.2.1:3 for why i made the result a pointerType
	---- fixme this seems wrong
	--- mb rule < k > *(tv(Loc:Nat, pointerType(arrayType(T:Type, N:Nat)))) => tv(Loc:Nat, pointerType(T:Type)) ...</ k > : KSentence [metadata "structural"] .
	
	--- fixme these are both pretty fishy
	mb rule < k > *(tv(Loc:Nat, pointerType(arrayType(T:Type, N:Nat)))) 
		=> tv(Loc:Nat, arrayType(T:Type, N:Nat)) 
	...</ k > : KSentence [metadata "structural"] .
	mb rule < k > *(tv(Loc:Nat, pointerType(functionType(T:Type, L:List{Type})))) 
		=> tv(Loc:Nat, pointerType(functionType(T:Type, L:List{Type}))) 
	...</ k > : KSentence [metadata "structural"] .
	
	--- FIXME this rule is super dangerous because if the value ends up inside any helper operator, it will match
	mb rule KL:KLabel((?,, tv(?, (arrayType(T:Type, ?) => pointerType(T:Type))),, ?))
		if KL:KLabel =/=Bool 'SizeofExpression
		andBool KL:KLabel =/=Bool 'SizeofType
		andBool KL:KLabel =/=Bool '&_
		: KSentence .
		
	mb [deref]: rule
		< k > *(tv(Loc:Nat, pointerType(T:Type))) 
			=> read(Loc:Nat, T:Type)
		...</ k >
		if notBool hasArrayType(T:Type)
		andBool notBool hasFunctionType(T:Type)
		: KSentence [metadata "structural"] .
endm

mod COMMON-SEMANTICS-REFERENCE is
	including COMMON-SEMANTICS-EXPRESSIONS-INCLUDE .
	
	mb context &([HOLE] -> X:Id) : KSentence .
	
	op fixPointerType : Type -> Type .
	ceq fixPointerType(T:Type) = pointerType(T:Type)
		if notBool(hasArrayType(T:Type)) .
	eq fixPointerType(arrayType(T:Type, ?)) = pointerType(T:Type) .
	
	--- C1X 6.5.3.2:3 The unary & operator yields the address of its operand. If the operand has type ‘‘type’’, the result has type ‘‘pointer to type’’. If the operand is the result of a unary * operator, neither that operator nor the & operator is evaluated and the result is as if both were omitted, except that the constraints on the operators still apply and the result is not an lvalue. Similarly, if the operand is the result of a [] operator, neither the & operator nor the unary * that is implied by the [] is evaluated and the result is as if the & operator were removed and the [] operator were changed to a + operator. Otherwise, the result is a pointer to the object or function designated by its operand.
	
	mb rule &(*(E:Expression)) => E:Expression : KSentence [metadata "structural"] .
	mb rule &(E1:Expression[E2:Expression]) => E1:Expression + E2:Expression : KSentence [metadata "structural"] .
	mb [ref]: rule
		< k > &(X:Id) => tv(Loc:Nat, pointerType(T:Type)) ...</ k >
		< env >... X:Id |-> Loc:Nat ...</ env >
		< types >... X:Id |-> T:Type ...</ types >
		: KSentence [metadata "structural"] .
	
	op getOffset : K K Type -> K .
	
	mb context getOffset(?, value(`[HOLE`]:K), ?) : KSentence .
	mb [address-of-arrow-struct]: rule
		< k > &(tv(Loc:Nat, pointerType(structType(S:Id))) -> X:Id)
			=> getOffset(Loc:Nat, value(calculateLength(L1:List{Type})), fixPointerType(T:Type))
		...</ k >
		< structs >... S:Id |-> (L1:List{Type} :: typedDeclaration(T:Type, X:Id) :: ?) ...</ structs >
		: KSentence [metadata "structural"] .
	mb [address-of-arrow-union]: rule
		< k > &(tv(Loc:Nat, pointerType(unionType(S:Id))) -> X:Id)
			=> getOffset(Loc:Nat, 0, fixPointerType(T:Type))
		...</ k >
		< structs >... S:Id |-> (? :: typedDeclaration(T:Type, X:Id) :: ?) ...</ structs >
		: KSentence [metadata "structural"] .
		
	eq getOffset(N:Nat, M:Nat, T:Type) = tv(N:Nat +Nat bito(M:Nat), T:Type) .

		
	--- mb [address-of-arrow-union]: rule
		--- < k > &(tv(Loc:Nat, pointerType(unionType(S:Id))) -> X:Id) 
			--- --- => cast(fixPointerType(T:Type), tv(Base:Nat, pointerType(void)))
			--- => tv(Loc:Nat, fixPointerType(T:Type))
		--- ...</ k >
		--- < structs >... 
			--- S:Id |-> (?:List{Type} :: typedDeclaration(T:Type, X:Id) :: ?:List{Type}) 
		--- ...</ structs >
		--- : KSentence [metadata "structural"] .
		
	mb [address-of-dot]: rule
		< k > &(E:Expression . X:Id) => &(&(E:Expression) -> X:Id) ...</ k >
		: KSentence [metadata "structural"] .
endm

mod COMMON-SEMANTICS-INCREMENT-AND-DECREMENT is
	including COMMON-SEMANTICS-EXPRESSIONS-INCLUDE .
	
	--- c1x 6.5.3.1:2 The value of the operand of the prefix ++ operator is incremented. The result is the new value of the operand after incrementation. The expression ++E is equivalent to (E+=1). See the discussions of additive operators and compound assignment for information on constraints, types, side effects, and conversions and the effects of operations on pointers.
	eq ++ E:Expression = E:Expression += tv(1, int) .
	--- c1x 6.5.3.1:3 The prefix -- operator is analogous to the prefix ++ operator, except that the value of the operand is decremented.
	eq -- E:Expression = E:Expression -= tv(1, int) .

	--- op postOpRef : K KLabel -> K .
	--- mb context postOpRef(Deref([HOLE]), ?) : KSentence .
	--- mb [make-postinc-ref]: rule < k > [E:Expression ++ => postOpRef(Deref(&(E:Expression)), '_++)] ...</ k > : KSentence [metadata "structural"] .
	--- mb [make-postdec-ref]: rule < k > [E:Expression -- => postOpRef(Deref(&(E:Expression)), '_--)] ...</ k > : KSentence [metadata "structural"] .
	
	--- op postInc : K K Type -> K [metadata "strict(2)"] .
	--- op postDec : K K Type -> K [metadata "strict(2)"] .
	--- mb [post-increment-start]: rule
		--- < k > [postOpRef(Deref(tv(Loc:Nat, pointerType(T:Type))), '_++)
		--- => postInc(Loc:Nat, readFromMem(Loc:Nat, T:Type), T:Type)
		--- ] ...</ k >
		--- : KSentence [metadata "structural"] .
		
	--- mb [post-increment]: rule
		--- < k > [postInc(Loc:Nat, tv(I:Int, T:Type), T:Type)
		--- => assign(Deref(tv(Loc:Nat, pointerType(T:Type))), tv(I:Int, T:Type) + tv(1, T:Type)) ~> discard ~> tv(I:Int, T:Type)
		--- ] ...</ k >
		--- if hasIntegerType(T:Type)
		--- : KSentence [metadata "structural"] .
	--- --- fixme would be simpler if i did integer promotions etc.
	--- mb [post-increment]: rule
		--- < k > [postInc(Loc:Nat, tv(I:Int, pointerType(T:Type)), pointerType(T:Type))
		--- => assign(Deref(tv(Loc:Nat, pointerType(pointerType(T:Type)))), tv(I:Int, pointerType(T:Type)) + tv(1, int)) ~> discard ~> tv(I:Int, pointerType(T:Type))
		--- ] ...</ k >
		--- : KSentence [metadata "structural"] .
		
	--- mb [post-decrement-start]: rule
		--- < k > [postOpRef(Deref(tv(Loc:Nat, pointerType(T:Type))), '_--)
		--- => postDec(Loc:Nat, readFromMem(Loc:Nat, T:Type), T:Type)
		--- ] ...</ k >
		--- : KSentence [metadata "structural"] .
		
	--- mb [post-decrement]: rule
		--- < k > [postDec(Loc:Nat, tv(I:Int, T:Type), T:Type)
		--- => assign(Deref(tv(Loc:Nat, pointerType(T:Type))), tv(I:Int, T:Type) - tv(1, T:Type)) ~> discard ~> tv(I:Int, T:Type)
		--- ] ...</ k >
		--- if hasIntegerType(T:Type)
		--- : KSentence [metadata "structural"] .
	--- --- fixme would be simpler if i did integer promotions etc.
	--- mb [post-decrement]: rule
		--- < k > [postDec(Loc:Nat, tv(I:Int, pointerType(T:Type)), pointerType(T:Type))
		--- => assign(Deref(tv(Loc:Nat, pointerType(pointerType(T:Type)))), tv(I:Int, pointerType(T:Type)) - tv(1, int)) ~> discard ~> tv(I:Int, pointerType(T:Type))
		--- ] ...</ k >
		--- : KSentence [metadata "structural"] .
endm

mod COMMON-SEMANTICS-SEQUENCING is
	including COMMON-SEMANTICS-EXPRESSIONS-INCLUDE .
	
	mb rule < k > Comma(K:C :: K'::C :: L:List{C}) => K:C ~> discard ~> Comma(K'::C :: L:List{C}) ...</ k >
		: KSentence .
	mb rule < k > Comma(K:C) => K:C ...</ k >
		: KSentence .
endm

mod COMMON-C-EXPRESSIONS is
	including COMMON-SEMANTICS-EXPRESSIONS-INCLUDE .

	including COMMON-SEMANTICS-BOOLEAN .
	including COMMON-SEMANTICS-SIZEOF .
	including COMMON-SEMANTICS-IDENTIFIERS .
	including COMMON-SEMANTICS-FUNCTION-CALLS .
	including COMMON-SEMANTICS-ARRAY-SUBSCRIPTING .
	including COMMON-SEMANTICS-ASSIGNMENT .
	including COMMON-SEMANTICS-LITERALS .
	including COMMON-SEMANTICS-BITWISE .
	including COMMON-SEMANTICS-BOOLEAN-ARITHMETIC .
	including COMMON-SEMANTICS-ARITHMETIC .
	including COMMON-SEMANTICS-MEMBERS .
	including COMMON-SEMANTICS-DEREFERENCE .
	including COMMON-SEMANTICS-REFERENCE .
	including COMMON-SEMANTICS-INCREMENT-AND-DECREMENT .
	including COMMON-SEMANTICS-SEQUENCING .
	
	eq NothingExpression = emptyValue .
endm
