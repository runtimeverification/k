K Tutorial --- LAMBDA --- Syntax
by Grigore Rosu

Here we define our first K module, which contains the initial syntax of LAMBDA.

The keyword "syntax" adds new productions to the syntax grammar, using a
BNF-like notation.

Terminals are enclosed in double-quotes, like strings.

You can define multiple productions for the same non-terminal in the same
syntax declaration using the "|" separator.

Productions can have attributes, which are enclosed in square brackets.

The attribute "left" tells the parser that we want the lambda application to be
left associative.  For example, "a b c d" will then parse as "(((a b) c) d)".

The attribute "bracket" tells the parser to not generate a node for the
parenthesis production in the abstract syntax trees associated to programs.
In other words, we want to allow parentheses to be used for grouping, but we
do not want to bother to give them their obvious (ignore) semantics.

In our variant of lambda calculus defined here, identifiers and lambda
abstractions are meant to be irreducible, that is, are meant to be values.
However, so far "Val" is just another non-terminal, just like "Exp",
without any semantic meaning.  It will get a semantic meaning later.

After you are done with typing your definition in the file lambda.k (up in the
folder "work"), kompile it in the current folder ("work") with the command:

  kompile lambda.k

If you get no errors then a parser has been generated by the K tool.  This
parser will be called from now on by default by the krun tool.  To see whether
and how the parser works, write some LAMBDA programs and store them in files
with the extension .lambda, or use the provided ones.  For example:

  krun closed_variable_capture.lambda

Make sure you call the krun command from the folder containing your language
definition (otherwise type "krun --help" to learn how to pass a language
definition as a parameter to krun).  The file closed_variable_capture.lambda
contains the LAMBDA program "(lambda z.(z z)) (lambda x.lambda y.(x y))".
The krun command should then produce the output:

<k>
  (lambda z . (z  z))  (lambda x . (lambda y . (x  y))) 
</k>

If you see such an output it means that your program has been parsed (and then
pretty printed) correctly.  If you want to see the internal abstract syntax
tree (AST) representation of the parsed program, which we call the K AST, then
type "kast" in the command instead of "krun":

  kast closed_variable_capture.lambda

You should normally never need to see this internal representation in your
K definitions, so do not get scared (yes, it is ugly for humans, but it is
very convenient for tools).

Note that krun placed the program in a <k> ... </k> cell.  In K, computations
happen only in cells.  If you do not define a configuration in your definition,
then a configuration will be created automatically for you which contains only
one cell, called k, which contains the program.

Parse several programs to get a feel for how the parser works.  Parse also
some incorrect programs, to see how the parser generates error messages.

In the next lesson we will see how to define semantic rules that iteratively
rewrite expressions over the defined syntax until they evaluate to a result.
This way, we obtain our first programming language defined using K.
