#!/usr/bin/env perl

# imports
use strict;
use warnings;
use Getopt::Long;
use File::Spec;
use File::Basename;
use Time::HiRes qw( gettimeofday tv_interval);
# specific imports : common_functions.pl
my $namespace = File::Spec->catfile((File::Basename::fileparse($0))[1], 'perl', 'common_functions.pl');
require $namespace;
$namespace = File::Spec->catfile((File::Basename::fileparse($0))[1], 'perl', 'ast.pl');
require $namespace;

my $tstart = [gettimeofday];
my $t0 = [gettimeofday];
my $elapsed = 0;

################
# Variables    #
################

# options
my $help;

my $pgm           = "?";
my $lang          = "?";
my $syntax_module = "?";
my $verbose       = 0;
my $out_file      = "?";


# utils
my @all_tokens  = ();
my @all_syntax  = ();
my @identifiers = ();
my $k_tools_dir = File::Spec->catfile((File::Basename::fileparse($0))[1], 'maude','compiler');
my $k_prelude = File::Spec->catfile($k_tools_dir,"..","lib","k-prelude");


# comments
my $comment = join("|", (                                                                                                      
    "\\/\\/.*?(\n|\$)",                     
    "\\/\\*.*?\\*\\/",                                                                                                   
    "---\\(.*?---\\)",                                                                                          
    "---.*?(\n|\$)",                                                                                                  
    "\\*\\*\\*\\(.*?\\*\\*\\*\\)",                                                                              
    "\\*\\*\\*.*?(\n|\$)" )); 



################
# main         #
################

# read command line arguments
usage() if (@ARGV < 1 or
    ! GetOptions('help|?' => \$help,
	'pgm=s'      => \$pgm,
	'lang=s'     => \$lang,
	'smod=s'     => \$syntax_module,
	'o|output=s' => \$out_file,
	'v|verbose'  => \$verbose,
    ) or defined $help );



##############################
# solve command line options #
##############################
if ($pgm eq "?")
{
    if (-e $ARGV[0])
    {
	$pgm  = $ARGV[0];
    }
    else
    {
	print "If option -pgm is not used then kast program considers the FIRST argument as being the program file. If this file is not found, it returns this error.\n";
	exit(1);
    }
}

my ($fname, $path, $suffix) = fileparse($pgm, qr/\.[^.]*/);
if ($suffix eq "")
{
    print "Cannot infer lang name. Please make sure that $fname has the form \"program_name.lang\" (e.g. helloworld.c).\n \"lang\" (e.g \"c\") is the name of your language; both \"lang.k\" and \"lang-compiled.maude\" must exist.\n";
    exit(1);
}

# 2. compiled file
$suffix =~ s/^\.//;
$lang = $suffix if ($lang eq "?");
# 3. syntax module
$syntax_module = uc($lang) . "-SYNTAX" if ($syntax_module eq "?");


# message
print "Tokenizing program ... " if $verbose;


##############################################################
#  TOKENIZING
# collect identifiers from program:                          #
# 1. eliminate comments                                      #
# 2. eliminate strings                                       #
# 3. eliminate tokens + keywords from program                #
# 4. collect all left possible identifiers and declare them  #
##############################################################


# get the program
local $_ = get_file_content($pgm);
my $temp = $_;

# get tokens
my $dir = dirname($lang);
my $tokens_file = File::Spec->catfile($dir, ".k/all_tokens.tok");
my $tokens = get_file_content($tokens_file);
my @all = split("\n", $tokens);
@all_tokens = split('\s', shift(@all));
@all_syntax = split('\s', shift(@all));


# remove comments
s!($comment)!
{
    local $_ = $1;
    s/\S//gs;
    $_;
}!gse;


# remove strings
s/(?<!\\)".*?(?<!\\)"//sg;

# syntax contains undescores:
# remove them and keep only keywords
my @temp = ();
for my $syntax_item (@all_syntax)
{
    my @keywords = split("[^a-zA-Z]+", $syntax_item);
    for my $kwd (@keywords)
    {
	push(@temp, $kwd);
    }
    
    push(@temp, $syntax_item) if !(scalar @keywords > 0);
}

@all_tokens = reverse length_sort(@all_tokens);
@all_syntax = reverse length_sort(@temp);

# print "TOKENS: @all_tokens\n\n@all_syntax\n\nPROGRAM:$_\n\n";

# remove syntax
for my $syntax_item (@all_syntax)
{
    $syntax_item =~ s/^_*//;
    $syntax_item =~ s/_*$//;
    my @tmp = reverse length_sort(set(split("_", $syntax_item)));
    my $t   = join ("|", map (quotemeta, @tmp));
    s/\b($t)\b/  /sg if $t !~ /^\s*$/;
}

# remove the rest of tokens (in reversed topological order)
# make sure this is still needed ...
for my $token (@all_tokens)
{
    s/\Q$token\E/ /sg;
}

# collect identifiers
s/\b([a-zA-Z_\$]\w*)\b/
{
    push (@identifiers, $1);
    "";
}/sge;

# make identifiers unique
@identifiers = set(@identifiers);


############################
# end section              #
############################







##############################
# Creating the Maude module  #
# 1. tokenize the program    #
# 2. create a maude module   #
##############################

####################
# 1. tokenization  #
####################
$_ = $temp;

# remove extension of program file
$pgm =~ s/\..*$//s;
my $ids = join(" ", @identifiers);


# remove comments
s!($comment)!
{
    local $_ = $1;
    s/\S//gs;
    $_;
}!gse;


# replace found ids with #id("...");
# also use freeze/unfreeze for strings
my @ordered_ids = reverse length_sort(@identifiers);
s/(?<!\\)".*?(?<!\\)"/Freeze($&, "STRINGS")/sge;
for my $id (@ordered_ids)
{
    s/(?<![a-zA-Z_0-9])($id)(?![a-zA-Z_0-9])/#id("$1")/sg;
}

# freeze also the construct #id("identifier")
s/#id\((?<!\\)".*?(?<!\\)"\)/Freeze($&, "STRINGS")/sge;

# spacify
my @tks = (@all_tokens, @all_syntax);
$_ = spacify($_, @tks);

# unfreeze everything
$_ = Unfreeze("STRINGS", $_);
# print "PROGRAM:\n$_\n\n";


#################################
# kasting                       #
#################################

my $to_reduce = "mod TEST-DO-NOT-USE-THIS-NAME is including $syntax_module .
  sort ParsedPrm .
  op parse_ : Universal -> ParsedPrm [poly(1)] .
endm
  
set print mixfix off .
red parse( $_ ) .
q";

my $tempFile = "programCompile.tmp";
open MYFILE,">",$tempFile or die "Cannot create $tempFile\n";
print MYFILE "load $k_prelude\nload .k\/$lang.maude\n$to_reduce\n";
close(MYFILE);
# push(@generated_files, $tempFile);

$elapsed = tv_interval ( $t0 );
print "DONE [" . sprintf("%.3f", $elapsed) . "s]\n" if $verbose;
$t0 = [gettimeofday];
print "Kasting program ...... " if $verbose;

my $xml_ast = "ast.xml";

# run maude with this input
my $output = `maude -no-wrap programCompile.tmp -xml-log=$xml_ast`;

# get ast
my $ast = get_ast($xml_ast);

# time
$elapsed = tv_interval ( $t0 );
print "DONE [" . sprintf("%.3f", $elapsed) . "s]\n" if $verbose;
$t0 = [gettimeofday];

# clean
unlink("programCompile.tmp") if !$verbose;
unlink($xml_ast) if !$verbose;


$out_file = "/dev/stdout" if $out_file eq "?";
# saving
open FILE, ">", "$out_file" or die "Cannot create $out_file\n";
print FILE $ast;
close FILE;


$elapsed = tv_interval ( $tstart );
print "Total time ........... DONE [" . sprintf("%.3f", $elapsed) . "s]\n\n" if $verbose;



################
# end main     #
################





###########
# utils   #
###########

# an attempt to tokenize a program
sub spacify
{
    local $_ = shift;
    my @tokens = @_;
    
    my @temp = @tokens;
    @tokens = ();
    for my $tok (@temp)
    {
	my @keywords = split("_", $tok);
	for my $kwd (@keywords)
	{
	    push(@tokens, $kwd) if $kwd ne "";
	}
    }

    @tokens = reverse length_sort(set(@tokens));
    
    my @tkz = ();
    for my $tok (@tokens)
    {
	if ($tok ne ";")
	{
	    push(@tkz, quotemeta($tok));
	}
	else
	{
	    push(@tkz, $tok);
	}
    }
    
    my $tokens_pattern = join("|", @tkz);

    s/($tokens_pattern)/ $1 /sg;

    $_;
}


# print a help message and exit
sub usage
{
    print "Unknown option: @_\n" if @_;
    print "usage: kast [-pgm] program_name [-cfile compiled_file] [-smod syntax_module]\n\t[-o output_file] [-verbose] \n\n
  Options:
  \t-pgm        : specifies the file where the program is.
  \t-lang       : specifies the name of the language.  
  \t\t<lang>.k must exist and kompile should have been called on it.
  \t\tThe default value for <lang> is the extensions of <pgm>
  \t-smod       : specifies the syntax module name
  \t\tThe default value for <smod> is <LANG>-SYNTAX
  \t-o[utput]   : specifies the output file
  \t\tThe default value is /dev/stdout
  \t-verbose    : verbose mode
  \n
  Currently, kast needs to be called in the directory containing the definition and the definition is assumed to have been kompiled prior to calling kast.\n\n
  ";
    exit;
}


# returns file content as string
sub get_file_content
{
    my $filename = shift;
    
    open FILEHANDLE, "<", $filename or die "Could not open $filename:\n$!";
    my @input = <FILEHANDLE>;
    close FILEHANDLE;

    return join("", @input);
}

# sorts an array by length of its elements
sub length_sort
{
    sort {length $a <=> length $b} @_;
}

# get set-like array from another array
# get rid of duplicates
sub set
{
    if (@_)
    {
	my %map = map { $_ => 1 } @_;
	return keys %map;
    }
    
    ();
}
