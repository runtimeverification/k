 mod COMMON-SEMANTICS-IF-THEN is
	including COMMON-INCLUDE .
	
	--- fixme need to represent null with 0
	--- mb [if-then-true]: rule
		--- < k > if (tv(V:BaseValue, ?)) S:Statement => sequencePoint ~> S:Statement ...</ k >
		--- if notBool(V:BaseValue ==Bool 0 orBool V:BaseValue ==Bool sym(0) +Nat 0 orBool V:BaseValue ==Bool 0.0)
		--- : KSentence [metadata "computational rule"] . --- nondet
	--- mb [if-then-false]: rule
		--- < k > if (tv(V:BaseValue, ?)) S:Statement => sequencePoint ...</ k >
		--- if (V:BaseValue ==Bool 0 orBool V:BaseValue ==Bool sym(0) +Nat 0 orBool V:BaseValue ==Bool 0.0)
		--- : KSentence [metadata "computational rule"] . --- nondet
		
	mb [if-then-else-true]: rule
		< k > IfThenElse(tv(1, int), S:K, ?) => sequencePoint ~> S:K ...</ k >
		: KSentence [metadata "computational rule"] . --- nondet
	mb [if-then-else-false]: rule
		< k > IfThenElse(tv(0, int), ?, S:K) => sequencePoint ~> S:K ...</ k >
		: KSentence [metadata "computational rule"] . --- nondet
		
	mb [if-then-else]: rule
		< k > IfThenElse(tv(V:BaseValue, T:Type), S:K, S':K)
			=> IfThenElse(tv(V:BaseValue, T:Type) != tv(0, int), S:K, S':K) 
		...</ k >
		if T:Type =/=Bool int
		orBool (
			V:BaseValue =/=Bool 0
			andBool V:BaseValue =/=Bool 1 
		)
		: KSentence [metadata "structural rule"] .
endm

mod COMMON-SEMANTICS-WHILE is
	including COMMON-INCLUDE .
	
	mb [while-mark]: rule
		< k > While(B:Expression, S:Statement) ~> K:K
			=> loopMarked ~> While(B:Expression, S:Statement) ~> popLoop
		</ k >
		< loopStack > (.).List => ListItem(K:K) ...</ loopStack >
		: KSentence [metadata "structural"] .
	mb [while]: rule
		< k > loopMarked ~> While(B:Expression, S:Statement)
			=> IfThenElse(B:Expression, (S:Statement ~> loopMarked ~> While(B:Expression, S:Statement)), Nop)
		...</ k >
		: KSentence [metadata "structural"] .
endm

mod COMMON-SEMANTICS-DO-WHILE is
	including COMMON-INCLUDE .
	
	mb [do-while-mark]: rule
		< k > DoWhile(B:Expression, S:Statement) ~> K:K
			=> loopMarked ~> DoWhile(B:Expression, S:Statement) ~> popLoop
		</ k >
		< loopStack > (.).List => ListItem(K:K) ...</ loopStack >
		: KSentence [metadata "structural"] .
	mb [do-while]: rule
		< k > loopMarked ~> DoWhile(B:Expression, S:Statement)
			=> S:Statement ~> IfThenElse(B:Expression, (loopMarked ~> DoWhile(B:Expression, S:Statement)), Nop)
		...</ k >
		: KSentence [metadata "structural"] .
endm

mod COMMON-SEMANTICS-FOR is
	including COMMON-INCLUDE .
	
	eq ForClauseDeclaration(K:K) = K:K .
	eq ForClauseExpression(K:K) = K:K ~> discard .
	
	mb [for-mark]: rule
		< k > (For(Pre:K, Control:K, Post:K, S:Statement) ~> K:K
			=> pushBlock ~> Pre:K ~> loopMarked ~> For(Pre:K, Control:K, Post:K, S:Statement) ~> popLoop) 
		</ k >
		< loopStack > . => ListItem((popBlock ~> K:K)) ...</ loopStack >
		: KSentence [metadata "structural"] .
	mb [for]: rule
		< k > loopMarked ~> For(Pre:K, Control:K, Post:K, S:Statement)
			=> IfThenElse(Control:K, (S:Statement ~> Post:K ~> discard ~> loopMarked ~> For(Pre:K, Control:K, Post:K, S:Statement)), Nop)
		...</ k >
		: KSentence [metadata "structural"] .
endm

mod COMMON-SEMANTICS-SWITCH is
	including COMMON-INCLUDE .
	
	--- --- fixme shouldn't there be sequence points here?
	--- mb rule
		--- < k > ['switch`(_`)`(_`)_(SN:Nat,, tv(V:BaseValue, ?),, K1:K) ~> ? => K2:K] </ k >
		--- < currentFunction > F:Id </ currentFunction >
		--- < loopStack > [? => S:List] </ loopStack >
		--- < gotoMap >... kpair(F:Id, case(SN:Nat, V:BaseValue)) |-> kpair(K2:K, S:List) ...</ gotoMap >
		--- : KSentence [metadata "computational rule"] .
	--- mb rule
		--- < k > ['switch`(_`)`(_`)_(SN:Nat,, tv(V:BaseValue, ?),, K1:K) ~> ? => K2:K] </ k >
		--- < currentFunction > F:Id </ currentFunction >
		--- < loopStack > [? => S:List] </ loopStack >
		--- < gotoMap > LM:Map kpair(F:Id, defaultCase(SN:Nat)) |-> kpair(K2:K, S:List) </ gotoMap >
		--- if notBool $hasMapping(LM:Map, kpair(F:Id, case(SN:Nat, V:BaseValue)))
		--- : KSentence [metadata "computational rule"] .
	--- mb rule
		--- < k > ['switch`(_`)`(_`)_(SN:Nat,, tv(V:BaseValue, ?),, K1:K) => .K] ...</ k >
		--- < currentFunction > F:Id </ currentFunction >
		--- < gotoMap > LM:Map </ gotoMap >
		--- if notBool (
			--- $hasMapping(LM:Map, kpair(F:Id, case(SN:Nat, V:BaseValue)))
			--- orBool $hasMapping(LM:Map, kpair(F:Id, defaultCase(SN:Nat)))
		--- )
		--- : KSentence [metadata "computational rule"] .

	--- mb [case-fall-through]: rule
		--- < k > ['case`(_`)_:_(?,, ?,, K:K) => K:K] ...</ k >
		--- : KSentence [metadata "structural"] .
	--- mb [default-fall-through]: rule
		--- < k > ['default`(_`):_(?,, K:K) => K:K] ...</ k >
		--- : KSentence [metadata "structural"] .
endm

mod COMMON-SEMANTICS-GOTO is
	including COMMON-INCLUDE .
	
	--- mb context 'calculateGotoMap(?,, ('case`(_`)_:_(?:K,,`[HOLE`]:K,, ?) ~> ?),, ?,, ?) : KSentence .
	
	--- CONFIRM It seems there are no sequence points for a goto
	--- mb rule 
		--- < k > goto(X:Id); ~> ? => K:K </ k >
		--- < currentFunction > F:Id </ currentFunction >
		--- < loopStack > ? => S:List </ loopStack >
		--- < gotoMap >... kpair(F:Id, X:Id) |-> kpair(K:K, S:List) ...</ gotoMap >
		--- : KSentence [metadata "computational rule"] .
		
	op calculateGotoMap : Id K List K -> K . --- func name, body, loop stack, tail
	eq calculateGotoMap(X:Id, K:K) = calculateGotoMap(X:Id, K:K, (.).List, (.).K) .
	mb rule 
		< k > calculateGotoMap(?, (.).K, ?, ?) => (.).K ...</ k >
		: KSentence [metadata "structural"] .
	--- FIXME this is totally wrong, just for now
	mb rule 
		< k > calculateGotoMap(?, ?, ?, ?) => (.).K ...</ k >
		: KSentence [metadata "structural"] .
	--- mb rule 
		--- < k > [calculateGotoMap(X:Id, (L:KLabel(Args:List{K}) ~> K:K), S:List, Tail:K) 
		--- => calculateGotoMap(X:Id, K:K, S:List, Tail:K)] ...</ k >
		--- if L:KLabel ==Bool 'Local
		--- orBool L:KLabel ==Bool '_; --- assumes we don't put '_; around actual statements
		--- orBool L:KLabel ==Bool 'goto_;
		--- orBool L:KLabel ==Bool 'continue`;
		--- orBool L:KLabel ==Bool 'break`;
		--- orBool L:KLabel ==Bool 'return`;
		--- orBool L:KLabel ==Bool 'return_;
		--- ---orBool L:KLabel ==Bool 'default`:_
		--- : KSentence [metadata "structural"] .
	--- mb rule 
		--- < k > [calculateGotoMap(X:Id, ('Block`(`)(.List{K}) ~> K:K), S:List, Tail:K) 
		--- => calculateGotoMap(X:Id, K:K, S:List, Tail:K)] ...</ k >
		--- : KSentence [metadata "structural"] .
	--- mb rule 
		--- < k > [calculateGotoMap(X:Id, ('Block(Arg:K) ~> K:K), S:List, Tail:K) 
		--- => calculateGotoMap(X:Id, (Arg:K ~> K:K), S:List, Tail:K)] ...</ k >
		--- : KSentence [metadata "structural"] .
	--- mb rule 
		--- < k > [calculateGotoMap(X:Id, (L:KLabel(?,, Arg:K) ~> K:K), S:List, Tail:K) 
		--- => calculateGotoMap(X:Id, (Arg:K ~> K:K), S:List, Tail:K)] ...</ k >
		--- if L:KLabel ==Bool 'if`(_`)_
		--- ---orBool L:KLabel ==Bool 'case_:_
		--- : KSentence [metadata "structural"] .
	--- mb rule 
		--- < k > [calculateGotoMap(X:Id, ('if`(_`)_else_(?,, Arg1:K,, Arg2:K) ~> K:K), S:List, Tail:K) 
		--- => calculateGotoMap(X:Id, Arg1:K, S:List, (Tail:K ~> K:K))
		--- ~> calculateGotoMap(X:Id, Arg2:K, S:List, (Tail:K ~> K:K))
		--- ~> calculateGotoMap(X:Id, K:K, S:List, Tail:K)
		--- ] ...</ k >
		--- : KSentence [metadata "structural"] .	
	
	--- mb rule 
		--- < k > [calculateGotoMap(X:Id, ('_:_(Target:Id,, Arg:K) ~> K:K), S:List, Tail:K) 
		--- => calculateGotoMap(X:Id, (Arg:K ~> K:K), S:List, Tail:K)] ...</ k >
		--- < gotoMap >... [.Map => kpair(X:Id, Target:Id) |-> kpair((Arg:K ~> K:K ~> Tail:K), S:List)] ...</ gotoMap >
		--- : KSentence [metadata "structural"] .
	
	--- mb rule 
		--- < k > [calculateGotoMap(X:Id, ('case`(_`)_:_(SN:Nat,, tv(Target:BaseValue, T:Type),, Arg:K) ~> K:K), S:List, Tail:K) 
		--- => calculateGotoMap(X:Id, (Arg:K ~> K:K), S:List, Tail:K)] ...</ k >
		--- < gotoMap >... [.Map => kpair(X:Id, case(SN:Nat, Target:BaseValue)) |-> kpair((Arg:K ~> K:K ~> Tail:K), S:List)] ...</ gotoMap >
		--- : KSentence [metadata "structural"] .
	--- mb rule 
		--- < k > [calculateGotoMap(X:Id, ('default`(_`):_(SN:Nat,, Arg:K) ~> K:K), S:List, Tail:K) 
		--- => calculateGotoMap(X:Id, (Arg:K ~> K:K), S:List, Tail:K)] ...</ k >
		--- < gotoMap >... [.Map => kpair(X:Id, defaultCase(SN:Nat)) |-> kpair((Arg:K ~> K:K ~> Tail:K), S:List)] ...</ gotoMap >
		--- : KSentence [metadata "structural"] .

	--- mb rule 
		--- < k > [calculateGotoMap(X:Id, ('while`(_`)_(B:Expression,, S:Statement) ~> K:K), S':List, Tail:K) 
		--- => calculateGotoMap(X:Id, 
			---xxx (S:Statement ~> loopMarked ~> (while (B:Expression) S:Statement) ~> K:K),
			---xxx (ListItem((K:K ~> Tail:K)) S':List),
			--- Tail:K)] ...</ k >
		--- : KSentence [metadata "structural"] .
	--- mb rule 
		--- < k > [calculateGotoMap(X:Id, (loopMarked ~> (while (B:Expression) S:Statement) ~> K:K), (ListItem( (K:K ~> Tail:K)) S':List), Tail:K)
		--- => calculateGotoMap(X:Id, K:K, S':List, Tail:K)] ...</ k >
		--- : KSentence [metadata "structural"] .
		
	--- mb rule 
		--- < k > [calculateGotoMap(X:Id, ('switch`(_`)`(_`)_(?,, B:Expression,, S:Statement) ~> K:K), S:List, Tail:K) 
		--- => calculateGotoMap(X:Id,
			---xxx (S:Statement ~> popLoop ~> K:K),
			---xxx (ListItem((K:K ~> Tail:K)) S:List),
			--- Tail:K)] ...</ k >
		--- : KSentence [metadata "structural"] .
	
	--- mb rule 
		--- < k > [calculateGotoMap(X:Id, (popLoop ~> K:K), (? S:List), Tail:K)
		--- => calculateGotoMap(X:Id, K:K, S:List, Tail:K)] ...</ k >
		--- : KSentence [metadata "structural"] .
endm

mod COMMON-SEMANTICS-RETURN is
	including COMMON-INCLUDE .
	
	--- fixme can be combined into one cleaning rule
	mb [return-value-clean-local]: rule 
		< k > Return(?) ...</ k >
		< locals >... BagItem(sym(Block:Nat) +Nat ?) => (.).Bag ...</ locals >	
		< mem >... Block:Nat |-> ? => (.).Map ...</ mem >
		: KSentence [metadata "structural"] .

	--- --- this is used for threads
	--- mb [return-nostack]: rule 
		--- < k > [L:KLabel(?) ~> ? => .K] </ k >
		--- < callStack > .List </ callStack >
		--- if L:KLabel ==Bool 'return`;
		--- orBool L:KLabel ==Bool 'return_;
		--- : KSentence [metadata "structural"] .
			
	mb [return-value]: rule 
		< control >
			< k > Return(V:Value) ~> ? => sequencePoint ~> V:Value ~> K:K </ k >
			< locals > (.).Bag => L:Bag </ locals >
			(? => C:Bag)
		</ control >
		< callStack >
			List(
				< stackFrame >
					C:Bag
					< continuation > K:K </ continuation >
					< locals > L:Bag </ locals >
				</ stackFrame >
			) => (.).List
		...</ callStack >
		: KSentence [metadata "structural"] .
endm

mod COMMON-SEMANTICS-BLOCKS is
	including COMMON-INCLUDE .
	
	mb rule BlockStatement(Block:K) => pushBlock ~> Block:K ~> popBlock : KSentence .
	
	mb [push-block]: rule
		< k > pushBlock => (.).K ...</ k > 
		< local >
			C:Bag
			< localVariables > Vars:Set => (.).Set </ localVariables >
			--- < nestingDepth > N:Nat => sNat(N:Nat) </ nestingDepth >
		</ local >
		< blockStack > (.).List => List(< stackFrame > C:Bag 
		--- < nestingDepth > N:Nat </ nestingDepth > 
		< localVariables > Vars:Set </ localVariables >
		</ stackFrame >) ...</ blockStack >
		: KSentence [metadata "structural"] .
		
	mb [pop-block]: rule
		< k > popBlock => (.).K ...</ k > 
		< local > ? => C:Bag </ local >
		< blockStack > List(< stackFrame > C:Bag </ stackFrame >) => (.).List ...</ blockStack >
		: KSentence [metadata "structural"] .
	
	mb [dissolve-block]: rule
		< k > Block(BlockNum:Nat, ?, Statements:List{C}) => listToK(Statements:List{C}) ...</ k > 
		< currentBlock > ? => BlockNum:Nat </ currentBlock >
		: KSentence [metadata "structural"] .
endm

mod COMMON-C-STATEMENTS is
	including COMMON-INCLUDE .
	including COMMON-SEMANTICS-IF-THEN .
	including COMMON-SEMANTICS-FOR .
	including COMMON-SEMANTICS-WHILE .
	including COMMON-SEMANTICS-SWITCH .
	including COMMON-SEMANTICS-GOTO .
	including COMMON-SEMANTICS-RETURN .
	including COMMON-SEMANTICS-BLOCKS .
	including COMMON-SEMANTICS-DO-WHILE .
	
	mb rule Nop => . : KSentence [metadata "structural"] .
	--- mb rule [Block`(`) => .K] : KSentence [metadata "structural"] .
	
	--- --- replace sequencing with ~>
	--- mb rule [S1:Statement S2:Statement => S1:Statement ~> S2:Statement] : KSentence [metadata "structural"] .
		
	--- --- skip labels
	--- mb [skip-label]: rule < k > [L:Id : S:Statement => S:Statement] ...</ k > : KSentence [metadata "structural"] .
	

	--- dissolve expression statements that are finished evaluating
	mb [expression-statement]: rule < k > Computation(K:K) => K:K ~> discard ~> sequencePoint ...</ k > : KSentence [metadata "structural"] .
	
	mb [popLoop]: rule
		< k > (popLoop ~> ?) => K:K </ k >
		< loopStack > ListItem(K:K) => (.).List ...</ loopStack >
		: KSentence [metadata "structural"] .
		
	mb [break]: rule
		< k > Break ~> ? => K:K </ k >
		< loopStack > ListItem(K:K) => (.).List ...</ loopStack >
		: KSentence [metadata "computational rule"] . --- nondet
	
	--- --- fixme not sure about this, isn't it possible for K:K to grab greedily?
	--- mb [continue]: rule
		--- < k > [continue ; ~> K:K => continue ;] ...</ k >
		--- if K:K =/=Bool loopMarked
		--- : KSentence [metadata "structural"] . --- nondet
	--- mb [continue-done]: rule
		--- < k > [continue ; => .K] ~> loopMarked ...</ k >
		--- : KSentence [metadata "structural"] . --- nondet
endm
